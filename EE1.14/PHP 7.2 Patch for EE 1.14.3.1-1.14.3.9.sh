diff --git a/app/Mage.php b/app/Mage.php
index b44ce8f..d70408c 100644
--- a/app/Mage.php
+++ b/app/Mage.php
@@ -53,6 +53,9 @@ if (defined('COMPILER_INCLUDE_PATH')) {
 
 Varien_Autoload::register();
 
+include_once "phpseclib/bootstrap.php";
+include_once "mcrypt_compat/mcrypt.php";
+
 /**
  * Main Mage hub class
  *
diff --git a/app/code/core/Enterprise/GiftWrapping/Model/Total/Quote/Giftwrapping.php b/app/code/core/Enterprise/GiftWrapping/Model/Total/Quote/Giftwrapping.php
index 350a849..8658c53 100644
--- a/app/code/core/Enterprise/GiftWrapping/Model/Total/Quote/Giftwrapping.php
+++ b/app/code/core/Enterprise/GiftWrapping/Model/Total/Quote/Giftwrapping.php
@@ -177,7 +177,7 @@ class Enterprise_GiftWrapping_Model_Total_Quote_Giftwrapping extends Mage_Sales_
         $printedCardBasePrice = false;
         $printedCardPrice = false;
         if ($this->_quoteEntity->getGwAddCard()) {
-            $printedCardBasePrice = Mage::helper('enterprise_giftwrapping')->getPrintedCardPrice($this->_store);
+            $printedCardBasePrice = (float)Mage::helper('enterprise_giftwrapping')->getPrintedCardPrice($this->_store);
             $printedCardPrice = $this->_store->convertPrice($printedCardBasePrice);
         }
         $address->setGwCardBasePrice($printedCardBasePrice);
diff --git a/app/code/core/Enterprise/Rma/Model/Resource/Item.php b/app/code/core/Enterprise/Rma/Model/Resource/Item.php
index c053787..64a0cfd 100644
--- a/app/code/core/Enterprise/Rma/Model/Resource/Item.php
+++ b/app/code/core/Enterprise/Rma/Model/Resource/Item.php
@@ -92,7 +92,7 @@ class Enterprise_Rma_Model_Resource_Item extends Mage_Eav_Model_Entity_Abstract
     protected function _isApplicableAttribute($object, $attribute)
     {
         $applyTo = $attribute->getApplyTo();
-        return count($applyTo) == 0 || in_array($object->getTypeId(), $applyTo);
+        return empty($applyTo) == true || in_array($object->getTypeId(), $applyTo);
     }
 
     /**
diff --git a/app/code/core/Enterprise/Rma/Model/Rma/Source/Abstract.php b/app/code/core/Enterprise/Rma/Model/Rma/Source/Abstract.php
index a3aea6d..4359dd8 100644
--- a/app/code/core/Enterprise/Rma/Model/Rma/Source/Abstract.php
+++ b/app/code/core/Enterprise/Rma/Model/Rma/Source/Abstract.php
@@ -31,7 +31,7 @@
  * @package    Enterprise_Rma
  * @author     Magento Core Team <core@magentocommerce.com>
  */
-abstract class Enterprise_Rma_Model_Rma_Source_Abstract extends Mage_Eav_Model_Entity_Attribute_Source_Table
+abstract class Enterprise_Rma_Model_Rma_Source_Abstract extends Mage_Eav_Model_Entity_Attribute_Source_Abstract
 {
     /**
      * Getter for all available options
diff --git a/app/code/core/Enterprise/Rma/controllers/TrackingController.php b/app/code/core/Enterprise/Rma/controllers/TrackingController.php
index 7587061..801f1da 100644
--- a/app/code/core/Enterprise/Rma/controllers/TrackingController.php
+++ b/app/code/core/Enterprise/Rma/controllers/TrackingController.php
@@ -38,7 +38,7 @@ class Enterprise_Rma_TrackingController extends Mage_Core_Controller_Front_Actio
             ->loadByHash($this->getRequest()->getParam('hash'));
 
         Mage::register('rma_current_shipping', $shippingInfoModel);
-        if (count($shippingInfoModel->getTrackingInfo()) == 0) {
+        if (empty($shippingInfoModel->getTrackingInfo()) == true) {
             $this->norouteAction();
             return;
         }
diff --git a/app/code/core/Mage/Core/Helper/Data.php b/app/code/core/Mage/Core/Helper/Data.php
index b5addd8..06d11a8 100644
--- a/app/code/core/Mage/Core/Helper/Data.php
+++ b/app/code/core/Mage/Core/Helper/Data.php
@@ -651,11 +651,30 @@ XML;
      * Decodes the given $encodedValue string which is
      * encoded in the JSON format
      *
+     * switch added to prevent exceptions in json_decode
+     *
      * @param string $encodedValue
      * @return mixed
      */
     public function jsonDecode($encodedValue, $objectDecodeType = Zend_Json::TYPE_ARRAY)
     {
+        switch (true) {
+            case (null === $encodedValue):
+                $encodedValue = 'null';
+                break;
+            case (true === $encodedValue):
+                $encodedValue = 'true';
+                break;
+            case (false === $encodedValue):
+                $encodedValue = 'false';
+                break;
+            case ('' === $encodedValue):
+                $encodedValue = '""';
+                break;
+            default:
+                // do nothing
+        }
+
         return Zend_Json::decode($encodedValue, $objectDecodeType);
     }
 
diff --git a/app/code/core/Mage/Core/Model/Resource/Session.php b/app/code/core/Mage/Core/Model/Resource/Session.php
index c8546bb..42996fe 100644
--- a/app/code/core/Mage/Core/Model/Resource/Session.php
+++ b/app/code/core/Mage/Core/Model/Resource/Session.php
@@ -215,7 +215,7 @@ class Mage_Core_Model_Resource_Session implements Zend_Session_SaveHandler_Inter
 
         $data = $this->_read->fetchOne($select, $bind);
 
-        return $data;
+        return (string)$data;
     }
 
     /**
diff --git a/app/code/core/Mage/Core/Model/Session/Abstract/Varien.php b/app/code/core/Mage/Core/Model/Session/Abstract/Varien.php
index 303fe84..37b111b 100644
--- a/app/code/core/Mage/Core/Model/Session/Abstract/Varien.php
+++ b/app/code/core/Mage/Core/Model/Session/Abstract/Varien.php
@@ -62,7 +62,6 @@ class Mage_Core_Model_Session_Abstract_Varien extends Varien_Object
              * backward compatibility with db argument (option is @deprecated after 1.12.0.2)
              */
             case 'db':
-                $moduleName = 'user';
                 /* @var $sessionResource Mage_Core_Model_Resource_Session */
                 $sessionResource = Mage::getResourceSingleton('core/session');
                 $sessionResource->setSaveHandler();
@@ -78,9 +77,9 @@ class Mage_Core_Model_Session_Abstract_Varien extends Varien_Object
                 }
             default:
                 session_save_path($this->getSessionSavePath());
+                session_module_name($moduleName);
                 break;
         }
-        session_module_name($moduleName);
 
         $cookie = $this->getCookie();
         if (Mage::app()->getStore()->isAdmin()) {
diff --git a/app/code/core/Mage/Core/functions.php b/app/code/core/Mage/Core/functions.php
index 0273751..1034a3c 100644
--- a/app/code/core/Mage/Core/functions.php
+++ b/app/code/core/Mage/Core/functions.php
@@ -51,24 +51,6 @@ if (get_magic_quotes_gpc()) {
 }
 
 /**
- * Class autoload
- *
- * @todo change to spl_autoload_register
- * @deprecated
- * @param string $class
- */
-function __autoload($class)
-{
-    if (defined('COMPILER_INCLUDE_PATH')) {
-        $classFile = $class.'.php';
-    } else {
-        $classFile = uc_words($class, DIRECTORY_SEPARATOR).'.php';
-    }
-
-    include($classFile);
-}
-
-/**
  * Object destructor
  *
  * @param mixed $object
@@ -178,6 +160,11 @@ function mageCoreErrorHandler($errno, $errstr, $errfile, $errline){
         define('E_DEPRECATED', 8192);
     }
 
+    // Suppress deprecation warnings on PHP 7.x
+    if ($errno == E_DEPRECATED && version_compare(PHP_VERSION, '7.0.0', '>=')) {
+        return true;
+    }
+
     // PEAR specific message handling
     if (stripos($errfile.$errstr, 'pear') !== false) {
          // ignore strict and deprecated notices
diff --git a/app/code/core/Mage/Customer/Model/Customer/Attribute/Source/Group.php b/app/code/core/Mage/Customer/Model/Customer/Attribute/Source/Group.php
index 4adcaa1..f642fa6 100644
--- a/app/code/core/Mage/Customer/Model/Customer/Attribute/Source/Group.php
+++ b/app/code/core/Mage/Customer/Model/Customer/Attribute/Source/Group.php
@@ -33,7 +33,7 @@
  */
 class Mage_Customer_Model_Customer_Attribute_Source_Group extends Mage_Eav_Model_Entity_Attribute_Source_Table
 {
-    public function getAllOptions()
+    public function getAllOptions($withEmpty = true, $defaultValues = false)
     {
         if (!$this->_options) {
             $this->_options = Mage::getResourceModel('customer/group_collection')
diff --git a/app/code/core/Mage/Customer/Model/Customer/Attribute/Source/Store.php b/app/code/core/Mage/Customer/Model/Customer/Attribute/Source/Store.php
index d9eeb75..3a0aaa2 100644
--- a/app/code/core/Mage/Customer/Model/Customer/Attribute/Source/Store.php
+++ b/app/code/core/Mage/Customer/Model/Customer/Attribute/Source/Store.php
@@ -33,7 +33,7 @@
  */
 class Mage_Customer_Model_Customer_Attribute_Source_Store extends Mage_Eav_Model_Entity_Attribute_Source_Table
 {
-    public function getAllOptions()
+    public function getAllOptions($withEmpty = true, $defaultValues = false)
     {
         if (!$this->_options) {
             $collection = Mage::getResourceModel('core/store_collection');
diff --git a/app/code/core/Mage/Customer/Model/Customer/Attribute/Source/Website.php b/app/code/core/Mage/Customer/Model/Customer/Attribute/Source/Website.php
index df411ed..8e690f9 100644
--- a/app/code/core/Mage/Customer/Model/Customer/Attribute/Source/Website.php
+++ b/app/code/core/Mage/Customer/Model/Customer/Attribute/Source/Website.php
@@ -33,7 +33,7 @@
  */
 class Mage_Customer_Model_Customer_Attribute_Source_Website extends Mage_Eav_Model_Entity_Attribute_Source_Table
 {
-    public function getAllOptions()
+    public function getAllOptions($withEmpty = true, $defaultValues = false)
     {
         if (!$this->_options) {
             $this->_options = Mage::getSingleton('adminhtml/system_store')->getWebsiteValuesForForm(true, true);
diff --git a/app/code/core/Mage/Customer/Model/Entity/Address/Attribute/Source/Country.php b/app/code/core/Mage/Customer/Model/Entity/Address/Attribute/Source/Country.php
index 6fc31e9..4a53d1c 100644
--- a/app/code/core/Mage/Customer/Model/Entity/Address/Attribute/Source/Country.php
+++ b/app/code/core/Mage/Customer/Model/Entity/Address/Attribute/Source/Country.php
@@ -56,7 +56,7 @@ class Mage_Customer_Model_Entity_Address_Attribute_Source_Country
      *
      * @return array
      */
-    public function getAllOptions()
+    public function getAllOptions($withEmpty = true, $defaultValues = false)
     {
         if (!$this->_options) {
             $this->_options = $this->_factory->getResourceModel('directory/country_collection')
diff --git a/app/code/core/Mage/Customer/Model/Resource/Address/Attribute/Source/Country.php b/app/code/core/Mage/Customer/Model/Resource/Address/Attribute/Source/Country.php
index df013a7..456eefa 100644
--- a/app/code/core/Mage/Customer/Model/Resource/Address/Attribute/Source/Country.php
+++ b/app/code/core/Mage/Customer/Model/Resource/Address/Attribute/Source/Country.php
@@ -39,7 +39,7 @@ class Mage_Customer_Model_Resource_Address_Attribute_Source_Country extends Mage
      *
      * @return array
      */
-    public function getAllOptions()
+    public function getAllOptions($withEmpty = true, $defaultValues = false)
     {
         if (!$this->_options) {
             $this->_options = Mage::getResourceModel('directory/country_collection')
diff --git a/app/code/core/Mage/Customer/Model/Resource/Address/Attribute/Source/Region.php b/app/code/core/Mage/Customer/Model/Resource/Address/Attribute/Source/Region.php
index c5c9721..81e8d1f 100644
--- a/app/code/core/Mage/Customer/Model/Resource/Address/Attribute/Source/Region.php
+++ b/app/code/core/Mage/Customer/Model/Resource/Address/Attribute/Source/Region.php
@@ -39,7 +39,7 @@ class Mage_Customer_Model_Resource_Address_Attribute_Source_Region extends Mage_
      *
      * @return array
      */
-    public function getAllOptions()
+    public function getAllOptions($withEmpty = true, $defaultValues = false)
     {
         if (!$this->_options) {
             $this->_options = Mage::getResourceModel('directory/region_collection')->load()->toOptionArray();
diff --git a/app/code/core/Mage/Eav/Model/Entity/Attribute/Source/Store.php b/app/code/core/Mage/Eav/Model/Entity/Attribute/Source/Store.php
index f0b68a4..907e4af 100644
--- a/app/code/core/Mage/Eav/Model/Entity/Attribute/Source/Store.php
+++ b/app/code/core/Mage/Eav/Model/Entity/Attribute/Source/Store.php
@@ -38,7 +38,7 @@ class Mage_Eav_Model_Entity_Attribute_Source_Store extends Mage_Eav_Model_Entity
      *
      * @return array
      */
-    public function getAllOptions()
+    public function getAllOptions($withEmpty = true, $defaultValues = false)
     {
         if ($this->_options === null) {
             $this->_options = Mage::getResourceModel('core/store_collection')->load()->toOptionArray();
diff --git a/app/code/core/Mage/Install/etc/install.xml b/app/code/core/Mage/Install/etc/install.xml
index f734da2..b9ca62d 100644
--- a/app/code/core/Mage/Install/etc/install.xml
+++ b/app/code/core/Mage/Install/etc/install.xml
@@ -88,6 +88,10 @@
                 <gd/>
                 <soap/>
                 <mbstring/>
+                <mcrypt>
+                    <openssl/>
+                    <mcrypt/>
+                </mcrypt>
             </extensions>
         </php>
     </check>
diff --git a/app/code/core/Mage/Sales/etc/config.xml b/app/code/core/Mage/Sales/etc/config.xml
index fe04095..0863bfc 100644
--- a/app/code/core/Mage/Sales/etc/config.xml
+++ b/app/code/core/Mage/Sales/etc/config.xml
@@ -1218,7 +1218,7 @@
                     </subtotal>
                     <shipping>
                         <class>sales/quote_address_total_shipping</class>
-                        <after>subtotal,freeshipping,tax_subtotal</after>
+                        <after>subtotal,freeshipping,tax_subtotal,msrp</after>
                         <before>grand_total</before>
                     </shipping>
                     <grand_total>
@@ -1227,6 +1227,7 @@
                     </grand_total>
                     <msrp>
                         <class>sales/quote_address_total_msrp</class>
+                        <before>grand_total</before>
                     </msrp>
                 </totals>
                 <nominal_totals>
diff --git a/app/code/core/Mage/Shipping/Model/Carrier/Abstract.php b/app/code/core/Mage/Shipping/Model/Carrier/Abstract.php
index 8b53e93..37dd38a 100644
--- a/app/code/core/Mage/Shipping/Model/Carrier/Abstract.php
+++ b/app/code/core/Mage/Shipping/Model/Carrier/Abstract.php
@@ -417,7 +417,7 @@ abstract class Mage_Shipping_Model_Carrier_Abstract extends Varien_Object
      */
     public function getFinalPriceWithHandlingFee($cost)
     {
-        $handlingFee = $this->getConfigData('handling_fee');
+        $handlingFee = (float)$this->getConfigData('handling_fee');
         $handlingType = $this->getConfigData('handling_type');
         if (!$handlingType) {
             $handlingType = self::HANDLING_TYPE_FIXED;
diff --git a/app/code/core/Mage/Wishlist/Model/Observer.php b/app/code/core/Mage/Wishlist/Model/Observer.php
index 406218d..2243e09 100644
--- a/app/code/core/Mage/Wishlist/Model/Observer.php
+++ b/app/code/core/Mage/Wishlist/Model/Observer.php
@@ -102,7 +102,7 @@ class Mage_Wishlist_Model_Observer extends Mage_Core_Model_Abstract
             $wishlistIds = array($singleWishlistId);
         }
 
-        if (count($wishlistIds) && $request->getParam('wishlist_next')){
+        if (!empty($wishlistIds) && $request->getParam('wishlist_next')){
             $wishlistId = array_shift($wishlistIds);
 
             if (Mage::getSingleton('customer/session')->isLoggedIn()) {
@@ -125,7 +125,7 @@ class Mage_Wishlist_Model_Observer extends Mage_Core_Model_Abstract
             Mage::getSingleton('checkout/session')->setSingleWishlistId(null);
         }
 
-        if ($request->getParam('wishlist_next') && count($urls)) {
+        if ($request->getParam('wishlist_next') && !empty($urls)) {
             $url = array_shift($urls);
             $message = array_shift($messages);
 
diff --git a/lib/Varien/Autoload.php b/lib/Varien/Autoload.php
index 5dac5cb..f892a9e2 100644
--- a/lib/Varien/Autoload.php
+++ b/lib/Varien/Autoload.php
@@ -91,7 +91,7 @@ class Varien_Autoload
         }
         $classFile.= '.php';
         //echo $classFile;die();
-        return include $classFile;
+        return @include $classFile;
     }
 
     /**
diff --git a/lib/Varien/File/Uploader.php b/lib/Varien/File/Uploader.php
index bb40125..262595e 100644
--- a/lib/Varien/File/Uploader.php
+++ b/lib/Varien/File/Uploader.php
@@ -519,7 +519,7 @@ class Varien_File_Uploader
 
                 $fileAttributes = $tmp_var;
                 $this->_file = $fileAttributes;
-            } elseif( count($fileId) > 0 && isset($_FILES[$fileId])) {
+            } elseif( empty($fileId) == false && isset($_FILES[$fileId])) {
                 $this->_uploadType = self::SINGLE_STYLE;
                 $this->_file = $_FILES[$fileId];
             } elseif( $fileId == '' ) {
diff --git a/lib/Varien/Io/Sftp.php b/lib/Varien/Io/Sftp.php
index b9dbeaa..b86a3d7 100644
--- a/lib/Varien/Io/Sftp.php
+++ b/lib/Varien/Io/Sftp.php
@@ -40,7 +40,7 @@ class Varien_Io_Sftp extends Varien_Io_Abstract implements Varien_Io_Interface
     const SSH2_PORT = 22;
 
     /**
-     * @var Net_SFTP $_connection
+     * @var phpseclib\Net\SFTP $_connection
      */
     protected $_connection = null;
 
@@ -66,7 +66,7 @@ class Varien_Io_Sftp extends Varien_Io_Abstract implements Varien_Io_Interface
             $host = $args['host'];
             $port = self::SSH2_PORT;
         }
-        $this->_connection = new Net_SFTP($host, $port, $args['timeout']);
+        $this->_connection = new phpseclib\Net\SFTP($host, $port, $args['timeout']);
         if (!$this->_connection->login($args['username'], $args['password'])) {
             throw new Exception(sprintf(__("Unable to open SFTP connection as %s@%s", $args['username'], $args['host'])));
         }
diff --git a/lib/mcrypt_compat/mcrypt.php b/lib/mcrypt_compat/mcrypt.php
new file mode 100644
index 0000000..5ce4caf
--- /dev/null
+++ b/lib/mcrypt_compat/mcrypt.php
@@ -0,0 +1,1341 @@
+<?php
+
+/**
+ * mcrypt polyfill
+ *
+ * PHP 7.1 removed the mcrypt extension. This provides a compatibility layer for legacy applications.
+ *
+ * PHP versions 5 and 7
+ *
+ * LICENSE: Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+ * THE SOFTWARE.
+ *
+ * @author    Jim Wigginton <terrafrost@php.net>
+ * @copyright 2016 Jim Wigginton
+ * @license   http://www.opensource.org/licenses/mit-license.html  MIT License
+ * @link      http://phpseclib.sourceforge.net
+ */
+
+use phpseclib\Crypt\Rijndael;
+use phpseclib\Crypt\Twofish;
+use phpseclib\Crypt\Blowfish;
+use phpseclib\Crypt\TripleDES;
+use phpseclib\Crypt\DES;
+use phpseclib\Crypt\RC2;
+use phpseclib\Crypt\RC4;
+use phpseclib\Crypt\Random;
+use phpseclib\Crypt\Base;
+
+if (!defined('MCRYPT_MODE_ECB')) {
+    /**#@+
+     * mcrypt constants
+     *
+     * @access public
+     */
+    // http://php.net/manual/en/mcrypt.constants.php
+    define('MCRYPT_MODE_ECB', 'ecb');
+    define('MCRYPT_MODE_CBC', 'cbc');
+    define('MCRYPT_MODE_CFB', 'cfb');
+    define('MCRYPT_MODE_OFB', 'ofb');
+    define('MCRYPT_MODE_NOFB', 'nofb');
+    define('MCRYPT_MODE_STREAM', 'stream');
+
+    define('MCRYPT_ENCRYPT', 0);
+    define('MCRYPT_DECRYPT', 1);
+    define('MCRYPT_DEV_RANDOM', 0);
+    define('MCRYPT_DEV_URANDOM', 1);
+    define('MCRYPT_RAND', 2);
+
+    // http://php.net/manual/en/mcrypt.ciphers.php
+    define('MCRYPT_3DES', 'tripledes');
+    define('MCRYPT_ARCFOUR_IV', 'arcfour-iv');
+    define('MCRYPT_ARCFOUR', 'arcfour');
+    define('MCRYPT_BLOWFISH', 'blowfish');
+    define('MCRYPT_CAST_128', 'cast-128');
+    define('MCRYPT_CAST_256', 'cast-256');
+    define('MCRYPT_CRYPT', 'crypt');
+    define('MCRYPT_DES', 'des');
+    // MCRYPT_DES_COMPAT?
+    // MCRYPT_ENIGMA?
+    define('MCRYPT_GOST', 'gost');
+    define('MCRYPT_IDEA', 'idea');
+    define('MCRYPT_LOKI97', 'loki97');
+    define('MCRYPT_MARS', 'mars');
+    define('MCRYPT_PANAMA', 'panama');
+    define('MCRYPT_RIJNDAEL_128', 'rijndael-128');
+    define('MCRYPT_RIJNDAEL_192', 'rijndael-192');
+    define('MCRYPT_RIJNDAEL_256', 'rijndael-256');
+    define('MCRYPT_RC2', 'rc2');
+    // MCRYPT_RC4?
+    define('MCRYPT_RC6', 'rc6');
+    // MCRYPT_RC6_128
+    // MCRYPT_RC6_192
+    // MCRYPT_RC6_256
+    define('MCRYPT_SAFER64', 'safer-sk64');
+    define('MCRYPT_SAFER128', 'safer-sk128');
+    define('MCRYPT_SAFERPLUS', 'saferplus');
+    define('MCRYPT_SERPENT', 'serpent');
+    // MCRYPT_SERPENT_128?
+    // MCRYPT_SERPENT_192?
+    // MCRYPT_SERPENT_256?
+    define('MCRYPT_SKIPJACK', 'skipjack');
+    // MCRYPT_TEAN?
+    define('MCRYPT_THREEWAY', 'threeway');
+    define('MCRYPT_TRIPLEDES', 'tripledes');
+    define('MCRYPT_TWOFISH', 'twofish');
+    // MCRYPT_TWOFISH128?
+    // MCRYPT_TWOFISH192?
+    // MCRYPT_TWOFISH256?
+    define('MCRYPT_WAKE', 'wake');
+    define('MCRYPT_XTEA', 'xtea');
+    /**#@-*/
+}
+
+if (!function_exists('phpseclib_mcrypt_list_algorithms')) {
+    /**
+     * Sets the key
+     *
+     * @param \phpseclib\Crypt\Base $td
+     * @param string $key
+     * @access private
+     */
+    function phpseclib_set_key(Base $td, $key)
+    {
+        $length = $origLength = strlen($key);
+
+        $reflection = new \ReflectionClass($td);
+
+        switch ($reflection->getShortName()) {
+            case 'TripleDES':
+                $length = 24;
+                break;
+            case 'DES':
+                $length = 8;
+                break;
+            case 'Twofish':
+            case 'Rijndael':
+                switch (true) {
+                    case $length <= 16:
+                        $length = 16;
+                        break;
+                    case $length <= 24:
+                        $length = 24;
+                        break;
+                    default:
+                        $length = 32;
+                }
+                break;
+            case 'Blowfish':
+                switch (true) {
+                    case $length <= 3:
+                        while (strlen($key) <= 5) {
+                            $key.= $key;
+                        }
+                        $key = substr($key, 0, 6);
+                        $td->setKey($key);
+                        return;
+                    case $length > 56:
+                        $length = 56;
+                }
+                break;
+            case 'RC2':
+                if ($length > 56) {
+                    $length = 56;
+                }
+                break;
+            case 'RC4':
+                if ($length > 256) {
+                    $length = 256;
+                }
+        }
+
+        if ($length != $origLength) {
+            $key = str_pad(substr($key, 0, $length), $length, "\0");
+        }
+
+        $td->setKey($key);
+    }
+
+    /**
+     * Sets the IV
+     *
+     * @param \phpseclib\Crypt\Base $td
+     * @param string $iv
+     * @access private
+     */
+    function phpseclib_set_iv(Base $td, $iv)
+    {
+        if (phpseclib_mcrypt_module_is_iv_mode($td->mcrypt_mode)) {
+            $length = $td->getBlockLength() >> 3;
+            $iv = str_pad(substr($iv, 0, $length), $length, "\0");
+            $td->setIV($iv);
+        }
+    }
+
+    /**
+     * Gets an array of all supported ciphers.
+     *
+     * @param string $lib_dir optional
+     * @return array
+     * @access public
+     */
+    function phpseclib_mcrypt_list_algorithms($lib_dir = '')
+    {
+        return array(
+            'rijndael-128',
+            'twofish',
+            'rijndael-192',
+            'blowfish-compat',
+            'des',
+            'rijndael-256',
+            'blowfish',
+            'rc2',
+            'tripledes',
+            'arcfour'
+        );
+    }
+
+    /**
+     * Gets an array of all supported modes
+     *
+     * @param string $lib_dir optional
+     * @return array
+     * @access public
+     */
+    function phpseclib_mcrypt_list_modes($lib_dir = '')
+    {
+        return array(
+            'cbc',
+            'cfb',
+            'ctr',
+            'ecb',
+            'ncfb',
+            'nofb',
+            //'ofb',
+            'stream'
+        );
+    }
+
+    /**
+     * Creates an initialization vector (IV) from a random source
+     *
+     * The IV is only meant to give an alternative seed to the encryption routines. This IV does not need
+     * to be secret at all, though it can be desirable. You even can send it along with your ciphertext
+     * without losing security.
+     *
+     * @param int $size
+     * @param int $source optional
+     * @return string
+     * @access public
+     */
+    function phpseclib_mcrypt_create_iv($size, $source = MCRYPT_DEV_URANDOM)
+    {
+        if ($size < 1 || $size > 0x7FFFFFFF) {
+            trigger_error('mcrypt_create_iv(): Cannot create an IV with a size of less than 1 or greater than 2147483647', E_USER_WARNING);
+            return '';
+        }
+        return Random::string($size);
+    }
+
+    /**
+     * Opens the module of the algorithm and the mode to be used
+     *
+     * This function opens the module of the algorithm and the mode to be used. The name of the algorithm
+     * is specified in algorithm, e.g. "twofish" or is one of the MCRYPT_ciphername constants. The module
+     * is closed by calling mcrypt_module_close().
+     *
+     * @param string $algorithm
+     * @param string $algorithm_directory
+     * @param string $mode
+     * @param string $mode_directory
+     * @return object
+     * @access public
+     */
+    function phpseclib_mcrypt_module_open($algorithm, $algorithm_directory, $mode, $mode_directory)
+    {
+        $modeMap = array(
+            'ctr' => Base::MODE_CTR,
+            'ecb' => Base::MODE_ECB,
+            'cbc' => Base::MODE_CBC,
+            'ncfb'=> Base::MODE_CFB,
+            'nofb'=> Base::MODE_OFB,
+            'stream' => Base::MODE_STREAM
+        );
+        switch (true) {
+            case !isset($modeMap[$mode]):
+            case $mode == 'stream' && $algorithm != 'arcfour':
+            case $algorithm == 'arcfour' && $mode != 'stream':
+                trigger_error('mcrypt_module_open(): Could not open encryption module', E_USER_WARNING);
+                return false;
+        }
+        switch ($algorithm) {
+            case 'rijndael-128':
+                $cipher = new Rijndael($modeMap[$mode]);
+                $cipher->setBlockLength(128);
+                break;
+            case 'twofish':
+                $cipher = new Twofish($modeMap[$mode]);
+                break;
+            case 'rijndael-192':
+                $cipher = new Rijndael($modeMap[$mode]);
+                $cipher->setBlockLength(192);
+                break;
+            case 'des':
+                $cipher = new DES($modeMap[$mode]);
+                break;
+            case 'rijndael-256':
+                $cipher = new Rijndael($modeMap[$mode]);
+                $cipher->setBlockLength(256);
+                break;
+            case 'blowfish':
+                $cipher = new Blowfish($modeMap[$mode]);
+                break;
+            case 'rc2':
+                $cipher = new RC2($modeMap[$mode]);
+                break;
+            case'tripledes':
+                $cipher = new TripleDES($modeMap[$mode]);
+                break;
+            case 'arcfour':
+                $cipher = new RC4();
+                break;
+            default:
+                trigger_error('mcrypt_module_open(): Could not open encryption module', E_USER_WARNING);
+                return false;
+        }
+
+        $cipher->mcrypt_mode = $mode;
+        $cipher->disablePadding();
+
+        return $cipher;
+    }
+
+    /**
+     * Returns the maximum supported keysize of the opened mode
+     *
+     * Gets the maximum supported key size of the algorithm in bytes.
+     *
+     * @param \phpseclib\Crypt\Base $td
+     * @return int
+     * @access public
+     */
+    function phpseclib_mcrypt_enc_get_key_size(Base $td)
+    {
+        // invalid parameters with mcrypt result in warning's. type hinting, as this function is doing,
+        // produces a catchable fatal error.
+
+        $reflection = new \ReflectionClass($td);
+
+        switch ($reflection->getShortName()) {
+            case 'Rijndael':
+            case 'Twofish':
+                return 32;
+            case 'DES':
+                return 8;
+            case 'TripleDES':
+                return 24;
+            case 'RC4':
+                return 256;
+            case 'Blowfish':
+                return 56;
+            case 'RC2':
+                return 128;
+        }
+    }
+
+   /**
+     * Gets the name of the specified cipher
+     *
+     * @param string $cipher
+     * @return mixed
+     * @access public
+     */
+    function phpseclib_mcrypt_get_cipher_name($cipher)
+    {
+        switch ($cipher) {
+            case 'rijndael-128':
+                return 'Rijndael-128';
+            case 'twofish':
+                return 'Twofish';
+            case 'rijndael-192':
+                return 'Rijndael-192';
+            case 'des':
+                return 'DES';
+            case 'rijndael-256':
+                return 'Rijndael-256';
+            case 'blowfish':
+                return 'Blowfish';
+            case 'rc2':
+                return 'RC2';
+            case 'tripledes':
+                return '3DES';
+            case 'arcfour':
+                return 'RC4';
+            default:
+                return false;
+        }
+    }
+
+   /**
+     * Gets the block size of the specified cipher
+     *
+     * @param string $cipher
+     * @param string $mode optional
+     * @return int
+     * @access public
+     */
+    function phpseclib_mcrypt_get_block_size($cipher, $mode = false)
+    {
+        if (!$mode) {
+            $mode = $cipher == 'rc4' ? 'stream' : 'cbc';
+        }
+        $td = @phpseclib_mcrypt_module_open($cipher, '', $mode, '');
+        if ($td === false) {
+            trigger_error('mcrypt_get_block_size(): Module initialization failed', E_USER_WARNING);
+            return false;
+        }
+        return phpseclib_mcrypt_enc_get_block_size($td);
+    }
+
+   /**
+     * Gets the key size of the specified cipher
+     *
+     * @param string $cipher
+     * @param string $mode optional
+     * @return int
+     * @access public
+     */
+    function phpseclib_mcrypt_get_key_size($cipher, $mode = false)
+    {
+        if (!$mode) {
+            $mode = $cipher == 'rc4' ? 'stream' : 'cbc';
+        }
+        $td = @phpseclib_mcrypt_module_open($cipher, '', $mode, '');
+        if ($td === false) {
+            trigger_error('mcrypt_get_key_size(): Module initialization failed', E_USER_WARNING);
+            return false;
+        }
+        return phpseclib_mcrypt_enc_get_key_size($td);
+    }
+
+   /**
+     * Returns the size of the IV belonging to a specific cipher/mode combination
+     *
+     * @param string $cipher
+     * @param string $mode
+     * @return int
+     * @access public
+     */
+    function phpseclib_mcrypt_get_iv_size($cipher, $mode)
+    {
+        $td = @phpseclib_mcrypt_module_open($cipher, '', $mode, '');
+        if ($td === false) {
+            trigger_error('mcrypt_get_iv_size(): Module initialization failed', E_USER_WARNING);
+            return false;
+        }
+        return phpseclib_mcrypt_enc_get_iv_size($td);
+    }
+
+    /**
+     * Returns the maximum supported keysize of the opened mode
+     *
+     * Gets the maximum supported keysize of the opened mode.
+     *
+     * @param string $algorithm
+     * @param string $lib_dir
+     * @return int
+     * @access public
+     */
+    function phpseclib_mcrypt_module_get_algo_key_size($algorithm, $lib_dir = '')
+    {
+        $mode = $algorithm == 'rc4' ? 'stream' : 'cbc';
+        $td = @phpseclib_mcrypt_module_open($algorithm, '', $mode, '');
+        if ($td === false) {
+            trigger_error('mcrypt_module_get_algo_key_size(): Module initialization failed', E_USER_WARNING);
+            return false;
+        }
+        return phpseclib_mcrypt_enc_get_key_size($td);
+    }
+
+    /**
+     * Returns the size of the IV of the opened algorithm
+     *
+     * This function returns the size of the IV of the algorithm specified by the encryption
+     * descriptor in bytes. An IV is used in cbc, cfb and ofb modes, and in some algorithms
+     * in stream mode.
+     *
+     * @param \phpseclib\Crypt\Base $td
+     * @return int
+     * @access public
+     */
+    function phpseclib_mcrypt_enc_get_iv_size(Base $td)
+    {
+        return $td->getBlockLength() >> 3;
+    }
+
+    /**
+     * Returns the blocksize of the opened algorithm
+     *
+     * Gets the blocksize of the opened algorithm.
+     *
+     * @param \phpseclib\Crypt\Base $td
+     * @return int
+     * @access public
+     */
+    function phpseclib_mcrypt_enc_get_block_size(Base $td)
+    {
+        return $td->getBlockLength() >> 3;
+    }
+
+    /**
+     * Returns the blocksize of the specified algorithm
+     *
+     * Gets the blocksize of the specified algorithm.
+     *
+     * @param string $algorithm
+     * @param string $lib_dir
+     * @return int
+     * @access public
+     */
+    function phpseclib_mcrypt_module_get_algo_block_size($algorithm, $lib_dir = '')
+    {
+        // cbc isn't a valid mode for rc4 but that's ok: -1 will still be returned
+        $td = @phpseclib_mcrypt_module_open($algorithm, '', 'cbc', '');
+        if ($td === false) {
+            return -1;
+        }
+        return $td->getBlockLength() >> 3;
+    }
+
+    /**
+     * Returns the name of the opened algorithm
+     *
+     * This function returns the name of the algorithm.
+     *
+     * @param \phpseclib\Crypt\Base $td
+     * @return string|bool
+     * @access public
+     */
+    function phpseclib_mcrypt_enc_get_algorithms_name(Base $td)
+    {
+        $reflection = new \ReflectionObject($td);
+        switch ($reflection->getShortName()) {
+            case 'Rijndael':
+                return 'RIJNDAEL-' . $td->getBlockLength();
+            case 'Twofish':
+                return 'TWOFISH';
+            case 'Blowfish':
+                return 'BLOWFISH'; // what about BLOWFISH-COMPAT?
+            case 'DES':
+                return 'DES';
+            case 'RC2':
+                return 'RC2';
+            case 'TripleDES':
+                return 'TRIPLEDES';
+            case 'RC4':
+                return 'ARCFOUR';
+        }
+
+        return false;
+    }
+
+    /**
+     * Returns the name of the opened mode
+     *
+     * This function returns the name of the mode.
+     *
+     * @param \phpseclib\Crypt\Base $td
+     * @return string|bool
+     * @access public
+     */
+    function phpseclib_mcrypt_enc_get_modes_name(Base $td)
+    {
+        $modeMap = array(
+            Base::MODE_CTR => 'CTR',
+            Base::MODE_ECB => 'ECB',
+            Base::MODE_CBC => 'CBC',
+            Base::MODE_CFB => 'nCFB',
+            Base::MODE_OFB => 'nOFB',
+            Base::MODE_STREAM => 'STREAM'
+        );
+
+        return isset($modeMap[$td->mode]) ? $modeMap[$td->mode] : false;
+    }
+
+    /**
+     * Checks whether the encryption of the opened mode works on blocks
+     *
+     * Tells whether the algorithm of the opened mode works on blocks (e.g. FALSE for stream, and TRUE for cbc, cfb, ofb)..
+     *
+     * @param \phpseclib\Crypt\Base $td
+     * @return bool
+     * @access public
+     */
+    function phpseclib_mcrypt_enc_is_block_algorithm_mode(Base $td)
+    {
+        return $td->mode != Base::MODE_STREAM;
+    }
+
+    /**
+     * Checks whether the algorithm of the opened mode is a block algorithm
+     *
+     * Tells whether the algorithm of the opened mode is a block algorithm.
+     *
+     * @param \phpseclib\Crypt\Base $td
+     * @return bool
+     * @access public
+     */
+    function phpseclib_mcrypt_enc_is_block_algorithm(Base $td)
+    {
+        return phpseclib_mcrypt_enc_get_algorithms_name($td) != 'ARCFOUR';
+    }
+
+    /**
+     * Checks whether the opened mode outputs blocks
+     *
+     * Tells whether the opened mode outputs blocks (e.g. TRUE for cbc and ecb, and FALSE for cfb and stream).
+     *
+     * @param \phpseclib\Crypt\Base $td
+     * @return bool
+     * @access public
+     */
+    function phpseclib_mcrypt_enc_is_block_mode(Base $td)
+    {
+        return $td->mode == Base::MODE_ECB || $td->mode == Base::MODE_CBC;
+    }
+
+    /**
+     * Runs a self test on the opened module
+     *
+     * This function runs the self test on the algorithm specified by the descriptor td.
+     *
+     * @param \phpseclib\Crypt\Base $td
+     * @return bool
+     * @access public
+     */
+    function phpseclib_mcrypt_enc_self_test(Base $td)
+    {
+        return true;
+    }
+
+    /**
+     * This function initializes all buffers needed for en/decryption.
+     *
+     * @param \phpseclib\Crypt\Base $td
+     * @param string $key
+     * @param string $iv
+     * @return int
+     * @access public
+     */
+    function phpseclib_mcrypt_generic_init(Base $td, $key, $iv)
+    {
+        $iv_size = phpseclib_mcrypt_enc_get_iv_size($td);
+        if (strlen($iv) != $iv_size && $td->mcrypt_mode != 'ecb') {
+            trigger_error('mcrypt_generic_init(): Iv size incorrect; supplied length: ' . strlen($iv) . ', needed: ' . $iv_size, E_USER_WARNING);
+        }
+        if (!strlen($key)) {
+            trigger_error('mcrypt_generic_init(): Key size is 0', E_USER_WARNING);
+            return -3;
+        }
+        $max_key_size = phpseclib_mcrypt_enc_get_key_size($td);
+        if (strlen($key) > $max_key_size) {
+            trigger_error('mcrypt_generic_init(): Key size too large; supplied length: ' . strlen($key) . ', max: ' . $max_key_size, E_USER_WARNING);
+        }
+        phpseclib_set_key($td, $key);
+        phpseclib_set_iv($td, $iv);
+
+        $td->enableContinuousBuffer();
+        $td->mcrypt_polyfill_init = true;
+
+        return 0;
+    }
+
+    /**
+     * Encrypt / decrypt data
+     *
+     * Performs checks common to both mcrypt_generic and mdecrypt_generic
+     *
+     * @param \phpseclib\Crypt\Base $td
+     * @param string $data
+     * @param string $op
+     * @return string|bool
+     * @access private
+     */
+    function phpseclib_mcrypt_generic_helper(Base $td, &$data, $op)
+    {
+        // in the orig mcrypt, if mcrypt_generic_init() was called and an empty key was provided you'd get the following error:
+        // Warning: mcrypt_generic(): supplied resource is not a valid MCrypt resource
+        // that error doesn't really make a lot of sense in this context since $td is not a resource nor should it be one.
+        // in light of that we'll just display the same error that you get when you don't call mcrypt_generic_init() at all
+        if (!isset($td->mcrypt_polyfill_init)) {
+            trigger_error('m' . $op . '_generic(): Operation disallowed prior to mcrypt_generic_init().', E_USER_WARNING);
+            return false;
+        }
+
+        // phpseclib does not currently provide a way to retrieve the mode once it has been set via "public" methods
+        if (phpseclib_mcrypt_module_is_block_mode($td->mcrypt_mode)) {
+            $block_length = phpseclib_mcrypt_enc_get_iv_size($td);
+            $extra = strlen($data) % $block_length;
+            if ($extra) {
+                $data.= str_repeat("\0", $block_length - $extra);
+            }
+        }
+
+        return $op == 'crypt' ? $td->encrypt($data) : $td->decrypt($data);
+    }
+
+    /**
+     * This function encrypts data
+     *
+     * This function encrypts data. The data is padded with "\0" to make sure the length of the data
+     * is n * blocksize. This function returns the encrypted data. Note that the length of the
+     * returned string can in fact be longer than the input, due to the padding of the data.
+     *
+     * If you want to store the encrypted data in a database make sure to store the entire string as
+     * returned by mcrypt_generic, or the string will not entirely decrypt properly. If your original
+     * string is 10 characters long and the block size is 8 (use mcrypt_enc_get_block_size() to
+     * determine the blocksize), you would need at least 16 characters in your database field. Note
+     * the string returned by mdecrypt_generic() will be 16 characters as well...use rtrim($str, "\0")
+     * to remove the padding.
+     *
+     * If you are for example storing the data in a MySQL database remember that varchar fields
+     * automatically have trailing spaces removed during insertion. As encrypted data can end in a
+     * space (ASCII 32), the data will be damaged by this removal. Store data in a tinyblob/tinytext
+     * (or larger) field instead.
+     *
+     * @param \phpseclib\Crypt\Base $td
+     * @param string $data
+     * @return string|bool
+     * @access public
+     */
+    function phpseclib_mcrypt_generic(Base $td, $data)
+    {
+        return phpseclib_mcrypt_generic_helper($td, $data, 'crypt');
+    }
+
+    /**
+     * Decrypts data
+     *
+     * This function decrypts data. Note that the length of the returned string can in fact be
+     * longer than the unencrypted string, due to the padding of the data.
+     *
+     * @param \phpseclib\Crypt\Base $td
+     * @param string $data
+     * @return string|bool
+     * @access public
+     */
+    function phpseclib_mdecrypt_generic(Base $td, $data)
+    {
+        return phpseclib_mcrypt_generic_helper($td, $data, 'decrypt');
+    }
+
+    /**
+     * This function deinitializes an encryption module
+     *
+     * This function terminates encryption specified by the encryption descriptor (td).
+     * It clears all buffers, but does not close the module. You need to call
+     * mcrypt_module_close() yourself. (But PHP does this for you at the end of the
+     * script.)
+     *
+     * @param \phpseclib\Crypt\Base $td
+     * @return bool
+     * @access public
+     */
+    function phpseclib_mcrypt_generic_deinit(Base $td)
+    {
+        if (!isset($td->mcrypt_polyfill_init)) {
+            trigger_error('mcrypt_generic_deinit(): Could not terminate encryption specifier', E_USER_WARNING);
+            return false;
+        }
+
+        $td->disableContinuousBuffer();
+        unset($td->mcrypt_polyfill_init);
+        return true;
+    }
+
+    /**
+     * Closes the mcrypt module
+     *
+     * Closes the specified encryption handle.
+     *
+     * @param \phpseclib\Crypt\Base $td
+     * @return bool
+     * @access public
+     */
+    function phpseclib_mcrypt_module_close(Base $td)
+    {
+        //unset($td->mcrypt_polyfill_init);
+        return true;
+    }
+
+    /**
+     * Returns an array with the supported keysizes of the opened algorithm
+     *
+     * Returns an array with the key sizes supported by the specified algorithm.
+     * If it returns an empty array then all key sizes between 1 and mcrypt_module_get_algo_key_size()
+     * are supported by the algorithm.
+     *
+     * @param string $algorithm
+     * @param string $lib_dir optional
+     * @return array
+     * @access public
+     */
+    function phpseclib_mcrypt_module_get_supported_key_sizes($algorithm, $lib_dir = '')
+    {
+        switch ($algorithm) {
+            case 'rijndael-128':
+            case 'rijndael-192':
+            case 'rijndael-256':
+            case 'twofish':
+                return array(16, 24, 32);
+            case 'des':
+                return array(8);
+            case 'tripledes':
+                return array(24);
+            //case 'arcfour':
+            //case 'blowfish':
+            //case 'rc2':
+            default:
+                return array();
+        }
+    }
+
+    /**
+     * Returns an array with the supported keysizes of the opened algorithm
+     *
+     * Gets the supported key sizes of the opened algorithm.
+     *
+     * @param \phpseclib\Crypt\Base $td
+     * @return array
+     * @access public
+     */
+    function phpseclib_mcrypt_enc_get_supported_key_sizes(Base $td)
+    {
+        $algorithm = strtolower(phpseclib_mcrypt_enc_get_algorithms_name($td));
+        return phpseclib_mcrypt_module_get_supported_key_sizes($algorithm);
+    }
+
+    /**
+     * Returns if the specified module is a block algorithm or not
+     *
+     * This function returns TRUE if the mode is for use with block algorithms, otherwise it returns FALSE. (e.g. FALSE for stream, and TRUE for cbc, cfb, ofb).
+     *
+     * @param string $mode
+     * @param string $lib_dir optional
+     * @return bool
+     * @access public
+     */
+    function phpseclib_mcrypt_module_is_block_algorithm_mode($mode, $lib_dir = '')
+    {
+        switch ($mode) {
+            case 'cbc':
+            case 'ctr':
+            case 'ecb':
+            case 'cfb':
+            case 'ncfb':
+            case 'nofb':
+                return true;
+        }
+        return false;
+    }
+
+    /**
+     * This function checks whether the specified algorithm is a block algorithm
+     *
+     * This function returns TRUE if the specified algorithm is a block algorithm, or FALSE if it is a stream one.
+     *
+     * @param string $mode
+     * @param string $lib_dir optional
+     * @return bool
+     * @access public
+     */
+    function phpseclib_mcrypt_module_is_block_algorithm($algorithm, $lib_dir = '')
+    {
+        switch ($algorithm) {
+            case 'rijndael-128':
+            case 'twofish':
+            case 'rijndael-192':
+            case 'des':
+            case 'rijndael-256':
+            case 'blowfish':
+            case 'rc2':
+            case 'tripledes':
+                return true;
+        }
+        return false;
+    }
+
+    /**
+     * Returns if the specified mode outputs blocks or not
+     *
+     * This function returns TRUE if the mode outputs blocks of bytes or FALSE if it outputs just bytes. (e.g. TRUE for cbc and ecb, and FALSE for cfb and stream).
+     *
+     * @param string $mode
+     * @param string $lib_dir optional
+     * @return bool
+     * @access public
+     */
+    function phpseclib_mcrypt_module_is_block_mode($mode, $lib_dir = '')
+    {
+        switch ($mode) {
+            case 'cbc':
+            case 'ecb':
+                return true;
+        }
+        return false;
+    }
+
+    /**
+     * Returns if the specified mode can use an IV or not
+     *
+     * @param string $mode
+     * @return bool
+     * @access private
+     */
+    function phpseclib_mcrypt_module_is_iv_mode($mode)
+    {
+        switch ($mode) {
+            case 'ecb':
+            case 'stream':
+                return false;
+        }
+        return true;
+    }
+
+    /**
+     * This function runs a self test on the specified module
+     *
+     * This function runs the self test on the algorithm specified.
+     *
+     * @param string $mode
+     * @param string $lib_dir optional
+     * @return bool
+     * @access public
+     */
+    function phpseclib_mcrypt_module_self_test($algorithm, $lib_dir = '')
+    {
+        return in_array($algorithm, phpseclib_mcrypt_list_algorithms());
+    }
+
+    /**
+     * Encrypt / decrypt data
+     *
+     * Performs checks common to both mcrypt_encrypt and mcrypt_decrypt
+     *
+     * @param string $cipher
+     * @param string $key
+     * @param string $data
+     * @param string $mode
+     * @param string $iv
+     * @param string $op
+     * @return string|bool
+     * @access private
+     */
+    function phpseclib_mcrypt_helper($cipher, $key, $data, $mode, $iv, $op)
+    {
+        // PHP 5.6 made mcrypt_encrypt() a lot less tolerant of bad input but it neglected to change
+        // anything about mcrypt_generic(). and despite the changes insufficiently long plaintext
+        // is still accepted.
+        $keyLen = strlen($key);
+        $sizes = phpseclib_mcrypt_module_get_supported_key_sizes($cipher);
+        if (count($sizes) && !in_array($keyLen, $sizes)) {
+            trigger_error(
+                'mcrypt_' . $op . '(): Key of size ' . $keyLen . ' not supported by this algorithm. Only keys of sizes ' .
+                preg_replace('#, (\d+)$#', ' or $1', implode(', ', $sizes)) . ' supported',
+                E_USER_WARNING
+            );
+            return false;
+        }
+        $td = @phpseclib_mcrypt_module_open($cipher, '', $mode, '');
+        if ($td === false) {
+            trigger_error('mcrypt_encrypt(): Module initialization failed', E_USER_WARNING);
+            return false;
+        }
+        $maxKeySize = phpseclib_mcrypt_enc_get_key_size($td);
+        if (!count($sizes) && $keyLen > $maxKeySize) {
+            trigger_error(
+                'mcrypt_' . $op . '(): Key of size ' . $keyLen . ' not supported by this algorithm. Only keys of size 1 to ' . $maxKeySize . ' supported',
+                E_USER_WARNING
+            );
+            return false;
+        }
+        if (phpseclib_mcrypt_module_is_iv_mode($mode)) {
+            $iv_size = phpseclib_mcrypt_enc_get_iv_size($td);
+            if (!isset($iv) && $iv_size) {
+                trigger_error(
+                    'mcrypt_' . $op . '(): Encryption mode requires an initialization vector of size ' . $iv_size,
+                    E_USER_WARNING
+                );
+                return false;
+            }
+            if (strlen($iv) != $iv_size) {
+                trigger_error(
+                    'mcrypt_' . $op . '(): Received initialization vector of size ' . strlen($iv) . ', but size ' . $iv_size . ' is required for this encryption mode',
+                    E_USER_WARNING
+                );
+                return false;
+            }
+        } else {
+            $iv = null;
+        }
+        phpseclib_mcrypt_generic_init($td, $key, $iv);
+        return $op == 'encrypt' ? phpseclib_mcrypt_generic($td, $data) : phpseclib_mdecrypt_generic($td, $data);
+    }
+
+    /**
+     * Encrypts plaintext with given parameters
+     *
+     * Encrypts the data and returns it.
+     *
+     * @param string $cipher
+     * @param string $key
+     * @param string $data
+     * @param string $mode
+     * @param string $iv optional
+     * @return string|bool
+     * @access public
+     */
+    function phpseclib_mcrypt_encrypt($cipher, $key, $data, $mode, $iv = null)
+    {
+        return phpseclib_mcrypt_helper($cipher, $key, $data, $mode, $iv, 'encrypt');
+    }
+
+    /**
+     * Decrypts crypttext with given parameters
+     *
+     * Decrypts the data and returns the unencrypted data.
+     *
+     * @param string $cipher
+     * @param string $key
+     * @param string $data
+     * @param string $mode
+     * @param string $iv optional
+     * @return string|bool
+     * @access public
+     */
+    function phpseclib_mcrypt_decrypt($cipher, $key, $data, $mode, $iv = null)
+    {
+        return phpseclib_mcrypt_helper($cipher, $key, $data, $mode, $iv, 'decrypt');
+    }
+
+    /**
+     * mcrypt_compat stream filter
+     *
+     * @author  Jim Wigginton <terrafrost@php.net>
+     * @access  public
+     */
+    class phpseclib_mcrypt_filter extends php_user_filter
+    {
+        /**
+         * The Cipher Object
+         *
+         * @var object
+         * @access private
+         */
+        private $cipher;
+
+        /**
+         * To encrypt or decrypt
+         *
+         * @var boolean
+         * @access private
+         */
+        private $op;
+
+        /**
+         * Buffer for ECB / CBC
+         *
+         * @var string
+         * @access private
+         */
+        private $buffer = '';
+
+        /**
+         * Cipher block length
+         *
+         * @var int
+         * @access private
+         */
+        private $block_length = '';
+
+        /**
+         * Called when applying the filter
+         *
+         * This method is called whenever data is read from or written to the attached stream
+         * (such as with fread() or fwrite()).
+         *
+         * @param resource $in
+         * @param resource $out
+         * @param int $consumed
+         * @param bool $closing
+         * @link http://php.net/manual/en/php-user-filter.filter.php
+         * @return int
+         * @access public
+         */
+        public function filter($in, $out, &$consumed, $closing)
+        {
+            $newlen = 0;
+            $block_mode = phpseclib_mcrypt_module_is_block_mode($this->cipher->mcrypt_mode);
+            while ($bucket = stream_bucket_make_writeable($in)) {
+                if ($block_mode) {
+                    $bucket->data = $this->buffer . $bucket->data;
+                    $extra = strlen($bucket->data) % $this->block_length;
+                    if ($extra) {
+                        $this->buffer = substr($bucket->data, -$extra);
+                        $bucket->data = substr($bucket->data, 0, -$extra);
+                    }
+                }
+
+                $bucket->data = $this->op ?
+                    $this->cipher->encrypt($bucket->data) :
+                    $this->cipher->decrypt($bucket->data);
+                $newlen+= strlen($bucket->data);
+                $consumed+= $bucket->datalen;
+
+                stream_bucket_append($out, $bucket);
+            }
+
+            return $block_mode && $newlen < $this->block_length ? PSFS_FEED_ME : PSFS_PASS_ON;
+        }
+
+        /**
+         * Called when creating the filter
+         *
+         * This method is called during instantiation of the filter class object.
+         * If your filter allocates or initializes any other resources (such as a buffer),
+         * this is the place to do it.
+         *
+         * @link http://php.net/manual/en/php-user-filter.oncreate.php
+         * @return bool
+         * @access public
+         */
+        public function onCreate()
+        {
+            if (!isset($this->params) || !is_array($this->params)) {
+                trigger_error('stream_filter_append(): Filter parameters for ' . $this->filtername . ' must be an array');
+                return false;
+            }
+            if (!isset($this->params['iv']) || !is_string($this->params['iv'])) {
+                trigger_error('stream_filter_append(): Filter parameter[iv] not provided or not of type: string');
+                return false;
+            }
+            if (!isset($this->params['key']) || !is_string($this->params['key'])) {
+                trigger_error('stream_filter_append(): key not specified or is not a string');
+                return false;
+            }
+            $filtername = substr($this->filtername, 0, 10) == 'phpseclib.' ?
+                substr($this->filtername, 10) :
+                $this->filtername;
+            $parts = explode('.', $filtername);
+            if (count($parts) != 2) {
+                trigger_error('stream_filter_append(): Could not open encryption module');
+                return false;
+            }
+            switch ($parts[0]) {
+                case 'mcrypt':
+                case 'mdecrypt':
+                    break;
+                default:
+                    trigger_error('stream_filter_append(): Could not open encryption module');
+                    return false;
+            }
+            $mode = isset($this->params['mode']) ? $this->params['mode'] : 'cbc';
+            $cipher = @phpseclib_mcrypt_module_open($parts[1], '', $mode, '');
+            if ($cipher === false) {
+                trigger_error('stream_filter_append(): Could not open encryption module');
+                return false;
+            }
+
+            $cipher->enableContinuousBuffer();
+            phpseclib_set_key($cipher, $this->params['key']);
+            phpseclib_set_iv($cipher, $this->params['iv']);
+
+            $this->op = $parts[0] == 'mcrypt';
+            $this->cipher = $cipher;
+            $this->block_length = phpseclib_mcrypt_enc_get_iv_size($cipher);
+
+            return true;
+        }
+    }
+
+    stream_filter_register('phpseclib.mcrypt.*', 'phpseclib_mcrypt_filter');
+    stream_filter_register('phpseclib.mdecrypt.*', 'phpseclib_mcrypt_filter');
+}
+
+// define
+if (!function_exists('mcrypt_list_algorithms')) {
+    function mcrypt_list_algorithms($lib_dir = '')
+    {
+        return phpseclib_mcrypt_list_algorithms($lib_dir);
+    }
+
+    function mcrypt_list_modes($lib_dir = '')
+    {
+        return phpseclib_mcrypt_list_modes($lib_dir);
+    }
+
+    function mcrypt_create_iv($size, $source = MCRYPT_DEV_URANDOM)
+    {
+        return phpseclib_mcrypt_create_iv($size, $source);
+    }
+
+    function mcrypt_module_open($algorithm, $algorithm_directory, $mode, $mode_directory)
+    {
+        return phpseclib_mcrypt_module_open($algorithm, $algorithm_directory, $mode, $mode_directory);
+    }
+
+    function mcrypt_enc_get_key_size(Base $td)
+    {
+        return phpseclib_mcrypt_enc_get_key_size($td);
+    }
+
+    function mcrypt_enc_get_iv_size(Base $td)
+    {
+        return phpseclib_mcrypt_enc_get_iv_size($td);
+    }
+
+    function mcrypt_enc_get_block_size(Base $td)
+    {
+        return phpseclib_mcrypt_enc_get_block_size($td);
+    }
+
+    function mcrypt_generic_init(Base $td, $key, $iv)
+    {
+        return phpseclib_mcrypt_generic_init($td, $key, $iv);
+    }
+
+    function mcrypt_generic(Base $td, $data)
+    {
+        return phpseclib_mcrypt_generic($td, $data);
+    }
+
+    function mcrypt_generic_deinit(Base $td)
+    {
+        return phpseclib_mcrypt_generic_deinit($td);
+    }
+
+    function mcrypt_module_close(Base $td)
+    {
+        return phpseclib_mcrypt_module_close($td);
+    }
+
+    function mdecrypt_generic(Base $td, $data)
+    {
+        return phpseclib_mdecrypt_generic($td, $data);
+    }
+
+    function mcrypt_enc_get_algorithms_name(Base $td)
+    {
+        return phpseclib_mcrypt_enc_get_algorithms_name($td);
+    }
+
+    function mcrypt_enc_get_modes_name(Base $td)
+    {
+        return phpseclib_mcrypt_enc_get_modes_name($td);
+    }
+
+    function mcrypt_enc_is_block_algorithm_mode(Base $td)
+    {
+        return phpseclib_mcrypt_enc_is_block_algorithm_mode($td);
+    }
+
+    function mcrypt_enc_is_block_algorithm(Base $td)
+    {
+        return phpseclib_mcrypt_enc_is_block_algorithm($td);
+    }
+
+    function mcrypt_enc_self_test(Base $td)
+    {
+        return phpseclib_mcrypt_enc_self_test($td);
+    }
+
+    function mcrypt_module_get_supported_key_sizes($algorithm, $lib_dir = '')
+    {
+        return phpseclib_mcrypt_module_get_supported_key_sizes($algorithm, $lib_dir);
+    }
+
+    function mcrypt_encrypt($cipher, $key, $data, $mode, $iv = null)
+    {
+        return phpseclib_mcrypt_encrypt($cipher, $key, $data, $mode, $iv);
+    }
+
+    function mcrypt_module_get_algo_block_size($algorithm, $lib_dir = '')
+    {
+        return phpseclib_mcrypt_module_get_algo_block_size($algorithm, $lib_dir);
+    }
+
+    function mcrypt_get_block_size($cipher, $mode = '')
+    {
+        return phpseclib_mcrypt_get_block_size($cipher, $mode);
+    }
+
+    function mcrypt_get_cipher_name($cipher)
+    {
+        return phpseclib_mcrypt_get_cipher_name($cipher);
+    }
+
+    function mcrypt_get_key_size($cipher, $mode = false)
+    {
+        return phpseclib_mcrypt_get_key_size($cipher, $mode);
+    }
+
+    function mcrypt_get_iv_size($cipher, $mode)
+    {
+        return phpseclib_mcrypt_get_iv_size($cipher, $mode);
+    }
+
+    function mcrypt_module_get_algo_key_size($algorithm, $lib_dir = '')
+    {
+        return phpseclib_mcrypt_module_get_algo_key_size($algorithm, $lib_dir);
+    }
+
+    function mcrypt_enc_get_supported_key_sizes(Base $td)
+    {
+        return phpseclib_mcrypt_enc_get_supported_key_sizes($td);
+    }
+
+    function mcrypt_module_is_block_algorithm_mode($mode, $lib_dir = '')
+    {
+        return phpseclib_mcrypt_module_is_block_algorithm_mode($mode, $lib_dir);
+    }
+
+    function mcrypt_module_is_block_algorithm($algorithm, $lib_dir=  '')
+    {
+        return phpseclib_mcrypt_module_is_block_algorithm($algorithm, $lib_dir);
+    }
+
+    function mcrypt_module_is_block_mode($mode, $lib_dir = '')
+    {
+        return phpseclib_mcrypt_module_is_block_mode($mode, $lib_dir);
+    }
+
+    function mcrypt_module_self_test($algorithm, $lib_dir = '')
+    {
+        return phpseclib_mcrypt_module_self_test($algorithm, $lib_dir);
+    }
+
+    function mcrypt_decrypt($cipher, $key, $data, $mode, $iv = null)
+    {
+        return phpseclib_mcrypt_decrypt($cipher, $key, $data, $mode, $iv);
+    }
+
+    //if (!in_array('mcrypt.*', stream_get_filters()) {
+    stream_filter_register('mcrypt.*', 'phpseclib_mcrypt_filter');
+    stream_filter_register('mdecrypt.*', 'phpseclib_mcrypt_filter');
+    //}
+}
diff --git a/lib/phpseclib/Crypt/AES.php b/lib/phpseclib/Crypt/AES.php
index 3beffa9..7d8cb8b 100644
--- a/lib/phpseclib/Crypt/AES.php
+++ b/lib/phpseclib/Crypt/AES.php
@@ -1,28 +1,31 @@
 <?php
-/* vim: set expandtab tabstop=4 shiftwidth=4 softtabstop=4: */
 
 /**
  * Pure-PHP implementation of AES.
  *
- * Uses mcrypt, if available, and an internal implementation, otherwise.
+ * Uses mcrypt, if available/possible, and an internal implementation, otherwise.
  *
- * PHP versions 4 and 5
+ * PHP version 5
  *
- * If {@link Crypt_AES::setKeyLength() setKeyLength()} isn't called, it'll be calculated from
- * {@link Crypt_AES::setKey() setKey()}.  ie. if the key is 128-bits, the key length will be 128-bits.  If it's 136-bits
- * it'll be null-padded to 160-bits and 160 bits will be the key length until {@link Crypt_Rijndael::setKey() setKey()}
+ * NOTE: Since AES.php is (for compatibility and phpseclib-historical reasons) virtually
+ * just a wrapper to Rijndael.php you may consider using Rijndael.php instead of
+ * to save one include_once().
+ *
+ * If {@link self::setKeyLength() setKeyLength()} isn't called, it'll be calculated from
+ * {@link self::setKey() setKey()}.  ie. if the key is 128-bits, the key length will be 128-bits.  If it's 136-bits
+ * it'll be null-padded to 192-bits and 192 bits will be the key length until {@link self::setKey() setKey()}
  * is called, again, at which point, it'll be recalculated.
  *
- * Since Crypt_AES extends Crypt_Rijndael, some functions are available to be called that, in the context of AES, don't
- * make a whole lot of sense.  {@link Crypt_AES::setBlockLength() setBlockLength()}, for instance.  Calling that function,
+ * Since \phpseclib\Crypt\AES extends \phpseclib\Crypt\Rijndael, some functions are available to be called that, in the context of AES, don't
+ * make a whole lot of sense.  {@link self::setBlockLength() setBlockLength()}, for instance.  Calling that function,
  * however possible, won't do anything (AES has a fixed block length whereas Rijndael has a variable one).
  *
  * Here's a short example of how to use this library:
  * <code>
  * <?php
- *    include('Crypt/AES.php');
+ *    include 'vendor/autoload.php';
  *
- *    $aes = new Crypt_AES();
+ *    $aes = new \phpseclib\Crypt\AES();
  *
  *    $aes->setKey('abcdefghijklmnop');
  *
@@ -36,179 +39,33 @@
  * ?>
  * </code>
  *
- * LICENSE: This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA  02111-1307  USA
- *
- * @category   Crypt
- * @package    Crypt_AES
- * @author     Jim Wigginton <terrafrost@php.net>
- * @copyright  MMVIII Jim Wigginton
- * @license    http://www.gnu.org/licenses/lgpl.txt
- * @version    $Id: AES.php,v 1.7 2010/02/09 06:10:25 terrafrost Exp $
- * @link       http://phpseclib.sourceforge.net
+ * @category  Crypt
+ * @package   AES
+ * @author    Jim Wigginton <terrafrost@php.net>
+ * @copyright 2008 Jim Wigginton
+ * @license   http://www.opensource.org/licenses/mit-license.html  MIT License
+ * @link      http://phpseclib.sourceforge.net
  */
 
-/**
- * Include Crypt_Rijndael
- */
-require_once 'Rijndael.php';
-
-/**#@+
- * @access public
- * @see Crypt_AES::encrypt()
- * @see Crypt_AES::decrypt()
- */
-/**
- * Encrypt / decrypt using the Counter mode.
- *
- * Set to -1 since that's what Crypt/Random.php uses to index the CTR mode.
- *
- * @link http://en.wikipedia.org/wiki/Block_cipher_modes_of_operation#Counter_.28CTR.29
- */
-define('CRYPT_AES_MODE_CTR', -1);
-/**
- * Encrypt / decrypt using the Electronic Code Book mode.
- *
- * @link http://en.wikipedia.org/wiki/Block_cipher_modes_of_operation#Electronic_codebook_.28ECB.29
- */
-define('CRYPT_AES_MODE_ECB', 1);
-/**
- * Encrypt / decrypt using the Code Book Chaining mode.
- *
- * @link http://en.wikipedia.org/wiki/Block_cipher_modes_of_operation#Cipher-block_chaining_.28CBC.29
- */
-define('CRYPT_AES_MODE_CBC', 2);
-/**#@-*/
-
-/**#@+
- * @access private
- * @see Crypt_AES::Crypt_AES()
- */
-/**
- * Toggles the internal implementation
- */
-define('CRYPT_AES_MODE_INTERNAL', 1);
-/**
- * Toggles the mcrypt implementation
- */
-define('CRYPT_AES_MODE_MCRYPT', 2);
-/**#@-*/
+namespace phpseclib\Crypt;
 
 /**
  * Pure-PHP implementation of AES.
  *
+ * @package AES
  * @author  Jim Wigginton <terrafrost@php.net>
- * @version 0.1.0
  * @access  public
- * @package Crypt_AES
  */
-class Crypt_AES extends Crypt_Rijndael {
-    /**
-     * mcrypt resource for encryption
-     *
-     * The mcrypt resource can be recreated every time something needs to be created or it can be created just once.
-     * Since mcrypt operates in continuous mode, by default, it'll need to be recreated when in non-continuous mode.
-     *
-     * @see Crypt_AES::encrypt()
-     * @var String
-     * @access private
-     */
-    var $enmcrypt;
-
-    /**
-     * mcrypt resource for decryption
-     *
-     * The mcrypt resource can be recreated every time something needs to be created or it can be created just once.
-     * Since mcrypt operates in continuous mode, by default, it'll need to be recreated when in non-continuous mode.
-     *
-     * @see Crypt_AES::decrypt()
-     * @var String
-     * @access private
-     */
-    var $demcrypt;
-
-    /**
-     * Default Constructor.
-     *
-     * Determines whether or not the mcrypt extension should be used.  $mode should only, at present, be
-     * CRYPT_AES_MODE_ECB or CRYPT_AES_MODE_CBC.  If not explictly set, CRYPT_AES_MODE_CBC will be used.
-     *
-     * @param optional Integer $mode
-     * @return Crypt_AES
-     * @access public
-     */
-    function Crypt_AES($mode = CRYPT_AES_MODE_CBC)
-    {
-        if ( !defined('CRYPT_AES_MODE') ) {
-            switch (true) {
-                case extension_loaded('mcrypt'):
-                    // i'd check to see if aes was supported, by doing in_array('des', mcrypt_list_algorithms('')),
-                    // but since that can be changed after the object has been created, there doesn't seem to be
-                    // a lot of point...
-                    define('CRYPT_AES_MODE', CRYPT_AES_MODE_MCRYPT);
-                    break;
-                default:
-                    define('CRYPT_AES_MODE', CRYPT_AES_MODE_INTERNAL);
-            }
-        }
-
-        switch ( CRYPT_AES_MODE ) {
-            case CRYPT_AES_MODE_MCRYPT:
-                switch ($mode) {
-                    case CRYPT_AES_MODE_ECB:
-                        $this->mode = MCRYPT_MODE_ECB;
-                        break;
-                    case CRYPT_AES_MODE_CTR:
-                        // ctr doesn't have a constant associated with it even though it appears to be fairly widely
-                        // supported.  in lieu of knowing just how widely supported it is, i've, for now, opted not to
-                        // include a compatibility layer.  the layer has been implemented but, for now, is commented out.
-                        $this->mode = 'ctr';
-                        //$this->mode = in_array('ctr', mcrypt_list_modes()) ? 'ctr' : CRYPT_AES_MODE_CTR;
-                        break;
-                    case CRYPT_AES_MODE_CBC:
-                    default:
-                        $this->mode = MCRYPT_MODE_CBC;
-                }
-
-                break;
-            default:
-                switch ($mode) {
-                    case CRYPT_AES_MODE_ECB:
-                        $this->mode = CRYPT_RIJNDAEL_MODE_ECB;
-                        break;
-                    case CRYPT_AES_MODE_CTR:
-                        $this->mode = CRYPT_RIJNDAEL_MODE_CTR;
-                        break;
-                    case CRYPT_AES_MODE_CBC:
-                    default:
-                        $this->mode = CRYPT_RIJNDAEL_MODE_CBC;
-                }
-        }
-
-        if (CRYPT_AES_MODE == CRYPT_AES_MODE_INTERNAL) {
-            parent::Crypt_Rijndael($this->mode);
-        }
-    }
-
+class AES extends Rijndael
+{
     /**
      * Dummy function
      *
-     * Since Crypt_AES extends Crypt_Rijndael, this function is, technically, available, but it doesn't do anything.
+     * Since \phpseclib\Crypt\AES extends \phpseclib\Crypt\Rijndael, this function is, technically, available, but it doesn't do anything.
      *
+     * @see \phpseclib\Crypt\Rijndael::setBlockLength()
      * @access public
-     * @param Integer $length
+     * @param int $length
      */
     function setBlockLength($length)
     {
@@ -216,264 +73,54 @@ class Crypt_AES extends Crypt_Rijndael {
     }
 
     /**
-     * Encrypts a message.
-     *
-     * $plaintext will be padded with up to 16 additional bytes.  Other AES implementations may or may not pad in the
-     * same manner.  Other common approaches to padding and the reasons why it's necessary are discussed in the following
-     * URL:
-     *
-     * {@link http://www.di-mgt.com.au/cryptopad.html http://www.di-mgt.com.au/cryptopad.html}
+     * Sets the key length
      *
-     * An alternative to padding is to, separately, send the length of the file.  This is what SSH, in fact, does.
-     * strlen($plaintext) will still need to be a multiple of 16, however, arbitrary values can be added to make it that
-     * length.
+     * Valid key lengths are 128, 192, and 256.  If the length is less than 128, it will be rounded up to
+     * 128.  If the length is greater than 128 and invalid, it will be rounded down to the closest valid amount.
      *
-     * @see Crypt_AES::decrypt()
+     * @see \phpseclib\Crypt\Rijndael:setKeyLength()
      * @access public
-     * @param String $plaintext
+     * @param int $length
      */
-    function encrypt($plaintext)
+    function setKeyLength($length)
     {
-        if ( CRYPT_AES_MODE == CRYPT_AES_MODE_MCRYPT ) {
-            $this->_mcryptSetup();
-            /*
-            if ($this->mode == CRYPT_AES_MODE_CTR) {
-                $iv = $this->encryptIV;
-                $xor = mcrypt_generic($this->enmcrypt, $this->_generate_xor(strlen($plaintext), $iv));
-                $ciphertext = $plaintext ^ $xor;
-                if ($this->continuousBuffer) {
-                    $this->encryptIV = $iv;
-                }
-                return $ciphertext;
-            }
-            */
-
-            if ($this->mode != 'ctr') {
-                $plaintext = $this->_pad($plaintext);
-            }
-
-            $ciphertext = mcrypt_generic($this->enmcrypt, $plaintext);
-
-            if (!$this->continuousBuffer) {
-                mcrypt_generic_init($this->enmcrypt, $this->key, $this->iv);
-            }
-
-            return $ciphertext;
+        switch ($length) {
+            case 160:
+                $length = 192;
+                break;
+            case 224:
+                $length = 256;
         }
-
-        return parent::encrypt($plaintext);
+        parent::setKeyLength($length);
     }
 
     /**
-     * Decrypts a message.
+     * Sets the key.
      *
-     * If strlen($ciphertext) is not a multiple of 16, null bytes will be added to the end of the string until it is.
+     * Rijndael supports five different key lengths, AES only supports three.
      *
-     * @see Crypt_AES::encrypt()
+     * @see \phpseclib\Crypt\Rijndael:setKey()
+     * @see setKeyLength()
      * @access public
-     * @param String $ciphertext
+     * @param string $key
      */
-    function decrypt($ciphertext)
+    function setKey($key)
     {
-        if ( CRYPT_AES_MODE == CRYPT_AES_MODE_MCRYPT ) {
-            $this->_mcryptSetup();
-            /*
-            if ($this->mode == CRYPT_AES_MODE_CTR) {
-                $iv = $this->decryptIV;
-                $xor = mcrypt_generic($this->enmcrypt, $this->_generate_xor(strlen($ciphertext), $iv));
-                $plaintext = $ciphertext ^ $xor;
-                if ($this->continuousBuffer) {
-                    $this->decryptIV = $iv;
-                }
-                return $plaintext;
-            }
-            */
-
-            if ($this->mode != 'ctr') {
-                // we pad with chr(0) since that's what mcrypt_generic does.  to quote from http://php.net/function.mcrypt-generic :
-                // "The data is padded with "\0" to make sure the length of the data is n * blocksize."
-                $ciphertext = str_pad($ciphertext, (strlen($ciphertext) + 15) & 0xFFFFFFF0, chr(0));
-            }
-
-            $plaintext = mdecrypt_generic($this->demcrypt, $ciphertext);
-
-            if (!$this->continuousBuffer) {
-                mcrypt_generic_init($this->demcrypt, $this->key, $this->iv);
-            }
-
-            return $this->mode != 'ctr' ? $this->_unpad($plaintext) : $plaintext;
-        }
-
-        return parent::decrypt($ciphertext);
-    }
-
-    /**
-     * Setup mcrypt
-     *
-     * Validates all the variables.
-     *
-     * @access private
-     */
-    function _mcryptSetup()
-    {
-        if (!$this->changed) {
-            return;
-        }
+        parent::setKey($key);
 
         if (!$this->explicit_key_length) {
-            // this just copied from Crypt_Rijndael::_setup()
-            $length = strlen($this->key) >> 2;
-            if ($length > 8) {
-                $length = 8;
-            } else if ($length < 4) {
-                $length = 4;
+            $length = strlen($key);
+            switch (true) {
+                case $length <= 16:
+                    $this->key_length = 16;
+                    break;
+                case $length <= 24:
+                    $this->key_length = 24;
+                    break;
+                default:
+                    $this->key_length = 32;
             }
-            $this->Nk = $length;
-            $this->key_size = $length << 2;
-        }
-
-        switch ($this->Nk) {
-            case 4: // 128
-                $this->key_size = 16;
-                break;
-            case 5: // 160
-            case 6: // 192
-                $this->key_size = 24;
-                break;
-            case 7: // 224
-            case 8: // 256
-                $this->key_size = 32;
-        }
-
-        $this->key = substr($this->key, 0, $this->key_size);
-        $this->encryptIV = $this->decryptIV = $this->iv = str_pad(substr($this->iv, 0, 16), 16, chr(0));
-
-        if (!isset($this->enmcrypt)) {
-            $mode = $this->mode;
-            //$mode = $this->mode == CRYPT_AES_MODE_CTR ? MCRYPT_MODE_ECB : $this->mode;
-
-            $this->demcrypt = mcrypt_module_open(MCRYPT_RIJNDAEL_128, '', $mode, '');
-            $this->enmcrypt = mcrypt_module_open(MCRYPT_RIJNDAEL_128, '', $mode, '');
-        } // else should mcrypt_generic_deinit be called?
-
-        mcrypt_generic_init($this->demcrypt, $this->key, $this->iv);
-        mcrypt_generic_init($this->enmcrypt, $this->key, $this->iv);
-
-        $this->changed = false;
-    }
-
-    /**
-     * Encrypts a block
-     *
-     * Optimized over Crypt_Rijndael's implementation by means of loop unrolling.
-     *
-     * @see Crypt_Rijndael::_encryptBlock()
-     * @access private
-     * @param String $in
-     * @return String
-     */
-    function _encryptBlock($in)
-    {
-        $state = unpack('N*word', $in);
-
-        $Nr = $this->Nr;
-        $w = $this->w;
-        $t0 = $this->t0;
-        $t1 = $this->t1;
-        $t2 = $this->t2;
-        $t3 = $this->t3;
-
-        // addRoundKey and reindex $state
-        $state = array(
-            $state['word1'] ^ $w[0][0],
-            $state['word2'] ^ $w[0][1],
-            $state['word3'] ^ $w[0][2],
-            $state['word4'] ^ $w[0][3]
-        );
-
-        // shiftRows + subWord + mixColumns + addRoundKey
-        // we could loop unroll this and use if statements to do more rounds as necessary, but, in my tests, that yields
-        // only a marginal improvement.  since that also, imho, hinders the readability of the code, i've opted not to do it.
-        for ($round = 1; $round < $this->Nr; $round++) {
-            $state = array(
-                $t0[$state[0] & 0xFF000000] ^ $t1[$state[1] & 0x00FF0000] ^ $t2[$state[2] & 0x0000FF00] ^ $t3[$state[3] & 0x000000FF] ^ $w[$round][0],
-                $t0[$state[1] & 0xFF000000] ^ $t1[$state[2] & 0x00FF0000] ^ $t2[$state[3] & 0x0000FF00] ^ $t3[$state[0] & 0x000000FF] ^ $w[$round][1],
-                $t0[$state[2] & 0xFF000000] ^ $t1[$state[3] & 0x00FF0000] ^ $t2[$state[0] & 0x0000FF00] ^ $t3[$state[1] & 0x000000FF] ^ $w[$round][2],
-                $t0[$state[3] & 0xFF000000] ^ $t1[$state[0] & 0x00FF0000] ^ $t2[$state[1] & 0x0000FF00] ^ $t3[$state[2] & 0x000000FF] ^ $w[$round][3]
-            );
-
+            $this->_setEngine();
         }
-
-        // subWord
-        $state = array(
-            $this->_subWord($state[0]),
-            $this->_subWord($state[1]),
-            $this->_subWord($state[2]),
-            $this->_subWord($state[3])
-        );
-
-        // shiftRows + addRoundKey
-        $state = array(
-            ($state[0] & 0xFF000000) ^ ($state[1] & 0x00FF0000) ^ ($state[2] & 0x0000FF00) ^ ($state[3] & 0x000000FF) ^ $this->w[$this->Nr][0],
-            ($state[1] & 0xFF000000) ^ ($state[2] & 0x00FF0000) ^ ($state[3] & 0x0000FF00) ^ ($state[0] & 0x000000FF) ^ $this->w[$this->Nr][1],
-            ($state[2] & 0xFF000000) ^ ($state[3] & 0x00FF0000) ^ ($state[0] & 0x0000FF00) ^ ($state[1] & 0x000000FF) ^ $this->w[$this->Nr][2],
-            ($state[3] & 0xFF000000) ^ ($state[0] & 0x00FF0000) ^ ($state[1] & 0x0000FF00) ^ ($state[2] & 0x000000FF) ^ $this->w[$this->Nr][3]
-        );
-
-        return pack('N*', $state[0], $state[1], $state[2], $state[3]);
-    }
-
-    /**
-     * Decrypts a block
-     *
-     * Optimized over Crypt_Rijndael's implementation by means of loop unrolling.
-     *
-     * @see Crypt_Rijndael::_decryptBlock()
-     * @access private
-     * @param String $in
-     * @return String
-     */
-    function _decryptBlock($in)
-    {
-        $state = unpack('N*word', $in);
-
-        $Nr = $this->Nr;
-        $dw = $this->dw;
-        $dt0 = $this->dt0;
-        $dt1 = $this->dt1;
-        $dt2 = $this->dt2;
-        $dt3 = $this->dt3;
-
-        // addRoundKey and reindex $state
-        $state = array(
-            $state['word1'] ^ $dw[$this->Nr][0],
-            $state['word2'] ^ $dw[$this->Nr][1],
-            $state['word3'] ^ $dw[$this->Nr][2],
-            $state['word4'] ^ $dw[$this->Nr][3]
-        );
-
-
-        // invShiftRows + invSubBytes + invMixColumns + addRoundKey
-        for ($round = $this->Nr - 1; $round > 0; $round--) {
-            $state = array(
-                $dt0[$state[0] & 0xFF000000] ^ $dt1[$state[3] & 0x00FF0000] ^ $dt2[$state[2] & 0x0000FF00] ^ $dt3[$state[1] & 0x000000FF] ^ $dw[$round][0],
-                $dt0[$state[1] & 0xFF000000] ^ $dt1[$state[0] & 0x00FF0000] ^ $dt2[$state[3] & 0x0000FF00] ^ $dt3[$state[2] & 0x000000FF] ^ $dw[$round][1],
-                $dt0[$state[2] & 0xFF000000] ^ $dt1[$state[1] & 0x00FF0000] ^ $dt2[$state[0] & 0x0000FF00] ^ $dt3[$state[3] & 0x000000FF] ^ $dw[$round][2],
-                $dt0[$state[3] & 0xFF000000] ^ $dt1[$state[2] & 0x00FF0000] ^ $dt2[$state[1] & 0x0000FF00] ^ $dt3[$state[0] & 0x000000FF] ^ $dw[$round][3]
-            );
-        }
-
-        // invShiftRows + invSubWord + addRoundKey
-        $state = array(
-            $this->_invSubWord(($state[0] & 0xFF000000) ^ ($state[3] & 0x00FF0000) ^ ($state[2] & 0x0000FF00) ^ ($state[1] & 0x000000FF)) ^ $dw[0][0],
-            $this->_invSubWord(($state[1] & 0xFF000000) ^ ($state[0] & 0x00FF0000) ^ ($state[3] & 0x0000FF00) ^ ($state[2] & 0x000000FF)) ^ $dw[0][1],
-            $this->_invSubWord(($state[2] & 0xFF000000) ^ ($state[1] & 0x00FF0000) ^ ($state[0] & 0x0000FF00) ^ ($state[3] & 0x000000FF)) ^ $dw[0][2],
-            $this->_invSubWord(($state[3] & 0xFF000000) ^ ($state[2] & 0x00FF0000) ^ ($state[1] & 0x0000FF00) ^ ($state[0] & 0x000000FF)) ^ $dw[0][3]
-        );
-
-        return pack('N*', $state[0], $state[1], $state[2], $state[3]);
     }
 }
-
-// vim: ts=4:sw=4:et:
-// vim6: fdl=1:
diff --git a/lib/phpseclib/Crypt/Base.php b/lib/phpseclib/Crypt/Base.php
new file mode 100644
index 0000000..7c9032f
--- /dev/null
+++ b/lib/phpseclib/Crypt/Base.php
@@ -0,0 +1,2708 @@
+<?php
+
+/**
+ * Base Class for all \phpseclib\Crypt\* cipher classes
+ *
+ * PHP version 5
+ *
+ * Internally for phpseclib developers:
+ *  If you plan to add a new cipher class, please note following rules:
+ *
+ *  - The new \phpseclib\Crypt\* cipher class should extend \phpseclib\Crypt\Base
+ *
+ *  - Following methods are then required to be overridden/overloaded:
+ *
+ *    - _encryptBlock()
+ *
+ *    - _decryptBlock()
+ *
+ *    - _setupKey()
+ *
+ *  - All other methods are optional to be overridden/overloaded
+ *
+ *  - Look at the source code of the current ciphers how they extend \phpseclib\Crypt\Base
+ *    and take one of them as a start up for the new cipher class.
+ *
+ *  - Please read all the other comments/notes/hints here also for each class var/method
+ *
+ * @category  Crypt
+ * @package   Base
+ * @author    Jim Wigginton <terrafrost@php.net>
+ * @author    Hans-Juergen Petrich <petrich@tronic-media.com>
+ * @copyright 2007 Jim Wigginton
+ * @license   http://www.opensource.org/licenses/mit-license.html  MIT License
+ * @link      http://phpseclib.sourceforge.net
+ */
+
+namespace phpseclib\Crypt;
+
+/**
+ * Base Class for all \phpseclib\Crypt\* cipher classes
+ *
+ * @package Base
+ * @author  Jim Wigginton <terrafrost@php.net>
+ * @author  Hans-Juergen Petrich <petrich@tronic-media.com>
+ */
+abstract class Base
+{
+    /**#@+
+     * @access public
+     * @see \phpseclib\Crypt\Base::encrypt()
+     * @see \phpseclib\Crypt\Base::decrypt()
+     */
+    /**
+     * Encrypt / decrypt using the Counter mode.
+     *
+     * Set to -1 since that's what Crypt/Random.php uses to index the CTR mode.
+     *
+     * @link http://en.wikipedia.org/wiki/Block_cipher_modes_of_operation#Counter_.28CTR.29
+     */
+    const MODE_CTR = -1;
+    /**
+     * Encrypt / decrypt using the Electronic Code Book mode.
+     *
+     * @link http://en.wikipedia.org/wiki/Block_cipher_modes_of_operation#Electronic_codebook_.28ECB.29
+     */
+    const MODE_ECB = 1;
+    /**
+     * Encrypt / decrypt using the Code Book Chaining mode.
+     *
+     * @link http://en.wikipedia.org/wiki/Block_cipher_modes_of_operation#Cipher-block_chaining_.28CBC.29
+     */
+    const MODE_CBC = 2;
+    /**
+     * Encrypt / decrypt using the Cipher Feedback mode.
+     *
+     * @link http://en.wikipedia.org/wiki/Block_cipher_modes_of_operation#Cipher_feedback_.28CFB.29
+     */
+    const MODE_CFB = 3;
+    /**
+     * Encrypt / decrypt using the Cipher Feedback mode (8bit)
+     */
+    const MODE_CFB8 = 38;
+    /**
+     * Encrypt / decrypt using the Output Feedback mode.
+     *
+     * @link http://en.wikipedia.org/wiki/Block_cipher_modes_of_operation#Output_feedback_.28OFB.29
+     */
+    const MODE_OFB = 4;
+    /**
+     * Encrypt / decrypt using streaming mode.
+     */
+    const MODE_STREAM = 5;
+    /**#@-*/
+
+    /**
+     * Whirlpool available flag
+     *
+     * @see \phpseclib\Crypt\Base::_hashInlineCryptFunction()
+     * @var bool
+     * @access private
+     */
+    static $WHIRLPOOL_AVAILABLE;
+
+    /**#@+
+     * @access private
+     * @see \phpseclib\Crypt\Base::__construct()
+     */
+    /**
+     * Base value for the internal implementation $engine switch
+     */
+    const ENGINE_INTERNAL = 1;
+    /**
+     * Base value for the mcrypt implementation $engine switch
+     */
+    const ENGINE_MCRYPT = 2;
+    /**
+     * Base value for the mcrypt implementation $engine switch
+     */
+    const ENGINE_OPENSSL = 3;
+    /**#@-*/
+
+    /**
+     * The Encryption Mode
+     *
+     * @see self::__construct()
+     * @var int
+     * @access private
+     */
+    var $mode;
+
+    /**
+     * The Block Length of the block cipher
+     *
+     * @var int
+     * @access private
+     */
+    var $block_size = 16;
+
+    /**
+     * The Key
+     *
+     * @see self::setKey()
+     * @var string
+     * @access private
+     */
+    var $key = "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0";
+
+    /**
+     * The Initialization Vector
+     *
+     * @see self::setIV()
+     * @var string
+     * @access private
+     */
+    var $iv;
+
+    /**
+     * A "sliding" Initialization Vector
+     *
+     * @see self::enableContinuousBuffer()
+     * @see self::_clearBuffers()
+     * @var string
+     * @access private
+     */
+    var $encryptIV;
+
+    /**
+     * A "sliding" Initialization Vector
+     *
+     * @see self::enableContinuousBuffer()
+     * @see self::_clearBuffers()
+     * @var string
+     * @access private
+     */
+    var $decryptIV;
+
+    /**
+     * Continuous Buffer status
+     *
+     * @see self::enableContinuousBuffer()
+     * @var bool
+     * @access private
+     */
+    var $continuousBuffer = false;
+
+    /**
+     * Encryption buffer for CTR, OFB and CFB modes
+     *
+     * @see self::encrypt()
+     * @see self::_clearBuffers()
+     * @var array
+     * @access private
+     */
+    var $enbuffer;
+
+    /**
+     * Decryption buffer for CTR, OFB and CFB modes
+     *
+     * @see self::decrypt()
+     * @see self::_clearBuffers()
+     * @var array
+     * @access private
+     */
+    var $debuffer;
+
+    /**
+     * mcrypt resource for encryption
+     *
+     * The mcrypt resource can be recreated every time something needs to be created or it can be created just once.
+     * Since mcrypt operates in continuous mode, by default, it'll need to be recreated when in non-continuous mode.
+     *
+     * @see self::encrypt()
+     * @var resource
+     * @access private
+     */
+    var $enmcrypt;
+
+    /**
+     * mcrypt resource for decryption
+     *
+     * The mcrypt resource can be recreated every time something needs to be created or it can be created just once.
+     * Since mcrypt operates in continuous mode, by default, it'll need to be recreated when in non-continuous mode.
+     *
+     * @see self::decrypt()
+     * @var resource
+     * @access private
+     */
+    var $demcrypt;
+
+    /**
+     * Does the enmcrypt resource need to be (re)initialized?
+     *
+     * @see \phpseclib\Crypt\Twofish::setKey()
+     * @see \phpseclib\Crypt\Twofish::setIV()
+     * @var bool
+     * @access private
+     */
+    var $enchanged = true;
+
+    /**
+     * Does the demcrypt resource need to be (re)initialized?
+     *
+     * @see \phpseclib\Crypt\Twofish::setKey()
+     * @see \phpseclib\Crypt\Twofish::setIV()
+     * @var bool
+     * @access private
+     */
+    var $dechanged = true;
+
+    /**
+     * mcrypt resource for CFB mode
+     *
+     * mcrypt's CFB mode, in (and only in) buffered context,
+     * is broken, so phpseclib implements the CFB mode by it self,
+     * even when the mcrypt php extension is available.
+     *
+     * In order to do the CFB-mode work (fast) phpseclib
+     * use a separate ECB-mode mcrypt resource.
+     *
+     * @link http://phpseclib.sourceforge.net/cfb-demo.phps
+     * @see self::encrypt()
+     * @see self::decrypt()
+     * @see self::_setupMcrypt()
+     * @var resource
+     * @access private
+     */
+    var $ecb;
+
+    /**
+     * Optimizing value while CFB-encrypting
+     *
+     * Only relevant if $continuousBuffer enabled
+     * and $engine == self::ENGINE_MCRYPT
+     *
+     * It's faster to re-init $enmcrypt if
+     * $buffer bytes > $cfb_init_len than
+     * using the $ecb resource furthermore.
+     *
+     * This value depends of the chosen cipher
+     * and the time it would be needed for it's
+     * initialization [by mcrypt_generic_init()]
+     * which, typically, depends on the complexity
+     * on its internaly Key-expanding algorithm.
+     *
+     * @see self::encrypt()
+     * @var int
+     * @access private
+     */
+    var $cfb_init_len = 600;
+
+    /**
+     * Does internal cipher state need to be (re)initialized?
+     *
+     * @see self::setKey()
+     * @see self::setIV()
+     * @see self::disableContinuousBuffer()
+     * @var bool
+     * @access private
+     */
+    var $changed = true;
+
+    /**
+     * Padding status
+     *
+     * @see self::enablePadding()
+     * @var bool
+     * @access private
+     */
+    var $padding = true;
+
+    /**
+     * Is the mode one that is paddable?
+     *
+     * @see self::__construct()
+     * @var bool
+     * @access private
+     */
+    var $paddable = false;
+
+    /**
+     * Holds which crypt engine internaly should be use,
+     * which will be determined automatically on __construct()
+     *
+     * Currently available $engines are:
+     * - self::ENGINE_OPENSSL  (very fast, php-extension: openssl, extension_loaded('openssl') required)
+     * - self::ENGINE_MCRYPT   (fast, php-extension: mcrypt, extension_loaded('mcrypt') required)
+     * - self::ENGINE_INTERNAL (slower, pure php-engine, no php-extension required)
+     *
+     * @see self::_setEngine()
+     * @see self::encrypt()
+     * @see self::decrypt()
+     * @var int
+     * @access private
+     */
+    var $engine;
+
+    /**
+     * Holds the preferred crypt engine
+     *
+     * @see self::_setEngine()
+     * @see self::setPreferredEngine()
+     * @var int
+     * @access private
+     */
+    var $preferredEngine;
+
+    /**
+     * The mcrypt specific name of the cipher
+     *
+     * Only used if $engine == self::ENGINE_MCRYPT
+     *
+     * @link http://www.php.net/mcrypt_module_open
+     * @link http://www.php.net/mcrypt_list_algorithms
+     * @see self::_setupMcrypt()
+     * @var string
+     * @access private
+     */
+    var $cipher_name_mcrypt;
+
+    /**
+     * The openssl specific name of the cipher
+     *
+     * Only used if $engine == self::ENGINE_OPENSSL
+     *
+     * @link http://www.php.net/openssl-get-cipher-methods
+     * @var string
+     * @access private
+     */
+    var $cipher_name_openssl;
+
+    /**
+     * The openssl specific name of the cipher in ECB mode
+     *
+     * If OpenSSL does not support the mode we're trying to use (CTR)
+     * it can still be emulated with ECB mode.
+     *
+     * @link http://www.php.net/openssl-get-cipher-methods
+     * @var string
+     * @access private
+     */
+    var $cipher_name_openssl_ecb;
+
+    /**
+     * The default salt used by setPassword()
+     *
+     * @see self::setPassword()
+     * @var string
+     * @access private
+     */
+    var $password_default_salt = 'phpseclib/salt';
+
+    /**
+     * The name of the performance-optimized callback function
+     *
+     * Used by encrypt() / decrypt()
+     * only if $engine == self::ENGINE_INTERNAL
+     *
+     * @see self::encrypt()
+     * @see self::decrypt()
+     * @see self::_setupInlineCrypt()
+     * @see self::$use_inline_crypt
+     * @var Callback
+     * @access private
+     */
+    var $inline_crypt;
+
+    /**
+     * Holds whether performance-optimized $inline_crypt() can/should be used.
+     *
+     * @see self::encrypt()
+     * @see self::decrypt()
+     * @see self::inline_crypt
+     * @var mixed
+     * @access private
+     */
+    var $use_inline_crypt;
+
+    /**
+     * If OpenSSL can be used in ECB but not in CTR we can emulate CTR
+     *
+     * @see self::_openssl_ctr_process()
+     * @var bool
+     * @access private
+     */
+    var $openssl_emulate_ctr = false;
+
+    /**
+     * Determines what options are passed to openssl_encrypt/decrypt
+     *
+     * @see self::isValidEngine()
+     * @var mixed
+     * @access private
+     */
+    var $openssl_options;
+
+    /**
+     * Has the key length explicitly been set or should it be derived from the key, itself?
+     *
+     * @see self::setKeyLength()
+     * @var bool
+     * @access private
+     */
+    var $explicit_key_length = false;
+
+    /**
+     * Don't truncate / null pad key
+     *
+     * @see self::_clearBuffers()
+     * @var bool
+     * @access private
+     */
+    var $skip_key_adjustment = false;
+
+    /**
+     * Default Constructor.
+     *
+     * Determines whether or not the mcrypt extension should be used.
+     *
+     * $mode could be:
+     *
+     * - self::MODE_ECB
+     *
+     * - self::MODE_CBC
+     *
+     * - self::MODE_CTR
+     *
+     * - self::MODE_CFB
+     *
+     * - self::MODE_OFB
+     *
+     * If not explicitly set, self::MODE_CBC will be used.
+     *
+     * @param int $mode
+     * @access public
+     */
+    function __construct($mode = self::MODE_CBC)
+    {
+        // $mode dependent settings
+        switch ($mode) {
+            case self::MODE_ECB:
+                $this->paddable = true;
+                $this->mode = self::MODE_ECB;
+                break;
+            case self::MODE_CTR:
+            case self::MODE_CFB:
+            case self::MODE_CFB8:
+            case self::MODE_OFB:
+            case self::MODE_STREAM:
+                $this->mode = $mode;
+                break;
+            case self::MODE_CBC:
+            default:
+                $this->paddable = true;
+                $this->mode = self::MODE_CBC;
+        }
+
+        $this->_setEngine();
+
+        // Determining whether inline crypting can be used by the cipher
+        if ($this->use_inline_crypt !== false) {
+            $this->use_inline_crypt = version_compare(PHP_VERSION, '5.3.0') >= 0 || function_exists('create_function');
+        }
+    }
+
+    /**
+     * Sets the initialization vector. (optional)
+     *
+     * SetIV is not required when self::MODE_ECB (or ie for AES: \phpseclib\Crypt\AES::MODE_ECB) is being used.  If not explicitly set, it'll be assumed
+     * to be all zero's.
+     *
+     * @access public
+     * @param string $iv
+     * @internal Can be overwritten by a sub class, but does not have to be
+     */
+    function setIV($iv)
+    {
+        if ($this->mode == self::MODE_ECB) {
+            return;
+        }
+
+        $this->iv = $iv;
+        $this->changed = true;
+    }
+
+    /**
+     * Sets the key length.
+     *
+     * Keys with explicitly set lengths need to be treated accordingly
+     *
+     * @access public
+     * @param int $length
+     */
+    function setKeyLength($length)
+    {
+        $this->explicit_key_length = true;
+        $this->changed = true;
+        $this->_setEngine();
+    }
+
+    /**
+     * Returns the current key length in bits
+     *
+     * @access public
+     * @return int
+     */
+    function getKeyLength()
+    {
+        return $this->key_length << 3;
+    }
+
+    /**
+     * Returns the current block length in bits
+     *
+     * @access public
+     * @return int
+     */
+    function getBlockLength()
+    {
+        return $this->block_size << 3;
+    }
+
+    /**
+     * Sets the key.
+     *
+     * The min/max length(s) of the key depends on the cipher which is used.
+     * If the key not fits the length(s) of the cipher it will paded with null bytes
+     * up to the closest valid key length.  If the key is more than max length,
+     * we trim the excess bits.
+     *
+     * If the key is not explicitly set, it'll be assumed to be all null bytes.
+     *
+     * @access public
+     * @param string $key
+     * @internal Could, but not must, extend by the child Crypt_* class
+     */
+    function setKey($key)
+    {
+        if (!$this->explicit_key_length) {
+            $this->setKeyLength(strlen($key) << 3);
+            $this->explicit_key_length = false;
+        }
+
+        $this->key = $key;
+        $this->changed = true;
+        $this->_setEngine();
+    }
+
+    /**
+     * Sets the password.
+     *
+     * Depending on what $method is set to, setPassword()'s (optional) parameters are as follows:
+     *     {@link http://en.wikipedia.org/wiki/PBKDF2 pbkdf2} or pbkdf1:
+     *         $hash, $salt, $count, $dkLen
+     *
+     *         Where $hash (default = sha1) currently supports the following hashes: see: Crypt/Hash.php
+     *
+     * @see Crypt/Hash.php
+     * @param string $password
+     * @param string $method
+     * @return bool
+     * @access public
+     * @internal Could, but not must, extend by the child Crypt_* class
+     */
+    function setPassword($password, $method = 'pbkdf2')
+    {
+        $key = '';
+
+        switch ($method) {
+            default: // 'pbkdf2' or 'pbkdf1'
+                $func_args = func_get_args();
+
+                // Hash function
+                $hash = isset($func_args[2]) ? $func_args[2] : 'sha1';
+
+                // WPA and WPA2 use the SSID as the salt
+                $salt = isset($func_args[3]) ? $func_args[3] : $this->password_default_salt;
+
+                // RFC2898#section-4.2 uses 1,000 iterations by default
+                // WPA and WPA2 use 4,096.
+                $count = isset($func_args[4]) ? $func_args[4] : 1000;
+
+                // Keylength
+                if (isset($func_args[5])) {
+                    $dkLen = $func_args[5];
+                } else {
+                    $dkLen = $method == 'pbkdf1' ? 2 * $this->key_length : $this->key_length;
+                }
+
+                switch (true) {
+                    case $method == 'pbkdf1':
+                        $hashObj = new Hash();
+                        $hashObj->setHash($hash);
+                        if ($dkLen > $hashObj->getLength()) {
+                            user_error('Derived key too long');
+                            return false;
+                        }
+                        $t = $password . $salt;
+                        for ($i = 0; $i < $count; ++$i) {
+                            $t = $hashObj->hash($t);
+                        }
+                        $key = substr($t, 0, $dkLen);
+
+                        $this->setKey(substr($key, 0, $dkLen >> 1));
+                        $this->setIV(substr($key, $dkLen >> 1));
+
+                        return true;
+                    // Determining if php[>=5.5.0]'s hash_pbkdf2() function avail- and useable
+                    case !function_exists('hash_pbkdf2'):
+                    case !function_exists('hash_algos'):
+                    case !in_array($hash, hash_algos()):
+                        $i = 1;
+                        while (strlen($key) < $dkLen) {
+                            $hmac = new Hash();
+                            $hmac->setHash($hash);
+                            $hmac->setKey($password);
+                            $f = $u = $hmac->hash($salt . pack('N', $i++));
+                            for ($j = 2; $j <= $count; ++$j) {
+                                $u = $hmac->hash($u);
+                                $f^= $u;
+                            }
+                            $key.= $f;
+                        }
+                        $key = substr($key, 0, $dkLen);
+                        break;
+                    default:
+                        $key = hash_pbkdf2($hash, $password, $salt, $count, $dkLen, true);
+                }
+        }
+
+        $this->setKey($key);
+
+        return true;
+    }
+
+    /**
+     * Encrypts a message.
+     *
+     * $plaintext will be padded with additional bytes such that it's length is a multiple of the block size. Other cipher
+     * implementations may or may not pad in the same manner.  Other common approaches to padding and the reasons why it's
+     * necessary are discussed in the following
+     * URL:
+     *
+     * {@link http://www.di-mgt.com.au/cryptopad.html http://www.di-mgt.com.au/cryptopad.html}
+     *
+     * An alternative to padding is to, separately, send the length of the file.  This is what SSH, in fact, does.
+     * strlen($plaintext) will still need to be a multiple of the block size, however, arbitrary values can be added to make it that
+     * length.
+     *
+     * @see self::decrypt()
+     * @access public
+     * @param string $plaintext
+     * @return string $ciphertext
+     * @internal Could, but not must, extend by the child Crypt_* class
+     */
+    function encrypt($plaintext)
+    {
+        if ($this->paddable) {
+            $plaintext = $this->_pad($plaintext);
+        }
+
+        if ($this->engine === self::ENGINE_OPENSSL) {
+            if ($this->changed) {
+                $this->_clearBuffers();
+                $this->changed = false;
+            }
+            switch ($this->mode) {
+                case self::MODE_STREAM:
+                    return openssl_encrypt($plaintext, $this->cipher_name_openssl, $this->key, $this->openssl_options);
+                case self::MODE_ECB:
+                    $result = openssl_encrypt($plaintext, $this->cipher_name_openssl, $this->key, $this->openssl_options);
+                    return !defined('OPENSSL_RAW_DATA') ? substr($result, 0, -$this->block_size) : $result;
+                case self::MODE_CBC:
+                    $result = openssl_encrypt($plaintext, $this->cipher_name_openssl, $this->key, $this->openssl_options, $this->encryptIV);
+                    if (!defined('OPENSSL_RAW_DATA')) {
+                        $result = substr($result, 0, -$this->block_size);
+                    }
+                    if ($this->continuousBuffer) {
+                        $this->encryptIV = substr($result, -$this->block_size);
+                    }
+                    return $result;
+                case self::MODE_CTR:
+                    return $this->_openssl_ctr_process($plaintext, $this->encryptIV, $this->enbuffer);
+                case self::MODE_CFB:
+                    // cfb loosely routines inspired by openssl's:
+                    // {@link http://cvs.openssl.org/fileview?f=openssl/crypto/modes/cfb128.c&v=1.3.2.2.2.1}
+                    $ciphertext = '';
+                    if ($this->continuousBuffer) {
+                        $iv = &$this->encryptIV;
+                        $pos = &$this->enbuffer['pos'];
+                    } else {
+                        $iv = $this->encryptIV;
+                        $pos = 0;
+                    }
+                    $len = strlen($plaintext);
+                    $i = 0;
+                    if ($pos) {
+                        $orig_pos = $pos;
+                        $max = $this->block_size - $pos;
+                        if ($len >= $max) {
+                            $i = $max;
+                            $len-= $max;
+                            $pos = 0;
+                        } else {
+                            $i = $len;
+                            $pos+= $len;
+                            $len = 0;
+                        }
+                        // ie. $i = min($max, $len), $len-= $i, $pos+= $i, $pos%= $blocksize
+                        $ciphertext = substr($iv, $orig_pos) ^ $plaintext;
+                        $iv = substr_replace($iv, $ciphertext, $orig_pos, $i);
+                        $plaintext = substr($plaintext, $i);
+                    }
+
+                    $overflow = $len % $this->block_size;
+
+                    if ($overflow) {
+                        $ciphertext.= openssl_encrypt(substr($plaintext, 0, -$overflow) . str_repeat("\0", $this->block_size), $this->cipher_name_openssl, $this->key, $this->openssl_options, $iv);
+                        $iv = $this->_string_pop($ciphertext, $this->block_size);
+
+                        $size = $len - $overflow;
+                        $block = $iv ^ substr($plaintext, -$overflow);
+                        $iv = substr_replace($iv, $block, 0, $overflow);
+                        $ciphertext.= $block;
+                        $pos = $overflow;
+                    } elseif ($len) {
+                        $ciphertext = openssl_encrypt($plaintext, $this->cipher_name_openssl, $this->key, $this->openssl_options, $iv);
+                        $iv = substr($ciphertext, -$this->block_size);
+                    }
+
+                    return $ciphertext;
+                case self::MODE_CFB8:
+                    $ciphertext = openssl_encrypt($plaintext, $this->cipher_name_openssl, $this->key, $this->openssl_options, $this->encryptIV);
+                    if ($this->continuousBuffer) {
+                        if (($len = strlen($ciphertext)) >= $this->block_size) {
+                            $this->encryptIV = substr($ciphertext, -$this->block_size);
+                        } else {
+                            $this->encryptIV = substr($this->encryptIV, $len - $this->block_size) . substr($ciphertext, -$len);
+                        }
+                    }
+                    return $ciphertext;
+                case self::MODE_OFB:
+                    return $this->_openssl_ofb_process($plaintext, $this->encryptIV, $this->enbuffer);
+            }
+        }
+
+        if ($this->engine === self::ENGINE_MCRYPT) {
+            if ($this->changed) {
+                $this->_setupMcrypt();
+                $this->changed = false;
+            }
+            if ($this->enchanged) {
+                @mcrypt_generic_init($this->enmcrypt, $this->key, $this->encryptIV);
+                $this->enchanged = false;
+            }
+
+            // re: {@link http://phpseclib.sourceforge.net/cfb-demo.phps}
+            // using mcrypt's default handing of CFB the above would output two different things.  using phpseclib's
+            // rewritten CFB implementation the above outputs the same thing twice.
+            if ($this->mode == self::MODE_CFB && $this->continuousBuffer) {
+                $block_size = $this->block_size;
+                $iv = &$this->encryptIV;
+                $pos = &$this->enbuffer['pos'];
+                $len = strlen($plaintext);
+                $ciphertext = '';
+                $i = 0;
+                if ($pos) {
+                    $orig_pos = $pos;
+                    $max = $block_size - $pos;
+                    if ($len >= $max) {
+                        $i = $max;
+                        $len-= $max;
+                        $pos = 0;
+                    } else {
+                        $i = $len;
+                        $pos+= $len;
+                        $len = 0;
+                    }
+                    $ciphertext = substr($iv, $orig_pos) ^ $plaintext;
+                    $iv = substr_replace($iv, $ciphertext, $orig_pos, $i);
+                    $this->enbuffer['enmcrypt_init'] = true;
+                }
+                if ($len >= $block_size) {
+                    if ($this->enbuffer['enmcrypt_init'] === false || $len > $this->cfb_init_len) {
+                        if ($this->enbuffer['enmcrypt_init'] === true) {
+                            @mcrypt_generic_init($this->enmcrypt, $this->key, $iv);
+                            $this->enbuffer['enmcrypt_init'] = false;
+                        }
+                        $ciphertext.= @mcrypt_generic($this->enmcrypt, substr($plaintext, $i, $len - $len % $block_size));
+                        $iv = substr($ciphertext, -$block_size);
+                        $len%= $block_size;
+                    } else {
+                        while ($len >= $block_size) {
+                            $iv = @mcrypt_generic($this->ecb, $iv) ^ substr($plaintext, $i, $block_size);
+                            $ciphertext.= $iv;
+                            $len-= $block_size;
+                            $i+= $block_size;
+                        }
+                    }
+                }
+
+                if ($len) {
+                    $iv = @mcrypt_generic($this->ecb, $iv);
+                    $block = $iv ^ substr($plaintext, -$len);
+                    $iv = substr_replace($iv, $block, 0, $len);
+                    $ciphertext.= $block;
+                    $pos = $len;
+                }
+
+                return $ciphertext;
+            }
+
+            $ciphertext = @mcrypt_generic($this->enmcrypt, $plaintext);
+
+            if (!$this->continuousBuffer) {
+                @mcrypt_generic_init($this->enmcrypt, $this->key, $this->encryptIV);
+            }
+
+            return $ciphertext;
+        }
+
+        if ($this->changed) {
+            $this->_setup();
+            $this->changed = false;
+        }
+        if ($this->use_inline_crypt) {
+            $inline = $this->inline_crypt;
+            return $inline('encrypt', $this, $plaintext);
+        }
+
+        $buffer = &$this->enbuffer;
+        $block_size = $this->block_size;
+        $ciphertext = '';
+        switch ($this->mode) {
+            case self::MODE_ECB:
+                for ($i = 0; $i < strlen($plaintext); $i+=$block_size) {
+                    $ciphertext.= $this->_encryptBlock(substr($plaintext, $i, $block_size));
+                }
+                break;
+            case self::MODE_CBC:
+                $xor = $this->encryptIV;
+                for ($i = 0; $i < strlen($plaintext); $i+=$block_size) {
+                    $block = substr($plaintext, $i, $block_size);
+                    $block = $this->_encryptBlock($block ^ $xor);
+                    $xor = $block;
+                    $ciphertext.= $block;
+                }
+                if ($this->continuousBuffer) {
+                    $this->encryptIV = $xor;
+                }
+                break;
+            case self::MODE_CTR:
+                $xor = $this->encryptIV;
+                if (strlen($buffer['ciphertext'])) {
+                    for ($i = 0; $i < strlen($plaintext); $i+=$block_size) {
+                        $block = substr($plaintext, $i, $block_size);
+                        if (strlen($block) > strlen($buffer['ciphertext'])) {
+                            $buffer['ciphertext'].= $this->_encryptBlock($xor);
+                        }
+                        $this->_increment_str($xor);
+                        $key = $this->_string_shift($buffer['ciphertext'], $block_size);
+                        $ciphertext.= $block ^ $key;
+                    }
+                } else {
+                    for ($i = 0; $i < strlen($plaintext); $i+=$block_size) {
+                        $block = substr($plaintext, $i, $block_size);
+                        $key = $this->_encryptBlock($xor);
+                        $this->_increment_str($xor);
+                        $ciphertext.= $block ^ $key;
+                    }
+                }
+                if ($this->continuousBuffer) {
+                    $this->encryptIV = $xor;
+                    if ($start = strlen($plaintext) % $block_size) {
+                        $buffer['ciphertext'] = substr($key, $start) . $buffer['ciphertext'];
+                    }
+                }
+                break;
+            case self::MODE_CFB:
+                // cfb loosely routines inspired by openssl's:
+                // {@link http://cvs.openssl.org/fileview?f=openssl/crypto/modes/cfb128.c&v=1.3.2.2.2.1}
+                if ($this->continuousBuffer) {
+                    $iv = &$this->encryptIV;
+                    $pos = &$buffer['pos'];
+                } else {
+                    $iv = $this->encryptIV;
+                    $pos = 0;
+                }
+                $len = strlen($plaintext);
+                $i = 0;
+                if ($pos) {
+                    $orig_pos = $pos;
+                    $max = $block_size - $pos;
+                    if ($len >= $max) {
+                        $i = $max;
+                        $len-= $max;
+                        $pos = 0;
+                    } else {
+                        $i = $len;
+                        $pos+= $len;
+                        $len = 0;
+                    }
+                    // ie. $i = min($max, $len), $len-= $i, $pos+= $i, $pos%= $blocksize
+                    $ciphertext = substr($iv, $orig_pos) ^ $plaintext;
+                    $iv = substr_replace($iv, $ciphertext, $orig_pos, $i);
+                }
+                while ($len >= $block_size) {
+                    $iv = $this->_encryptBlock($iv) ^ substr($plaintext, $i, $block_size);
+                    $ciphertext.= $iv;
+                    $len-= $block_size;
+                    $i+= $block_size;
+                }
+                if ($len) {
+                    $iv = $this->_encryptBlock($iv);
+                    $block = $iv ^ substr($plaintext, $i);
+                    $iv = substr_replace($iv, $block, 0, $len);
+                    $ciphertext.= $block;
+                    $pos = $len;
+                }
+                break;
+            case self::MODE_CFB8:
+                $ciphertext = '';
+                $len = strlen($plaintext);
+                $iv = $this->encryptIV;
+
+                for ($i = 0; $i < $len; ++$i) {
+                    $ciphertext .= ($c = $plaintext[$i] ^ $this->_encryptBlock($iv));
+                    $iv = substr($iv, 1) . $c;
+                }
+
+                if ($this->continuousBuffer) {
+                    if ($len >= $block_size) {
+                        $this->encryptIV = substr($ciphertext, -$block_size);
+                    } else {
+                        $this->encryptIV = substr($this->encryptIV, $len - $block_size) . substr($ciphertext, -$len);
+                    }
+                }
+                break;
+            case self::MODE_OFB:
+                $xor = $this->encryptIV;
+                if (strlen($buffer['xor'])) {
+                    for ($i = 0; $i < strlen($plaintext); $i+=$block_size) {
+                        $block = substr($plaintext, $i, $block_size);
+                        if (strlen($block) > strlen($buffer['xor'])) {
+                            $xor = $this->_encryptBlock($xor);
+                            $buffer['xor'].= $xor;
+                        }
+                        $key = $this->_string_shift($buffer['xor'], $block_size);
+                        $ciphertext.= $block ^ $key;
+                    }
+                } else {
+                    for ($i = 0; $i < strlen($plaintext); $i+=$block_size) {
+                        $xor = $this->_encryptBlock($xor);
+                        $ciphertext.= substr($plaintext, $i, $block_size) ^ $xor;
+                    }
+                    $key = $xor;
+                }
+                if ($this->continuousBuffer) {
+                    $this->encryptIV = $xor;
+                    if ($start = strlen($plaintext) % $block_size) {
+                        $buffer['xor'] = substr($key, $start) . $buffer['xor'];
+                    }
+                }
+                break;
+            case self::MODE_STREAM:
+                $ciphertext = $this->_encryptBlock($plaintext);
+                break;
+        }
+
+        return $ciphertext;
+    }
+
+    /**
+     * Decrypts a message.
+     *
+     * If strlen($ciphertext) is not a multiple of the block size, null bytes will be added to the end of the string until
+     * it is.
+     *
+     * @see self::encrypt()
+     * @access public
+     * @param string $ciphertext
+     * @return string $plaintext
+     * @internal Could, but not must, extend by the child Crypt_* class
+     */
+    function decrypt($ciphertext)
+    {
+        if ($this->paddable) {
+            // we pad with chr(0) since that's what mcrypt_generic does.  to quote from {@link http://www.php.net/function.mcrypt-generic}:
+            // "The data is padded with "\0" to make sure the length of the data is n * blocksize."
+            $ciphertext = str_pad($ciphertext, strlen($ciphertext) + ($this->block_size - strlen($ciphertext) % $this->block_size) % $this->block_size, chr(0));
+        }
+
+        if ($this->engine === self::ENGINE_OPENSSL) {
+            if ($this->changed) {
+                $this->_clearBuffers();
+                $this->changed = false;
+            }
+            switch ($this->mode) {
+                case self::MODE_STREAM:
+                    $plaintext = openssl_decrypt($ciphertext, $this->cipher_name_openssl, $this->key, $this->openssl_options);
+                    break;
+                case self::MODE_ECB:
+                    if (!defined('OPENSSL_RAW_DATA')) {
+                        $ciphertext.= openssl_encrypt('', $this->cipher_name_openssl_ecb, $this->key, true);
+                    }
+                    $plaintext = openssl_decrypt($ciphertext, $this->cipher_name_openssl, $this->key, $this->openssl_options);
+                    break;
+                case self::MODE_CBC:
+                    if (!defined('OPENSSL_RAW_DATA')) {
+                        $padding = str_repeat(chr($this->block_size), $this->block_size) ^ substr($ciphertext, -$this->block_size);
+                        $ciphertext.= substr(openssl_encrypt($padding, $this->cipher_name_openssl_ecb, $this->key, true), 0, $this->block_size);
+                        $offset = 2 * $this->block_size;
+                    } else {
+                        $offset = $this->block_size;
+                    }
+                    $plaintext = openssl_decrypt($ciphertext, $this->cipher_name_openssl, $this->key, $this->openssl_options, $this->decryptIV);
+                    if ($this->continuousBuffer) {
+                        $this->decryptIV = substr($ciphertext, -$offset, $this->block_size);
+                    }
+                    break;
+                case self::MODE_CTR:
+                    $plaintext = $this->_openssl_ctr_process($ciphertext, $this->decryptIV, $this->debuffer);
+                    break;
+                case self::MODE_CFB:
+                    // cfb loosely routines inspired by openssl's:
+                    // {@link http://cvs.openssl.org/fileview?f=openssl/crypto/modes/cfb128.c&v=1.3.2.2.2.1}
+                    $plaintext = '';
+                    if ($this->continuousBuffer) {
+                        $iv = &$this->decryptIV;
+                        $pos = &$this->buffer['pos'];
+                    } else {
+                        $iv = $this->decryptIV;
+                        $pos = 0;
+                    }
+                    $len = strlen($ciphertext);
+                    $i = 0;
+                    if ($pos) {
+                        $orig_pos = $pos;
+                        $max = $this->block_size - $pos;
+                        if ($len >= $max) {
+                            $i = $max;
+                            $len-= $max;
+                            $pos = 0;
+                        } else {
+                            $i = $len;
+                            $pos+= $len;
+                            $len = 0;
+                        }
+                        // ie. $i = min($max, $len), $len-= $i, $pos+= $i, $pos%= $this->blocksize
+                        $plaintext = substr($iv, $orig_pos) ^ $ciphertext;
+                        $iv = substr_replace($iv, substr($ciphertext, 0, $i), $orig_pos, $i);
+                        $ciphertext = substr($ciphertext, $i);
+                    }
+                    $overflow = $len % $this->block_size;
+                    if ($overflow) {
+                        $plaintext.= openssl_decrypt(substr($ciphertext, 0, -$overflow), $this->cipher_name_openssl, $this->key, $this->openssl_options, $iv);
+                        if ($len - $overflow) {
+                            $iv = substr($ciphertext, -$overflow - $this->block_size, -$overflow);
+                        }
+                        $iv = openssl_encrypt(str_repeat("\0", $this->block_size), $this->cipher_name_openssl, $this->key, $this->openssl_options, $iv);
+                        $plaintext.= $iv ^ substr($ciphertext, -$overflow);
+                        $iv = substr_replace($iv, substr($ciphertext, -$overflow), 0, $overflow);
+                        $pos = $overflow;
+                    } elseif ($len) {
+                        $plaintext.= openssl_decrypt($ciphertext, $this->cipher_name_openssl, $this->key, $this->openssl_options, $iv);
+                        $iv = substr($ciphertext, -$this->block_size);
+                    }
+                    break;
+                case self::MODE_CFB8:
+                    $plaintext = openssl_decrypt($ciphertext, $this->cipher_name_openssl, $this->key, $this->openssl_options, $this->decryptIV);
+                    if ($this->continuousBuffer) {
+                        if (($len = strlen($ciphertext)) >= $this->block_size) {
+                            $this->decryptIV = substr($ciphertext, -$this->block_size);
+                        } else {
+                            $this->decryptIV = substr($this->decryptIV, $len - $this->block_size) . substr($ciphertext, -$len);
+                        }
+                    }
+                    break;
+                case self::MODE_OFB:
+                    $plaintext = $this->_openssl_ofb_process($ciphertext, $this->decryptIV, $this->debuffer);
+            }
+
+            return $this->paddable ? $this->_unpad($plaintext) : $plaintext;
+        }
+
+        if ($this->engine === self::ENGINE_MCRYPT) {
+            $block_size = $this->block_size;
+            if ($this->changed) {
+                $this->_setupMcrypt();
+                $this->changed = false;
+            }
+            if ($this->dechanged) {
+                @mcrypt_generic_init($this->demcrypt, $this->key, $this->decryptIV);
+                $this->dechanged = false;
+            }
+
+            if ($this->mode == self::MODE_CFB && $this->continuousBuffer) {
+                $iv = &$this->decryptIV;
+                $pos = &$this->debuffer['pos'];
+                $len = strlen($ciphertext);
+                $plaintext = '';
+                $i = 0;
+                if ($pos) {
+                    $orig_pos = $pos;
+                    $max = $block_size - $pos;
+                    if ($len >= $max) {
+                        $i = $max;
+                        $len-= $max;
+                        $pos = 0;
+                    } else {
+                        $i = $len;
+                        $pos+= $len;
+                        $len = 0;
+                    }
+                    // ie. $i = min($max, $len), $len-= $i, $pos+= $i, $pos%= $blocksize
+                    $plaintext = substr($iv, $orig_pos) ^ $ciphertext;
+                    $iv = substr_replace($iv, substr($ciphertext, 0, $i), $orig_pos, $i);
+                }
+                if ($len >= $block_size) {
+                    $cb = substr($ciphertext, $i, $len - $len % $block_size);
+                    $plaintext.= @mcrypt_generic($this->ecb, $iv . $cb) ^ $cb;
+                    $iv = substr($cb, -$block_size);
+                    $len%= $block_size;
+                }
+                if ($len) {
+                    $iv = @mcrypt_generic($this->ecb, $iv);
+                    $plaintext.= $iv ^ substr($ciphertext, -$len);
+                    $iv = substr_replace($iv, substr($ciphertext, -$len), 0, $len);
+                    $pos = $len;
+                }
+
+                return $plaintext;
+            }
+
+            $plaintext = @mdecrypt_generic($this->demcrypt, $ciphertext);
+
+            if (!$this->continuousBuffer) {
+                @mcrypt_generic_init($this->demcrypt, $this->key, $this->decryptIV);
+            }
+
+            return $this->paddable ? $this->_unpad($plaintext) : $plaintext;
+        }
+
+        if ($this->changed) {
+            $this->_setup();
+            $this->changed = false;
+        }
+        if ($this->use_inline_crypt) {
+            $inline = $this->inline_crypt;
+            return $inline('decrypt', $this, $ciphertext);
+        }
+
+        $block_size = $this->block_size;
+
+        $buffer = &$this->debuffer;
+        $plaintext = '';
+        switch ($this->mode) {
+            case self::MODE_ECB:
+                for ($i = 0; $i < strlen($ciphertext); $i+=$block_size) {
+                    $plaintext.= $this->_decryptBlock(substr($ciphertext, $i, $block_size));
+                }
+                break;
+            case self::MODE_CBC:
+                $xor = $this->decryptIV;
+                for ($i = 0; $i < strlen($ciphertext); $i+=$block_size) {
+                    $block = substr($ciphertext, $i, $block_size);
+                    $plaintext.= $this->_decryptBlock($block) ^ $xor;
+                    $xor = $block;
+                }
+                if ($this->continuousBuffer) {
+                    $this->decryptIV = $xor;
+                }
+                break;
+            case self::MODE_CTR:
+                $xor = $this->decryptIV;
+                if (strlen($buffer['ciphertext'])) {
+                    for ($i = 0; $i < strlen($ciphertext); $i+=$block_size) {
+                        $block = substr($ciphertext, $i, $block_size);
+                        if (strlen($block) > strlen($buffer['ciphertext'])) {
+                            $buffer['ciphertext'].= $this->_encryptBlock($xor);
+                            $this->_increment_str($xor);
+                        }
+                        $key = $this->_string_shift($buffer['ciphertext'], $block_size);
+                        $plaintext.= $block ^ $key;
+                    }
+                } else {
+                    for ($i = 0; $i < strlen($ciphertext); $i+=$block_size) {
+                        $block = substr($ciphertext, $i, $block_size);
+                        $key = $this->_encryptBlock($xor);
+                        $this->_increment_str($xor);
+                        $plaintext.= $block ^ $key;
+                    }
+                }
+                if ($this->continuousBuffer) {
+                    $this->decryptIV = $xor;
+                    if ($start = strlen($ciphertext) % $block_size) {
+                        $buffer['ciphertext'] = substr($key, $start) . $buffer['ciphertext'];
+                    }
+                }
+                break;
+            case self::MODE_CFB:
+                if ($this->continuousBuffer) {
+                    $iv = &$this->decryptIV;
+                    $pos = &$buffer['pos'];
+                } else {
+                    $iv = $this->decryptIV;
+                    $pos = 0;
+                }
+                $len = strlen($ciphertext);
+                $i = 0;
+                if ($pos) {
+                    $orig_pos = $pos;
+                    $max = $block_size - $pos;
+                    if ($len >= $max) {
+                        $i = $max;
+                        $len-= $max;
+                        $pos = 0;
+                    } else {
+                        $i = $len;
+                        $pos+= $len;
+                        $len = 0;
+                    }
+                    // ie. $i = min($max, $len), $len-= $i, $pos+= $i, $pos%= $blocksize
+                    $plaintext = substr($iv, $orig_pos) ^ $ciphertext;
+                    $iv = substr_replace($iv, substr($ciphertext, 0, $i), $orig_pos, $i);
+                }
+                while ($len >= $block_size) {
+                    $iv = $this->_encryptBlock($iv);
+                    $cb = substr($ciphertext, $i, $block_size);
+                    $plaintext.= $iv ^ $cb;
+                    $iv = $cb;
+                    $len-= $block_size;
+                    $i+= $block_size;
+                }
+                if ($len) {
+                    $iv = $this->_encryptBlock($iv);
+                    $plaintext.= $iv ^ substr($ciphertext, $i);
+                    $iv = substr_replace($iv, substr($ciphertext, $i), 0, $len);
+                    $pos = $len;
+                }
+                break;
+            case self::MODE_CFB8:
+                $plaintext = '';
+                $len = strlen($ciphertext);
+                $iv = $this->decryptIV;
+
+                for ($i = 0; $i < $len; ++$i) {
+                    $plaintext .= $ciphertext[$i] ^ $this->_encryptBlock($iv);
+                    $iv = substr($iv, 1) . $ciphertext[$i];
+                }
+
+                if ($this->continuousBuffer) {
+                    if ($len >= $block_size) {
+                        $this->decryptIV = substr($ciphertext, -$block_size);
+                    } else {
+                        $this->decryptIV = substr($this->decryptIV, $len - $block_size) . substr($ciphertext, -$len);
+                    }
+                }
+                break;
+            case self::MODE_OFB:
+                $xor = $this->decryptIV;
+                if (strlen($buffer['xor'])) {
+                    for ($i = 0; $i < strlen($ciphertext); $i+=$block_size) {
+                        $block = substr($ciphertext, $i, $block_size);
+                        if (strlen($block) > strlen($buffer['xor'])) {
+                            $xor = $this->_encryptBlock($xor);
+                            $buffer['xor'].= $xor;
+                        }
+                        $key = $this->_string_shift($buffer['xor'], $block_size);
+                        $plaintext.= $block ^ $key;
+                    }
+                } else {
+                    for ($i = 0; $i < strlen($ciphertext); $i+=$block_size) {
+                        $xor = $this->_encryptBlock($xor);
+                        $plaintext.= substr($ciphertext, $i, $block_size) ^ $xor;
+                    }
+                    $key = $xor;
+                }
+                if ($this->continuousBuffer) {
+                    $this->decryptIV = $xor;
+                    if ($start = strlen($ciphertext) % $block_size) {
+                        $buffer['xor'] = substr($key, $start) . $buffer['xor'];
+                    }
+                }
+                break;
+            case self::MODE_STREAM:
+                $plaintext = $this->_decryptBlock($ciphertext);
+                break;
+        }
+        return $this->paddable ? $this->_unpad($plaintext) : $plaintext;
+    }
+
+    /**
+     * OpenSSL CTR Processor
+     *
+     * PHP's OpenSSL bindings do not operate in continuous mode so we'll wrap around it. Since the keystream
+     * for CTR is the same for both encrypting and decrypting this function is re-used by both Base::encrypt()
+     * and Base::decrypt(). Also, OpenSSL doesn't implement CTR for all of it's symmetric ciphers so this
+     * function will emulate CTR with ECB when necessary.
+     *
+     * @see self::encrypt()
+     * @see self::decrypt()
+     * @param string $plaintext
+     * @param string $encryptIV
+     * @param array $buffer
+     * @return string
+     * @access private
+     */
+    function _openssl_ctr_process($plaintext, &$encryptIV, &$buffer)
+    {
+        $ciphertext = '';
+
+        $block_size = $this->block_size;
+        $key = $this->key;
+
+        if ($this->openssl_emulate_ctr) {
+            $xor = $encryptIV;
+            if (strlen($buffer['ciphertext'])) {
+                for ($i = 0; $i < strlen($plaintext); $i+=$block_size) {
+                    $block = substr($plaintext, $i, $block_size);
+                    if (strlen($block) > strlen($buffer['ciphertext'])) {
+                        $result = openssl_encrypt($xor, $this->cipher_name_openssl_ecb, $key, $this->openssl_options);
+                        $result = !defined('OPENSSL_RAW_DATA') ? substr($result, 0, -$this->block_size) : $result;
+                        $buffer['ciphertext'].= $result;
+                    }
+                    $this->_increment_str($xor);
+                    $otp = $this->_string_shift($buffer['ciphertext'], $block_size);
+                    $ciphertext.= $block ^ $otp;
+                }
+            } else {
+                for ($i = 0; $i < strlen($plaintext); $i+=$block_size) {
+                    $block = substr($plaintext, $i, $block_size);
+                    $otp = openssl_encrypt($xor, $this->cipher_name_openssl_ecb, $key, $this->openssl_options);
+                    $otp = !defined('OPENSSL_RAW_DATA') ? substr($otp, 0, -$this->block_size) : $otp;
+                    $this->_increment_str($xor);
+                    $ciphertext.= $block ^ $otp;
+                }
+            }
+            if ($this->continuousBuffer) {
+                $encryptIV = $xor;
+                if ($start = strlen($plaintext) % $block_size) {
+                    $buffer['ciphertext'] = substr($key, $start) . $buffer['ciphertext'];
+                }
+            }
+
+            return $ciphertext;
+        }
+
+        if (strlen($buffer['ciphertext'])) {
+            $ciphertext = $plaintext ^ $this->_string_shift($buffer['ciphertext'], strlen($plaintext));
+            $plaintext = substr($plaintext, strlen($ciphertext));
+
+            if (!strlen($plaintext)) {
+                return $ciphertext;
+            }
+        }
+
+        $overflow = strlen($plaintext) % $block_size;
+        if ($overflow) {
+            $plaintext2 = $this->_string_pop($plaintext, $overflow); // ie. trim $plaintext to a multiple of $block_size and put rest of $plaintext in $plaintext2
+            $encrypted = openssl_encrypt($plaintext . str_repeat("\0", $block_size), $this->cipher_name_openssl, $key, $this->openssl_options, $encryptIV);
+            $temp = $this->_string_pop($encrypted, $block_size);
+            $ciphertext.= $encrypted . ($plaintext2 ^ $temp);
+            if ($this->continuousBuffer) {
+                $buffer['ciphertext'] = substr($temp, $overflow);
+                $encryptIV = $temp;
+            }
+        } elseif (!strlen($buffer['ciphertext'])) {
+            $ciphertext.= openssl_encrypt($plaintext . str_repeat("\0", $block_size), $this->cipher_name_openssl, $key, $this->openssl_options, $encryptIV);
+            $temp = $this->_string_pop($ciphertext, $block_size);
+            if ($this->continuousBuffer) {
+                $encryptIV = $temp;
+            }
+        }
+        if ($this->continuousBuffer) {
+            if (!defined('OPENSSL_RAW_DATA')) {
+                $encryptIV.= openssl_encrypt('', $this->cipher_name_openssl_ecb, $key, $this->openssl_options);
+            }
+            $encryptIV = openssl_decrypt($encryptIV, $this->cipher_name_openssl_ecb, $key, $this->openssl_options);
+            if ($overflow) {
+                $this->_increment_str($encryptIV);
+            }
+        }
+
+        return $ciphertext;
+    }
+
+    /**
+     * OpenSSL OFB Processor
+     *
+     * PHP's OpenSSL bindings do not operate in continuous mode so we'll wrap around it. Since the keystream
+     * for OFB is the same for both encrypting and decrypting this function is re-used by both Base::encrypt()
+     * and Base::decrypt().
+     *
+     * @see self::encrypt()
+     * @see self::decrypt()
+     * @param string $plaintext
+     * @param string $encryptIV
+     * @param array $buffer
+     * @return string
+     * @access private
+     */
+    function _openssl_ofb_process($plaintext, &$encryptIV, &$buffer)
+    {
+        if (strlen($buffer['xor'])) {
+            $ciphertext = $plaintext ^ $buffer['xor'];
+            $buffer['xor'] = substr($buffer['xor'], strlen($ciphertext));
+            $plaintext = substr($plaintext, strlen($ciphertext));
+        } else {
+            $ciphertext = '';
+        }
+
+        $block_size = $this->block_size;
+
+        $len = strlen($plaintext);
+        $key = $this->key;
+        $overflow = $len % $block_size;
+
+        if (strlen($plaintext)) {
+            if ($overflow) {
+                $ciphertext.= openssl_encrypt(substr($plaintext, 0, -$overflow) . str_repeat("\0", $block_size), $this->cipher_name_openssl, $key, $this->openssl_options, $encryptIV);
+                $xor = $this->_string_pop($ciphertext, $block_size);
+                if ($this->continuousBuffer) {
+                    $encryptIV = $xor;
+                }
+                $ciphertext.= $this->_string_shift($xor, $overflow) ^ substr($plaintext, -$overflow);
+                if ($this->continuousBuffer) {
+                    $buffer['xor'] = $xor;
+                }
+            } else {
+                $ciphertext = openssl_encrypt($plaintext, $this->cipher_name_openssl, $key, $this->openssl_options, $encryptIV);
+                if ($this->continuousBuffer) {
+                    $encryptIV = substr($ciphertext, -$block_size) ^ substr($plaintext, -$block_size);
+                }
+            }
+        }
+
+        return $ciphertext;
+    }
+
+    /**
+     * phpseclib <-> OpenSSL Mode Mapper
+     *
+     * May need to be overwritten by classes extending this one in some cases
+     *
+     * @return int
+     * @access private
+     */
+    function _openssl_translate_mode()
+    {
+        switch ($this->mode) {
+            case self::MODE_ECB:
+                return 'ecb';
+            case self::MODE_CBC:
+                return 'cbc';
+            case self::MODE_CTR:
+                return 'ctr';
+            case self::MODE_CFB:
+                return 'cfb';
+            case self::MODE_CFB8:
+                return 'cfb8';
+            case self::MODE_OFB:
+                return 'ofb';
+        }
+    }
+
+    /**
+     * Pad "packets".
+     *
+     * Block ciphers working by encrypting between their specified [$this->]block_size at a time
+     * If you ever need to encrypt or decrypt something that isn't of the proper length, it becomes necessary to
+     * pad the input so that it is of the proper length.
+     *
+     * Padding is enabled by default.  Sometimes, however, it is undesirable to pad strings.  Such is the case in SSH,
+     * where "packets" are padded with random bytes before being encrypted.  Unpad these packets and you risk stripping
+     * away characters that shouldn't be stripped away. (SSH knows how many bytes are added because the length is
+     * transmitted separately)
+     *
+     * @see self::disablePadding()
+     * @access public
+     */
+    function enablePadding()
+    {
+        $this->padding = true;
+    }
+
+    /**
+     * Do not pad packets.
+     *
+     * @see self::enablePadding()
+     * @access public
+     */
+    function disablePadding()
+    {
+        $this->padding = false;
+    }
+
+    /**
+     * Treat consecutive "packets" as if they are a continuous buffer.
+     *
+     * Say you have a 32-byte plaintext $plaintext.  Using the default behavior, the two following code snippets
+     * will yield different outputs:
+     *
+     * <code>
+     *    echo $rijndael->encrypt(substr($plaintext,  0, 16));
+     *    echo $rijndael->encrypt(substr($plaintext, 16, 16));
+     * </code>
+     * <code>
+     *    echo $rijndael->encrypt($plaintext);
+     * </code>
+     *
+     * The solution is to enable the continuous buffer.  Although this will resolve the above discrepancy, it creates
+     * another, as demonstrated with the following:
+     *
+     * <code>
+     *    $rijndael->encrypt(substr($plaintext, 0, 16));
+     *    echo $rijndael->decrypt($rijndael->encrypt(substr($plaintext, 16, 16)));
+     * </code>
+     * <code>
+     *    echo $rijndael->decrypt($rijndael->encrypt(substr($plaintext, 16, 16)));
+     * </code>
+     *
+     * With the continuous buffer disabled, these would yield the same output.  With it enabled, they yield different
+     * outputs.  The reason is due to the fact that the initialization vector's change after every encryption /
+     * decryption round when the continuous buffer is enabled.  When it's disabled, they remain constant.
+     *
+     * Put another way, when the continuous buffer is enabled, the state of the \phpseclib\Crypt\*() object changes after each
+     * encryption / decryption round, whereas otherwise, it'd remain constant.  For this reason, it's recommended that
+     * continuous buffers not be used.  They do offer better security and are, in fact, sometimes required (SSH uses them),
+     * however, they are also less intuitive and more likely to cause you problems.
+     *
+     * @see self::disableContinuousBuffer()
+     * @access public
+     * @internal Could, but not must, extend by the child Crypt_* class
+     */
+    function enableContinuousBuffer()
+    {
+        if ($this->mode == self::MODE_ECB) {
+            return;
+        }
+
+        $this->continuousBuffer = true;
+
+        $this->_setEngine();
+    }
+
+    /**
+     * Treat consecutive packets as if they are a discontinuous buffer.
+     *
+     * The default behavior.
+     *
+     * @see self::enableContinuousBuffer()
+     * @access public
+     * @internal Could, but not must, extend by the child Crypt_* class
+     */
+    function disableContinuousBuffer()
+    {
+        if ($this->mode == self::MODE_ECB) {
+            return;
+        }
+        if (!$this->continuousBuffer) {
+            return;
+        }
+
+        $this->continuousBuffer = false;
+        $this->changed = true;
+
+        $this->_setEngine();
+    }
+
+    /**
+     * Test for engine validity
+     *
+     * @see self::__construct()
+     * @param int $engine
+     * @access public
+     * @return bool
+     */
+    function isValidEngine($engine)
+    {
+        switch ($engine) {
+            case self::ENGINE_OPENSSL:
+                if ($this->mode == self::MODE_STREAM && $this->continuousBuffer) {
+                    return false;
+                }
+                $this->openssl_emulate_ctr = false;
+                $result = $this->cipher_name_openssl &&
+                          extension_loaded('openssl') &&
+                          // PHP 5.3.0 - 5.3.2 did not let you set IV's
+                          version_compare(PHP_VERSION, '5.3.3', '>=');
+                if (!$result) {
+                    return false;
+                }
+
+                // prior to PHP 5.4.0 OPENSSL_RAW_DATA and OPENSSL_ZERO_PADDING were not defined. instead of expecting an integer
+                // $options openssl_encrypt expected a boolean $raw_data.
+                if (!defined('OPENSSL_RAW_DATA')) {
+                    $this->openssl_options = true;
+                } else {
+                    $this->openssl_options = OPENSSL_RAW_DATA | OPENSSL_ZERO_PADDING;
+                }
+
+                $methods = openssl_get_cipher_methods();
+                if (in_array($this->cipher_name_openssl, $methods)) {
+                    return true;
+                }
+                // not all of openssl's symmetric cipher's support ctr. for those
+                // that don't we'll emulate it
+                switch ($this->mode) {
+                    case self::MODE_CTR:
+                        if (in_array($this->cipher_name_openssl_ecb, $methods)) {
+                            $this->openssl_emulate_ctr = true;
+                            return true;
+                        }
+                }
+                return false;
+            case self::ENGINE_MCRYPT:
+                return $this->cipher_name_mcrypt &&
+                       extension_loaded('mcrypt') &&
+                       in_array($this->cipher_name_mcrypt, @mcrypt_list_algorithms());
+            case self::ENGINE_INTERNAL:
+                return true;
+        }
+
+        return false;
+    }
+
+    /**
+     * Sets the preferred crypt engine
+     *
+     * Currently, $engine could be:
+     *
+     * - \phpseclib\Crypt\Base::ENGINE_OPENSSL  [very fast]
+     *
+     * - \phpseclib\Crypt\Base::ENGINE_MCRYPT   [fast]
+     *
+     * - \phpseclib\Crypt\Base::ENGINE_INTERNAL [slow]
+     *
+     * If the preferred crypt engine is not available the fastest available one will be used
+     *
+     * @see self::__construct()
+     * @param int $engine
+     * @access public
+     */
+    function setPreferredEngine($engine)
+    {
+        switch ($engine) {
+            //case self::ENGINE_OPENSSL;
+            case self::ENGINE_MCRYPT:
+            case self::ENGINE_INTERNAL:
+                $this->preferredEngine = $engine;
+                break;
+            default:
+                $this->preferredEngine = self::ENGINE_OPENSSL;
+        }
+
+        $this->_setEngine();
+    }
+
+    /**
+     * Returns the engine currently being utilized
+     *
+     * @see self::_setEngine()
+     * @access public
+     */
+    function getEngine()
+    {
+        return $this->engine;
+    }
+
+    /**
+     * Sets the engine as appropriate
+     *
+     * @see self::__construct()
+     * @access private
+     */
+    function _setEngine()
+    {
+        $this->engine = null;
+
+        $candidateEngines = array(
+            $this->preferredEngine,
+            self::ENGINE_OPENSSL,
+            self::ENGINE_MCRYPT
+        );
+        foreach ($candidateEngines as $engine) {
+            if ($this->isValidEngine($engine)) {
+                $this->engine = $engine;
+                break;
+            }
+        }
+        if (!$this->engine) {
+            $this->engine = self::ENGINE_INTERNAL;
+        }
+
+        if ($this->engine != self::ENGINE_MCRYPT && $this->enmcrypt) {
+            // Closing the current mcrypt resource(s). _mcryptSetup() will, if needed,
+            // (re)open them with the module named in $this->cipher_name_mcrypt
+            @mcrypt_module_close($this->enmcrypt);
+            @mcrypt_module_close($this->demcrypt);
+            $this->enmcrypt = null;
+            $this->demcrypt = null;
+
+            if ($this->ecb) {
+                @mcrypt_module_close($this->ecb);
+                $this->ecb = null;
+            }
+        }
+
+        $this->changed = true;
+    }
+
+    /**
+     * Encrypts a block
+     *
+     * Note: Must be extended by the child \phpseclib\Crypt\* class
+     *
+     * @access private
+     * @param string $in
+     * @return string
+     */
+    abstract function _encryptBlock($in);
+
+    /**
+     * Decrypts a block
+     *
+     * Note: Must be extended by the child \phpseclib\Crypt\* class
+     *
+     * @access private
+     * @param string $in
+     * @return string
+     */
+    abstract function _decryptBlock($in);
+
+    /**
+     * Setup the key (expansion)
+     *
+     * Only used if $engine == self::ENGINE_INTERNAL
+     *
+     * Note: Must extend by the child \phpseclib\Crypt\* class
+     *
+     * @see self::_setup()
+     * @access private
+     */
+    abstract function _setupKey();
+
+    /**
+     * Setup the self::ENGINE_INTERNAL $engine
+     *
+     * (re)init, if necessary, the internal cipher $engine and flush all $buffers
+     * Used (only) if $engine == self::ENGINE_INTERNAL
+     *
+     * _setup() will be called each time if $changed === true
+     * typically this happens when using one or more of following public methods:
+     *
+     * - setKey()
+     *
+     * - setIV()
+     *
+     * - disableContinuousBuffer()
+     *
+     * - First run of encrypt() / decrypt() with no init-settings
+     *
+     * @see self::setKey()
+     * @see self::setIV()
+     * @see self::disableContinuousBuffer()
+     * @access private
+     * @internal _setup() is always called before en/decryption.
+     * @internal Could, but not must, extend by the child Crypt_* class
+     */
+    function _setup()
+    {
+        $this->_clearBuffers();
+        $this->_setupKey();
+
+        if ($this->use_inline_crypt) {
+            $this->_setupInlineCrypt();
+        }
+    }
+
+    /**
+     * Setup the self::ENGINE_MCRYPT $engine
+     *
+     * (re)init, if necessary, the (ext)mcrypt resources and flush all $buffers
+     * Used (only) if $engine = self::ENGINE_MCRYPT
+     *
+     * _setupMcrypt() will be called each time if $changed === true
+     * typically this happens when using one or more of following public methods:
+     *
+     * - setKey()
+     *
+     * - setIV()
+     *
+     * - disableContinuousBuffer()
+     *
+     * - First run of encrypt() / decrypt()
+     *
+     * @see self::setKey()
+     * @see self::setIV()
+     * @see self::disableContinuousBuffer()
+     * @access private
+     * @internal Could, but not must, extend by the child Crypt_* class
+     */
+    function _setupMcrypt()
+    {
+        $this->_clearBuffers();
+        $this->enchanged = $this->dechanged = true;
+
+        if (!isset($this->enmcrypt)) {
+            static $mcrypt_modes = array(
+                self::MODE_CTR    => 'ctr',
+                self::MODE_ECB    => MCRYPT_MODE_ECB,
+                self::MODE_CBC    => MCRYPT_MODE_CBC,
+                self::MODE_CFB    => 'ncfb',
+                self::MODE_CFB8   => MCRYPT_MODE_CFB,
+                self::MODE_OFB    => MCRYPT_MODE_NOFB,
+                self::MODE_STREAM => MCRYPT_MODE_STREAM,
+            );
+
+            $this->demcrypt = @mcrypt_module_open($this->cipher_name_mcrypt, '', $mcrypt_modes[$this->mode], '');
+            $this->enmcrypt = @mcrypt_module_open($this->cipher_name_mcrypt, '', $mcrypt_modes[$this->mode], '');
+
+            // we need the $ecb mcrypt resource (only) in MODE_CFB with enableContinuousBuffer()
+            // to workaround mcrypt's broken ncfb implementation in buffered mode
+            // see: {@link http://phpseclib.sourceforge.net/cfb-demo.phps}
+            if ($this->mode == self::MODE_CFB) {
+                $this->ecb = @mcrypt_module_open($this->cipher_name_mcrypt, '', MCRYPT_MODE_ECB, '');
+            }
+        } // else should mcrypt_generic_deinit be called?
+
+        if ($this->mode == self::MODE_CFB) {
+            @mcrypt_generic_init($this->ecb, $this->key, str_repeat("\0", $this->block_size));
+        }
+    }
+
+    /**
+     * Pads a string
+     *
+     * Pads a string using the RSA PKCS padding standards so that its length is a multiple of the blocksize.
+     * $this->block_size - (strlen($text) % $this->block_size) bytes are added, each of which is equal to
+     * chr($this->block_size - (strlen($text) % $this->block_size)
+     *
+     * If padding is disabled and $text is not a multiple of the blocksize, the string will be padded regardless
+     * and padding will, hence forth, be enabled.
+     *
+     * @see self::_unpad()
+     * @param string $text
+     * @access private
+     * @return string
+     */
+    function _pad($text)
+    {
+        $length = strlen($text);
+
+        if (!$this->padding) {
+            if ($length % $this->block_size == 0) {
+                return $text;
+            } else {
+                user_error("The plaintext's length ($length) is not a multiple of the block size ({$this->block_size})");
+                $this->padding = true;
+            }
+        }
+
+        $pad = $this->block_size - ($length % $this->block_size);
+
+        return str_pad($text, $length + $pad, chr($pad));
+    }
+
+    /**
+     * Unpads a string.
+     *
+     * If padding is enabled and the reported padding length is invalid the encryption key will be assumed to be wrong
+     * and false will be returned.
+     *
+     * @see self::_pad()
+     * @param string $text
+     * @access private
+     * @return string
+     */
+    function _unpad($text)
+    {
+        if (!$this->padding) {
+            return $text;
+        }
+
+        $length = ord($text[strlen($text) - 1]);
+
+        if (!$length || $length > $this->block_size) {
+            return false;
+        }
+
+        return substr($text, 0, -$length);
+    }
+
+    /**
+     * Clears internal buffers
+     *
+     * Clearing/resetting the internal buffers is done everytime
+     * after disableContinuousBuffer() or on cipher $engine (re)init
+     * ie after setKey() or setIV()
+     *
+     * @access public
+     * @internal Could, but not must, extend by the child Crypt_* class
+     */
+    function _clearBuffers()
+    {
+        $this->enbuffer = $this->debuffer = array('ciphertext' => '', 'xor' => '', 'pos' => 0, 'enmcrypt_init' => true);
+
+        // mcrypt's handling of invalid's $iv:
+        // $this->encryptIV = $this->decryptIV = strlen($this->iv) == $this->block_size ? $this->iv : str_repeat("\0", $this->block_size);
+        $this->encryptIV = $this->decryptIV = str_pad(substr($this->iv, 0, $this->block_size), $this->block_size, "\0");
+
+        if (!$this->skip_key_adjustment) {
+            $this->key = str_pad(substr($this->key, 0, $this->key_length), $this->key_length, "\0");
+        }
+    }
+
+    /**
+     * String Shift
+     *
+     * Inspired by array_shift
+     *
+     * @param string $string
+     * @param int $index
+     * @access private
+     * @return string
+     */
+    function _string_shift(&$string, $index = 1)
+    {
+        $substr = substr($string, 0, $index);
+        $string = substr($string, $index);
+        return $substr;
+    }
+
+    /**
+     * String Pop
+     *
+     * Inspired by array_pop
+     *
+     * @param string $string
+     * @param int $index
+     * @access private
+     * @return string
+     */
+    function _string_pop(&$string, $index = 1)
+    {
+        $substr = substr($string, -$index);
+        $string = substr($string, 0, -$index);
+        return $substr;
+    }
+
+    /**
+     * Increment the current string
+     *
+     * @see self::decrypt()
+     * @see self::encrypt()
+     * @param string $var
+     * @access private
+     */
+    function _increment_str(&$var)
+    {
+        for ($i = 4; $i <= strlen($var); $i+= 4) {
+            $temp = substr($var, -$i, 4);
+            switch ($temp) {
+                case "\xFF\xFF\xFF\xFF":
+                    $var = substr_replace($var, "\x00\x00\x00\x00", -$i, 4);
+                    break;
+                case "\x7F\xFF\xFF\xFF":
+                    $var = substr_replace($var, "\x80\x00\x00\x00", -$i, 4);
+                    return;
+                default:
+                    $temp = unpack('Nnum', $temp);
+                    $var = substr_replace($var, pack('N', $temp['num'] + 1), -$i, 4);
+                    return;
+            }
+        }
+
+        $remainder = strlen($var) % 4;
+
+        if ($remainder == 0) {
+            return;
+        }
+
+        $temp = unpack('Nnum', str_pad(substr($var, 0, $remainder), 4, "\0", STR_PAD_LEFT));
+        $temp = substr(pack('N', $temp['num'] + 1), -$remainder);
+        $var = substr_replace($var, $temp, 0, $remainder);
+    }
+
+    /**
+     * Setup the performance-optimized function for de/encrypt()
+     *
+     * Stores the created (or existing) callback function-name
+     * in $this->inline_crypt
+     *
+     * Internally for phpseclib developers:
+     *
+     *     _setupInlineCrypt() would be called only if:
+     *
+     *     - $engine == self::ENGINE_INTERNAL and
+     *
+     *     - $use_inline_crypt === true
+     *
+     *     - each time on _setup(), after(!) _setupKey()
+     *
+     *
+     *     This ensures that _setupInlineCrypt() has always a
+     *     full ready2go initializated internal cipher $engine state
+     *     where, for example, the keys allready expanded,
+     *     keys/block_size calculated and such.
+     *
+     *     It is, each time if called, the responsibility of _setupInlineCrypt():
+     *
+     *     - to set $this->inline_crypt to a valid and fully working callback function
+     *       as a (faster) replacement for encrypt() / decrypt()
+     *
+     *     - NOT to create unlimited callback functions (for memory reasons!)
+     *       no matter how often _setupInlineCrypt() would be called. At some
+     *       point of amount they must be generic re-useable.
+     *
+     *     - the code of _setupInlineCrypt() it self,
+     *       and the generated callback code,
+     *       must be, in following order:
+     *       - 100% safe
+     *       - 100% compatible to encrypt()/decrypt()
+     *       - using only php5+ features/lang-constructs/php-extensions if
+     *         compatibility (down to php4) or fallback is provided
+     *       - readable/maintainable/understandable/commented and... not-cryptic-styled-code :-)
+     *       - >= 10% faster than encrypt()/decrypt() [which is, by the way,
+     *         the reason for the existence of _setupInlineCrypt() :-)]
+     *       - memory-nice
+     *       - short (as good as possible)
+     *
+     * Note: - _setupInlineCrypt() is using _createInlineCryptFunction() to create the full callback function code.
+     *       - In case of using inline crypting, _setupInlineCrypt() must extend by the child \phpseclib\Crypt\* class.
+     *       - The following variable names are reserved:
+     *         - $_*  (all variable names prefixed with an underscore)
+     *         - $self (object reference to it self. Do not use $this, but $self instead)
+     *         - $in (the content of $in has to en/decrypt by the generated code)
+     *       - The callback function should not use the 'return' statement, but en/decrypt'ing the content of $in only
+     *
+     *
+     * @see self::_setup()
+     * @see self::_createInlineCryptFunction()
+     * @see self::encrypt()
+     * @see self::decrypt()
+     * @access private
+     * @internal If a Crypt_* class providing inline crypting it must extend _setupInlineCrypt()
+     */
+    function _setupInlineCrypt()
+    {
+        // If, for any reason, an extending \phpseclib\Crypt\Base() \phpseclib\Crypt\* class
+        // not using inline crypting then it must be ensured that: $this->use_inline_crypt = false
+        // ie in the class var declaration of $use_inline_crypt in general for the \phpseclib\Crypt\* class,
+        // in the constructor at object instance-time
+        // or, if it's runtime-specific, at runtime
+
+        $this->use_inline_crypt = false;
+    }
+
+    /**
+     * Creates the performance-optimized function for en/decrypt()
+     *
+     * Internally for phpseclib developers:
+     *
+     *    _createInlineCryptFunction():
+     *
+     *    - merge the $cipher_code [setup'ed by _setupInlineCrypt()]
+     *      with the current [$this->]mode of operation code
+     *
+     *    - create the $inline function, which called by encrypt() / decrypt()
+     *      as its replacement to speed up the en/decryption operations.
+     *
+     *    - return the name of the created $inline callback function
+     *
+     *    - used to speed up en/decryption
+     *
+     *
+     *
+     *    The main reason why can speed up things [up to 50%] this way are:
+     *
+     *    - using variables more effective then regular.
+     *      (ie no use of expensive arrays but integers $k_0, $k_1 ...
+     *      or even, for example, the pure $key[] values hardcoded)
+     *
+     *    - avoiding 1000's of function calls of ie _encryptBlock()
+     *      but inlining the crypt operations.
+     *      in the mode of operation for() loop.
+     *
+     *    - full loop unroll the (sometimes key-dependent) rounds
+     *      avoiding this way ++$i counters and runtime-if's etc...
+     *
+     *    The basic code architectur of the generated $inline en/decrypt()
+     *    lambda function, in pseudo php, is:
+     *
+     *    <code>
+     *    +----------------------------------------------------------------------------------------------+
+     *    | callback $inline = create_function:                                                          |
+     *    | lambda_function_0001_crypt_ECB($action, $text)                                               |
+     *    | {                                                                                            |
+     *    |     INSERT PHP CODE OF:                                                                      |
+     *    |     $cipher_code['init_crypt'];                  // general init code.                       |
+     *    |                                                  // ie: $sbox'es declarations used for       |
+     *    |                                                  //     encrypt and decrypt'ing.             |
+     *    |                                                                                              |
+     *    |     switch ($action) {                                                                       |
+     *    |         case 'encrypt':                                                                      |
+     *    |             INSERT PHP CODE OF:                                                              |
+     *    |             $cipher_code['init_encrypt'];       // encrypt sepcific init code.               |
+     *    |                                                    ie: specified $key or $box                |
+     *    |                                                        declarations for encrypt'ing.         |
+     *    |                                                                                              |
+     *    |             foreach ($ciphertext) {                                                          |
+     *    |                 $in = $block_size of $ciphertext;                                            |
+     *    |                                                                                              |
+     *    |                 INSERT PHP CODE OF:                                                          |
+     *    |                 $cipher_code['encrypt_block'];  // encrypt's (string) $in, which is always:  |
+     *    |                                                 // strlen($in) == $this->block_size          |
+     *    |                                                 // here comes the cipher algorithm in action |
+     *    |                                                 // for encryption.                           |
+     *    |                                                 // $cipher_code['encrypt_block'] has to      |
+     *    |                                                 // encrypt the content of the $in variable   |
+     *    |                                                                                              |
+     *    |                 $plaintext .= $in;                                                           |
+     *    |             }                                                                                |
+     *    |             return $plaintext;                                                               |
+     *    |                                                                                              |
+     *    |         case 'decrypt':                                                                      |
+     *    |             INSERT PHP CODE OF:                                                              |
+     *    |             $cipher_code['init_decrypt'];       // decrypt sepcific init code                |
+     *    |                                                    ie: specified $key or $box                |
+     *    |                                                        declarations for decrypt'ing.         |
+     *    |             foreach ($plaintext) {                                                           |
+     *    |                 $in = $block_size of $plaintext;                                             |
+     *    |                                                                                              |
+     *    |                 INSERT PHP CODE OF:                                                          |
+     *    |                 $cipher_code['decrypt_block'];  // decrypt's (string) $in, which is always   |
+     *    |                                                 // strlen($in) == $this->block_size          |
+     *    |                                                 // here comes the cipher algorithm in action |
+     *    |                                                 // for decryption.                           |
+     *    |                                                 // $cipher_code['decrypt_block'] has to      |
+     *    |                                                 // decrypt the content of the $in variable   |
+     *    |                 $ciphertext .= $in;                                                          |
+     *    |             }                                                                                |
+     *    |             return $ciphertext;                                                              |
+     *    |     }                                                                                        |
+     *    | }                                                                                            |
+     *    +----------------------------------------------------------------------------------------------+
+     *    </code>
+     *
+     *    See also the \phpseclib\Crypt\*::_setupInlineCrypt()'s for
+     *    productive inline $cipher_code's how they works.
+     *
+     *    Structure of:
+     *    <code>
+     *    $cipher_code = array(
+     *        'init_crypt'    => (string) '', // optional
+     *        'init_encrypt'  => (string) '', // optional
+     *        'init_decrypt'  => (string) '', // optional
+     *        'encrypt_block' => (string) '', // required
+     *        'decrypt_block' => (string) ''  // required
+     *    );
+     *    </code>
+     *
+     * @see self::_setupInlineCrypt()
+     * @see self::encrypt()
+     * @see self::decrypt()
+     * @param array $cipher_code
+     * @access private
+     * @return string (the name of the created callback function)
+     */
+    function _createInlineCryptFunction($cipher_code)
+    {
+        $block_size = $this->block_size;
+
+        // optional
+        $init_crypt    = isset($cipher_code['init_crypt'])    ? $cipher_code['init_crypt']    : '';
+        $init_encrypt  = isset($cipher_code['init_encrypt'])  ? $cipher_code['init_encrypt']  : '';
+        $init_decrypt  = isset($cipher_code['init_decrypt'])  ? $cipher_code['init_decrypt']  : '';
+        // required
+        $encrypt_block = $cipher_code['encrypt_block'];
+        $decrypt_block = $cipher_code['decrypt_block'];
+
+        // Generating mode of operation inline code,
+        // merged with the $cipher_code algorithm
+        // for encrypt- and decryption.
+        switch ($this->mode) {
+            case self::MODE_ECB:
+                $encrypt = $init_encrypt . '
+                    $_ciphertext = "";
+                    $_plaintext_len = strlen($_text);
+
+                    for ($_i = 0; $_i < $_plaintext_len; $_i+= '.$block_size.') {
+                        $in = substr($_text, $_i, '.$block_size.');
+                        '.$encrypt_block.'
+                        $_ciphertext.= $in;
+                    }
+
+                    return $_ciphertext;
+                    ';
+
+                $decrypt = $init_decrypt . '
+                    $_plaintext = "";
+                    $_text = str_pad($_text, strlen($_text) + ('.$block_size.' - strlen($_text) % '.$block_size.') % '.$block_size.', chr(0));
+                    $_ciphertext_len = strlen($_text);
+
+                    for ($_i = 0; $_i < $_ciphertext_len; $_i+= '.$block_size.') {
+                        $in = substr($_text, $_i, '.$block_size.');
+                        '.$decrypt_block.'
+                        $_plaintext.= $in;
+                    }
+
+                    return $self->_unpad($_plaintext);
+                    ';
+                break;
+            case self::MODE_CTR:
+                $encrypt = $init_encrypt . '
+                    $_ciphertext = "";
+                    $_plaintext_len = strlen($_text);
+                    $_xor = $self->encryptIV;
+                    $_buffer = &$self->enbuffer;
+                    if (strlen($_buffer["ciphertext"])) {
+                        for ($_i = 0; $_i < $_plaintext_len; $_i+= '.$block_size.') {
+                            $_block = substr($_text, $_i, '.$block_size.');
+                            if (strlen($_block) > strlen($_buffer["ciphertext"])) {
+                                $in = $_xor;
+                                '.$encrypt_block.'
+                                $self->_increment_str($_xor);
+                                $_buffer["ciphertext"].= $in;
+                            }
+                            $_key = $self->_string_shift($_buffer["ciphertext"], '.$block_size.');
+                            $_ciphertext.= $_block ^ $_key;
+                        }
+                    } else {
+                        for ($_i = 0; $_i < $_plaintext_len; $_i+= '.$block_size.') {
+                            $_block = substr($_text, $_i, '.$block_size.');
+                            $in = $_xor;
+                            '.$encrypt_block.'
+                            $self->_increment_str($_xor);
+                            $_key = $in;
+                            $_ciphertext.= $_block ^ $_key;
+                        }
+                    }
+                    if ($self->continuousBuffer) {
+                        $self->encryptIV = $_xor;
+                        if ($_start = $_plaintext_len % '.$block_size.') {
+                            $_buffer["ciphertext"] = substr($_key, $_start) . $_buffer["ciphertext"];
+                        }
+                    }
+
+                    return $_ciphertext;
+                ';
+
+                $decrypt = $init_encrypt . '
+                    $_plaintext = "";
+                    $_ciphertext_len = strlen($_text);
+                    $_xor = $self->decryptIV;
+                    $_buffer = &$self->debuffer;
+
+                    if (strlen($_buffer["ciphertext"])) {
+                        for ($_i = 0; $_i < $_ciphertext_len; $_i+= '.$block_size.') {
+                            $_block = substr($_text, $_i, '.$block_size.');
+                            if (strlen($_block) > strlen($_buffer["ciphertext"])) {
+                                $in = $_xor;
+                                '.$encrypt_block.'
+                                $self->_increment_str($_xor);
+                                $_buffer["ciphertext"].= $in;
+                            }
+                            $_key = $self->_string_shift($_buffer["ciphertext"], '.$block_size.');
+                            $_plaintext.= $_block ^ $_key;
+                        }
+                    } else {
+                        for ($_i = 0; $_i < $_ciphertext_len; $_i+= '.$block_size.') {
+                            $_block = substr($_text, $_i, '.$block_size.');
+                            $in = $_xor;
+                            '.$encrypt_block.'
+                            $self->_increment_str($_xor);
+                            $_key = $in;
+                            $_plaintext.= $_block ^ $_key;
+                        }
+                    }
+                    if ($self->continuousBuffer) {
+                        $self->decryptIV = $_xor;
+                        if ($_start = $_ciphertext_len % '.$block_size.') {
+                            $_buffer["ciphertext"] = substr($_key, $_start) . $_buffer["ciphertext"];
+                        }
+                    }
+
+                    return $_plaintext;
+                    ';
+                break;
+            case self::MODE_CFB:
+                $encrypt = $init_encrypt . '
+                    $_ciphertext = "";
+                    $_buffer = &$self->enbuffer;
+
+                    if ($self->continuousBuffer) {
+                        $_iv = &$self->encryptIV;
+                        $_pos = &$_buffer["pos"];
+                    } else {
+                        $_iv = $self->encryptIV;
+                        $_pos = 0;
+                    }
+                    $_len = strlen($_text);
+                    $_i = 0;
+                    if ($_pos) {
+                        $_orig_pos = $_pos;
+                        $_max = '.$block_size.' - $_pos;
+                        if ($_len >= $_max) {
+                            $_i = $_max;
+                            $_len-= $_max;
+                            $_pos = 0;
+                        } else {
+                            $_i = $_len;
+                            $_pos+= $_len;
+                            $_len = 0;
+                        }
+                        $_ciphertext = substr($_iv, $_orig_pos) ^ $_text;
+                        $_iv = substr_replace($_iv, $_ciphertext, $_orig_pos, $_i);
+                    }
+                    while ($_len >= '.$block_size.') {
+                        $in = $_iv;
+                        '.$encrypt_block.';
+                        $_iv = $in ^ substr($_text, $_i, '.$block_size.');
+                        $_ciphertext.= $_iv;
+                        $_len-= '.$block_size.';
+                        $_i+= '.$block_size.';
+                    }
+                    if ($_len) {
+                        $in = $_iv;
+                        '.$encrypt_block.'
+                        $_iv = $in;
+                        $_block = $_iv ^ substr($_text, $_i);
+                        $_iv = substr_replace($_iv, $_block, 0, $_len);
+                        $_ciphertext.= $_block;
+                        $_pos = $_len;
+                    }
+                    return $_ciphertext;
+                ';
+
+                $decrypt = $init_encrypt . '
+                    $_plaintext = "";
+                    $_buffer = &$self->debuffer;
+
+                    if ($self->continuousBuffer) {
+                        $_iv = &$self->decryptIV;
+                        $_pos = &$_buffer["pos"];
+                    } else {
+                        $_iv = $self->decryptIV;
+                        $_pos = 0;
+                    }
+                    $_len = strlen($_text);
+                    $_i = 0;
+                    if ($_pos) {
+                        $_orig_pos = $_pos;
+                        $_max = '.$block_size.' - $_pos;
+                        if ($_len >= $_max) {
+                            $_i = $_max;
+                            $_len-= $_max;
+                            $_pos = 0;
+                        } else {
+                            $_i = $_len;
+                            $_pos+= $_len;
+                            $_len = 0;
+                        }
+                        $_plaintext = substr($_iv, $_orig_pos) ^ $_text;
+                        $_iv = substr_replace($_iv, substr($_text, 0, $_i), $_orig_pos, $_i);
+                    }
+                    while ($_len >= '.$block_size.') {
+                        $in = $_iv;
+                        '.$encrypt_block.'
+                        $_iv = $in;
+                        $cb = substr($_text, $_i, '.$block_size.');
+                        $_plaintext.= $_iv ^ $cb;
+                        $_iv = $cb;
+                        $_len-= '.$block_size.';
+                        $_i+= '.$block_size.';
+                    }
+                    if ($_len) {
+                        $in = $_iv;
+                        '.$encrypt_block.'
+                        $_iv = $in;
+                        $_plaintext.= $_iv ^ substr($_text, $_i);
+                        $_iv = substr_replace($_iv, substr($_text, $_i), 0, $_len);
+                        $_pos = $_len;
+                    }
+
+                    return $_plaintext;
+                    ';
+                break;
+            case self::MODE_CFB8:
+                $encrypt = $init_encrypt . '
+                    $_ciphertext = "";
+                    $_len = strlen($_text);
+                    $_iv = $self->encryptIV;
+
+                    for ($_i = 0; $_i < $_len; ++$_i) {
+                        $in = $_iv;
+                        '.$encrypt_block.'
+                        $_ciphertext .= ($_c = $_text[$_i] ^ $in);
+                        $_iv = substr($_iv, 1) . $_c;
+                    }
+
+                    if ($self->continuousBuffer) {
+                        if ($_len >= '.$block_size.') {
+                            $self->encryptIV = substr($_ciphertext, -'.$block_size.');
+                        } else {
+                            $self->encryptIV = substr($self->encryptIV, $_len - '.$block_size.') . substr($_ciphertext, -$_len);
+                        }
+                    }
+
+                    return $_ciphertext;
+                    ';
+                $decrypt = $init_encrypt . '
+                    $_plaintext = "";
+                    $_len = strlen($_text);
+                    $_iv = $self->decryptIV;
+
+                    for ($_i = 0; $_i < $_len; ++$_i) {
+                        $in = $_iv;
+                        '.$encrypt_block.'
+                        $_plaintext .= $_text[$_i] ^ $in;
+                        $_iv = substr($_iv, 1) . $_text[$_i];
+                    }
+
+                    if ($self->continuousBuffer) {
+                        if ($_len >= '.$block_size.') {
+                            $self->decryptIV = substr($_text, -'.$block_size.');
+                        } else {
+                            $self->decryptIV = substr($self->decryptIV, $_len - '.$block_size.') . substr($_text, -$_len);
+                        }
+                    }
+
+                    return $_plaintext;
+                    ';
+                break;
+            case self::MODE_OFB:
+                $encrypt = $init_encrypt . '
+                    $_ciphertext = "";
+                    $_plaintext_len = strlen($_text);
+                    $_xor = $self->encryptIV;
+                    $_buffer = &$self->enbuffer;
+
+                    if (strlen($_buffer["xor"])) {
+                        for ($_i = 0; $_i < $_plaintext_len; $_i+= '.$block_size.') {
+                            $_block = substr($_text, $_i, '.$block_size.');
+                            if (strlen($_block) > strlen($_buffer["xor"])) {
+                                $in = $_xor;
+                                '.$encrypt_block.'
+                                $_xor = $in;
+                                $_buffer["xor"].= $_xor;
+                            }
+                            $_key = $self->_string_shift($_buffer["xor"], '.$block_size.');
+                            $_ciphertext.= $_block ^ $_key;
+                        }
+                    } else {
+                        for ($_i = 0; $_i < $_plaintext_len; $_i+= '.$block_size.') {
+                            $in = $_xor;
+                            '.$encrypt_block.'
+                            $_xor = $in;
+                            $_ciphertext.= substr($_text, $_i, '.$block_size.') ^ $_xor;
+                        }
+                        $_key = $_xor;
+                    }
+                    if ($self->continuousBuffer) {
+                        $self->encryptIV = $_xor;
+                        if ($_start = $_plaintext_len % '.$block_size.') {
+                             $_buffer["xor"] = substr($_key, $_start) . $_buffer["xor"];
+                        }
+                    }
+                    return $_ciphertext;
+                    ';
+
+                $decrypt = $init_encrypt . '
+                    $_plaintext = "";
+                    $_ciphertext_len = strlen($_text);
+                    $_xor = $self->decryptIV;
+                    $_buffer = &$self->debuffer;
+
+                    if (strlen($_buffer["xor"])) {
+                        for ($_i = 0; $_i < $_ciphertext_len; $_i+= '.$block_size.') {
+                            $_block = substr($_text, $_i, '.$block_size.');
+                            if (strlen($_block) > strlen($_buffer["xor"])) {
+                                $in = $_xor;
+                                '.$encrypt_block.'
+                                $_xor = $in;
+                                $_buffer["xor"].= $_xor;
+                            }
+                            $_key = $self->_string_shift($_buffer["xor"], '.$block_size.');
+                            $_plaintext.= $_block ^ $_key;
+                        }
+                    } else {
+                        for ($_i = 0; $_i < $_ciphertext_len; $_i+= '.$block_size.') {
+                            $in = $_xor;
+                            '.$encrypt_block.'
+                            $_xor = $in;
+                            $_plaintext.= substr($_text, $_i, '.$block_size.') ^ $_xor;
+                        }
+                        $_key = $_xor;
+                    }
+                    if ($self->continuousBuffer) {
+                        $self->decryptIV = $_xor;
+                        if ($_start = $_ciphertext_len % '.$block_size.') {
+                             $_buffer["xor"] = substr($_key, $_start) . $_buffer["xor"];
+                        }
+                    }
+                    return $_plaintext;
+                    ';
+                break;
+            case self::MODE_STREAM:
+                $encrypt = $init_encrypt . '
+                    $_ciphertext = "";
+                    '.$encrypt_block.'
+                    return $_ciphertext;
+                    ';
+                $decrypt = $init_decrypt . '
+                    $_plaintext = "";
+                    '.$decrypt_block.'
+                    return $_plaintext;
+                    ';
+                break;
+            // case self::MODE_CBC:
+            default:
+                $encrypt = $init_encrypt . '
+                    $_ciphertext = "";
+                    $_plaintext_len = strlen($_text);
+
+                    $in = $self->encryptIV;
+
+                    for ($_i = 0; $_i < $_plaintext_len; $_i+= '.$block_size.') {
+                        $in = substr($_text, $_i, '.$block_size.') ^ $in;
+                        '.$encrypt_block.'
+                        $_ciphertext.= $in;
+                    }
+
+                    if ($self->continuousBuffer) {
+                        $self->encryptIV = $in;
+                    }
+
+                    return $_ciphertext;
+                    ';
+
+                $decrypt = $init_decrypt . '
+                    $_plaintext = "";
+                    $_text = str_pad($_text, strlen($_text) + ('.$block_size.' - strlen($_text) % '.$block_size.') % '.$block_size.', chr(0));
+                    $_ciphertext_len = strlen($_text);
+
+                    $_iv = $self->decryptIV;
+
+                    for ($_i = 0; $_i < $_ciphertext_len; $_i+= '.$block_size.') {
+                        $in = $_block = substr($_text, $_i, '.$block_size.');
+                        '.$decrypt_block.'
+                        $_plaintext.= $in ^ $_iv;
+                        $_iv = $_block;
+                    }
+
+                    if ($self->continuousBuffer) {
+                        $self->decryptIV = $_iv;
+                    }
+
+                    return $self->_unpad($_plaintext);
+                    ';
+                break;
+        }
+
+        // Create the $inline function and return its name as string. Ready to run!
+        if (version_compare(PHP_VERSION, '5.3.0') >= 0) {
+            eval('$func = function ($_action, &$self, $_text) { ' . $init_crypt . 'if ($_action == "encrypt") { ' . $encrypt . ' } else { ' . $decrypt . ' } };');
+            return $func;
+        }
+
+        return create_function('$_action, &$self, $_text', $init_crypt . 'if ($_action == "encrypt") { ' . $encrypt . ' } else { ' . $decrypt . ' }');
+    }
+
+    /**
+     * Holds the lambda_functions table (classwide)
+     *
+     * Each name of the lambda function, created from
+     * _setupInlineCrypt() && _createInlineCryptFunction()
+     * is stored, classwide (!), here for reusing.
+     *
+     * The string-based index of $function is a classwide
+     * unique value representing, at least, the $mode of
+     * operation (or more... depends of the optimizing level)
+     * for which $mode the lambda function was created.
+     *
+     * @access private
+     * @return array &$functions
+     */
+    function &_getLambdaFunctions()
+    {
+        static $functions = array();
+        return $functions;
+    }
+
+    /**
+     * Generates a digest from $bytes
+     *
+     * @see self::_setupInlineCrypt()
+     * @access private
+     * @param $bytes
+     * @return string
+     */
+    function _hashInlineCryptFunction($bytes)
+    {
+        if (!isset(self::$WHIRLPOOL_AVAILABLE)) {
+            self::$WHIRLPOOL_AVAILABLE = extension_loaded('hash') && in_array('whirlpool', hash_algos());
+        }
+
+        $result = '';
+        $hash = $bytes;
+
+        switch (true) {
+            case self::$WHIRLPOOL_AVAILABLE:
+                foreach (str_split($bytes, 64) as $t) {
+                    $hash = hash('whirlpool', $hash, true);
+                    $result .= $t ^ $hash;
+                }
+                return $result . hash('whirlpool', $hash, true);
+            default:
+                $len = strlen($bytes);
+                for ($i = 0; $i < $len; $i+=20) {
+                    $t = substr($bytes, $i, 20);
+                    $hash = pack('H*', sha1($hash));
+                    $result .= $t ^ $hash;
+                }
+                return $result . pack('H*', sha1($hash));
+        }
+    }
+
+    /**
+     * Convert float to int
+     *
+     * On ARM CPUs converting floats to ints doesn't always work
+     *
+     * @access private
+     * @param string $x
+     * @return int
+     */
+    function safe_intval($x)
+    {
+        switch (true) {
+            case is_int($x):
+            // PHP 5.3, per http://php.net/releases/5_3_0.php, introduced "more consistent float rounding"
+            case (php_uname('m') & "\xDF\xDF\xDF") != 'ARM':
+                return $x;
+        }
+        return (fmod($x, 0x80000000) & 0x7FFFFFFF) |
+            ((fmod(floor($x / 0x80000000), 2) & 1) << 31);
+    }
+
+    /**
+     * eval()'able string for in-line float to int
+     *
+     * @access private
+     * @return string
+     */
+    function safe_intval_inline()
+    {
+        switch (true) {
+            case defined('PHP_INT_SIZE') && PHP_INT_SIZE == 8:
+            case (php_uname('m') & "\xDF\xDF\xDF") != 'ARM':
+                return '%s';
+                break;
+            default:
+                $safeint = '(is_int($temp = %s) ? $temp : (fmod($temp, 0x80000000) & 0x7FFFFFFF) | ';
+                return $safeint . '((fmod(floor($temp / 0x80000000), 2) & 1) << 31))';
+        }
+    }
+}
diff --git a/lib/phpseclib/Crypt/Blowfish.php b/lib/phpseclib/Crypt/Blowfish.php
new file mode 100644
index 0000000..74cc49d
--- /dev/null
+++ b/lib/phpseclib/Crypt/Blowfish.php
@@ -0,0 +1,571 @@
+<?php
+
+/**
+ * Pure-PHP implementation of Blowfish.
+ *
+ * Uses mcrypt, if available, and an internal implementation, otherwise.
+ *
+ * PHP version 5
+ *
+ * Useful resources are as follows:
+ *
+ *  - {@link http://en.wikipedia.org/wiki/Blowfish_(cipher) Wikipedia description of Blowfish}
+ *
+ * Here's a short example of how to use this library:
+ * <code>
+ * <?php
+ *    include 'vendor/autoload.php';
+ *
+ *    $blowfish = new \phpseclib\Crypt\Blowfish();
+ *
+ *    $blowfish->setKey('12345678901234567890123456789012');
+ *
+ *    $plaintext = str_repeat('a', 1024);
+ *
+ *    echo $blowfish->decrypt($blowfish->encrypt($plaintext));
+ * ?>
+ * </code>
+ *
+ * @category  Crypt
+ * @package   Blowfish
+ * @author    Jim Wigginton <terrafrost@php.net>
+ * @author    Hans-Juergen Petrich <petrich@tronic-media.com>
+ * @copyright 2007 Jim Wigginton
+ * @license   http://www.opensource.org/licenses/mit-license.html  MIT License
+ * @link      http://phpseclib.sourceforge.net
+ */
+
+namespace phpseclib\Crypt;
+
+/**
+ * Pure-PHP implementation of Blowfish.
+ *
+ * @package Blowfish
+ * @author  Jim Wigginton <terrafrost@php.net>
+ * @author  Hans-Juergen Petrich <petrich@tronic-media.com>
+ * @access  public
+ */
+class Blowfish extends Base
+{
+    /**
+     * Block Length of the cipher
+     *
+     * @see \phpseclib\Crypt\Base::block_size
+     * @var int
+     * @access private
+     */
+    var $block_size = 8;
+
+    /**
+     * The mcrypt specific name of the cipher
+     *
+     * @see \phpseclib\Crypt\Base::cipher_name_mcrypt
+     * @var string
+     * @access private
+     */
+    var $cipher_name_mcrypt = 'blowfish';
+
+    /**
+     * Optimizing value while CFB-encrypting
+     *
+     * @see \phpseclib\Crypt\Base::cfb_init_len
+     * @var int
+     * @access private
+     */
+    var $cfb_init_len = 500;
+
+    /**
+     * The fixed subkeys boxes ($sbox0 - $sbox3) with 256 entries each
+     *
+     * S-Box 0
+     *
+     * @access private
+     * @var    array
+     */
+    var $sbox0 = array(
+        0xd1310ba6, 0x98dfb5ac, 0x2ffd72db, 0xd01adfb7, 0xb8e1afed, 0x6a267e96, 0xba7c9045, 0xf12c7f99,
+        0x24a19947, 0xb3916cf7, 0x0801f2e2, 0x858efc16, 0x636920d8, 0x71574e69, 0xa458fea3, 0xf4933d7e,
+        0x0d95748f, 0x728eb658, 0x718bcd58, 0x82154aee, 0x7b54a41d, 0xc25a59b5, 0x9c30d539, 0x2af26013,
+        0xc5d1b023, 0x286085f0, 0xca417918, 0xb8db38ef, 0x8e79dcb0, 0x603a180e, 0x6c9e0e8b, 0xb01e8a3e,
+        0xd71577c1, 0xbd314b27, 0x78af2fda, 0x55605c60, 0xe65525f3, 0xaa55ab94, 0x57489862, 0x63e81440,
+        0x55ca396a, 0x2aab10b6, 0xb4cc5c34, 0x1141e8ce, 0xa15486af, 0x7c72e993, 0xb3ee1411, 0x636fbc2a,
+        0x2ba9c55d, 0x741831f6, 0xce5c3e16, 0x9b87931e, 0xafd6ba33, 0x6c24cf5c, 0x7a325381, 0x28958677,
+        0x3b8f4898, 0x6b4bb9af, 0xc4bfe81b, 0x66282193, 0x61d809cc, 0xfb21a991, 0x487cac60, 0x5dec8032,
+        0xef845d5d, 0xe98575b1, 0xdc262302, 0xeb651b88, 0x23893e81, 0xd396acc5, 0x0f6d6ff3, 0x83f44239,
+        0x2e0b4482, 0xa4842004, 0x69c8f04a, 0x9e1f9b5e, 0x21c66842, 0xf6e96c9a, 0x670c9c61, 0xabd388f0,
+        0x6a51a0d2, 0xd8542f68, 0x960fa728, 0xab5133a3, 0x6eef0b6c, 0x137a3be4, 0xba3bf050, 0x7efb2a98,
+        0xa1f1651d, 0x39af0176, 0x66ca593e, 0x82430e88, 0x8cee8619, 0x456f9fb4, 0x7d84a5c3, 0x3b8b5ebe,
+        0xe06f75d8, 0x85c12073, 0x401a449f, 0x56c16aa6, 0x4ed3aa62, 0x363f7706, 0x1bfedf72, 0x429b023d,
+        0x37d0d724, 0xd00a1248, 0xdb0fead3, 0x49f1c09b, 0x075372c9, 0x80991b7b, 0x25d479d8, 0xf6e8def7,
+        0xe3fe501a, 0xb6794c3b, 0x976ce0bd, 0x04c006ba, 0xc1a94fb6, 0x409f60c4, 0x5e5c9ec2, 0x196a2463,
+        0x68fb6faf, 0x3e6c53b5, 0x1339b2eb, 0x3b52ec6f, 0x6dfc511f, 0x9b30952c, 0xcc814544, 0xaf5ebd09,
+        0xbee3d004, 0xde334afd, 0x660f2807, 0x192e4bb3, 0xc0cba857, 0x45c8740f, 0xd20b5f39, 0xb9d3fbdb,
+        0x5579c0bd, 0x1a60320a, 0xd6a100c6, 0x402c7279, 0x679f25fe, 0xfb1fa3cc, 0x8ea5e9f8, 0xdb3222f8,
+        0x3c7516df, 0xfd616b15, 0x2f501ec8, 0xad0552ab, 0x323db5fa, 0xfd238760, 0x53317b48, 0x3e00df82,
+        0x9e5c57bb, 0xca6f8ca0, 0x1a87562e, 0xdf1769db, 0xd542a8f6, 0x287effc3, 0xac6732c6, 0x8c4f5573,
+        0x695b27b0, 0xbbca58c8, 0xe1ffa35d, 0xb8f011a0, 0x10fa3d98, 0xfd2183b8, 0x4afcb56c, 0x2dd1d35b,
+        0x9a53e479, 0xb6f84565, 0xd28e49bc, 0x4bfb9790, 0xe1ddf2da, 0xa4cb7e33, 0x62fb1341, 0xcee4c6e8,
+        0xef20cada, 0x36774c01, 0xd07e9efe, 0x2bf11fb4, 0x95dbda4d, 0xae909198, 0xeaad8e71, 0x6b93d5a0,
+        0xd08ed1d0, 0xafc725e0, 0x8e3c5b2f, 0x8e7594b7, 0x8ff6e2fb, 0xf2122b64, 0x8888b812, 0x900df01c,
+        0x4fad5ea0, 0x688fc31c, 0xd1cff191, 0xb3a8c1ad, 0x2f2f2218, 0xbe0e1777, 0xea752dfe, 0x8b021fa1,
+        0xe5a0cc0f, 0xb56f74e8, 0x18acf3d6, 0xce89e299, 0xb4a84fe0, 0xfd13e0b7, 0x7cc43b81, 0xd2ada8d9,
+        0x165fa266, 0x80957705, 0x93cc7314, 0x211a1477, 0xe6ad2065, 0x77b5fa86, 0xc75442f5, 0xfb9d35cf,
+        0xebcdaf0c, 0x7b3e89a0, 0xd6411bd3, 0xae1e7e49, 0x00250e2d, 0x2071b35e, 0x226800bb, 0x57b8e0af,
+        0x2464369b, 0xf009b91e, 0x5563911d, 0x59dfa6aa, 0x78c14389, 0xd95a537f, 0x207d5ba2, 0x02e5b9c5,
+        0x83260376, 0x6295cfa9, 0x11c81968, 0x4e734a41, 0xb3472dca, 0x7b14a94a, 0x1b510052, 0x9a532915,
+        0xd60f573f, 0xbc9bc6e4, 0x2b60a476, 0x81e67400, 0x08ba6fb5, 0x571be91f, 0xf296ec6b, 0x2a0dd915,
+        0xb6636521, 0xe7b9f9b6, 0xff34052e, 0xc5855664, 0x53b02d5d, 0xa99f8fa1, 0x08ba4799, 0x6e85076a
+    );
+
+    /**
+     * S-Box 1
+     *
+     * @access private
+     * @var    array
+     */
+    var $sbox1 = array(
+        0x4b7a70e9, 0xb5b32944, 0xdb75092e, 0xc4192623, 0xad6ea6b0, 0x49a7df7d, 0x9cee60b8, 0x8fedb266,
+        0xecaa8c71, 0x699a17ff, 0x5664526c, 0xc2b19ee1, 0x193602a5, 0x75094c29, 0xa0591340, 0xe4183a3e,
+        0x3f54989a, 0x5b429d65, 0x6b8fe4d6, 0x99f73fd6, 0xa1d29c07, 0xefe830f5, 0x4d2d38e6, 0xf0255dc1,
+        0x4cdd2086, 0x8470eb26, 0x6382e9c6, 0x021ecc5e, 0x09686b3f, 0x3ebaefc9, 0x3c971814, 0x6b6a70a1,
+        0x687f3584, 0x52a0e286, 0xb79c5305, 0xaa500737, 0x3e07841c, 0x7fdeae5c, 0x8e7d44ec, 0x5716f2b8,
+        0xb03ada37, 0xf0500c0d, 0xf01c1f04, 0x0200b3ff, 0xae0cf51a, 0x3cb574b2, 0x25837a58, 0xdc0921bd,
+        0xd19113f9, 0x7ca92ff6, 0x94324773, 0x22f54701, 0x3ae5e581, 0x37c2dadc, 0xc8b57634, 0x9af3dda7,
+        0xa9446146, 0x0fd0030e, 0xecc8c73e, 0xa4751e41, 0xe238cd99, 0x3bea0e2f, 0x3280bba1, 0x183eb331,
+        0x4e548b38, 0x4f6db908, 0x6f420d03, 0xf60a04bf, 0x2cb81290, 0x24977c79, 0x5679b072, 0xbcaf89af,
+        0xde9a771f, 0xd9930810, 0xb38bae12, 0xdccf3f2e, 0x5512721f, 0x2e6b7124, 0x501adde6, 0x9f84cd87,
+        0x7a584718, 0x7408da17, 0xbc9f9abc, 0xe94b7d8c, 0xec7aec3a, 0xdb851dfa, 0x63094366, 0xc464c3d2,
+        0xef1c1847, 0x3215d908, 0xdd433b37, 0x24c2ba16, 0x12a14d43, 0x2a65c451, 0x50940002, 0x133ae4dd,
+        0x71dff89e, 0x10314e55, 0x81ac77d6, 0x5f11199b, 0x043556f1, 0xd7a3c76b, 0x3c11183b, 0x5924a509,
+        0xf28fe6ed, 0x97f1fbfa, 0x9ebabf2c, 0x1e153c6e, 0x86e34570, 0xeae96fb1, 0x860e5e0a, 0x5a3e2ab3,
+        0x771fe71c, 0x4e3d06fa, 0x2965dcb9, 0x99e71d0f, 0x803e89d6, 0x5266c825, 0x2e4cc978, 0x9c10b36a,
+        0xc6150eba, 0x94e2ea78, 0xa5fc3c53, 0x1e0a2df4, 0xf2f74ea7, 0x361d2b3d, 0x1939260f, 0x19c27960,
+        0x5223a708, 0xf71312b6, 0xebadfe6e, 0xeac31f66, 0xe3bc4595, 0xa67bc883, 0xb17f37d1, 0x018cff28,
+        0xc332ddef, 0xbe6c5aa5, 0x65582185, 0x68ab9802, 0xeecea50f, 0xdb2f953b, 0x2aef7dad, 0x5b6e2f84,
+        0x1521b628, 0x29076170, 0xecdd4775, 0x619f1510, 0x13cca830, 0xeb61bd96, 0x0334fe1e, 0xaa0363cf,
+        0xb5735c90, 0x4c70a239, 0xd59e9e0b, 0xcbaade14, 0xeecc86bc, 0x60622ca7, 0x9cab5cab, 0xb2f3846e,
+        0x648b1eaf, 0x19bdf0ca, 0xa02369b9, 0x655abb50, 0x40685a32, 0x3c2ab4b3, 0x319ee9d5, 0xc021b8f7,
+        0x9b540b19, 0x875fa099, 0x95f7997e, 0x623d7da8, 0xf837889a, 0x97e32d77, 0x11ed935f, 0x16681281,
+        0x0e358829, 0xc7e61fd6, 0x96dedfa1, 0x7858ba99, 0x57f584a5, 0x1b227263, 0x9b83c3ff, 0x1ac24696,
+        0xcdb30aeb, 0x532e3054, 0x8fd948e4, 0x6dbc3128, 0x58ebf2ef, 0x34c6ffea, 0xfe28ed61, 0xee7c3c73,
+        0x5d4a14d9, 0xe864b7e3, 0x42105d14, 0x203e13e0, 0x45eee2b6, 0xa3aaabea, 0xdb6c4f15, 0xfacb4fd0,
+        0xc742f442, 0xef6abbb5, 0x654f3b1d, 0x41cd2105, 0xd81e799e, 0x86854dc7, 0xe44b476a, 0x3d816250,
+        0xcf62a1f2, 0x5b8d2646, 0xfc8883a0, 0xc1c7b6a3, 0x7f1524c3, 0x69cb7492, 0x47848a0b, 0x5692b285,
+        0x095bbf00, 0xad19489d, 0x1462b174, 0x23820e00, 0x58428d2a, 0x0c55f5ea, 0x1dadf43e, 0x233f7061,
+        0x3372f092, 0x8d937e41, 0xd65fecf1, 0x6c223bdb, 0x7cde3759, 0xcbee7460, 0x4085f2a7, 0xce77326e,
+        0xa6078084, 0x19f8509e, 0xe8efd855, 0x61d99735, 0xa969a7aa, 0xc50c06c2, 0x5a04abfc, 0x800bcadc,
+        0x9e447a2e, 0xc3453484, 0xfdd56705, 0x0e1e9ec9, 0xdb73dbd3, 0x105588cd, 0x675fda79, 0xe3674340,
+        0xc5c43465, 0x713e38d8, 0x3d28f89e, 0xf16dff20, 0x153e21e7, 0x8fb03d4a, 0xe6e39f2b, 0xdb83adf7
+    );
+
+    /**
+     * S-Box 2
+     *
+     * @access private
+     * @var    array
+     */
+    var $sbox2 = array(
+        0xe93d5a68, 0x948140f7, 0xf64c261c, 0x94692934, 0x411520f7, 0x7602d4f7, 0xbcf46b2e, 0xd4a20068,
+        0xd4082471, 0x3320f46a, 0x43b7d4b7, 0x500061af, 0x1e39f62e, 0x97244546, 0x14214f74, 0xbf8b8840,
+        0x4d95fc1d, 0x96b591af, 0x70f4ddd3, 0x66a02f45, 0xbfbc09ec, 0x03bd9785, 0x7fac6dd0, 0x31cb8504,
+        0x96eb27b3, 0x55fd3941, 0xda2547e6, 0xabca0a9a, 0x28507825, 0x530429f4, 0x0a2c86da, 0xe9b66dfb,
+        0x68dc1462, 0xd7486900, 0x680ec0a4, 0x27a18dee, 0x4f3ffea2, 0xe887ad8c, 0xb58ce006, 0x7af4d6b6,
+        0xaace1e7c, 0xd3375fec, 0xce78a399, 0x406b2a42, 0x20fe9e35, 0xd9f385b9, 0xee39d7ab, 0x3b124e8b,
+        0x1dc9faf7, 0x4b6d1856, 0x26a36631, 0xeae397b2, 0x3a6efa74, 0xdd5b4332, 0x6841e7f7, 0xca7820fb,
+        0xfb0af54e, 0xd8feb397, 0x454056ac, 0xba489527, 0x55533a3a, 0x20838d87, 0xfe6ba9b7, 0xd096954b,
+        0x55a867bc, 0xa1159a58, 0xcca92963, 0x99e1db33, 0xa62a4a56, 0x3f3125f9, 0x5ef47e1c, 0x9029317c,
+        0xfdf8e802, 0x04272f70, 0x80bb155c, 0x05282ce3, 0x95c11548, 0xe4c66d22, 0x48c1133f, 0xc70f86dc,
+        0x07f9c9ee, 0x41041f0f, 0x404779a4, 0x5d886e17, 0x325f51eb, 0xd59bc0d1, 0xf2bcc18f, 0x41113564,
+        0x257b7834, 0x602a9c60, 0xdff8e8a3, 0x1f636c1b, 0x0e12b4c2, 0x02e1329e, 0xaf664fd1, 0xcad18115,
+        0x6b2395e0, 0x333e92e1, 0x3b240b62, 0xeebeb922, 0x85b2a20e, 0xe6ba0d99, 0xde720c8c, 0x2da2f728,
+        0xd0127845, 0x95b794fd, 0x647d0862, 0xe7ccf5f0, 0x5449a36f, 0x877d48fa, 0xc39dfd27, 0xf33e8d1e,
+        0x0a476341, 0x992eff74, 0x3a6f6eab, 0xf4f8fd37, 0xa812dc60, 0xa1ebddf8, 0x991be14c, 0xdb6e6b0d,
+        0xc67b5510, 0x6d672c37, 0x2765d43b, 0xdcd0e804, 0xf1290dc7, 0xcc00ffa3, 0xb5390f92, 0x690fed0b,
+        0x667b9ffb, 0xcedb7d9c, 0xa091cf0b, 0xd9155ea3, 0xbb132f88, 0x515bad24, 0x7b9479bf, 0x763bd6eb,
+        0x37392eb3, 0xcc115979, 0x8026e297, 0xf42e312d, 0x6842ada7, 0xc66a2b3b, 0x12754ccc, 0x782ef11c,
+        0x6a124237, 0xb79251e7, 0x06a1bbe6, 0x4bfb6350, 0x1a6b1018, 0x11caedfa, 0x3d25bdd8, 0xe2e1c3c9,
+        0x44421659, 0x0a121386, 0xd90cec6e, 0xd5abea2a, 0x64af674e, 0xda86a85f, 0xbebfe988, 0x64e4c3fe,
+        0x9dbc8057, 0xf0f7c086, 0x60787bf8, 0x6003604d, 0xd1fd8346, 0xf6381fb0, 0x7745ae04, 0xd736fccc,
+        0x83426b33, 0xf01eab71, 0xb0804187, 0x3c005e5f, 0x77a057be, 0xbde8ae24, 0x55464299, 0xbf582e61,
+        0x4e58f48f, 0xf2ddfda2, 0xf474ef38, 0x8789bdc2, 0x5366f9c3, 0xc8b38e74, 0xb475f255, 0x46fcd9b9,
+        0x7aeb2661, 0x8b1ddf84, 0x846a0e79, 0x915f95e2, 0x466e598e, 0x20b45770, 0x8cd55591, 0xc902de4c,
+        0xb90bace1, 0xbb8205d0, 0x11a86248, 0x7574a99e, 0xb77f19b6, 0xe0a9dc09, 0x662d09a1, 0xc4324633,
+        0xe85a1f02, 0x09f0be8c, 0x4a99a025, 0x1d6efe10, 0x1ab93d1d, 0x0ba5a4df, 0xa186f20f, 0x2868f169,
+        0xdcb7da83, 0x573906fe, 0xa1e2ce9b, 0x4fcd7f52, 0x50115e01, 0xa70683fa, 0xa002b5c4, 0x0de6d027,
+        0x9af88c27, 0x773f8641, 0xc3604c06, 0x61a806b5, 0xf0177a28, 0xc0f586e0, 0x006058aa, 0x30dc7d62,
+        0x11e69ed7, 0x2338ea63, 0x53c2dd94, 0xc2c21634, 0xbbcbee56, 0x90bcb6de, 0xebfc7da1, 0xce591d76,
+        0x6f05e409, 0x4b7c0188, 0x39720a3d, 0x7c927c24, 0x86e3725f, 0x724d9db9, 0x1ac15bb4, 0xd39eb8fc,
+        0xed545578, 0x08fca5b5, 0xd83d7cd3, 0x4dad0fc4, 0x1e50ef5e, 0xb161e6f8, 0xa28514d9, 0x6c51133c,
+        0x6fd5c7e7, 0x56e14ec4, 0x362abfce, 0xddc6c837, 0xd79a3234, 0x92638212, 0x670efa8e, 0x406000e0
+    );
+
+    /**
+     * S-Box 3
+     *
+     * @access private
+     * @var    array
+     */
+    var $sbox3 = array(
+        0x3a39ce37, 0xd3faf5cf, 0xabc27737, 0x5ac52d1b, 0x5cb0679e, 0x4fa33742, 0xd3822740, 0x99bc9bbe,
+        0xd5118e9d, 0xbf0f7315, 0xd62d1c7e, 0xc700c47b, 0xb78c1b6b, 0x21a19045, 0xb26eb1be, 0x6a366eb4,
+        0x5748ab2f, 0xbc946e79, 0xc6a376d2, 0x6549c2c8, 0x530ff8ee, 0x468dde7d, 0xd5730a1d, 0x4cd04dc6,
+        0x2939bbdb, 0xa9ba4650, 0xac9526e8, 0xbe5ee304, 0xa1fad5f0, 0x6a2d519a, 0x63ef8ce2, 0x9a86ee22,
+        0xc089c2b8, 0x43242ef6, 0xa51e03aa, 0x9cf2d0a4, 0x83c061ba, 0x9be96a4d, 0x8fe51550, 0xba645bd6,
+        0x2826a2f9, 0xa73a3ae1, 0x4ba99586, 0xef5562e9, 0xc72fefd3, 0xf752f7da, 0x3f046f69, 0x77fa0a59,
+        0x80e4a915, 0x87b08601, 0x9b09e6ad, 0x3b3ee593, 0xe990fd5a, 0x9e34d797, 0x2cf0b7d9, 0x022b8b51,
+        0x96d5ac3a, 0x017da67d, 0xd1cf3ed6, 0x7c7d2d28, 0x1f9f25cf, 0xadf2b89b, 0x5ad6b472, 0x5a88f54c,
+        0xe029ac71, 0xe019a5e6, 0x47b0acfd, 0xed93fa9b, 0xe8d3c48d, 0x283b57cc, 0xf8d56629, 0x79132e28,
+        0x785f0191, 0xed756055, 0xf7960e44, 0xe3d35e8c, 0x15056dd4, 0x88f46dba, 0x03a16125, 0x0564f0bd,
+        0xc3eb9e15, 0x3c9057a2, 0x97271aec, 0xa93a072a, 0x1b3f6d9b, 0x1e6321f5, 0xf59c66fb, 0x26dcf319,
+        0x7533d928, 0xb155fdf5, 0x03563482, 0x8aba3cbb, 0x28517711, 0xc20ad9f8, 0xabcc5167, 0xccad925f,
+        0x4de81751, 0x3830dc8e, 0x379d5862, 0x9320f991, 0xea7a90c2, 0xfb3e7bce, 0x5121ce64, 0x774fbe32,
+        0xa8b6e37e, 0xc3293d46, 0x48de5369, 0x6413e680, 0xa2ae0810, 0xdd6db224, 0x69852dfd, 0x09072166,
+        0xb39a460a, 0x6445c0dd, 0x586cdecf, 0x1c20c8ae, 0x5bbef7dd, 0x1b588d40, 0xccd2017f, 0x6bb4e3bb,
+        0xdda26a7e, 0x3a59ff45, 0x3e350a44, 0xbcb4cdd5, 0x72eacea8, 0xfa6484bb, 0x8d6612ae, 0xbf3c6f47,
+        0xd29be463, 0x542f5d9e, 0xaec2771b, 0xf64e6370, 0x740e0d8d, 0xe75b1357, 0xf8721671, 0xaf537d5d,
+        0x4040cb08, 0x4eb4e2cc, 0x34d2466a, 0x0115af84, 0xe1b00428, 0x95983a1d, 0x06b89fb4, 0xce6ea048,
+        0x6f3f3b82, 0x3520ab82, 0x011a1d4b, 0x277227f8, 0x611560b1, 0xe7933fdc, 0xbb3a792b, 0x344525bd,
+        0xa08839e1, 0x51ce794b, 0x2f32c9b7, 0xa01fbac9, 0xe01cc87e, 0xbcc7d1f6, 0xcf0111c3, 0xa1e8aac7,
+        0x1a908749, 0xd44fbd9a, 0xd0dadecb, 0xd50ada38, 0x0339c32a, 0xc6913667, 0x8df9317c, 0xe0b12b4f,
+        0xf79e59b7, 0x43f5bb3a, 0xf2d519ff, 0x27d9459c, 0xbf97222c, 0x15e6fc2a, 0x0f91fc71, 0x9b941525,
+        0xfae59361, 0xceb69ceb, 0xc2a86459, 0x12baa8d1, 0xb6c1075e, 0xe3056a0c, 0x10d25065, 0xcb03a442,
+        0xe0ec6e0e, 0x1698db3b, 0x4c98a0be, 0x3278e964, 0x9f1f9532, 0xe0d392df, 0xd3a0342b, 0x8971f21e,
+        0x1b0a7441, 0x4ba3348c, 0xc5be7120, 0xc37632d8, 0xdf359f8d, 0x9b992f2e, 0xe60b6f47, 0x0fe3f11d,
+        0xe54cda54, 0x1edad891, 0xce6279cf, 0xcd3e7e6f, 0x1618b166, 0xfd2c1d05, 0x848fd2c5, 0xf6fb2299,
+        0xf523f357, 0xa6327623, 0x93a83531, 0x56cccd02, 0xacf08162, 0x5a75ebb5, 0x6e163697, 0x88d273cc,
+        0xde966292, 0x81b949d0, 0x4c50901b, 0x71c65614, 0xe6c6c7bd, 0x327a140a, 0x45e1d006, 0xc3f27b9a,
+        0xc9aa53fd, 0x62a80f00, 0xbb25bfe2, 0x35bdd2f6, 0x71126905, 0xb2040222, 0xb6cbcf7c, 0xcd769c2b,
+        0x53113ec0, 0x1640e3d3, 0x38abbd60, 0x2547adf0, 0xba38209c, 0xf746ce76, 0x77afa1c5, 0x20756060,
+        0x85cbfe4e, 0x8ae88dd8, 0x7aaaf9b0, 0x4cf9aa7e, 0x1948c25c, 0x02fb8a8c, 0x01c36ae4, 0xd6ebe1f9,
+        0x90d4f869, 0xa65cdea0, 0x3f09252d, 0xc208e69f, 0xb74e6132, 0xce77e25b, 0x578fdfe3, 0x3ac372e6
+    );
+
+    /**
+     * P-Array consists of 18 32-bit subkeys
+     *
+     * @var array
+     * @access private
+     */
+    var $parray = array(
+        0x243f6a88, 0x85a308d3, 0x13198a2e, 0x03707344, 0xa4093822, 0x299f31d0,
+        0x082efa98, 0xec4e6c89, 0x452821e6, 0x38d01377, 0xbe5466cf, 0x34e90c6c,
+        0xc0ac29b7, 0xc97c50dd, 0x3f84d5b5, 0xb5470917, 0x9216d5d9, 0x8979fb1b
+    );
+
+    /**
+     * The BCTX-working Array
+     *
+     * Holds the expanded key [p] and the key-depended s-boxes [sb]
+     *
+     * @var array
+     * @access private
+     */
+    var $bctx;
+
+    /**
+     * Holds the last used key
+     *
+     * @var array
+     * @access private
+     */
+    var $kl;
+
+    /**
+     * The Key Length (in bytes)
+     *
+     * @see \phpseclib\Crypt\Base::setKeyLength()
+     * @var int
+     * @access private
+     * @internal The max value is 256 / 8 = 32, the min value is 128 / 8 = 16.  Exists in conjunction with $Nk
+     *    because the encryption / decryption / key schedule creation requires this number and not $key_length.  We could
+     *    derive this from $key_length or vice versa, but that'd mean we'd have to do multiple shift operations, so in lieu
+     *    of that, we'll just precompute it once.
+     */
+    var $key_length = 16;
+
+    /**
+     * Sets the key length.
+     *
+     * Key lengths can be between 32 and 448 bits.
+     *
+     * @access public
+     * @param int $length
+     */
+    function setKeyLength($length)
+    {
+        if ($length < 32) {
+            $this->key_length = 4;
+        } elseif ($length > 448) {
+            $this->key_length = 56;
+        } else {
+            $this->key_length = $length >> 3;
+        }
+
+        parent::setKeyLength($length);
+    }
+
+    /**
+     * Test for engine validity
+     *
+     * This is mainly just a wrapper to set things up for \phpseclib\Crypt\Base::isValidEngine()
+     *
+     * @see \phpseclib\Crypt\Base::isValidEngine()
+     * @param int $engine
+     * @access public
+     * @return bool
+     */
+    function isValidEngine($engine)
+    {
+        if ($engine == self::ENGINE_OPENSSL) {
+            if (version_compare(PHP_VERSION, '5.3.7') < 0 && $this->key_length != 16) {
+                return false;
+            }
+            if ($this->key_length < 16) {
+                return false;
+            }
+            $this->cipher_name_openssl_ecb = 'bf-ecb';
+            $this->cipher_name_openssl = 'bf-' . $this->_openssl_translate_mode();
+        }
+
+        return parent::isValidEngine($engine);
+    }
+
+    /**
+     * Setup the key (expansion)
+     *
+     * @see \phpseclib\Crypt\Base::_setupKey()
+     * @access private
+     */
+    function _setupKey()
+    {
+        if (isset($this->kl['key']) && $this->key === $this->kl['key']) {
+            // already expanded
+            return;
+        }
+        $this->kl = array('key' => $this->key);
+
+        /* key-expanding p[] and S-Box building sb[] */
+        $this->bctx = array(
+            'p'  => array(),
+            'sb' => array(
+                $this->sbox0,
+                $this->sbox1,
+                $this->sbox2,
+                $this->sbox3
+            )
+        );
+
+        // unpack binary string in unsigned chars
+        $key  = array_values(unpack('C*', $this->key));
+        $keyl = count($key);
+        for ($j = 0, $i = 0; $i < 18; ++$i) {
+            // xor P1 with the first 32-bits of the key, xor P2 with the second 32-bits ...
+            for ($data = 0, $k = 0; $k < 4; ++$k) {
+                $data = ($data << 8) | $key[$j];
+                if (++$j >= $keyl) {
+                    $j = 0;
+                }
+            }
+            $this->bctx['p'][] = $this->parray[$i] ^ $data;
+        }
+
+        // encrypt the zero-string, replace P1 and P2 with the encrypted data,
+        // encrypt P3 and P4 with the new P1 and P2, do it with all P-array and subkeys
+        $data = "\0\0\0\0\0\0\0\0";
+        for ($i = 0; $i < 18; $i += 2) {
+            list($l, $r) = array_values(unpack('N*', $data = $this->_encryptBlock($data)));
+            $this->bctx['p'][$i    ] = $l;
+            $this->bctx['p'][$i + 1] = $r;
+        }
+        for ($i = 0; $i < 4; ++$i) {
+            for ($j = 0; $j < 256; $j += 2) {
+                list($l, $r) = array_values(unpack('N*', $data = $this->_encryptBlock($data)));
+                $this->bctx['sb'][$i][$j    ] = $l;
+                $this->bctx['sb'][$i][$j + 1] = $r;
+            }
+        }
+    }
+
+    /**
+     * Encrypts a block
+     *
+     * @access private
+     * @param string $in
+     * @return string
+     */
+    function _encryptBlock($in)
+    {
+        $p = $this->bctx["p"];
+        // extract($this->bctx["sb"], EXTR_PREFIX_ALL, "sb"); // slower
+        $sb_0 = $this->bctx["sb"][0];
+        $sb_1 = $this->bctx["sb"][1];
+        $sb_2 = $this->bctx["sb"][2];
+        $sb_3 = $this->bctx["sb"][3];
+
+        $in = unpack("N*", $in);
+        $l = $in[1];
+        $r = $in[2];
+
+        for ($i = 0; $i < 16; $i+= 2) {
+            $l^= $p[$i];
+            $r^= $this->safe_intval(($this->safe_intval($sb_0[$l >> 24 & 0xff]  + $sb_1[$l >> 16 & 0xff]) ^
+                  $sb_2[$l >>  8 & 0xff]) +
+                  $sb_3[$l       & 0xff]);
+
+            $r^= $p[$i + 1];
+            $l^= $this->safe_intval(($this->safe_intval($sb_0[$r >> 24 & 0xff]  + $sb_1[$r >> 16 & 0xff]) ^
+                  $sb_2[$r >>  8 & 0xff]) +
+                  $sb_3[$r       & 0xff]);
+        }
+        return pack("N*", $r ^ $p[17], $l ^ $p[16]);
+    }
+
+    /**
+     * Decrypts a block
+     *
+     * @access private
+     * @param string $in
+     * @return string
+     */
+    function _decryptBlock($in)
+    {
+        $p = $this->bctx["p"];
+        $sb_0 = $this->bctx["sb"][0];
+        $sb_1 = $this->bctx["sb"][1];
+        $sb_2 = $this->bctx["sb"][2];
+        $sb_3 = $this->bctx["sb"][3];
+
+        $in = unpack("N*", $in);
+        $l = $in[1];
+        $r = $in[2];
+
+        for ($i = 17; $i > 2; $i-= 2) {
+            $l^= $p[$i];
+            $r^= $this->safe_intval(($this->safe_intval($sb_0[$l >> 24 & 0xff] + $sb_1[$l >> 16 & 0xff]) ^
+                  $sb_2[$l >>  8 & 0xff]) +
+                  $sb_3[$l       & 0xff]);
+
+            $r^= $p[$i - 1];
+            $l^= $this->safe_intval(($this->safe_intval($sb_0[$r >> 24 & 0xff] + $sb_1[$r >> 16 & 0xff]) ^
+                  $sb_2[$r >>  8 & 0xff]) +
+                  $sb_3[$r       & 0xff]);
+        }
+        return pack("N*", $r ^ $p[0], $l ^ $p[1]);
+    }
+
+    /**
+     * Setup the performance-optimized function for de/encrypt()
+     *
+     * @see \phpseclib\Crypt\Base::_setupInlineCrypt()
+     * @access private
+     */
+    function _setupInlineCrypt()
+    {
+        $lambda_functions =& self::_getLambdaFunctions();
+
+        // We create max. 10 hi-optimized code for memory reason. Means: For each $key one ultra fast inline-crypt function.
+        // (Currently, for Blowfish, one generated $lambda_function cost on php5.5@32bit ~100kb unfreeable mem and ~180kb on php5.5@64bit)
+        // After that, we'll still create very fast optimized code but not the hi-ultimative code, for each $mode one.
+        $gen_hi_opt_code = (bool)(count($lambda_functions) < 10);
+
+        // Generation of a unique hash for our generated code
+        $code_hash = "Crypt_Blowfish, {$this->mode}";
+        if ($gen_hi_opt_code) {
+            $code_hash = str_pad($code_hash, 32) . $this->_hashInlineCryptFunction($this->key);
+        }
+
+        $safeint = $this->safe_intval_inline();
+
+        if (!isset($lambda_functions[$code_hash])) {
+            switch (true) {
+                case $gen_hi_opt_code:
+                    $p = $this->bctx['p'];
+                    $init_crypt = '
+                        static $sb_0, $sb_1, $sb_2, $sb_3;
+                        if (!$sb_0) {
+                            $sb_0 = $self->bctx["sb"][0];
+                            $sb_1 = $self->bctx["sb"][1];
+                            $sb_2 = $self->bctx["sb"][2];
+                            $sb_3 = $self->bctx["sb"][3];
+                        }
+                    ';
+                    break;
+                default:
+                    $p   = array();
+                    for ($i = 0; $i < 18; ++$i) {
+                        $p[] = '$p_' . $i;
+                    }
+                    $init_crypt = '
+                        list($sb_0, $sb_1, $sb_2, $sb_3) = $self->bctx["sb"];
+                        list(' . implode(',', $p) . ') = $self->bctx["p"];
+
+                    ';
+            }
+
+            // Generating encrypt code:
+            $encrypt_block = '
+                $in = unpack("N*", $in);
+                $l = $in[1];
+                $r = $in[2];
+            ';
+            for ($i = 0; $i < 16; $i+= 2) {
+                $encrypt_block.= '
+                    $l^= ' . $p[$i] . ';
+                    $r^= ' . sprintf($safeint, '(' . sprintf($safeint, '$sb_0[$l >> 24 & 0xff] + $sb_1[$l >> 16 & 0xff]') . ' ^
+                          $sb_2[$l >>  8 & 0xff]) +
+                          $sb_3[$l       & 0xff]') . ';
+
+                    $r^= ' . $p[$i + 1] . ';
+                    $l^= ' . sprintf($safeint, '(' . sprintf($safeint, '$sb_0[$r >> 24 & 0xff] + $sb_1[$r >> 16 & 0xff]') . '  ^
+                          $sb_2[$r >>  8 & 0xff]) +
+                          $sb_3[$r       & 0xff]') . ';
+                ';
+            }
+            $encrypt_block.= '
+                $in = pack("N*",
+                    $r ^ ' . $p[17] . ',
+                    $l ^ ' . $p[16] . '
+                );
+            ';
+
+            // Generating decrypt code:
+            $decrypt_block = '
+                $in = unpack("N*", $in);
+                $l = $in[1];
+                $r = $in[2];
+            ';
+
+            for ($i = 17; $i > 2; $i-= 2) {
+                $decrypt_block.= '
+                    $l^= ' . $p[$i] . ';
+                    $r^= ' . sprintf($safeint, '(' . sprintf($safeint, '$sb_0[$l >> 24 & 0xff] + $sb_1[$l >> 16 & 0xff]') . ' ^
+                          $sb_2[$l >>  8 & 0xff]) +
+                          $sb_3[$l       & 0xff]') . ';
+
+                    $r^= ' . $p[$i - 1] . ';
+                    $l^= ' . sprintf($safeint, '(' . sprintf($safeint, '$sb_0[$r >> 24 & 0xff] + $sb_1[$r >> 16 & 0xff]') . ' ^
+                          $sb_2[$r >>  8 & 0xff]) +
+                          $sb_3[$r       & 0xff]') . ';
+                ';
+            }
+
+            $decrypt_block.= '
+                $in = pack("N*",
+                    $r ^ ' . $p[0] . ',
+                    $l ^ ' . $p[1] . '
+                );
+            ';
+
+            $lambda_functions[$code_hash] = $this->_createInlineCryptFunction(
+                array(
+                   'init_crypt'    => $init_crypt,
+                   'init_encrypt'  => '',
+                   'init_decrypt'  => '',
+                   'encrypt_block' => $encrypt_block,
+                   'decrypt_block' => $decrypt_block
+                )
+            );
+        }
+        $this->inline_crypt = $lambda_functions[$code_hash];
+    }
+}
diff --git a/lib/phpseclib/Crypt/DES.php b/lib/phpseclib/Crypt/DES.php
index fe31df8..9a8225f 100644
--- a/lib/phpseclib/Crypt/DES.php
+++ b/lib/phpseclib/Crypt/DES.php
@@ -1,12 +1,11 @@
 <?php
-/* vim: set expandtab tabstop=4 shiftwidth=4 softtabstop=4: */
 
 /**
  * Pure-PHP implementation of DES.
  *
  * Uses mcrypt, if available, and an internal implementation, otherwise.
  *
- * PHP versions 4 and 5
+ * PHP version 5
  *
  * Useful resources are as follows:
  *
@@ -17,9 +16,9 @@
  * Here's a short example of how to use this library:
  * <code>
  * <?php
- *    include('Crypt/DES.php');
+ *    include 'vendor/autoload.php';
  *
- *    $des = new Crypt_DES();
+ *    $des = new \phpseclib\Crypt\DES();
  *
  *    $des->setKey('abcdefgh');
  *
@@ -33,913 +32,1412 @@
  * ?>
  * </code>
  *
- * LICENSE: This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA  02111-1307  USA
- *
- * @category   Crypt
- * @package    Crypt_DES
- * @author     Jim Wigginton <terrafrost@php.net>
- * @copyright  MMVII Jim Wigginton
- * @license    http://www.gnu.org/licenses/lgpl.txt
- * @version    $Id: DES.php,v 1.12 2010/02/09 06:10:26 terrafrost Exp $
- * @link       http://phpseclib.sourceforge.net
- */
-
-/**#@+
- * @access private
- * @see Crypt_DES::_prepareKey()
- * @see Crypt_DES::_processBlock()
- */
-/**
- * Contains array_reverse($keys[CRYPT_DES_DECRYPT])
- */
-define('CRYPT_DES_ENCRYPT', 0);
-/**
- * Contains array_reverse($keys[CRYPT_DES_ENCRYPT])
- */
-define('CRYPT_DES_DECRYPT', 1);
-/**#@-*/
-
-/**#@+
- * @access public
- * @see Crypt_DES::encrypt()
- * @see Crypt_DES::decrypt()
- */
-/**
- * Encrypt / decrypt using the Counter mode.
- *
- * Set to -1 since that's what Crypt/Random.php uses to index the CTR mode.
- *
- * @link http://en.wikipedia.org/wiki/Block_cipher_modes_of_operation#Counter_.28CTR.29
- */
-define('CRYPT_DES_MODE_CTR', -1);
-/**
- * Encrypt / decrypt using the Electronic Code Book mode.
- *
- * @link http://en.wikipedia.org/wiki/Block_cipher_modes_of_operation#Electronic_codebook_.28ECB.29
- */
-define('CRYPT_DES_MODE_ECB', 1);
-/**
- * Encrypt / decrypt using the Code Book Chaining mode.
- *
- * @link http://en.wikipedia.org/wiki/Block_cipher_modes_of_operation#Cipher-block_chaining_.28CBC.29
+ * @category  Crypt
+ * @package   DES
+ * @author    Jim Wigginton <terrafrost@php.net>
+ * @copyright 2007 Jim Wigginton
+ * @license   http://www.opensource.org/licenses/mit-license.html  MIT License
+ * @link      http://phpseclib.sourceforge.net
  */
-define('CRYPT_DES_MODE_CBC', 2);
-/**#@-*/
 
-/**#@+
- * @access private
- * @see Crypt_DES::Crypt_DES()
- */
-/**
- * Toggles the internal implementation
- */
-define('CRYPT_DES_MODE_INTERNAL', 1);
-/**
- * Toggles the mcrypt implementation
- */
-define('CRYPT_DES_MODE_MCRYPT', 2);
-/**#@-*/
+namespace phpseclib\Crypt;
 
 /**
  * Pure-PHP implementation of DES.
  *
+ * @package DES
  * @author  Jim Wigginton <terrafrost@php.net>
- * @version 0.1.0
  * @access  public
- * @package Crypt_DES
  */
-class Crypt_DES {
+class DES extends Base
+{
+    /**#@+
+     * @access private
+     * @see \phpseclib\Crypt\DES::_setupKey()
+     * @see \phpseclib\Crypt\DES::_processBlock()
+     */
     /**
-     * The Key Schedule
+     * Contains $keys[self::ENCRYPT]
+     */
+    const ENCRYPT = 0;
+    /**
+     * Contains $keys[self::DECRYPT]
+     */
+    const DECRYPT = 1;
+    /**#@-*/
+
+    /**
+     * Block Length of the cipher
      *
-     * @see Crypt_DES::setKey()
-     * @var Array
+     * @see \phpseclib\Crypt\Base::block_size
+     * @var int
      * @access private
      */
-    var $keys = "\0\0\0\0\0\0\0\0";
+    var $block_size = 8;
 
     /**
-     * The Encryption Mode
+     * Key Length (in bytes)
      *
-     * @see Crypt_DES::Crypt_DES()
-     * @var Integer
+     * @see \phpseclib\Crypt\Base::setKeyLength()
+     * @var int
      * @access private
      */
-    var $mode;
+    var $key_length = 8;
 
     /**
-     * Continuous Buffer status
+     * The mcrypt specific name of the cipher
      *
-     * @see Crypt_DES::enableContinuousBuffer()
-     * @var Boolean
+     * @see \phpseclib\Crypt\Base::cipher_name_mcrypt
+     * @var string
      * @access private
      */
-    var $continuousBuffer = false;
+    var $cipher_name_mcrypt = 'des';
 
     /**
-     * Padding status
+     * The OpenSSL names of the cipher / modes
      *
-     * @see Crypt_DES::enablePadding()
-     * @var Boolean
+     * @see \phpseclib\Crypt\Base::openssl_mode_names
+     * @var array
      * @access private
      */
-    var $padding = true;
+    var $openssl_mode_names = array(
+        self::MODE_ECB => 'des-ecb',
+        self::MODE_CBC => 'des-cbc',
+        self::MODE_CFB => 'des-cfb',
+        self::MODE_OFB => 'des-ofb'
+        // self::MODE_CTR is undefined for DES
+    );
 
     /**
-     * The Initialization Vector
+     * Optimizing value while CFB-encrypting
      *
-     * @see Crypt_DES::setIV()
-     * @var String
+     * @see \phpseclib\Crypt\Base::cfb_init_len
+     * @var int
      * @access private
      */
-    var $iv = "\0\0\0\0\0\0\0\0";
+    var $cfb_init_len = 500;
 
     /**
-     * A "sliding" Initialization Vector
+     * Switch for DES/3DES encryption
+     *
+     * Used only if $engine == self::ENGINE_INTERNAL
      *
-     * @see Crypt_DES::enableContinuousBuffer()
-     * @var String
+     * @see self::_setupKey()
+     * @see self::_processBlock()
+     * @var int
      * @access private
      */
-    var $encryptIV = "\0\0\0\0\0\0\0\0";
+    var $des_rounds = 1;
 
     /**
-     * A "sliding" Initialization Vector
+     * max possible size of $key
      *
-     * @see Crypt_DES::enableContinuousBuffer()
-     * @var String
+     * @see self::setKey()
+     * @var string
      * @access private
      */
-    var $decryptIV = "\0\0\0\0\0\0\0\0";
+    var $key_length_max = 8;
 
     /**
-     * mcrypt resource for encryption
-     *
-     * The mcrypt resource can be recreated every time something needs to be created or it can be created just once.
-     * Since mcrypt operates in continuous mode, by default, it'll need to be recreated when in non-continuous mode.
+     * The Key Schedule
      *
-     * @see Crypt_AES::encrypt()
-     * @var String
+     * @see self::_setupKey()
+     * @var array
      * @access private
      */
-    var $enmcrypt;
+    var $keys;
 
     /**
-     * mcrypt resource for decryption
+     * Shuffle table.
      *
-     * The mcrypt resource can be recreated every time something needs to be created or it can be created just once.
-     * Since mcrypt operates in continuous mode, by default, it'll need to be recreated when in non-continuous mode.
+     * For each byte value index, the entry holds an 8-byte string
+     * with each byte containing all bits in the same state as the
+     * corresponding bit in the index value.
      *
-     * @see Crypt_AES::decrypt()
-     * @var String
+     * @see self::_processBlock()
+     * @see self::_setupKey()
+     * @var array
      * @access private
      */
-    var $demcrypt;
+    var $shuffle = array(
+        "\x00\x00\x00\x00\x00\x00\x00\x00", "\x00\x00\x00\x00\x00\x00\x00\xFF",
+        "\x00\x00\x00\x00\x00\x00\xFF\x00", "\x00\x00\x00\x00\x00\x00\xFF\xFF",
+        "\x00\x00\x00\x00\x00\xFF\x00\x00", "\x00\x00\x00\x00\x00\xFF\x00\xFF",
+        "\x00\x00\x00\x00\x00\xFF\xFF\x00", "\x00\x00\x00\x00\x00\xFF\xFF\xFF",
+        "\x00\x00\x00\x00\xFF\x00\x00\x00", "\x00\x00\x00\x00\xFF\x00\x00\xFF",
+        "\x00\x00\x00\x00\xFF\x00\xFF\x00", "\x00\x00\x00\x00\xFF\x00\xFF\xFF",
+        "\x00\x00\x00\x00\xFF\xFF\x00\x00", "\x00\x00\x00\x00\xFF\xFF\x00\xFF",
+        "\x00\x00\x00\x00\xFF\xFF\xFF\x00", "\x00\x00\x00\x00\xFF\xFF\xFF\xFF",
+        "\x00\x00\x00\xFF\x00\x00\x00\x00", "\x00\x00\x00\xFF\x00\x00\x00\xFF",
+        "\x00\x00\x00\xFF\x00\x00\xFF\x00", "\x00\x00\x00\xFF\x00\x00\xFF\xFF",
+        "\x00\x00\x00\xFF\x00\xFF\x00\x00", "\x00\x00\x00\xFF\x00\xFF\x00\xFF",
+        "\x00\x00\x00\xFF\x00\xFF\xFF\x00", "\x00\x00\x00\xFF\x00\xFF\xFF\xFF",
+        "\x00\x00\x00\xFF\xFF\x00\x00\x00", "\x00\x00\x00\xFF\xFF\x00\x00\xFF",
+        "\x00\x00\x00\xFF\xFF\x00\xFF\x00", "\x00\x00\x00\xFF\xFF\x00\xFF\xFF",
+        "\x00\x00\x00\xFF\xFF\xFF\x00\x00", "\x00\x00\x00\xFF\xFF\xFF\x00\xFF",
+        "\x00\x00\x00\xFF\xFF\xFF\xFF\x00", "\x00\x00\x00\xFF\xFF\xFF\xFF\xFF",
+        "\x00\x00\xFF\x00\x00\x00\x00\x00", "\x00\x00\xFF\x00\x00\x00\x00\xFF",
+        "\x00\x00\xFF\x00\x00\x00\xFF\x00", "\x00\x00\xFF\x00\x00\x00\xFF\xFF",
+        "\x00\x00\xFF\x00\x00\xFF\x00\x00", "\x00\x00\xFF\x00\x00\xFF\x00\xFF",
+        "\x00\x00\xFF\x00\x00\xFF\xFF\x00", "\x00\x00\xFF\x00\x00\xFF\xFF\xFF",
+        "\x00\x00\xFF\x00\xFF\x00\x00\x00", "\x00\x00\xFF\x00\xFF\x00\x00\xFF",
+        "\x00\x00\xFF\x00\xFF\x00\xFF\x00", "\x00\x00\xFF\x00\xFF\x00\xFF\xFF",
+        "\x00\x00\xFF\x00\xFF\xFF\x00\x00", "\x00\x00\xFF\x00\xFF\xFF\x00\xFF",
+        "\x00\x00\xFF\x00\xFF\xFF\xFF\x00", "\x00\x00\xFF\x00\xFF\xFF\xFF\xFF",
+        "\x00\x00\xFF\xFF\x00\x00\x00\x00", "\x00\x00\xFF\xFF\x00\x00\x00\xFF",
+        "\x00\x00\xFF\xFF\x00\x00\xFF\x00", "\x00\x00\xFF\xFF\x00\x00\xFF\xFF",
+        "\x00\x00\xFF\xFF\x00\xFF\x00\x00", "\x00\x00\xFF\xFF\x00\xFF\x00\xFF",
+        "\x00\x00\xFF\xFF\x00\xFF\xFF\x00", "\x00\x00\xFF\xFF\x00\xFF\xFF\xFF",
+        "\x00\x00\xFF\xFF\xFF\x00\x00\x00", "\x00\x00\xFF\xFF\xFF\x00\x00\xFF",
+        "\x00\x00\xFF\xFF\xFF\x00\xFF\x00", "\x00\x00\xFF\xFF\xFF\x00\xFF\xFF",
+        "\x00\x00\xFF\xFF\xFF\xFF\x00\x00", "\x00\x00\xFF\xFF\xFF\xFF\x00\xFF",
+        "\x00\x00\xFF\xFF\xFF\xFF\xFF\x00", "\x00\x00\xFF\xFF\xFF\xFF\xFF\xFF",
+        "\x00\xFF\x00\x00\x00\x00\x00\x00", "\x00\xFF\x00\x00\x00\x00\x00\xFF",
+        "\x00\xFF\x00\x00\x00\x00\xFF\x00", "\x00\xFF\x00\x00\x00\x00\xFF\xFF",
+        "\x00\xFF\x00\x00\x00\xFF\x00\x00", "\x00\xFF\x00\x00\x00\xFF\x00\xFF",
+        "\x00\xFF\x00\x00\x00\xFF\xFF\x00", "\x00\xFF\x00\x00\x00\xFF\xFF\xFF",
+        "\x00\xFF\x00\x00\xFF\x00\x00\x00", "\x00\xFF\x00\x00\xFF\x00\x00\xFF",
+        "\x00\xFF\x00\x00\xFF\x00\xFF\x00", "\x00\xFF\x00\x00\xFF\x00\xFF\xFF",
+        "\x00\xFF\x00\x00\xFF\xFF\x00\x00", "\x00\xFF\x00\x00\xFF\xFF\x00\xFF",
+        "\x00\xFF\x00\x00\xFF\xFF\xFF\x00", "\x00\xFF\x00\x00\xFF\xFF\xFF\xFF",
+        "\x00\xFF\x00\xFF\x00\x00\x00\x00", "\x00\xFF\x00\xFF\x00\x00\x00\xFF",
+        "\x00\xFF\x00\xFF\x00\x00\xFF\x00", "\x00\xFF\x00\xFF\x00\x00\xFF\xFF",
+        "\x00\xFF\x00\xFF\x00\xFF\x00\x00", "\x00\xFF\x00\xFF\x00\xFF\x00\xFF",
+        "\x00\xFF\x00\xFF\x00\xFF\xFF\x00", "\x00\xFF\x00\xFF\x00\xFF\xFF\xFF",
+        "\x00\xFF\x00\xFF\xFF\x00\x00\x00", "\x00\xFF\x00\xFF\xFF\x00\x00\xFF",
+        "\x00\xFF\x00\xFF\xFF\x00\xFF\x00", "\x00\xFF\x00\xFF\xFF\x00\xFF\xFF",
+        "\x00\xFF\x00\xFF\xFF\xFF\x00\x00", "\x00\xFF\x00\xFF\xFF\xFF\x00\xFF",
+        "\x00\xFF\x00\xFF\xFF\xFF\xFF\x00", "\x00\xFF\x00\xFF\xFF\xFF\xFF\xFF",
+        "\x00\xFF\xFF\x00\x00\x00\x00\x00", "\x00\xFF\xFF\x00\x00\x00\x00\xFF",
+        "\x00\xFF\xFF\x00\x00\x00\xFF\x00", "\x00\xFF\xFF\x00\x00\x00\xFF\xFF",
+        "\x00\xFF\xFF\x00\x00\xFF\x00\x00", "\x00\xFF\xFF\x00\x00\xFF\x00\xFF",
+        "\x00\xFF\xFF\x00\x00\xFF\xFF\x00", "\x00\xFF\xFF\x00\x00\xFF\xFF\xFF",
+        "\x00\xFF\xFF\x00\xFF\x00\x00\x00", "\x00\xFF\xFF\x00\xFF\x00\x00\xFF",
+        "\x00\xFF\xFF\x00\xFF\x00\xFF\x00", "\x00\xFF\xFF\x00\xFF\x00\xFF\xFF",
+        "\x00\xFF\xFF\x00\xFF\xFF\x00\x00", "\x00\xFF\xFF\x00\xFF\xFF\x00\xFF",
+        "\x00\xFF\xFF\x00\xFF\xFF\xFF\x00", "\x00\xFF\xFF\x00\xFF\xFF\xFF\xFF",
+        "\x00\xFF\xFF\xFF\x00\x00\x00\x00", "\x00\xFF\xFF\xFF\x00\x00\x00\xFF",
+        "\x00\xFF\xFF\xFF\x00\x00\xFF\x00", "\x00\xFF\xFF\xFF\x00\x00\xFF\xFF",
+        "\x00\xFF\xFF\xFF\x00\xFF\x00\x00", "\x00\xFF\xFF\xFF\x00\xFF\x00\xFF",
+        "\x00\xFF\xFF\xFF\x00\xFF\xFF\x00", "\x00\xFF\xFF\xFF\x00\xFF\xFF\xFF",
+        "\x00\xFF\xFF\xFF\xFF\x00\x00\x00", "\x00\xFF\xFF\xFF\xFF\x00\x00\xFF",
+        "\x00\xFF\xFF\xFF\xFF\x00\xFF\x00", "\x00\xFF\xFF\xFF\xFF\x00\xFF\xFF",
+        "\x00\xFF\xFF\xFF\xFF\xFF\x00\x00", "\x00\xFF\xFF\xFF\xFF\xFF\x00\xFF",
+        "\x00\xFF\xFF\xFF\xFF\xFF\xFF\x00", "\x00\xFF\xFF\xFF\xFF\xFF\xFF\xFF",
+        "\xFF\x00\x00\x00\x00\x00\x00\x00", "\xFF\x00\x00\x00\x00\x00\x00\xFF",
+        "\xFF\x00\x00\x00\x00\x00\xFF\x00", "\xFF\x00\x00\x00\x00\x00\xFF\xFF",
+        "\xFF\x00\x00\x00\x00\xFF\x00\x00", "\xFF\x00\x00\x00\x00\xFF\x00\xFF",
+        "\xFF\x00\x00\x00\x00\xFF\xFF\x00", "\xFF\x00\x00\x00\x00\xFF\xFF\xFF",
+        "\xFF\x00\x00\x00\xFF\x00\x00\x00", "\xFF\x00\x00\x00\xFF\x00\x00\xFF",
+        "\xFF\x00\x00\x00\xFF\x00\xFF\x00", "\xFF\x00\x00\x00\xFF\x00\xFF\xFF",
+        "\xFF\x00\x00\x00\xFF\xFF\x00\x00", "\xFF\x00\x00\x00\xFF\xFF\x00\xFF",
+        "\xFF\x00\x00\x00\xFF\xFF\xFF\x00", "\xFF\x00\x00\x00\xFF\xFF\xFF\xFF",
+        "\xFF\x00\x00\xFF\x00\x00\x00\x00", "\xFF\x00\x00\xFF\x00\x00\x00\xFF",
+        "\xFF\x00\x00\xFF\x00\x00\xFF\x00", "\xFF\x00\x00\xFF\x00\x00\xFF\xFF",
+        "\xFF\x00\x00\xFF\x00\xFF\x00\x00", "\xFF\x00\x00\xFF\x00\xFF\x00\xFF",
+        "\xFF\x00\x00\xFF\x00\xFF\xFF\x00", "\xFF\x00\x00\xFF\x00\xFF\xFF\xFF",
+        "\xFF\x00\x00\xFF\xFF\x00\x00\x00", "\xFF\x00\x00\xFF\xFF\x00\x00\xFF",
+        "\xFF\x00\x00\xFF\xFF\x00\xFF\x00", "\xFF\x00\x00\xFF\xFF\x00\xFF\xFF",
+        "\xFF\x00\x00\xFF\xFF\xFF\x00\x00", "\xFF\x00\x00\xFF\xFF\xFF\x00\xFF",
+        "\xFF\x00\x00\xFF\xFF\xFF\xFF\x00", "\xFF\x00\x00\xFF\xFF\xFF\xFF\xFF",
+        "\xFF\x00\xFF\x00\x00\x00\x00\x00", "\xFF\x00\xFF\x00\x00\x00\x00\xFF",
+        "\xFF\x00\xFF\x00\x00\x00\xFF\x00", "\xFF\x00\xFF\x00\x00\x00\xFF\xFF",
+        "\xFF\x00\xFF\x00\x00\xFF\x00\x00", "\xFF\x00\xFF\x00\x00\xFF\x00\xFF",
+        "\xFF\x00\xFF\x00\x00\xFF\xFF\x00", "\xFF\x00\xFF\x00\x00\xFF\xFF\xFF",
+        "\xFF\x00\xFF\x00\xFF\x00\x00\x00", "\xFF\x00\xFF\x00\xFF\x00\x00\xFF",
+        "\xFF\x00\xFF\x00\xFF\x00\xFF\x00", "\xFF\x00\xFF\x00\xFF\x00\xFF\xFF",
+        "\xFF\x00\xFF\x00\xFF\xFF\x00\x00", "\xFF\x00\xFF\x00\xFF\xFF\x00\xFF",
+        "\xFF\x00\xFF\x00\xFF\xFF\xFF\x00", "\xFF\x00\xFF\x00\xFF\xFF\xFF\xFF",
+        "\xFF\x00\xFF\xFF\x00\x00\x00\x00", "\xFF\x00\xFF\xFF\x00\x00\x00\xFF",
+        "\xFF\x00\xFF\xFF\x00\x00\xFF\x00", "\xFF\x00\xFF\xFF\x00\x00\xFF\xFF",
+        "\xFF\x00\xFF\xFF\x00\xFF\x00\x00", "\xFF\x00\xFF\xFF\x00\xFF\x00\xFF",
+        "\xFF\x00\xFF\xFF\x00\xFF\xFF\x00", "\xFF\x00\xFF\xFF\x00\xFF\xFF\xFF",
+        "\xFF\x00\xFF\xFF\xFF\x00\x00\x00", "\xFF\x00\xFF\xFF\xFF\x00\x00\xFF",
+        "\xFF\x00\xFF\xFF\xFF\x00\xFF\x00", "\xFF\x00\xFF\xFF\xFF\x00\xFF\xFF",
+        "\xFF\x00\xFF\xFF\xFF\xFF\x00\x00", "\xFF\x00\xFF\xFF\xFF\xFF\x00\xFF",
+        "\xFF\x00\xFF\xFF\xFF\xFF\xFF\x00", "\xFF\x00\xFF\xFF\xFF\xFF\xFF\xFF",
+        "\xFF\xFF\x00\x00\x00\x00\x00\x00", "\xFF\xFF\x00\x00\x00\x00\x00\xFF",
+        "\xFF\xFF\x00\x00\x00\x00\xFF\x00", "\xFF\xFF\x00\x00\x00\x00\xFF\xFF",
+        "\xFF\xFF\x00\x00\x00\xFF\x00\x00", "\xFF\xFF\x00\x00\x00\xFF\x00\xFF",
+        "\xFF\xFF\x00\x00\x00\xFF\xFF\x00", "\xFF\xFF\x00\x00\x00\xFF\xFF\xFF",
+        "\xFF\xFF\x00\x00\xFF\x00\x00\x00", "\xFF\xFF\x00\x00\xFF\x00\x00\xFF",
+        "\xFF\xFF\x00\x00\xFF\x00\xFF\x00", "\xFF\xFF\x00\x00\xFF\x00\xFF\xFF",
+        "\xFF\xFF\x00\x00\xFF\xFF\x00\x00", "\xFF\xFF\x00\x00\xFF\xFF\x00\xFF",
+        "\xFF\xFF\x00\x00\xFF\xFF\xFF\x00", "\xFF\xFF\x00\x00\xFF\xFF\xFF\xFF",
+        "\xFF\xFF\x00\xFF\x00\x00\x00\x00", "\xFF\xFF\x00\xFF\x00\x00\x00\xFF",
+        "\xFF\xFF\x00\xFF\x00\x00\xFF\x00", "\xFF\xFF\x00\xFF\x00\x00\xFF\xFF",
+        "\xFF\xFF\x00\xFF\x00\xFF\x00\x00", "\xFF\xFF\x00\xFF\x00\xFF\x00\xFF",
+        "\xFF\xFF\x00\xFF\x00\xFF\xFF\x00", "\xFF\xFF\x00\xFF\x00\xFF\xFF\xFF",
+        "\xFF\xFF\x00\xFF\xFF\x00\x00\x00", "\xFF\xFF\x00\xFF\xFF\x00\x00\xFF",
+        "\xFF\xFF\x00\xFF\xFF\x00\xFF\x00", "\xFF\xFF\x00\xFF\xFF\x00\xFF\xFF",
+        "\xFF\xFF\x00\xFF\xFF\xFF\x00\x00", "\xFF\xFF\x00\xFF\xFF\xFF\x00\xFF",
+        "\xFF\xFF\x00\xFF\xFF\xFF\xFF\x00", "\xFF\xFF\x00\xFF\xFF\xFF\xFF\xFF",
+        "\xFF\xFF\xFF\x00\x00\x00\x00\x00", "\xFF\xFF\xFF\x00\x00\x00\x00\xFF",
+        "\xFF\xFF\xFF\x00\x00\x00\xFF\x00", "\xFF\xFF\xFF\x00\x00\x00\xFF\xFF",
+        "\xFF\xFF\xFF\x00\x00\xFF\x00\x00", "\xFF\xFF\xFF\x00\x00\xFF\x00\xFF",
+        "\xFF\xFF\xFF\x00\x00\xFF\xFF\x00", "\xFF\xFF\xFF\x00\x00\xFF\xFF\xFF",
+        "\xFF\xFF\xFF\x00\xFF\x00\x00\x00", "\xFF\xFF\xFF\x00\xFF\x00\x00\xFF",
+        "\xFF\xFF\xFF\x00\xFF\x00\xFF\x00", "\xFF\xFF\xFF\x00\xFF\x00\xFF\xFF",
+        "\xFF\xFF\xFF\x00\xFF\xFF\x00\x00", "\xFF\xFF\xFF\x00\xFF\xFF\x00\xFF",
+        "\xFF\xFF\xFF\x00\xFF\xFF\xFF\x00", "\xFF\xFF\xFF\x00\xFF\xFF\xFF\xFF",
+        "\xFF\xFF\xFF\xFF\x00\x00\x00\x00", "\xFF\xFF\xFF\xFF\x00\x00\x00\xFF",
+        "\xFF\xFF\xFF\xFF\x00\x00\xFF\x00", "\xFF\xFF\xFF\xFF\x00\x00\xFF\xFF",
+        "\xFF\xFF\xFF\xFF\x00\xFF\x00\x00", "\xFF\xFF\xFF\xFF\x00\xFF\x00\xFF",
+        "\xFF\xFF\xFF\xFF\x00\xFF\xFF\x00", "\xFF\xFF\xFF\xFF\x00\xFF\xFF\xFF",
+        "\xFF\xFF\xFF\xFF\xFF\x00\x00\x00", "\xFF\xFF\xFF\xFF\xFF\x00\x00\xFF",
+        "\xFF\xFF\xFF\xFF\xFF\x00\xFF\x00", "\xFF\xFF\xFF\xFF\xFF\x00\xFF\xFF",
+        "\xFF\xFF\xFF\xFF\xFF\xFF\x00\x00", "\xFF\xFF\xFF\xFF\xFF\xFF\x00\xFF",
+        "\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x00", "\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF"
+    );
 
     /**
-     * Does the (en|de)mcrypt resource need to be (re)initialized?
+     * IP mapping helper table.
      *
-     * @see setKey()
-     * @see setIV()
-     * @var Boolean
+     * Indexing this table with each source byte performs the initial bit permutation.
+     *
+     * @var array
      * @access private
      */
-    var $changed = true;
+    var $ipmap = array(
+        0x00, 0x10, 0x01, 0x11, 0x20, 0x30, 0x21, 0x31,
+        0x02, 0x12, 0x03, 0x13, 0x22, 0x32, 0x23, 0x33,
+        0x40, 0x50, 0x41, 0x51, 0x60, 0x70, 0x61, 0x71,
+        0x42, 0x52, 0x43, 0x53, 0x62, 0x72, 0x63, 0x73,
+        0x04, 0x14, 0x05, 0x15, 0x24, 0x34, 0x25, 0x35,
+        0x06, 0x16, 0x07, 0x17, 0x26, 0x36, 0x27, 0x37,
+        0x44, 0x54, 0x45, 0x55, 0x64, 0x74, 0x65, 0x75,
+        0x46, 0x56, 0x47, 0x57, 0x66, 0x76, 0x67, 0x77,
+        0x80, 0x90, 0x81, 0x91, 0xA0, 0xB0, 0xA1, 0xB1,
+        0x82, 0x92, 0x83, 0x93, 0xA2, 0xB2, 0xA3, 0xB3,
+        0xC0, 0xD0, 0xC1, 0xD1, 0xE0, 0xF0, 0xE1, 0xF1,
+        0xC2, 0xD2, 0xC3, 0xD3, 0xE2, 0xF2, 0xE3, 0xF3,
+        0x84, 0x94, 0x85, 0x95, 0xA4, 0xB4, 0xA5, 0xB5,
+        0x86, 0x96, 0x87, 0x97, 0xA6, 0xB6, 0xA7, 0xB7,
+        0xC4, 0xD4, 0xC5, 0xD5, 0xE4, 0xF4, 0xE5, 0xF5,
+        0xC6, 0xD6, 0xC7, 0xD7, 0xE6, 0xF6, 0xE7, 0xF7,
+        0x08, 0x18, 0x09, 0x19, 0x28, 0x38, 0x29, 0x39,
+        0x0A, 0x1A, 0x0B, 0x1B, 0x2A, 0x3A, 0x2B, 0x3B,
+        0x48, 0x58, 0x49, 0x59, 0x68, 0x78, 0x69, 0x79,
+        0x4A, 0x5A, 0x4B, 0x5B, 0x6A, 0x7A, 0x6B, 0x7B,
+        0x0C, 0x1C, 0x0D, 0x1D, 0x2C, 0x3C, 0x2D, 0x3D,
+        0x0E, 0x1E, 0x0F, 0x1F, 0x2E, 0x3E, 0x2F, 0x3F,
+        0x4C, 0x5C, 0x4D, 0x5D, 0x6C, 0x7C, 0x6D, 0x7D,
+        0x4E, 0x5E, 0x4F, 0x5F, 0x6E, 0x7E, 0x6F, 0x7F,
+        0x88, 0x98, 0x89, 0x99, 0xA8, 0xB8, 0xA9, 0xB9,
+        0x8A, 0x9A, 0x8B, 0x9B, 0xAA, 0xBA, 0xAB, 0xBB,
+        0xC8, 0xD8, 0xC9, 0xD9, 0xE8, 0xF8, 0xE9, 0xF9,
+        0xCA, 0xDA, 0xCB, 0xDB, 0xEA, 0xFA, 0xEB, 0xFB,
+        0x8C, 0x9C, 0x8D, 0x9D, 0xAC, 0xBC, 0xAD, 0xBD,
+        0x8E, 0x9E, 0x8F, 0x9F, 0xAE, 0xBE, 0xAF, 0xBF,
+        0xCC, 0xDC, 0xCD, 0xDD, 0xEC, 0xFC, 0xED, 0xFD,
+        0xCE, 0xDE, 0xCF, 0xDF, 0xEE, 0xFE, 0xEF, 0xFF
+    );
 
     /**
-     * Default Constructor.
-     *
-     * Determines whether or not the mcrypt extension should be used.  $mode should only, at present, be
-     * CRYPT_DES_MODE_ECB or CRYPT_DES_MODE_CBC.  If not explictly set, CRYPT_DES_MODE_CBC will be used.
+     * Inverse IP mapping helper table.
+     * Indexing this table with a byte value reverses the bit order.
      *
-     * @param optional Integer $mode
-     * @return Crypt_DES
-     * @access public
+     * @var array
+     * @access private
      */
-    function Crypt_DES($mode = CRYPT_MODE_DES_CBC)
-    {
-        if ( !defined('CRYPT_DES_MODE') ) {
-            switch (true) {
-                case extension_loaded('mcrypt'):
-                    // i'd check to see if des was supported, by doing in_array('des', mcrypt_list_algorithms('')),
-                    // but since that can be changed after the object has been created, there doesn't seem to be
-                    // a lot of point...
-                    define('CRYPT_DES_MODE', CRYPT_DES_MODE_MCRYPT);
-                    break;
-                default:
-                    define('CRYPT_DES_MODE', CRYPT_DES_MODE_INTERNAL);
-            }
-        }
-
-        switch ( CRYPT_DES_MODE ) {
-            case CRYPT_DES_MODE_MCRYPT:
-                switch ($mode) {
-                    case CRYPT_DES_MODE_ECB:
-                        $this->mode = MCRYPT_MODE_ECB;
-                        break;
-                    case CRYPT_DES_MODE_CTR:
-                        $this->mode = 'ctr';
-                        //$this->mode = in_array('ctr', mcrypt_list_modes()) ? 'ctr' : CRYPT_DES_MODE_CTR;
-                        break;
-                    case CRYPT_DES_MODE_CBC:
-                    default:
-                        $this->mode = MCRYPT_MODE_CBC;
-                }
-
-                break;
-            default:
-                switch ($mode) {
-                    case CRYPT_DES_MODE_ECB:
-                    case CRYPT_DES_MODE_CTR:
-                    case CRYPT_DES_MODE_CBC:
-                        $this->mode = $mode;
-                        break;
-                    default:
-                        $this->mode = CRYPT_DES_MODE_CBC;
-                }
-        }
-    }
+    var $invipmap = array(
+        0x00, 0x80, 0x40, 0xC0, 0x20, 0xA0, 0x60, 0xE0,
+        0x10, 0x90, 0x50, 0xD0, 0x30, 0xB0, 0x70, 0xF0,
+        0x08, 0x88, 0x48, 0xC8, 0x28, 0xA8, 0x68, 0xE8,
+        0x18, 0x98, 0x58, 0xD8, 0x38, 0xB8, 0x78, 0xF8,
+        0x04, 0x84, 0x44, 0xC4, 0x24, 0xA4, 0x64, 0xE4,
+        0x14, 0x94, 0x54, 0xD4, 0x34, 0xB4, 0x74, 0xF4,
+        0x0C, 0x8C, 0x4C, 0xCC, 0x2C, 0xAC, 0x6C, 0xEC,
+        0x1C, 0x9C, 0x5C, 0xDC, 0x3C, 0xBC, 0x7C, 0xFC,
+        0x02, 0x82, 0x42, 0xC2, 0x22, 0xA2, 0x62, 0xE2,
+        0x12, 0x92, 0x52, 0xD2, 0x32, 0xB2, 0x72, 0xF2,
+        0x0A, 0x8A, 0x4A, 0xCA, 0x2A, 0xAA, 0x6A, 0xEA,
+        0x1A, 0x9A, 0x5A, 0xDA, 0x3A, 0xBA, 0x7A, 0xFA,
+        0x06, 0x86, 0x46, 0xC6, 0x26, 0xA6, 0x66, 0xE6,
+        0x16, 0x96, 0x56, 0xD6, 0x36, 0xB6, 0x76, 0xF6,
+        0x0E, 0x8E, 0x4E, 0xCE, 0x2E, 0xAE, 0x6E, 0xEE,
+        0x1E, 0x9E, 0x5E, 0xDE, 0x3E, 0xBE, 0x7E, 0xFE,
+        0x01, 0x81, 0x41, 0xC1, 0x21, 0xA1, 0x61, 0xE1,
+        0x11, 0x91, 0x51, 0xD1, 0x31, 0xB1, 0x71, 0xF1,
+        0x09, 0x89, 0x49, 0xC9, 0x29, 0xA9, 0x69, 0xE9,
+        0x19, 0x99, 0x59, 0xD9, 0x39, 0xB9, 0x79, 0xF9,
+        0x05, 0x85, 0x45, 0xC5, 0x25, 0xA5, 0x65, 0xE5,
+        0x15, 0x95, 0x55, 0xD5, 0x35, 0xB5, 0x75, 0xF5,
+        0x0D, 0x8D, 0x4D, 0xCD, 0x2D, 0xAD, 0x6D, 0xED,
+        0x1D, 0x9D, 0x5D, 0xDD, 0x3D, 0xBD, 0x7D, 0xFD,
+        0x03, 0x83, 0x43, 0xC3, 0x23, 0xA3, 0x63, 0xE3,
+        0x13, 0x93, 0x53, 0xD3, 0x33, 0xB3, 0x73, 0xF3,
+        0x0B, 0x8B, 0x4B, 0xCB, 0x2B, 0xAB, 0x6B, 0xEB,
+        0x1B, 0x9B, 0x5B, 0xDB, 0x3B, 0xBB, 0x7B, 0xFB,
+        0x07, 0x87, 0x47, 0xC7, 0x27, 0xA7, 0x67, 0xE7,
+        0x17, 0x97, 0x57, 0xD7, 0x37, 0xB7, 0x77, 0xF7,
+        0x0F, 0x8F, 0x4F, 0xCF, 0x2F, 0xAF, 0x6F, 0xEF,
+        0x1F, 0x9F, 0x5F, 0xDF, 0x3F, 0xBF, 0x7F, 0xFF
+    );
 
     /**
-     * Sets the key.
-     *
-     * Keys can be of any length.  DES, itself, uses 64-bit keys (eg. strlen($key) == 8), however, we
-     * only use the first eight, if $key has more then eight characters in it, and pad $key with the
-     * null byte if it is less then eight characters long.
-     *
-     * DES also requires that every eighth bit be a parity bit, however, we'll ignore that.
+     * Pre-permuted S-box1
      *
-     * If the key is not explicitly set, it'll be assumed to be all zero's.
+     * Each box ($sbox1-$sbox8) has been vectorized, then each value pre-permuted using the
+     * P table: concatenation can then be replaced by exclusive ORs.
      *
-     * @access public
-     * @param String $key
+     * @var array
+     * @access private
      */
-    function setKey($key)
-    {
-        $this->keys = ( CRYPT_DES_MODE == CRYPT_DES_MODE_MCRYPT ) ? substr($key, 0, 8) : $this->_prepareKey($key);
-        $this->changed = true;
-    }
+    var $sbox1 = array(
+        0x00808200, 0x00000000, 0x00008000, 0x00808202,
+        0x00808002, 0x00008202, 0x00000002, 0x00008000,
+        0x00000200, 0x00808200, 0x00808202, 0x00000200,
+        0x00800202, 0x00808002, 0x00800000, 0x00000002,
+        0x00000202, 0x00800200, 0x00800200, 0x00008200,
+        0x00008200, 0x00808000, 0x00808000, 0x00800202,
+        0x00008002, 0x00800002, 0x00800002, 0x00008002,
+        0x00000000, 0x00000202, 0x00008202, 0x00800000,
+        0x00008000, 0x00808202, 0x00000002, 0x00808000,
+        0x00808200, 0x00800000, 0x00800000, 0x00000200,
+        0x00808002, 0x00008000, 0x00008200, 0x00800002,
+        0x00000200, 0x00000002, 0x00800202, 0x00008202,
+        0x00808202, 0x00008002, 0x00808000, 0x00800202,
+        0x00800002, 0x00000202, 0x00008202, 0x00808200,
+        0x00000202, 0x00800200, 0x00800200, 0x00000000,
+        0x00008002, 0x00008200, 0x00000000, 0x00808002
+    );
 
     /**
-     * Sets the initialization vector. (optional)
-     *
-     * SetIV is not required when CRYPT_DES_MODE_ECB is being used.  If not explictly set, it'll be assumed
-     * to be all zero's.
+     * Pre-permuted S-box2
      *
-     * @access public
-     * @param String $iv
+     * @var array
+     * @access private
      */
-    function setIV($iv)
-    {
-        $this->encryptIV = $this->decryptIV = $this->iv = str_pad(substr($iv, 0, 8), 8, chr(0));
-        $this->changed = true;
-    }
+    var $sbox2 = array(
+        0x40084010, 0x40004000, 0x00004000, 0x00084010,
+        0x00080000, 0x00000010, 0x40080010, 0x40004010,
+        0x40000010, 0x40084010, 0x40084000, 0x40000000,
+        0x40004000, 0x00080000, 0x00000010, 0x40080010,
+        0x00084000, 0x00080010, 0x40004010, 0x00000000,
+        0x40000000, 0x00004000, 0x00084010, 0x40080000,
+        0x00080010, 0x40000010, 0x00000000, 0x00084000,
+        0x00004010, 0x40084000, 0x40080000, 0x00004010,
+        0x00000000, 0x00084010, 0x40080010, 0x00080000,
+        0x40004010, 0x40080000, 0x40084000, 0x00004000,
+        0x40080000, 0x40004000, 0x00000010, 0x40084010,
+        0x00084010, 0x00000010, 0x00004000, 0x40000000,
+        0x00004010, 0x40084000, 0x00080000, 0x40000010,
+        0x00080010, 0x40004010, 0x40000010, 0x00080010,
+        0x00084000, 0x00000000, 0x40004000, 0x00004010,
+        0x40000000, 0x40080010, 0x40084010, 0x00084000
+    );
 
     /**
-     * Generate CTR XOR encryption key
+     * Pre-permuted S-box3
      *
-     * Encrypt the output of this and XOR it against the ciphertext / plaintext to get the
-     * plaintext / ciphertext in CTR mode.
-     *
-     * @see Crypt_DES::decrypt()
-     * @see Crypt_DES::encrypt()
-     * @access public
-     * @param Integer $length
-     * @param String $iv
+     * @var array
+     * @access private
      */
-    function _generate_xor($length, &$iv)
-    {
-        $xor = '';
-        $num_blocks = ($length + 7) >> 3;
-        for ($i = 0; $i < $num_blocks; $i++) {
-            $xor.= $iv;
-            for ($j = 4; $j <= 8; $j+=4) {
-                $temp = substr($iv, -$j, 4);
-                switch ($temp) {
-                    case "\xFF\xFF\xFF\xFF":
-                        $iv = substr_replace($iv, "\x00\x00\x00\x00", -$j, 4);
-                        break;
-                    case "\x7F\xFF\xFF\xFF":
-                        $iv = substr_replace($iv, "\x80\x00\x00\x00", -$j, 4);
-                        break 2;
-                    default:
-                        extract(unpack('Ncount', $temp));
-                        $iv = substr_replace($iv, pack('N', $count + 1), -$j, 4);
-                        break 2;
-                }
-            }
-        }
-
-        return $xor;
-    }
+    var $sbox3 = array(
+        0x00000104, 0x04010100, 0x00000000, 0x04010004,
+        0x04000100, 0x00000000, 0x00010104, 0x04000100,
+        0x00010004, 0x04000004, 0x04000004, 0x00010000,
+        0x04010104, 0x00010004, 0x04010000, 0x00000104,
+        0x04000000, 0x00000004, 0x04010100, 0x00000100,
+        0x00010100, 0x04010000, 0x04010004, 0x00010104,
+        0x04000104, 0x00010100, 0x00010000, 0x04000104,
+        0x00000004, 0x04010104, 0x00000100, 0x04000000,
+        0x04010100, 0x04000000, 0x00010004, 0x00000104,
+        0x00010000, 0x04010100, 0x04000100, 0x00000000,
+        0x00000100, 0x00010004, 0x04010104, 0x04000100,
+        0x04000004, 0x00000100, 0x00000000, 0x04010004,
+        0x04000104, 0x00010000, 0x04000000, 0x04010104,
+        0x00000004, 0x00010104, 0x00010100, 0x04000004,
+        0x04010000, 0x04000104, 0x00000104, 0x04010000,
+        0x00010104, 0x00000004, 0x04010004, 0x00010100
+    );
 
     /**
-     * Encrypts a message.
-     *
-     * $plaintext will be padded with up to 8 additional bytes.  Other DES implementations may or may not pad in the
-     * same manner.  Other common approaches to padding and the reasons why it's necessary are discussed in the following
-     * URL:
+     * Pre-permuted S-box4
      *
-     * {@link http://www.di-mgt.com.au/cryptopad.html http://www.di-mgt.com.au/cryptopad.html}
-     *
-     * An alternative to padding is to, separately, send the length of the file.  This is what SSH, in fact, does.
-     * strlen($plaintext) will still need to be a multiple of 8, however, arbitrary values can be added to make it that
-     * length.
-     *
-     * @see Crypt_DES::decrypt()
-     * @access public
-     * @param String $plaintext
+     * @var array
+     * @access private
      */
-    function encrypt($plaintext)
-    {
-        if ($this->mode != CRYPT_DES_MODE_CTR && $this->mode != 'ctr') {
-            $plaintext = $this->_pad($plaintext);
-        }
-
-        if ( CRYPT_DES_MODE == CRYPT_DES_MODE_MCRYPT ) {
-            if ($this->changed) {
-                if (!isset($this->enmcrypt)) {
-                    $this->enmcrypt = mcrypt_module_open(MCRYPT_DES, '', $this->mode, '');
-                }
-                mcrypt_generic_init($this->enmcrypt, $this->keys, $this->encryptIV);
-                $this->changed = false;
-            }
-
-            $ciphertext = mcrypt_generic($this->enmcrypt, $plaintext);
-
-            if (!$this->continuousBuffer) {
-                mcrypt_generic_init($this->enmcrypt, $this->keys, $this->encryptIV);
-            }
-
-            return $ciphertext;
-        }
-
-        if (!is_array($this->keys)) {
-            $this->keys = $this->_prepareKey("\0\0\0\0\0\0\0\0");
-        }
-
-        $ciphertext = '';
-        switch ($this->mode) {
-            case CRYPT_DES_MODE_ECB:
-                for ($i = 0; $i < strlen($plaintext); $i+=8) {
-                    $ciphertext.= $this->_processBlock(substr($plaintext, $i, 8), CRYPT_DES_ENCRYPT);
-                }
-                break;
-            case CRYPT_DES_MODE_CBC:
-                $xor = $this->encryptIV;
-                for ($i = 0; $i < strlen($plaintext); $i+=8) {
-                    $block = substr($plaintext, $i, 8);
-                    $block = $this->_processBlock($block ^ $xor, CRYPT_DES_ENCRYPT);
-                    $xor = $block;
-                    $ciphertext.= $block;
-                }
-                if ($this->continuousBuffer) {
-                    $this->encryptIV = $xor;
-                }
-                break;
-            case CRYPT_DES_MODE_CTR:
-                $xor = $this->encryptIV;
-                for ($i = 0; $i < strlen($plaintext); $i+=8) {
-                    $block = substr($plaintext, $i, 8);
-                    $key = $this->_processBlock($this->_generate_xor(8, $xor), CRYPT_DES_ENCRYPT);
-                    $ciphertext.= $block ^ $key;
-                }
-                if ($this->continuousBuffer) {
-                    $this->encryptIV = $xor;
-                }
-        }
-
-        return $ciphertext;
-    }
+    var $sbox4 = array(
+        0x80401000, 0x80001040, 0x80001040, 0x00000040,
+        0x00401040, 0x80400040, 0x80400000, 0x80001000,
+        0x00000000, 0x00401000, 0x00401000, 0x80401040,
+        0x80000040, 0x00000000, 0x00400040, 0x80400000,
+        0x80000000, 0x00001000, 0x00400000, 0x80401000,
+        0x00000040, 0x00400000, 0x80001000, 0x00001040,
+        0x80400040, 0x80000000, 0x00001040, 0x00400040,
+        0x00001000, 0x00401040, 0x80401040, 0x80000040,
+        0x00400040, 0x80400000, 0x00401000, 0x80401040,
+        0x80000040, 0x00000000, 0x00000000, 0x00401000,
+        0x00001040, 0x00400040, 0x80400040, 0x80000000,
+        0x80401000, 0x80001040, 0x80001040, 0x00000040,
+        0x80401040, 0x80000040, 0x80000000, 0x00001000,
+        0x80400000, 0x80001000, 0x00401040, 0x80400040,
+        0x80001000, 0x00001040, 0x00400000, 0x80401000,
+        0x00000040, 0x00400000, 0x00001000, 0x00401040
+    );
 
     /**
-     * Decrypts a message.
+     * Pre-permuted S-box5
      *
-     * If strlen($ciphertext) is not a multiple of 8, null bytes will be added to the end of the string until it is.
-     *
-     * @see Crypt_DES::encrypt()
-     * @access public
-     * @param String $ciphertext
+     * @var array
+     * @access private
      */
-    function decrypt($ciphertext)
-    {
-        if ($this->mode != CRYPT_DES_MODE_CTR && $this->mode != 'ctr') {
-            // we pad with chr(0) since that's what mcrypt_generic does.  to quote from http://php.net/function.mcrypt-generic :
-            // "The data is padded with "\0" to make sure the length of the data is n * blocksize."
-            $ciphertext = str_pad($ciphertext, (strlen($ciphertext) + 7) & 0xFFFFFFF8, chr(0));
-        }
-
-        if ( CRYPT_DES_MODE == CRYPT_DES_MODE_MCRYPT ) {
-            if ($this->changed) {
-                if (!isset($this->demcrypt)) {
-                    $this->demcrypt = mcrypt_module_open(MCRYPT_DES, '', $this->mode, '');
-                }
-                mcrypt_generic_init($this->demcrypt, $this->keys, $this->decryptIV);
-                $this->changed = false;
-            }
-
-            $plaintext = mdecrypt_generic($this->demcrypt, $ciphertext);
-
-            if (!$this->continuousBuffer) {
-                mcrypt_generic_init($this->demcrypt, $this->keys, $this->decryptIV);
-            }
-
-            return $this->mode != 'ctr' ? $this->_unpad($plaintext) : $plaintext;
-        }
-
-        if (!is_array($this->keys)) {
-            $this->keys = $this->_prepareKey("\0\0\0\0\0\0\0\0");
-        }
+    var $sbox5 = array(
+        0x00000080, 0x01040080, 0x01040000, 0x21000080,
+        0x00040000, 0x00000080, 0x20000000, 0x01040000,
+        0x20040080, 0x00040000, 0x01000080, 0x20040080,
+        0x21000080, 0x21040000, 0x00040080, 0x20000000,
+        0x01000000, 0x20040000, 0x20040000, 0x00000000,
+        0x20000080, 0x21040080, 0x21040080, 0x01000080,
+        0x21040000, 0x20000080, 0x00000000, 0x21000000,
+        0x01040080, 0x01000000, 0x21000000, 0x00040080,
+        0x00040000, 0x21000080, 0x00000080, 0x01000000,
+        0x20000000, 0x01040000, 0x21000080, 0x20040080,
+        0x01000080, 0x20000000, 0x21040000, 0x01040080,
+        0x20040080, 0x00000080, 0x01000000, 0x21040000,
+        0x21040080, 0x00040080, 0x21000000, 0x21040080,
+        0x01040000, 0x00000000, 0x20040000, 0x21000000,
+        0x00040080, 0x01000080, 0x20000080, 0x00040000,
+        0x00000000, 0x20040000, 0x01040080, 0x20000080
+    );
 
-        $plaintext = '';
-        switch ($this->mode) {
-            case CRYPT_DES_MODE_ECB:
-                for ($i = 0; $i < strlen($ciphertext); $i+=8) {
-                    $plaintext.= $this->_processBlock(substr($ciphertext, $i, 8), CRYPT_DES_DECRYPT);
-                }
-                break;
-            case CRYPT_DES_MODE_CBC:
-                $xor = $this->decryptIV;
-                for ($i = 0; $i < strlen($ciphertext); $i+=8) {
-                    $block = substr($ciphertext, $i, 8);
-                    $plaintext.= $this->_processBlock($block, CRYPT_DES_DECRYPT) ^ $xor;
-                    $xor = $block;
-                }
-                if ($this->continuousBuffer) {
-                    $this->decryptIV = $xor;
-                }
-                break;
-            case CRYPT_DES_MODE_CTR:
-                $xor = $this->decryptIV;
-                for ($i = 0; $i < strlen($ciphertext); $i+=8) {
-                    $block = substr($ciphertext, $i, 8);
-                    $key = $this->_processBlock($this->_generate_xor(8, $xor), CRYPT_DES_ENCRYPT);
-                    $plaintext.= $block ^ $key;
-                }
-                if ($this->continuousBuffer) {
-                    $this->decryptIV = $xor;
-                }
-        }
+    /**
+     * Pre-permuted S-box6
+     *
+     * @var array
+     * @access private
+     */
+    var $sbox6 = array(
+        0x10000008, 0x10200000, 0x00002000, 0x10202008,
+        0x10200000, 0x00000008, 0x10202008, 0x00200000,
+        0x10002000, 0x00202008, 0x00200000, 0x10000008,
+        0x00200008, 0x10002000, 0x10000000, 0x00002008,
+        0x00000000, 0x00200008, 0x10002008, 0x00002000,
+        0x00202000, 0x10002008, 0x00000008, 0x10200008,
+        0x10200008, 0x00000000, 0x00202008, 0x10202000,
+        0x00002008, 0x00202000, 0x10202000, 0x10000000,
+        0x10002000, 0x00000008, 0x10200008, 0x00202000,
+        0x10202008, 0x00200000, 0x00002008, 0x10000008,
+        0x00200000, 0x10002000, 0x10000000, 0x00002008,
+        0x10000008, 0x10202008, 0x00202000, 0x10200000,
+        0x00202008, 0x10202000, 0x00000000, 0x10200008,
+        0x00000008, 0x00002000, 0x10200000, 0x00202008,
+        0x00002000, 0x00200008, 0x10002008, 0x00000000,
+        0x10202000, 0x10000000, 0x00200008, 0x10002008
+    );
 
-        return $this->mode != CRYPT_DES_MODE_CTR ? $this->_unpad($plaintext) : $plaintext;
-    }
+    /**
+     * Pre-permuted S-box7
+     *
+     * @var array
+     * @access private
+     */
+    var $sbox7 = array(
+        0x00100000, 0x02100001, 0x02000401, 0x00000000,
+        0x00000400, 0x02000401, 0x00100401, 0x02100400,
+        0x02100401, 0x00100000, 0x00000000, 0x02000001,
+        0x00000001, 0x02000000, 0x02100001, 0x00000401,
+        0x02000400, 0x00100401, 0x00100001, 0x02000400,
+        0x02000001, 0x02100000, 0x02100400, 0x00100001,
+        0x02100000, 0x00000400, 0x00000401, 0x02100401,
+        0x00100400, 0x00000001, 0x02000000, 0x00100400,
+        0x02000000, 0x00100400, 0x00100000, 0x02000401,
+        0x02000401, 0x02100001, 0x02100001, 0x00000001,
+        0x00100001, 0x02000000, 0x02000400, 0x00100000,
+        0x02100400, 0x00000401, 0x00100401, 0x02100400,
+        0x00000401, 0x02000001, 0x02100401, 0x02100000,
+        0x00100400, 0x00000000, 0x00000001, 0x02100401,
+        0x00000000, 0x00100401, 0x02100000, 0x00000400,
+        0x02000001, 0x02000400, 0x00000400, 0x00100001
+    );
 
     /**
-     * Treat consecutive "packets" as if they are a continuous buffer.
-     *
-     * Say you have a 16-byte plaintext $plaintext.  Using the default behavior, the two following code snippets
-     * will yield different outputs:
-     *
-     * <code>
-     *    echo $des->encrypt(substr($plaintext, 0, 8));
-     *    echo $des->encrypt(substr($plaintext, 8, 8));
-     * </code>
-     * <code>
-     *    echo $des->encrypt($plaintext);
-     * </code>
-     *
-     * The solution is to enable the continuous buffer.  Although this will resolve the above discrepancy, it creates
-     * another, as demonstrated with the following:
-     *
-     * <code>
-     *    $des->encrypt(substr($plaintext, 0, 8));
-     *    echo $des->decrypt($des->encrypt(substr($plaintext, 8, 8)));
-     * </code>
-     * <code>
-     *    echo $des->decrypt($des->encrypt(substr($plaintext, 8, 8)));
-     * </code>
-     *
-     * With the continuous buffer disabled, these would yield the same output.  With it enabled, they yield different
-     * outputs.  The reason is due to the fact that the initialization vector's change after every encryption /
-     * decryption round when the continuous buffer is enabled.  When it's disabled, they remain constant.
-     *
-     * Put another way, when the continuous buffer is enabled, the state of the Crypt_DES() object changes after each
-     * encryption / decryption round, whereas otherwise, it'd remain constant.  For this reason, it's recommended that
-     * continuous buffers not be used.  They do offer better security and are, in fact, sometimes required (SSH uses them),
-     * however, they are also less intuitive and more likely to cause you problems.
-     *
-     * @see Crypt_DES::disableContinuousBuffer()
-     * @access public
+     * Pre-permuted S-box8
+     *
+     * @var array
+     * @access private
      */
-    function enableContinuousBuffer()
-    {
-        $this->continuousBuffer = true;
-    }
+    var $sbox8 = array(
+        0x08000820, 0x00000800, 0x00020000, 0x08020820,
+        0x08000000, 0x08000820, 0x00000020, 0x08000000,
+        0x00020020, 0x08020000, 0x08020820, 0x00020800,
+        0x08020800, 0x00020820, 0x00000800, 0x00000020,
+        0x08020000, 0x08000020, 0x08000800, 0x00000820,
+        0x00020800, 0x00020020, 0x08020020, 0x08020800,
+        0x00000820, 0x00000000, 0x00000000, 0x08020020,
+        0x08000020, 0x08000800, 0x00020820, 0x00020000,
+        0x00020820, 0x00020000, 0x08020800, 0x00000800,
+        0x00000020, 0x08020020, 0x00000800, 0x00020820,
+        0x08000800, 0x00000020, 0x08000020, 0x08020000,
+        0x08020020, 0x08000000, 0x00020000, 0x08000820,
+        0x00000000, 0x08020820, 0x00020020, 0x08000020,
+        0x08020000, 0x08000800, 0x08000820, 0x00000000,
+        0x08020820, 0x00020800, 0x00020800, 0x00000820,
+        0x00000820, 0x00020020, 0x08000000, 0x08020800
+    );
 
     /**
-     * Treat consecutive packets as if they are a discontinuous buffer.
+     * Test for engine validity
      *
-     * The default behavior.
+     * This is mainly just a wrapper to set things up for \phpseclib\Crypt\Base::isValidEngine()
      *
-     * @see Crypt_DES::enableContinuousBuffer()
+     * @see \phpseclib\Crypt\Base::isValidEngine()
+     * @param int $engine
      * @access public
+     * @return bool
      */
-    function disableContinuousBuffer()
+    function isValidEngine($engine)
     {
-        $this->continuousBuffer = false;
-        $this->encryptIV = $this->iv;
-        $this->decryptIV = $this->iv;
+        if ($this->key_length_max == 8) {
+            if ($engine == self::ENGINE_OPENSSL) {
+                $this->cipher_name_openssl_ecb = 'des-ecb';
+                $this->cipher_name_openssl = 'des-' . $this->_openssl_translate_mode();
+            }
+        }
+
+        return parent::isValidEngine($engine);
     }
 
     /**
-     * Pad "packets".
+     * Sets the key.
      *
-     * DES works by encrypting eight bytes at a time.  If you ever need to encrypt or decrypt something that's not
-     * a multiple of eight, it becomes necessary to pad the input so that it's length is a multiple of eight.
+     * Keys can be of any length.  DES, itself, uses 64-bit keys (eg. strlen($key) == 8), however, we
+     * only use the first eight, if $key has more then eight characters in it, and pad $key with the
+     * null byte if it is less then eight characters long.
      *
-     * Padding is enabled by default.  Sometimes, however, it is undesirable to pad strings.  Such is the case in SSH1,
-     * where "packets" are padded with random bytes before being encrypted.  Unpad these packets and you risk stripping
-     * away characters that shouldn't be stripped away. (SSH knows how many bytes are added because the length is
-     * transmitted separately)
+     * DES also requires that every eighth bit be a parity bit, however, we'll ignore that.
      *
-     * @see Crypt_DES::disablePadding()
+     * If the key is not explicitly set, it'll be assumed to be all zero's.
+     *
+     * @see \phpseclib\Crypt\Base::setKey()
      * @access public
+     * @param string $key
      */
-    function enablePadding()
+    function setKey($key)
     {
-        $this->padding = true;
+        // We check/cut here only up to max length of the key.
+        // Key padding to the proper length will be done in _setupKey()
+        if (strlen($key) > $this->key_length_max) {
+            $key = substr($key, 0, $this->key_length_max);
+        }
+
+        // Sets the key
+        parent::setKey($key);
     }
 
     /**
-     * Do not pad packets.
+     * Encrypts a block
      *
-     * @see Crypt_DES::enablePadding()
-     * @access public
+     * @see \phpseclib\Crypt\Base::_encryptBlock()
+     * @see \phpseclib\Crypt\Base::encrypt()
+     * @see self::encrypt()
+     * @access private
+     * @param string $in
+     * @return string
      */
-    function disablePadding()
+    function _encryptBlock($in)
     {
-        $this->padding = false;
+        return $this->_processBlock($in, self::ENCRYPT);
     }
 
     /**
-     * Pads a string
+     * Decrypts a block
      *
-     * Pads a string using the RSA PKCS padding standards so that its length is a multiple of the blocksize (8).
-     * 8 - (strlen($text) & 7) bytes are added, each of which is equal to chr(8 - (strlen($text) & 7)
-     *
-     * If padding is disabled and $text is not a multiple of the blocksize, the string will be padded regardless
-     * and padding will, hence forth, be enabled.
-     *
-     * @see Crypt_DES::_unpad()
+     * @see \phpseclib\Crypt\Base::_decryptBlock()
+     * @see \phpseclib\Crypt\Base::decrypt()
+     * @see self::decrypt()
      * @access private
+     * @param string $in
+     * @return string
      */
-    function _pad($text)
+    function _decryptBlock($in)
     {
-        $length = strlen($text);
-
-        if (!$this->padding) {
-            if (($length & 7) == 0) {
-                return $text;
-            } else {
-                user_error("The plaintext's length ($length) is not a multiple of the block size (8)", E_USER_NOTICE);
-                $this->padding = true;
-            }
-        }
-
-        $pad = 8 - ($length & 7);
-        return str_pad($text, $length + $pad, chr($pad));
+        return $this->_processBlock($in, self::DECRYPT);
     }
 
     /**
-     * Unpads a string
+     * Encrypts or decrypts a 64-bit block
      *
-     * If padding is enabled and the reported padding length is invalid the encryption key will be assumed to be wrong
-     * and false will be returned.
+     * $mode should be either self::ENCRYPT or self::DECRYPT.  See
+     * {@link http://en.wikipedia.org/wiki/Image:Feistel.png Feistel.png} to get a general
+     * idea of what this function does.
      *
-     * @see Crypt_DES::_pad()
+     * @see self::_encryptBlock()
+     * @see self::_decryptBlock()
      * @access private
+     * @param string $block
+     * @param int $mode
+     * @return string
      */
-    function _unpad($text)
+    function _processBlock($block, $mode)
     {
-        if (!$this->padding) {
-            return $text;
+        static $sbox1, $sbox2, $sbox3, $sbox4, $sbox5, $sbox6, $sbox7, $sbox8, $shuffleip, $shuffleinvip;
+        if (!$sbox1) {
+            $sbox1 = array_map("intval", $this->sbox1);
+            $sbox2 = array_map("intval", $this->sbox2);
+            $sbox3 = array_map("intval", $this->sbox3);
+            $sbox4 = array_map("intval", $this->sbox4);
+            $sbox5 = array_map("intval", $this->sbox5);
+            $sbox6 = array_map("intval", $this->sbox6);
+            $sbox7 = array_map("intval", $this->sbox7);
+            $sbox8 = array_map("intval", $this->sbox8);
+            /* Merge $shuffle with $[inv]ipmap */
+            for ($i = 0; $i < 256; ++$i) {
+                $shuffleip[]    =  $this->shuffle[$this->ipmap[$i]];
+                $shuffleinvip[] =  $this->shuffle[$this->invipmap[$i]];
+            }
         }
 
-        $length = ord($text[strlen($text) - 1]);
+        $keys  = $this->keys[$mode];
+        $ki    = -1;
+
+        // Do the initial IP permutation.
+        $t = unpack('Nl/Nr', $block);
+        list($l, $r) = array($t['l'], $t['r']);
+        $block = ($shuffleip[ $r        & 0xFF] & "\x80\x80\x80\x80\x80\x80\x80\x80") |
+                 ($shuffleip[($r >>  8) & 0xFF] & "\x40\x40\x40\x40\x40\x40\x40\x40") |
+                 ($shuffleip[($r >> 16) & 0xFF] & "\x20\x20\x20\x20\x20\x20\x20\x20") |
+                 ($shuffleip[($r >> 24) & 0xFF] & "\x10\x10\x10\x10\x10\x10\x10\x10") |
+                 ($shuffleip[ $l        & 0xFF] & "\x08\x08\x08\x08\x08\x08\x08\x08") |
+                 ($shuffleip[($l >>  8) & 0xFF] & "\x04\x04\x04\x04\x04\x04\x04\x04") |
+                 ($shuffleip[($l >> 16) & 0xFF] & "\x02\x02\x02\x02\x02\x02\x02\x02") |
+                 ($shuffleip[($l >> 24) & 0xFF] & "\x01\x01\x01\x01\x01\x01\x01\x01");
+
+        // Extract L0 and R0.
+        $t = unpack('Nl/Nr', $block);
+        list($l, $r) = array($t['l'], $t['r']);
+
+        for ($des_round = 0; $des_round < $this->des_rounds; ++$des_round) {
+            // Perform the 16 steps.
+            for ($i = 0; $i < 16; $i++) {
+                // start of "the Feistel (F) function" - see the following URL:
+                // http://en.wikipedia.org/wiki/Image:Data_Encryption_Standard_InfoBox_Diagram.png
+                // Merge key schedule.
+                $b1 = (($r >>  3) & 0x1FFFFFFF) ^ ($r << 29) ^ $keys[++$ki];
+                $b2 = (($r >> 31) & 0x00000001) ^ ($r <<  1) ^ $keys[++$ki];
+
+                // S-box indexing.
+                $t = $sbox1[($b1 >> 24) & 0x3F] ^ $sbox2[($b2 >> 24) & 0x3F] ^
+                     $sbox3[($b1 >> 16) & 0x3F] ^ $sbox4[($b2 >> 16) & 0x3F] ^
+                     $sbox5[($b1 >>  8) & 0x3F] ^ $sbox6[($b2 >>  8) & 0x3F] ^
+                     $sbox7[ $b1        & 0x3F] ^ $sbox8[ $b2        & 0x3F] ^ $l;
+                // end of "the Feistel (F) function"
+
+                $l = $r;
+                $r = $t;
+            }
 
-        if (!$length || $length > 8) {
-            return false;
+            // Last step should not permute L & R.
+            $t = $l;
+            $l = $r;
+            $r = $t;
         }
 
-        return substr($text, 0, -$length);
+        // Perform the inverse IP permutation.
+        return ($shuffleinvip[($r >> 24) & 0xFF] & "\x80\x80\x80\x80\x80\x80\x80\x80") |
+               ($shuffleinvip[($l >> 24) & 0xFF] & "\x40\x40\x40\x40\x40\x40\x40\x40") |
+               ($shuffleinvip[($r >> 16) & 0xFF] & "\x20\x20\x20\x20\x20\x20\x20\x20") |
+               ($shuffleinvip[($l >> 16) & 0xFF] & "\x10\x10\x10\x10\x10\x10\x10\x10") |
+               ($shuffleinvip[($r >>  8) & 0xFF] & "\x08\x08\x08\x08\x08\x08\x08\x08") |
+               ($shuffleinvip[($l >>  8) & 0xFF] & "\x04\x04\x04\x04\x04\x04\x04\x04") |
+               ($shuffleinvip[ $r        & 0xFF] & "\x02\x02\x02\x02\x02\x02\x02\x02") |
+               ($shuffleinvip[ $l        & 0xFF] & "\x01\x01\x01\x01\x01\x01\x01\x01");
     }
 
     /**
-     * Encrypts or decrypts a 64-bit block
-     *
-     * $mode should be either CRYPT_DES_ENCRYPT or CRYPT_DES_DECRYPT.  See
-     * {@link http://en.wikipedia.org/wiki/Image:Feistel.png Feistel.png} to get a general
-     * idea of what this function does.
+     * Creates the key schedule
      *
+     * @see \phpseclib\Crypt\Base::_setupKey()
      * @access private
-     * @param String $block
-     * @param Integer $mode
-     * @return String
      */
-    function _processBlock($block, $mode)
+    function _setupKey()
     {
-        // s-boxes.  in the official DES docs, they're described as being matrices that
-        // one accesses by using the first and last bits to determine the row and the
-        // middle four bits to determine the column.  in this implementation, they've
-        // been converted to vectors
-        static $sbox = array(
-            array(
-                14,  0,  4, 15, 13,  7,  1,  4,  2, 14, 15,  2, 11, 13,  8,  1,
-                 3, 10 ,10,  6,  6, 12, 12, 11,  5,  9,  9,  5,  0,  3,  7,  8,
-                 4, 15,  1, 12, 14,  8,  8,  2, 13,  4,  6,  9,  2,  1, 11,  7,
-                15,  5, 12, 11,  9,  3,  7, 14,  3, 10, 10,  0,  5,  6,  0, 13
-            ),
-            array(
-                15,  3,  1, 13,  8,  4, 14,  7,  6, 15, 11,  2,  3,  8,  4, 14,
-                 9, 12,  7,  0,  2,  1, 13, 10, 12,  6,  0,  9,  5, 11, 10,  5,
-                 0, 13, 14,  8,  7, 10, 11,  1, 10,  3,  4, 15, 13,  4,  1,  2,
-                 5, 11,  8,  6, 12,  7,  6, 12,  9,  0,  3,  5,  2, 14, 15,  9
-            ),
-            array(
-                10, 13,  0,  7,  9,  0, 14,  9,  6,  3,  3,  4, 15,  6,  5, 10,
-                 1,  2, 13,  8, 12,  5,  7, 14, 11, 12,  4, 11,  2, 15,  8,  1,
-                13,  1,  6, 10,  4, 13,  9,  0,  8,  6, 15,  9,  3,  8,  0,  7,
-                11,  4,  1, 15,  2, 14, 12,  3,  5, 11, 10,  5, 14,  2,  7, 12
-            ),
-            array(
-                 7, 13, 13,  8, 14, 11,  3,  5,  0,  6,  6, 15,  9,  0, 10,  3,
-                 1,  4,  2,  7,  8,  2,  5, 12, 11,  1, 12, 10,  4, 14, 15,  9,
-                10,  3,  6, 15,  9,  0,  0,  6, 12, 10, 11,  1,  7, 13, 13,  8,
-                15,  9,  1,  4,  3,  5, 14, 11,  5, 12,  2,  7,  8,  2,  4, 14
-            ),
-            array(
-                 2, 14, 12, 11,  4,  2,  1, 12,  7,  4, 10,  7, 11, 13,  6,  1,
-                 8,  5,  5,  0,  3, 15, 15, 10, 13,  3,  0,  9, 14,  8,  9,  6,
-                 4, 11,  2,  8,  1, 12, 11,  7, 10,  1, 13, 14,  7,  2,  8, 13,
-                15,  6,  9, 15, 12,  0,  5,  9,  6, 10,  3,  4,  0,  5, 14,  3
-            ),
-            array(
-                12, 10,  1, 15, 10,  4, 15,  2,  9,  7,  2, 12,  6,  9,  8,  5,
-                 0,  6, 13,  1,  3, 13,  4, 14, 14,  0,  7, 11,  5,  3, 11,  8,
-                 9,  4, 14,  3, 15,  2,  5, 12,  2,  9,  8,  5, 12, 15,  3, 10,
-                 7, 11,  0, 14,  4,  1, 10,  7,  1,  6, 13,  0, 11,  8,  6, 13
-            ),
-            array(
-                 4, 13, 11,  0,  2, 11, 14,  7, 15,  4,  0,  9,  8,  1, 13, 10,
-                 3, 14, 12,  3,  9,  5,  7, 12,  5,  2, 10, 15,  6,  8,  1,  6,
-                 1,  6,  4, 11, 11, 13, 13,  8, 12,  1,  3,  4,  7, 10, 14,  7,
-                10,  9, 15,  5,  6,  0,  8, 15,  0, 14,  5,  2,  9,  3,  2, 12
-            ),
-            array(
-                13,  1,  2, 15,  8, 13,  4,  8,  6, 10, 15,  3, 11,  7,  1,  4,
-                10, 12,  9,  5,  3,  6, 14, 11,  5,  0,  0, 14, 12,  9,  7,  2,
-                 7,  2, 11,  1,  4, 14,  1,  7,  9,  4, 12, 10, 14,  8,  2, 13,
-                 0, 15,  6, 12, 10,  9, 13,  0, 15,  3,  3,  5,  5,  6,  8, 11
-            )
-        );
+        if (isset($this->kl['key']) && $this->key === $this->kl['key'] && $this->des_rounds === $this->kl['des_rounds']) {
+            // already expanded
+            return;
+        }
+        $this->kl = array('key' => $this->key, 'des_rounds' => $this->des_rounds);
 
-        $keys = $this->keys;
+        static $shifts = array( // number of key bits shifted per round
+            1, 1, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 1
+        );
 
-        $temp = unpack('Na/Nb', $block);
-        $block = array($temp['a'], $temp['b']);
+        static $pc1map = array(
+            0x00, 0x00, 0x08, 0x08, 0x04, 0x04, 0x0C, 0x0C,
+            0x02, 0x02, 0x0A, 0x0A, 0x06, 0x06, 0x0E, 0x0E,
+            0x10, 0x10, 0x18, 0x18, 0x14, 0x14, 0x1C, 0x1C,
+            0x12, 0x12, 0x1A, 0x1A, 0x16, 0x16, 0x1E, 0x1E,
+            0x20, 0x20, 0x28, 0x28, 0x24, 0x24, 0x2C, 0x2C,
+            0x22, 0x22, 0x2A, 0x2A, 0x26, 0x26, 0x2E, 0x2E,
+            0x30, 0x30, 0x38, 0x38, 0x34, 0x34, 0x3C, 0x3C,
+            0x32, 0x32, 0x3A, 0x3A, 0x36, 0x36, 0x3E, 0x3E,
+            0x40, 0x40, 0x48, 0x48, 0x44, 0x44, 0x4C, 0x4C,
+            0x42, 0x42, 0x4A, 0x4A, 0x46, 0x46, 0x4E, 0x4E,
+            0x50, 0x50, 0x58, 0x58, 0x54, 0x54, 0x5C, 0x5C,
+            0x52, 0x52, 0x5A, 0x5A, 0x56, 0x56, 0x5E, 0x5E,
+            0x60, 0x60, 0x68, 0x68, 0x64, 0x64, 0x6C, 0x6C,
+            0x62, 0x62, 0x6A, 0x6A, 0x66, 0x66, 0x6E, 0x6E,
+            0x70, 0x70, 0x78, 0x78, 0x74, 0x74, 0x7C, 0x7C,
+            0x72, 0x72, 0x7A, 0x7A, 0x76, 0x76, 0x7E, 0x7E,
+            0x80, 0x80, 0x88, 0x88, 0x84, 0x84, 0x8C, 0x8C,
+            0x82, 0x82, 0x8A, 0x8A, 0x86, 0x86, 0x8E, 0x8E,
+            0x90, 0x90, 0x98, 0x98, 0x94, 0x94, 0x9C, 0x9C,
+            0x92, 0x92, 0x9A, 0x9A, 0x96, 0x96, 0x9E, 0x9E,
+            0xA0, 0xA0, 0xA8, 0xA8, 0xA4, 0xA4, 0xAC, 0xAC,
+            0xA2, 0xA2, 0xAA, 0xAA, 0xA6, 0xA6, 0xAE, 0xAE,
+            0xB0, 0xB0, 0xB8, 0xB8, 0xB4, 0xB4, 0xBC, 0xBC,
+            0xB2, 0xB2, 0xBA, 0xBA, 0xB6, 0xB6, 0xBE, 0xBE,
+            0xC0, 0xC0, 0xC8, 0xC8, 0xC4, 0xC4, 0xCC, 0xCC,
+            0xC2, 0xC2, 0xCA, 0xCA, 0xC6, 0xC6, 0xCE, 0xCE,
+            0xD0, 0xD0, 0xD8, 0xD8, 0xD4, 0xD4, 0xDC, 0xDC,
+            0xD2, 0xD2, 0xDA, 0xDA, 0xD6, 0xD6, 0xDE, 0xDE,
+            0xE0, 0xE0, 0xE8, 0xE8, 0xE4, 0xE4, 0xEC, 0xEC,
+            0xE2, 0xE2, 0xEA, 0xEA, 0xE6, 0xE6, 0xEE, 0xEE,
+            0xF0, 0xF0, 0xF8, 0xF8, 0xF4, 0xF4, 0xFC, 0xFC,
+            0xF2, 0xF2, 0xFA, 0xFA, 0xF6, 0xF6, 0xFE, 0xFE
+        );
 
-        // because php does arithmetic right shifts, if the most significant bits are set, right
-        // shifting those into the correct position will add 1's - not 0's.  this will intefere
-        // with the | operation unless a second & is done.  so we isolate these bits and left shift
-        // them into place.  we then & each block with 0x7FFFFFFF to prevennt 1's from being added
-        // for any other shifts.
-        $msb = array(
-            ($block[0] >> 31) & 1,
-            ($block[1] >> 31) & 1
+        // Mapping tables for the PC-2 transformation.
+        static $pc2mapc1 = array(
+            0x00000000, 0x00000400, 0x00200000, 0x00200400,
+            0x00000001, 0x00000401, 0x00200001, 0x00200401,
+            0x02000000, 0x02000400, 0x02200000, 0x02200400,
+            0x02000001, 0x02000401, 0x02200001, 0x02200401
         );
-        $block[0] &= 0x7FFFFFFF;
-        $block[1] &= 0x7FFFFFFF;
-
-        // we isolate the appropriate bit in the appropriate integer and shift as appropriate.  in
-        // some cases, there are going to be multiple bits in the same integer that need to be shifted
-        // in the same way.  we combine those into one shift operation.
-        $block = array(
-            (($block[1] & 0x00000040) << 25) | (($block[1] & 0x00004000) << 16) |
-            (($block[1] & 0x00400001) <<  7) | (($block[1] & 0x40000100) >>  2) |
-            (($block[0] & 0x00000040) << 21) | (($block[0] & 0x00004000) << 12) |
-            (($block[0] & 0x00400001) <<  3) | (($block[0] & 0x40000100) >>  6) |
-            (($block[1] & 0x00000010) << 19) | (($block[1] & 0x00001000) << 10) |
-            (($block[1] & 0x00100000) <<  1) | (($block[1] & 0x10000000) >>  8) |
-            (($block[0] & 0x00000010) << 15) | (($block[0] & 0x00001000) <<  6) |
-            (($block[0] & 0x00100000) >>  3) | (($block[0] & 0x10000000) >> 12) |
-            (($block[1] & 0x00000004) << 13) | (($block[1] & 0x00000400) <<  4) |
-            (($block[1] & 0x00040000) >>  5) | (($block[1] & 0x04000000) >> 14) |
-            (($block[0] & 0x00000004) <<  9) | ( $block[0] & 0x00000400       ) |
-            (($block[0] & 0x00040000) >>  9) | (($block[0] & 0x04000000) >> 18) |
-            (($block[1] & 0x00010000) >> 11) | (($block[1] & 0x01000000) >> 20) |
-            (($block[0] & 0x00010000) >> 15) | (($block[0] & 0x01000000) >> 24)
-        ,
-            (($block[1] & 0x00000080) << 24) | (($block[1] & 0x00008000) << 15) |
-            (($block[1] & 0x00800002) <<  6) | (($block[0] & 0x00000080) << 20) |
-            (($block[0] & 0x00008000) << 11) | (($block[0] & 0x00800002) <<  2) |
-            (($block[1] & 0x00000020) << 18) | (($block[1] & 0x00002000) <<  9) |
-            ( $block[1] & 0x00200000       ) | (($block[1] & 0x20000000) >>  9) |
-            (($block[0] & 0x00000020) << 14) | (($block[0] & 0x00002000) <<  5) |
-            (($block[0] & 0x00200000) >>  4) | (($block[0] & 0x20000000) >> 13) |
-            (($block[1] & 0x00000008) << 12) | (($block[1] & 0x00000800) <<  3) |
-            (($block[1] & 0x00080000) >>  6) | (($block[1] & 0x08000000) >> 15) |
-            (($block[0] & 0x00000008) <<  8) | (($block[0] & 0x00000800) >>  1) |
-            (($block[0] & 0x00080000) >> 10) | (($block[0] & 0x08000000) >> 19) |
-            (($block[1] & 0x00000200) >>  3) | (($block[0] & 0x00000200) >>  7) |
-            (($block[1] & 0x00020000) >> 12) | (($block[1] & 0x02000000) >> 21) |
-            (($block[0] & 0x00020000) >> 16) | (($block[0] & 0x02000000) >> 25) |
-            ($msb[1] << 28) | ($msb[0] << 24)
+        static $pc2mapc2 = array(
+            0x00000000, 0x00000800, 0x08000000, 0x08000800,
+            0x00010000, 0x00010800, 0x08010000, 0x08010800,
+            0x00000000, 0x00000800, 0x08000000, 0x08000800,
+            0x00010000, 0x00010800, 0x08010000, 0x08010800,
+            0x00000100, 0x00000900, 0x08000100, 0x08000900,
+            0x00010100, 0x00010900, 0x08010100, 0x08010900,
+            0x00000100, 0x00000900, 0x08000100, 0x08000900,
+            0x00010100, 0x00010900, 0x08010100, 0x08010900,
+            0x00000010, 0x00000810, 0x08000010, 0x08000810,
+            0x00010010, 0x00010810, 0x08010010, 0x08010810,
+            0x00000010, 0x00000810, 0x08000010, 0x08000810,
+            0x00010010, 0x00010810, 0x08010010, 0x08010810,
+            0x00000110, 0x00000910, 0x08000110, 0x08000910,
+            0x00010110, 0x00010910, 0x08010110, 0x08010910,
+            0x00000110, 0x00000910, 0x08000110, 0x08000910,
+            0x00010110, 0x00010910, 0x08010110, 0x08010910,
+            0x00040000, 0x00040800, 0x08040000, 0x08040800,
+            0x00050000, 0x00050800, 0x08050000, 0x08050800,
+            0x00040000, 0x00040800, 0x08040000, 0x08040800,
+            0x00050000, 0x00050800, 0x08050000, 0x08050800,
+            0x00040100, 0x00040900, 0x08040100, 0x08040900,
+            0x00050100, 0x00050900, 0x08050100, 0x08050900,
+            0x00040100, 0x00040900, 0x08040100, 0x08040900,
+            0x00050100, 0x00050900, 0x08050100, 0x08050900,
+            0x00040010, 0x00040810, 0x08040010, 0x08040810,
+            0x00050010, 0x00050810, 0x08050010, 0x08050810,
+            0x00040010, 0x00040810, 0x08040010, 0x08040810,
+            0x00050010, 0x00050810, 0x08050010, 0x08050810,
+            0x00040110, 0x00040910, 0x08040110, 0x08040910,
+            0x00050110, 0x00050910, 0x08050110, 0x08050910,
+            0x00040110, 0x00040910, 0x08040110, 0x08040910,
+            0x00050110, 0x00050910, 0x08050110, 0x08050910,
+            0x01000000, 0x01000800, 0x09000000, 0x09000800,
+            0x01010000, 0x01010800, 0x09010000, 0x09010800,
+            0x01000000, 0x01000800, 0x09000000, 0x09000800,
+            0x01010000, 0x01010800, 0x09010000, 0x09010800,
+            0x01000100, 0x01000900, 0x09000100, 0x09000900,
+            0x01010100, 0x01010900, 0x09010100, 0x09010900,
+            0x01000100, 0x01000900, 0x09000100, 0x09000900,
+            0x01010100, 0x01010900, 0x09010100, 0x09010900,
+            0x01000010, 0x01000810, 0x09000010, 0x09000810,
+            0x01010010, 0x01010810, 0x09010010, 0x09010810,
+            0x01000010, 0x01000810, 0x09000010, 0x09000810,
+            0x01010010, 0x01010810, 0x09010010, 0x09010810,
+            0x01000110, 0x01000910, 0x09000110, 0x09000910,
+            0x01010110, 0x01010910, 0x09010110, 0x09010910,
+            0x01000110, 0x01000910, 0x09000110, 0x09000910,
+            0x01010110, 0x01010910, 0x09010110, 0x09010910,
+            0x01040000, 0x01040800, 0x09040000, 0x09040800,
+            0x01050000, 0x01050800, 0x09050000, 0x09050800,
+            0x01040000, 0x01040800, 0x09040000, 0x09040800,
+            0x01050000, 0x01050800, 0x09050000, 0x09050800,
+            0x01040100, 0x01040900, 0x09040100, 0x09040900,
+            0x01050100, 0x01050900, 0x09050100, 0x09050900,
+            0x01040100, 0x01040900, 0x09040100, 0x09040900,
+            0x01050100, 0x01050900, 0x09050100, 0x09050900,
+            0x01040010, 0x01040810, 0x09040010, 0x09040810,
+            0x01050010, 0x01050810, 0x09050010, 0x09050810,
+            0x01040010, 0x01040810, 0x09040010, 0x09040810,
+            0x01050010, 0x01050810, 0x09050010, 0x09050810,
+            0x01040110, 0x01040910, 0x09040110, 0x09040910,
+            0x01050110, 0x01050910, 0x09050110, 0x09050910,
+            0x01040110, 0x01040910, 0x09040110, 0x09040910,
+            0x01050110, 0x01050910, 0x09050110, 0x09050910
         );
-
-        for ($i = 0; $i < 16; $i++) {
-            // start of "the Feistel (F) function" - see the following URL:
-            // http://en.wikipedia.org/wiki/Image:Data_Encryption_Standard_InfoBox_Diagram.png
-            $temp = (($sbox[0][((($block[1] >> 27) & 0x1F) | (($block[1] & 1) << 5)) ^ $keys[$mode][$i][0]]) << 28)
-                  | (($sbox[1][(($block[1] & 0x1F800000) >> 23) ^ $keys[$mode][$i][1]]) << 24)
-                  | (($sbox[2][(($block[1] & 0x01F80000) >> 19) ^ $keys[$mode][$i][2]]) << 20)
-                  | (($sbox[3][(($block[1] & 0x001F8000) >> 15) ^ $keys[$mode][$i][3]]) << 16)
-                  | (($sbox[4][(($block[1] & 0x0001F800) >> 11) ^ $keys[$mode][$i][4]]) << 12)
-                  | (($sbox[5][(($block[1] & 0x00001F80) >>  7) ^ $keys[$mode][$i][5]]) <<  8)
-                  | (($sbox[6][(($block[1] & 0x000001F8) >>  3) ^ $keys[$mode][$i][6]]) <<  4)
-                  | ( $sbox[7][((($block[1] & 0x1F) << 1) | (($block[1] >> 31) & 1)) ^ $keys[$mode][$i][7]]);
-
-            $msb = ($temp >> 31) & 1;
-            $temp &= 0x7FFFFFFF;
-            $newBlock = (($temp & 0x00010000) << 15) | (($temp & 0x02020120) <<  5)
-                      | (($temp & 0x00001800) << 17) | (($temp & 0x01000000) >> 10)
-                      | (($temp & 0x00000008) << 24) | (($temp & 0x00100000) <<  6)
-                      | (($temp & 0x00000010) << 21) | (($temp & 0x00008000) <<  9)
-                      | (($temp & 0x00000200) << 12) | (($temp & 0x10000000) >> 27)
-                      | (($temp & 0x00000040) << 14) | (($temp & 0x08000000) >>  8)
-                      | (($temp & 0x00004000) <<  4) | (($temp & 0x00000002) << 16)
-                      | (($temp & 0x00442000) >>  6) | (($temp & 0x40800000) >> 15)
-                      | (($temp & 0x00000001) << 11) | (($temp & 0x20000000) >> 20)
-                      | (($temp & 0x00080000) >> 13) | (($temp & 0x00000004) <<  3)
-                      | (($temp & 0x04000000) >> 22) | (($temp & 0x00000480) >>  7)
-                      | (($temp & 0x00200000) >> 19) | ($msb << 23);
-            // end of "the Feistel (F) function" - $newBlock is F's output
-
-            $temp = $block[1];
-            $block[1] = $block[0] ^ $newBlock;
-            $block[0] = $temp;
-        }
-
-        $msb = array(
-            ($block[0] >> 31) & 1,
-            ($block[1] >> 31) & 1
+        static $pc2mapc3 = array(
+            0x00000000, 0x00000004, 0x00001000, 0x00001004,
+            0x00000000, 0x00000004, 0x00001000, 0x00001004,
+            0x10000000, 0x10000004, 0x10001000, 0x10001004,
+            0x10000000, 0x10000004, 0x10001000, 0x10001004,
+            0x00000020, 0x00000024, 0x00001020, 0x00001024,
+            0x00000020, 0x00000024, 0x00001020, 0x00001024,
+            0x10000020, 0x10000024, 0x10001020, 0x10001024,
+            0x10000020, 0x10000024, 0x10001020, 0x10001024,
+            0x00080000, 0x00080004, 0x00081000, 0x00081004,
+            0x00080000, 0x00080004, 0x00081000, 0x00081004,
+            0x10080000, 0x10080004, 0x10081000, 0x10081004,
+            0x10080000, 0x10080004, 0x10081000, 0x10081004,
+            0x00080020, 0x00080024, 0x00081020, 0x00081024,
+            0x00080020, 0x00080024, 0x00081020, 0x00081024,
+            0x10080020, 0x10080024, 0x10081020, 0x10081024,
+            0x10080020, 0x10080024, 0x10081020, 0x10081024,
+            0x20000000, 0x20000004, 0x20001000, 0x20001004,
+            0x20000000, 0x20000004, 0x20001000, 0x20001004,
+            0x30000000, 0x30000004, 0x30001000, 0x30001004,
+            0x30000000, 0x30000004, 0x30001000, 0x30001004,
+            0x20000020, 0x20000024, 0x20001020, 0x20001024,
+            0x20000020, 0x20000024, 0x20001020, 0x20001024,
+            0x30000020, 0x30000024, 0x30001020, 0x30001024,
+            0x30000020, 0x30000024, 0x30001020, 0x30001024,
+            0x20080000, 0x20080004, 0x20081000, 0x20081004,
+            0x20080000, 0x20080004, 0x20081000, 0x20081004,
+            0x30080000, 0x30080004, 0x30081000, 0x30081004,
+            0x30080000, 0x30080004, 0x30081000, 0x30081004,
+            0x20080020, 0x20080024, 0x20081020, 0x20081024,
+            0x20080020, 0x20080024, 0x20081020, 0x20081024,
+            0x30080020, 0x30080024, 0x30081020, 0x30081024,
+            0x30080020, 0x30080024, 0x30081020, 0x30081024,
+            0x00000002, 0x00000006, 0x00001002, 0x00001006,
+            0x00000002, 0x00000006, 0x00001002, 0x00001006,
+            0x10000002, 0x10000006, 0x10001002, 0x10001006,
+            0x10000002, 0x10000006, 0x10001002, 0x10001006,
+            0x00000022, 0x00000026, 0x00001022, 0x00001026,
+            0x00000022, 0x00000026, 0x00001022, 0x00001026,
+            0x10000022, 0x10000026, 0x10001022, 0x10001026,
+            0x10000022, 0x10000026, 0x10001022, 0x10001026,
+            0x00080002, 0x00080006, 0x00081002, 0x00081006,
+            0x00080002, 0x00080006, 0x00081002, 0x00081006,
+            0x10080002, 0x10080006, 0x10081002, 0x10081006,
+            0x10080002, 0x10080006, 0x10081002, 0x10081006,
+            0x00080022, 0x00080026, 0x00081022, 0x00081026,
+            0x00080022, 0x00080026, 0x00081022, 0x00081026,
+            0x10080022, 0x10080026, 0x10081022, 0x10081026,
+            0x10080022, 0x10080026, 0x10081022, 0x10081026,
+            0x20000002, 0x20000006, 0x20001002, 0x20001006,
+            0x20000002, 0x20000006, 0x20001002, 0x20001006,
+            0x30000002, 0x30000006, 0x30001002, 0x30001006,
+            0x30000002, 0x30000006, 0x30001002, 0x30001006,
+            0x20000022, 0x20000026, 0x20001022, 0x20001026,
+            0x20000022, 0x20000026, 0x20001022, 0x20001026,
+            0x30000022, 0x30000026, 0x30001022, 0x30001026,
+            0x30000022, 0x30000026, 0x30001022, 0x30001026,
+            0x20080002, 0x20080006, 0x20081002, 0x20081006,
+            0x20080002, 0x20080006, 0x20081002, 0x20081006,
+            0x30080002, 0x30080006, 0x30081002, 0x30081006,
+            0x30080002, 0x30080006, 0x30081002, 0x30081006,
+            0x20080022, 0x20080026, 0x20081022, 0x20081026,
+            0x20080022, 0x20080026, 0x20081022, 0x20081026,
+            0x30080022, 0x30080026, 0x30081022, 0x30081026,
+            0x30080022, 0x30080026, 0x30081022, 0x30081026
+        );
+        static $pc2mapc4 = array(
+            0x00000000, 0x00100000, 0x00000008, 0x00100008,
+            0x00000200, 0x00100200, 0x00000208, 0x00100208,
+            0x00000000, 0x00100000, 0x00000008, 0x00100008,
+            0x00000200, 0x00100200, 0x00000208, 0x00100208,
+            0x04000000, 0x04100000, 0x04000008, 0x04100008,
+            0x04000200, 0x04100200, 0x04000208, 0x04100208,
+            0x04000000, 0x04100000, 0x04000008, 0x04100008,
+            0x04000200, 0x04100200, 0x04000208, 0x04100208,
+            0x00002000, 0x00102000, 0x00002008, 0x00102008,
+            0x00002200, 0x00102200, 0x00002208, 0x00102208,
+            0x00002000, 0x00102000, 0x00002008, 0x00102008,
+            0x00002200, 0x00102200, 0x00002208, 0x00102208,
+            0x04002000, 0x04102000, 0x04002008, 0x04102008,
+            0x04002200, 0x04102200, 0x04002208, 0x04102208,
+            0x04002000, 0x04102000, 0x04002008, 0x04102008,
+            0x04002200, 0x04102200, 0x04002208, 0x04102208,
+            0x00000000, 0x00100000, 0x00000008, 0x00100008,
+            0x00000200, 0x00100200, 0x00000208, 0x00100208,
+            0x00000000, 0x00100000, 0x00000008, 0x00100008,
+            0x00000200, 0x00100200, 0x00000208, 0x00100208,
+            0x04000000, 0x04100000, 0x04000008, 0x04100008,
+            0x04000200, 0x04100200, 0x04000208, 0x04100208,
+            0x04000000, 0x04100000, 0x04000008, 0x04100008,
+            0x04000200, 0x04100200, 0x04000208, 0x04100208,
+            0x00002000, 0x00102000, 0x00002008, 0x00102008,
+            0x00002200, 0x00102200, 0x00002208, 0x00102208,
+            0x00002000, 0x00102000, 0x00002008, 0x00102008,
+            0x00002200, 0x00102200, 0x00002208, 0x00102208,
+            0x04002000, 0x04102000, 0x04002008, 0x04102008,
+            0x04002200, 0x04102200, 0x04002208, 0x04102208,
+            0x04002000, 0x04102000, 0x04002008, 0x04102008,
+            0x04002200, 0x04102200, 0x04002208, 0x04102208,
+            0x00020000, 0x00120000, 0x00020008, 0x00120008,
+            0x00020200, 0x00120200, 0x00020208, 0x00120208,
+            0x00020000, 0x00120000, 0x00020008, 0x00120008,
+            0x00020200, 0x00120200, 0x00020208, 0x00120208,
+            0x04020000, 0x04120000, 0x04020008, 0x04120008,
+            0x04020200, 0x04120200, 0x04020208, 0x04120208,
+            0x04020000, 0x04120000, 0x04020008, 0x04120008,
+            0x04020200, 0x04120200, 0x04020208, 0x04120208,
+            0x00022000, 0x00122000, 0x00022008, 0x00122008,
+            0x00022200, 0x00122200, 0x00022208, 0x00122208,
+            0x00022000, 0x00122000, 0x00022008, 0x00122008,
+            0x00022200, 0x00122200, 0x00022208, 0x00122208,
+            0x04022000, 0x04122000, 0x04022008, 0x04122008,
+            0x04022200, 0x04122200, 0x04022208, 0x04122208,
+            0x04022000, 0x04122000, 0x04022008, 0x04122008,
+            0x04022200, 0x04122200, 0x04022208, 0x04122208,
+            0x00020000, 0x00120000, 0x00020008, 0x00120008,
+            0x00020200, 0x00120200, 0x00020208, 0x00120208,
+            0x00020000, 0x00120000, 0x00020008, 0x00120008,
+            0x00020200, 0x00120200, 0x00020208, 0x00120208,
+            0x04020000, 0x04120000, 0x04020008, 0x04120008,
+            0x04020200, 0x04120200, 0x04020208, 0x04120208,
+            0x04020000, 0x04120000, 0x04020008, 0x04120008,
+            0x04020200, 0x04120200, 0x04020208, 0x04120208,
+            0x00022000, 0x00122000, 0x00022008, 0x00122008,
+            0x00022200, 0x00122200, 0x00022208, 0x00122208,
+            0x00022000, 0x00122000, 0x00022008, 0x00122008,
+            0x00022200, 0x00122200, 0x00022208, 0x00122208,
+            0x04022000, 0x04122000, 0x04022008, 0x04122008,
+            0x04022200, 0x04122200, 0x04022208, 0x04122208,
+            0x04022000, 0x04122000, 0x04022008, 0x04122008,
+            0x04022200, 0x04122200, 0x04022208, 0x04122208
+        );
+        static $pc2mapd1 = array(
+            0x00000000, 0x00000001, 0x08000000, 0x08000001,
+            0x00200000, 0x00200001, 0x08200000, 0x08200001,
+            0x00000002, 0x00000003, 0x08000002, 0x08000003,
+            0x00200002, 0x00200003, 0x08200002, 0x08200003
         );
-        $block[0] &= 0x7FFFFFFF;
-        $block[1] &= 0x7FFFFFFF;
-
-        $block = array(
-            (($block[0] & 0x01000004) <<  7) | (($block[1] & 0x01000004) <<  6) |
-            (($block[0] & 0x00010000) << 13) | (($block[1] & 0x00010000) << 12) |
-            (($block[0] & 0x00000100) << 19) | (($block[1] & 0x00000100) << 18) |
-            (($block[0] & 0x00000001) << 25) | (($block[1] & 0x00000001) << 24) |
-            (($block[0] & 0x02000008) >>  2) | (($block[1] & 0x02000008) >>  3) |
-            (($block[0] & 0x00020000) <<  4) | (($block[1] & 0x00020000) <<  3) |
-            (($block[0] & 0x00000200) << 10) | (($block[1] & 0x00000200) <<  9) |
-            (($block[0] & 0x00000002) << 16) | (($block[1] & 0x00000002) << 15) |
-            (($block[0] & 0x04000000) >> 11) | (($block[1] & 0x04000000) >> 12) |
-            (($block[0] & 0x00040000) >>  5) | (($block[1] & 0x00040000) >>  6) |
-            (($block[0] & 0x00000400) <<  1) | ( $block[1] & 0x00000400       ) |
-            (($block[0] & 0x08000000) >> 20) | (($block[1] & 0x08000000) >> 21) |
-            (($block[0] & 0x00080000) >> 14) | (($block[1] & 0x00080000) >> 15) |
-            (($block[0] & 0x00000800) >>  8) | (($block[1] & 0x00000800) >>  9)
-        ,
-            (($block[0] & 0x10000040) <<  3) | (($block[1] & 0x10000040) <<  2) |
-            (($block[0] & 0x00100000) <<  9) | (($block[1] & 0x00100000) <<  8) |
-            (($block[0] & 0x00001000) << 15) | (($block[1] & 0x00001000) << 14) |
-            (($block[0] & 0x00000010) << 21) | (($block[1] & 0x00000010) << 20) |
-            (($block[0] & 0x20000080) >>  6) | (($block[1] & 0x20000080) >>  7) |
-            ( $block[0] & 0x00200000       ) | (($block[1] & 0x00200000) >>  1) |
-            (($block[0] & 0x00002000) <<  6) | (($block[1] & 0x00002000) <<  5) |
-            (($block[0] & 0x00000020) << 12) | (($block[1] & 0x00000020) << 11) |
-            (($block[0] & 0x40000000) >> 15) | (($block[1] & 0x40000000) >> 16) |
-            (($block[0] & 0x00400000) >>  9) | (($block[1] & 0x00400000) >> 10) |
-            (($block[0] & 0x00004000) >>  3) | (($block[1] & 0x00004000) >>  4) |
-            (($block[0] & 0x00800000) >> 18) | (($block[1] & 0x00800000) >> 19) |
-            (($block[0] & 0x00008000) >> 12) | (($block[1] & 0x00008000) >> 13) |
-            ($msb[0] <<  7) | ($msb[1] <<  6)
+        static $pc2mapd2 = array(
+            0x00000000, 0x00100000, 0x00000800, 0x00100800,
+            0x00000000, 0x00100000, 0x00000800, 0x00100800,
+            0x04000000, 0x04100000, 0x04000800, 0x04100800,
+            0x04000000, 0x04100000, 0x04000800, 0x04100800,
+            0x00000004, 0x00100004, 0x00000804, 0x00100804,
+            0x00000004, 0x00100004, 0x00000804, 0x00100804,
+            0x04000004, 0x04100004, 0x04000804, 0x04100804,
+            0x04000004, 0x04100004, 0x04000804, 0x04100804,
+            0x00000000, 0x00100000, 0x00000800, 0x00100800,
+            0x00000000, 0x00100000, 0x00000800, 0x00100800,
+            0x04000000, 0x04100000, 0x04000800, 0x04100800,
+            0x04000000, 0x04100000, 0x04000800, 0x04100800,
+            0x00000004, 0x00100004, 0x00000804, 0x00100804,
+            0x00000004, 0x00100004, 0x00000804, 0x00100804,
+            0x04000004, 0x04100004, 0x04000804, 0x04100804,
+            0x04000004, 0x04100004, 0x04000804, 0x04100804,
+            0x00000200, 0x00100200, 0x00000A00, 0x00100A00,
+            0x00000200, 0x00100200, 0x00000A00, 0x00100A00,
+            0x04000200, 0x04100200, 0x04000A00, 0x04100A00,
+            0x04000200, 0x04100200, 0x04000A00, 0x04100A00,
+            0x00000204, 0x00100204, 0x00000A04, 0x00100A04,
+            0x00000204, 0x00100204, 0x00000A04, 0x00100A04,
+            0x04000204, 0x04100204, 0x04000A04, 0x04100A04,
+            0x04000204, 0x04100204, 0x04000A04, 0x04100A04,
+            0x00000200, 0x00100200, 0x00000A00, 0x00100A00,
+            0x00000200, 0x00100200, 0x00000A00, 0x00100A00,
+            0x04000200, 0x04100200, 0x04000A00, 0x04100A00,
+            0x04000200, 0x04100200, 0x04000A00, 0x04100A00,
+            0x00000204, 0x00100204, 0x00000A04, 0x00100A04,
+            0x00000204, 0x00100204, 0x00000A04, 0x00100A04,
+            0x04000204, 0x04100204, 0x04000A04, 0x04100A04,
+            0x04000204, 0x04100204, 0x04000A04, 0x04100A04,
+            0x00020000, 0x00120000, 0x00020800, 0x00120800,
+            0x00020000, 0x00120000, 0x00020800, 0x00120800,
+            0x04020000, 0x04120000, 0x04020800, 0x04120800,
+            0x04020000, 0x04120000, 0x04020800, 0x04120800,
+            0x00020004, 0x00120004, 0x00020804, 0x00120804,
+            0x00020004, 0x00120004, 0x00020804, 0x00120804,
+            0x04020004, 0x04120004, 0x04020804, 0x04120804,
+            0x04020004, 0x04120004, 0x04020804, 0x04120804,
+            0x00020000, 0x00120000, 0x00020800, 0x00120800,
+            0x00020000, 0x00120000, 0x00020800, 0x00120800,
+            0x04020000, 0x04120000, 0x04020800, 0x04120800,
+            0x04020000, 0x04120000, 0x04020800, 0x04120800,
+            0x00020004, 0x00120004, 0x00020804, 0x00120804,
+            0x00020004, 0x00120004, 0x00020804, 0x00120804,
+            0x04020004, 0x04120004, 0x04020804, 0x04120804,
+            0x04020004, 0x04120004, 0x04020804, 0x04120804,
+            0x00020200, 0x00120200, 0x00020A00, 0x00120A00,
+            0x00020200, 0x00120200, 0x00020A00, 0x00120A00,
+            0x04020200, 0x04120200, 0x04020A00, 0x04120A00,
+            0x04020200, 0x04120200, 0x04020A00, 0x04120A00,
+            0x00020204, 0x00120204, 0x00020A04, 0x00120A04,
+            0x00020204, 0x00120204, 0x00020A04, 0x00120A04,
+            0x04020204, 0x04120204, 0x04020A04, 0x04120A04,
+            0x04020204, 0x04120204, 0x04020A04, 0x04120A04,
+            0x00020200, 0x00120200, 0x00020A00, 0x00120A00,
+            0x00020200, 0x00120200, 0x00020A00, 0x00120A00,
+            0x04020200, 0x04120200, 0x04020A00, 0x04120A00,
+            0x04020200, 0x04120200, 0x04020A00, 0x04120A00,
+            0x00020204, 0x00120204, 0x00020A04, 0x00120A04,
+            0x00020204, 0x00120204, 0x00020A04, 0x00120A04,
+            0x04020204, 0x04120204, 0x04020A04, 0x04120A04,
+            0x04020204, 0x04120204, 0x04020A04, 0x04120A04
         );
+        static $pc2mapd3 = array(
+            0x00000000, 0x00010000, 0x02000000, 0x02010000,
+            0x00000020, 0x00010020, 0x02000020, 0x02010020,
+            0x00040000, 0x00050000, 0x02040000, 0x02050000,
+            0x00040020, 0x00050020, 0x02040020, 0x02050020,
+            0x00002000, 0x00012000, 0x02002000, 0x02012000,
+            0x00002020, 0x00012020, 0x02002020, 0x02012020,
+            0x00042000, 0x00052000, 0x02042000, 0x02052000,
+            0x00042020, 0x00052020, 0x02042020, 0x02052020,
+            0x00000000, 0x00010000, 0x02000000, 0x02010000,
+            0x00000020, 0x00010020, 0x02000020, 0x02010020,
+            0x00040000, 0x00050000, 0x02040000, 0x02050000,
+            0x00040020, 0x00050020, 0x02040020, 0x02050020,
+            0x00002000, 0x00012000, 0x02002000, 0x02012000,
+            0x00002020, 0x00012020, 0x02002020, 0x02012020,
+            0x00042000, 0x00052000, 0x02042000, 0x02052000,
+            0x00042020, 0x00052020, 0x02042020, 0x02052020,
+            0x00000010, 0x00010010, 0x02000010, 0x02010010,
+            0x00000030, 0x00010030, 0x02000030, 0x02010030,
+            0x00040010, 0x00050010, 0x02040010, 0x02050010,
+            0x00040030, 0x00050030, 0x02040030, 0x02050030,
+            0x00002010, 0x00012010, 0x02002010, 0x02012010,
+            0x00002030, 0x00012030, 0x02002030, 0x02012030,
+            0x00042010, 0x00052010, 0x02042010, 0x02052010,
+            0x00042030, 0x00052030, 0x02042030, 0x02052030,
+            0x00000010, 0x00010010, 0x02000010, 0x02010010,
+            0x00000030, 0x00010030, 0x02000030, 0x02010030,
+            0x00040010, 0x00050010, 0x02040010, 0x02050010,
+            0x00040030, 0x00050030, 0x02040030, 0x02050030,
+            0x00002010, 0x00012010, 0x02002010, 0x02012010,
+            0x00002030, 0x00012030, 0x02002030, 0x02012030,
+            0x00042010, 0x00052010, 0x02042010, 0x02052010,
+            0x00042030, 0x00052030, 0x02042030, 0x02052030,
+            0x20000000, 0x20010000, 0x22000000, 0x22010000,
+            0x20000020, 0x20010020, 0x22000020, 0x22010020,
+            0x20040000, 0x20050000, 0x22040000, 0x22050000,
+            0x20040020, 0x20050020, 0x22040020, 0x22050020,
+            0x20002000, 0x20012000, 0x22002000, 0x22012000,
+            0x20002020, 0x20012020, 0x22002020, 0x22012020,
+            0x20042000, 0x20052000, 0x22042000, 0x22052000,
+            0x20042020, 0x20052020, 0x22042020, 0x22052020,
+            0x20000000, 0x20010000, 0x22000000, 0x22010000,
+            0x20000020, 0x20010020, 0x22000020, 0x22010020,
+            0x20040000, 0x20050000, 0x22040000, 0x22050000,
+            0x20040020, 0x20050020, 0x22040020, 0x22050020,
+            0x20002000, 0x20012000, 0x22002000, 0x22012000,
+            0x20002020, 0x20012020, 0x22002020, 0x22012020,
+            0x20042000, 0x20052000, 0x22042000, 0x22052000,
+            0x20042020, 0x20052020, 0x22042020, 0x22052020,
+            0x20000010, 0x20010010, 0x22000010, 0x22010010,
+            0x20000030, 0x20010030, 0x22000030, 0x22010030,
+            0x20040010, 0x20050010, 0x22040010, 0x22050010,
+            0x20040030, 0x20050030, 0x22040030, 0x22050030,
+            0x20002010, 0x20012010, 0x22002010, 0x22012010,
+            0x20002030, 0x20012030, 0x22002030, 0x22012030,
+            0x20042010, 0x20052010, 0x22042010, 0x22052010,
+            0x20042030, 0x20052030, 0x22042030, 0x22052030,
+            0x20000010, 0x20010010, 0x22000010, 0x22010010,
+            0x20000030, 0x20010030, 0x22000030, 0x22010030,
+            0x20040010, 0x20050010, 0x22040010, 0x22050010,
+            0x20040030, 0x20050030, 0x22040030, 0x22050030,
+            0x20002010, 0x20012010, 0x22002010, 0x22012010,
+            0x20002030, 0x20012030, 0x22002030, 0x22012030,
+            0x20042010, 0x20052010, 0x22042010, 0x22052010,
+            0x20042030, 0x20052030, 0x22042030, 0x22052030
+        );
+        static $pc2mapd4 = array(
+            0x00000000, 0x00000400, 0x01000000, 0x01000400,
+            0x00000000, 0x00000400, 0x01000000, 0x01000400,
+            0x00000100, 0x00000500, 0x01000100, 0x01000500,
+            0x00000100, 0x00000500, 0x01000100, 0x01000500,
+            0x10000000, 0x10000400, 0x11000000, 0x11000400,
+            0x10000000, 0x10000400, 0x11000000, 0x11000400,
+            0x10000100, 0x10000500, 0x11000100, 0x11000500,
+            0x10000100, 0x10000500, 0x11000100, 0x11000500,
+            0x00080000, 0x00080400, 0x01080000, 0x01080400,
+            0x00080000, 0x00080400, 0x01080000, 0x01080400,
+            0x00080100, 0x00080500, 0x01080100, 0x01080500,
+            0x00080100, 0x00080500, 0x01080100, 0x01080500,
+            0x10080000, 0x10080400, 0x11080000, 0x11080400,
+            0x10080000, 0x10080400, 0x11080000, 0x11080400,
+            0x10080100, 0x10080500, 0x11080100, 0x11080500,
+            0x10080100, 0x10080500, 0x11080100, 0x11080500,
+            0x00000008, 0x00000408, 0x01000008, 0x01000408,
+            0x00000008, 0x00000408, 0x01000008, 0x01000408,
+            0x00000108, 0x00000508, 0x01000108, 0x01000508,
+            0x00000108, 0x00000508, 0x01000108, 0x01000508,
+            0x10000008, 0x10000408, 0x11000008, 0x11000408,
+            0x10000008, 0x10000408, 0x11000008, 0x11000408,
+            0x10000108, 0x10000508, 0x11000108, 0x11000508,
+            0x10000108, 0x10000508, 0x11000108, 0x11000508,
+            0x00080008, 0x00080408, 0x01080008, 0x01080408,
+            0x00080008, 0x00080408, 0x01080008, 0x01080408,
+            0x00080108, 0x00080508, 0x01080108, 0x01080508,
+            0x00080108, 0x00080508, 0x01080108, 0x01080508,
+            0x10080008, 0x10080408, 0x11080008, 0x11080408,
+            0x10080008, 0x10080408, 0x11080008, 0x11080408,
+            0x10080108, 0x10080508, 0x11080108, 0x11080508,
+            0x10080108, 0x10080508, 0x11080108, 0x11080508,
+            0x00001000, 0x00001400, 0x01001000, 0x01001400,
+            0x00001000, 0x00001400, 0x01001000, 0x01001400,
+            0x00001100, 0x00001500, 0x01001100, 0x01001500,
+            0x00001100, 0x00001500, 0x01001100, 0x01001500,
+            0x10001000, 0x10001400, 0x11001000, 0x11001400,
+            0x10001000, 0x10001400, 0x11001000, 0x11001400,
+            0x10001100, 0x10001500, 0x11001100, 0x11001500,
+            0x10001100, 0x10001500, 0x11001100, 0x11001500,
+            0x00081000, 0x00081400, 0x01081000, 0x01081400,
+            0x00081000, 0x00081400, 0x01081000, 0x01081400,
+            0x00081100, 0x00081500, 0x01081100, 0x01081500,
+            0x00081100, 0x00081500, 0x01081100, 0x01081500,
+            0x10081000, 0x10081400, 0x11081000, 0x11081400,
+            0x10081000, 0x10081400, 0x11081000, 0x11081400,
+            0x10081100, 0x10081500, 0x11081100, 0x11081500,
+            0x10081100, 0x10081500, 0x11081100, 0x11081500,
+            0x00001008, 0x00001408, 0x01001008, 0x01001408,
+            0x00001008, 0x00001408, 0x01001008, 0x01001408,
+            0x00001108, 0x00001508, 0x01001108, 0x01001508,
+            0x00001108, 0x00001508, 0x01001108, 0x01001508,
+            0x10001008, 0x10001408, 0x11001008, 0x11001408,
+            0x10001008, 0x10001408, 0x11001008, 0x11001408,
+            0x10001108, 0x10001508, 0x11001108, 0x11001508,
+            0x10001108, 0x10001508, 0x11001108, 0x11001508,
+            0x00081008, 0x00081408, 0x01081008, 0x01081408,
+            0x00081008, 0x00081408, 0x01081008, 0x01081408,
+            0x00081108, 0x00081508, 0x01081108, 0x01081508,
+            0x00081108, 0x00081508, 0x01081108, 0x01081508,
+            0x10081008, 0x10081408, 0x11081008, 0x11081408,
+            0x10081008, 0x10081408, 0x11081008, 0x11081408,
+            0x10081108, 0x10081508, 0x11081108, 0x11081508,
+            0x10081108, 0x10081508, 0x11081108, 0x11081508
+        );
+
+        $keys = array();
+        for ($des_round = 0; $des_round < $this->des_rounds; ++$des_round) {
+            // pad the key and remove extra characters as appropriate.
+            $key = str_pad(substr($this->key, $des_round * 8, 8), 8, "\0");
+
+            // Perform the PC/1 transformation and compute C and D.
+            $t = unpack('Nl/Nr', $key);
+            list($l, $r) = array($t['l'], $t['r']);
+            $key = ($this->shuffle[$pc1map[ $r        & 0xFF]] & "\x80\x80\x80\x80\x80\x80\x80\x00") |
+                   ($this->shuffle[$pc1map[($r >>  8) & 0xFF]] & "\x40\x40\x40\x40\x40\x40\x40\x00") |
+                   ($this->shuffle[$pc1map[($r >> 16) & 0xFF]] & "\x20\x20\x20\x20\x20\x20\x20\x00") |
+                   ($this->shuffle[$pc1map[($r >> 24) & 0xFF]] & "\x10\x10\x10\x10\x10\x10\x10\x00") |
+                   ($this->shuffle[$pc1map[ $l        & 0xFF]] & "\x08\x08\x08\x08\x08\x08\x08\x00") |
+                   ($this->shuffle[$pc1map[($l >>  8) & 0xFF]] & "\x04\x04\x04\x04\x04\x04\x04\x00") |
+                   ($this->shuffle[$pc1map[($l >> 16) & 0xFF]] & "\x02\x02\x02\x02\x02\x02\x02\x00") |
+                   ($this->shuffle[$pc1map[($l >> 24) & 0xFF]] & "\x01\x01\x01\x01\x01\x01\x01\x00");
+            $key = unpack('Nc/Nd', $key);
+            $c = ( $key['c'] >> 4) & 0x0FFFFFFF;
+            $d = (($key['d'] >> 4) & 0x0FFFFFF0) | ($key['c'] & 0x0F);
+
+            $keys[$des_round] = array(
+                self::ENCRYPT => array(),
+                self::DECRYPT => array_fill(0, 32, 0)
+            );
+            for ($i = 0, $ki = 31; $i < 16; ++$i, $ki-= 2) {
+                $c <<= $shifts[$i];
+                $c = ($c | ($c >> 28)) & 0x0FFFFFFF;
+                $d <<= $shifts[$i];
+                $d = ($d | ($d >> 28)) & 0x0FFFFFFF;
+
+                // Perform the PC-2 transformation.
+                $cp = $pc2mapc1[ $c >> 24        ] | $pc2mapc2[($c >> 16) & 0xFF] |
+                      $pc2mapc3[($c >>  8) & 0xFF] | $pc2mapc4[ $c        & 0xFF];
+                $dp = $pc2mapd1[ $d >> 24        ] | $pc2mapd2[($d >> 16) & 0xFF] |
+                      $pc2mapd3[($d >>  8) & 0xFF] | $pc2mapd4[ $d        & 0xFF];
+
+                // Reorder: odd bytes/even bytes. Push the result in key schedule.
+                $val1 = ( $cp        & 0xFF000000) | (($cp <<  8) & 0x00FF0000) |
+                        (($dp >> 16) & 0x0000FF00) | (($dp >>  8) & 0x000000FF);
+                $val2 = (($cp <<  8) & 0xFF000000) | (($cp << 16) & 0x00FF0000) |
+                        (($dp >>  8) & 0x0000FF00) | ( $dp        & 0x000000FF);
+                $keys[$des_round][self::ENCRYPT][       ] = $val1;
+                $keys[$des_round][self::DECRYPT][$ki - 1] = $val1;
+                $keys[$des_round][self::ENCRYPT][       ] = $val2;
+                $keys[$des_round][self::DECRYPT][$ki    ] = $val2;
+            }
+        }
 
-        return pack('NN', $block[0], $block[1]);
+        switch ($this->des_rounds) {
+            case 3: // 3DES keys
+                $this->keys = array(
+                    self::ENCRYPT => array_merge(
+                        $keys[0][self::ENCRYPT],
+                        $keys[1][self::DECRYPT],
+                        $keys[2][self::ENCRYPT]
+                    ),
+                    self::DECRYPT => array_merge(
+                        $keys[2][self::DECRYPT],
+                        $keys[1][self::ENCRYPT],
+                        $keys[0][self::DECRYPT]
+                    )
+                );
+                break;
+            // case 1: // DES keys
+            default:
+                $this->keys = array(
+                    self::ENCRYPT => $keys[0][self::ENCRYPT],
+                    self::DECRYPT => $keys[0][self::DECRYPT]
+                );
+        }
     }
 
     /**
-     * Creates the key schedule.
+     * Setup the performance-optimized function for de/encrypt()
      *
+     * @see \phpseclib\Crypt\Base::_setupInlineCrypt()
      * @access private
-     * @param String $key
-     * @return Array
      */
-    function _prepareKey($key)
+    function _setupInlineCrypt()
     {
-        static $shifts = array( // number of key bits shifted per round
-            1, 1, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 1
-        );
+        $lambda_functions =& self::_getLambdaFunctions();
+
+        // Engine configuration for:
+        // -  DES ($des_rounds == 1) or
+        // - 3DES ($des_rounds == 3)
+        $des_rounds = $this->des_rounds;
+
+        // We create max. 10 hi-optimized code for memory reason. Means: For each $key one ultra fast inline-crypt function.
+        // (Currently, for DES, one generated $lambda_function cost on php5.5@32bit ~135kb unfreeable mem and ~230kb on php5.5@64bit)
+        // (Currently, for TripleDES, one generated $lambda_function cost on php5.5@32bit ~240kb unfreeable mem and ~340kb on php5.5@64bit)
+        // After that, we'll still create very fast optimized code but not the hi-ultimative code, for each $mode one
+        $gen_hi_opt_code = (bool)( count($lambda_functions) < 10 );
+
+        // Generation of a unique hash for our generated code
+        $code_hash = "Crypt_DES, $des_rounds, {$this->mode}";
+        if ($gen_hi_opt_code) {
+            // For hi-optimized code, we create for each combination of
+            // $mode, $des_rounds and $this->key its own encrypt/decrypt function.
+            // After max 10 hi-optimized functions, we create generic
+            // (still very fast.. but not ultra) functions for each $mode/$des_rounds
+            // Currently 2 * 5 generic functions will be then max. possible.
+            $code_hash = str_pad($code_hash, 32) . $this->_hashInlineCryptFunction($this->key);
+        }
 
-        // pad the key and remove extra characters as appropriate.
-        $key = str_pad(substr($key, 0, 8), 8, chr(0));
+        // Is there a re-usable $lambda_functions in there? If not, we have to create it.
+        if (!isset($lambda_functions[$code_hash])) {
+            // Init code for both, encrypt and decrypt.
+            $init_crypt = 'static $sbox1, $sbox2, $sbox3, $sbox4, $sbox5, $sbox6, $sbox7, $sbox8, $shuffleip, $shuffleinvip;
+                if (!$sbox1) {
+                    $sbox1 = array_map("intval", $self->sbox1);
+                    $sbox2 = array_map("intval", $self->sbox2);
+                    $sbox3 = array_map("intval", $self->sbox3);
+                    $sbox4 = array_map("intval", $self->sbox4);
+                    $sbox5 = array_map("intval", $self->sbox5);
+                    $sbox6 = array_map("intval", $self->sbox6);
+                    $sbox7 = array_map("intval", $self->sbox7);
+                    $sbox8 = array_map("intval", $self->sbox8);'
+                    /* Merge $shuffle with $[inv]ipmap */ . '
+                    for ($i = 0; $i < 256; ++$i) {
+                        $shuffleip[]    =  $self->shuffle[$self->ipmap[$i]];
+                        $shuffleinvip[] =  $self->shuffle[$self->invipmap[$i]];
+                    }
+                }
+            ';
 
-        $temp = unpack('Na/Nb', $key);
-        $key = array($temp['a'], $temp['b']);
-        $msb = array(
-            ($key[0] >> 31) & 1,
-            ($key[1] >> 31) & 1
-        );
-        $key[0] &= 0x7FFFFFFF;
-        $key[1] &= 0x7FFFFFFF;
-
-        $key = array(
-            (($key[1] & 0x00000002) << 26) | (($key[1] & 0x00000204) << 17) |
-            (($key[1] & 0x00020408) <<  8) | (($key[1] & 0x02040800) >>  1) |
-            (($key[0] & 0x00000002) << 22) | (($key[0] & 0x00000204) << 13) |
-            (($key[0] & 0x00020408) <<  4) | (($key[0] & 0x02040800) >>  5) |
-            (($key[1] & 0x04080000) >> 10) | (($key[0] & 0x04080000) >> 14) |
-            (($key[1] & 0x08000000) >> 19) | (($key[0] & 0x08000000) >> 23) |
-            (($key[0] & 0x00000010) >>  1) | (($key[0] & 0x00001000) >> 10) |
-            (($key[0] & 0x00100000) >> 19) | (($key[0] & 0x10000000) >> 28)
-        ,
-            (($key[1] & 0x00000080) << 20) | (($key[1] & 0x00008000) << 11) |
-            (($key[1] & 0x00800000) <<  2) | (($key[0] & 0x00000080) << 16) |
-            (($key[0] & 0x00008000) <<  7) | (($key[0] & 0x00800000) >>  2) |
-            (($key[1] & 0x00000040) << 13) | (($key[1] & 0x00004000) <<  4) |
-            (($key[1] & 0x00400000) >>  5) | (($key[1] & 0x40000000) >> 14) |
-            (($key[0] & 0x00000040) <<  9) | ( $key[0] & 0x00004000       ) |
-            (($key[0] & 0x00400000) >>  9) | (($key[0] & 0x40000000) >> 18) |
-            (($key[1] & 0x00000020) <<  6) | (($key[1] & 0x00002000) >>  3) |
-            (($key[1] & 0x00200000) >> 12) | (($key[1] & 0x20000000) >> 21) |
-            (($key[0] & 0x00000020) <<  2) | (($key[0] & 0x00002000) >>  7) |
-            (($key[0] & 0x00200000) >> 16) | (($key[0] & 0x20000000) >> 25) |
-            (($key[1] & 0x00000010) >>  1) | (($key[1] & 0x00001000) >> 10) |
-            (($key[1] & 0x00100000) >> 19) | (($key[1] & 0x10000000) >> 28) |
-            ($msb[1] << 24) | ($msb[0] << 20)
-        ); 
+            switch (true) {
+                case $gen_hi_opt_code:
+                    // In Hi-optimized code mode, we use our [3]DES key schedule as hardcoded integers.
+                    // No futher initialisation of the $keys schedule is necessary.
+                    // That is the extra performance boost.
+                    $k = array(
+                        self::ENCRYPT => $this->keys[self::ENCRYPT],
+                        self::DECRYPT => $this->keys[self::DECRYPT]
+                    );
+                    $init_encrypt = '';
+                    $init_decrypt = '';
+                    break;
+                default:
+                    // In generic optimized code mode, we have to use, as the best compromise [currently],
+                    // our key schedule as $ke/$kd arrays. (with hardcoded indexes...)
+                    $k = array(
+                        self::ENCRYPT => array(),
+                        self::DECRYPT => array()
+                    );
+                    for ($i = 0, $c = count($this->keys[self::ENCRYPT]); $i < $c; ++$i) {
+                        $k[self::ENCRYPT][$i] = '$ke[' . $i . ']';
+                        $k[self::DECRYPT][$i] = '$kd[' . $i . ']';
+                    }
+                    $init_encrypt = '$ke = $self->keys[$self::ENCRYPT];';
+                    $init_decrypt = '$kd = $self->keys[$self::DECRYPT];';
+                    break;
+            }
 
-        $keys = array();
-        for ($i = 0; $i < 16; $i++) {
-            $key[0] <<= $shifts[$i];
-            $temp = ($key[0] & 0xF0000000) >> 28;
-            $key[0] = ($key[0] | $temp) & 0x0FFFFFFF;
-
-            $key[1] <<= $shifts[$i];
-            $temp = ($key[1] & 0xF0000000) >> 28;
-            $key[1] = ($key[1] | $temp) & 0x0FFFFFFF;
-
-            $temp = array(
-                (($key[1] & 0x00004000) >>  9) | (($key[1] & 0x00000800) >>  7) |
-                (($key[1] & 0x00020000) >> 14) | (($key[1] & 0x00000010) >>  2) |
-                (($key[1] & 0x08000000) >> 26) | (($key[1] & 0x00800000) >> 23)
-            ,
-                (($key[1] & 0x02400000) >> 20) | (($key[1] & 0x00000001) <<  4) |
-                (($key[1] & 0x00002000) >> 10) | (($key[1] & 0x00040000) >> 18) |
-                (($key[1] & 0x00000080) >>  6)
-            ,
-                ( $key[1] & 0x00000020       ) | (($key[1] & 0x00000200) >>  5) |
-                (($key[1] & 0x00010000) >> 13) | (($key[1] & 0x01000000) >> 22) |
-                (($key[1] & 0x00000004) >>  1) | (($key[1] & 0x00100000) >> 20)
-            ,
-                (($key[1] & 0x00001000) >>  7) | (($key[1] & 0x00200000) >> 17) |
-                (($key[1] & 0x00000002) <<  2) | (($key[1] & 0x00000100) >>  6) |
-                (($key[1] & 0x00008000) >> 14) | (($key[1] & 0x04000000) >> 26)
-            ,
-                (($key[0] & 0x00008000) >> 10) | ( $key[0] & 0x00000010       ) |
-                (($key[0] & 0x02000000) >> 22) | (($key[0] & 0x00080000) >> 17) |
-                (($key[0] & 0x00000200) >>  8) | (($key[0] & 0x00000002) >>  1)
-            ,
-                (($key[0] & 0x04000000) >> 21) | (($key[0] & 0x00010000) >> 12) |
-                (($key[0] & 0x00000020) >>  2) | (($key[0] & 0x00000800) >>  9) |
-                (($key[0] & 0x00800000) >> 22) | (($key[0] & 0x00000100) >>  8)
-            ,
-                (($key[0] & 0x00001000) >>  7) | (($key[0] & 0x00000088) >>  3) |
-                (($key[0] & 0x00020000) >> 14) | (($key[0] & 0x00000001) <<  2) |
-                (($key[0] & 0x00400000) >> 21)
-            ,
-                (($key[0] & 0x00000400) >>  5) | (($key[0] & 0x00004000) >> 10) |
-                (($key[0] & 0x00000040) >>  3) | (($key[0] & 0x00100000) >> 18) |
-                (($key[0] & 0x08000000) >> 26) | (($key[0] & 0x01000000) >> 24)
-            );
+            // Creating code for en- and decryption.
+            $crypt_block = array();
+            foreach (array(self::ENCRYPT, self::DECRYPT) as $c) {
+                /* Do the initial IP permutation. */
+                $crypt_block[$c] = '
+                    $in = unpack("N*", $in);
+                    $l  = $in[1];
+                    $r  = $in[2];
+                    $in = unpack("N*",
+                        ($shuffleip[ $r        & 0xFF] & "\x80\x80\x80\x80\x80\x80\x80\x80") |
+                        ($shuffleip[($r >>  8) & 0xFF] & "\x40\x40\x40\x40\x40\x40\x40\x40") |
+                        ($shuffleip[($r >> 16) & 0xFF] & "\x20\x20\x20\x20\x20\x20\x20\x20") |
+                        ($shuffleip[($r >> 24) & 0xFF] & "\x10\x10\x10\x10\x10\x10\x10\x10") |
+                        ($shuffleip[ $l        & 0xFF] & "\x08\x08\x08\x08\x08\x08\x08\x08") |
+                        ($shuffleip[($l >>  8) & 0xFF] & "\x04\x04\x04\x04\x04\x04\x04\x04") |
+                        ($shuffleip[($l >> 16) & 0xFF] & "\x02\x02\x02\x02\x02\x02\x02\x02") |
+                        ($shuffleip[($l >> 24) & 0xFF] & "\x01\x01\x01\x01\x01\x01\x01\x01")
+                    );
+                    ' . /* Extract L0 and R0 */ '
+                    $l = $in[1];
+                    $r = $in[2];
+                ';
+
+                $l = '$l';
+                $r = '$r';
+
+                // Perform DES or 3DES.
+                for ($ki = -1, $des_round = 0; $des_round < $des_rounds; ++$des_round) {
+                    // Perform the 16 steps.
+                    for ($i = 0; $i < 16; ++$i) {
+                        // start of "the Feistel (F) function" - see the following URL:
+                        // http://en.wikipedia.org/wiki/Image:Data_Encryption_Standard_InfoBox_Diagram.png
+                        // Merge key schedule.
+                        $crypt_block[$c].= '
+                            $b1 = ((' . $r . ' >>  3) & 0x1FFFFFFF)  ^ (' . $r . ' << 29) ^ ' . $k[$c][++$ki] . ';
+                            $b2 = ((' . $r . ' >> 31) & 0x00000001)  ^ (' . $r . ' <<  1) ^ ' . $k[$c][++$ki] . ';' .
+                            /* S-box indexing. */
+                            $l . ' = $sbox1[($b1 >> 24) & 0x3F] ^ $sbox2[($b2 >> 24) & 0x3F] ^
+                                     $sbox3[($b1 >> 16) & 0x3F] ^ $sbox4[($b2 >> 16) & 0x3F] ^
+                                     $sbox5[($b1 >>  8) & 0x3F] ^ $sbox6[($b2 >>  8) & 0x3F] ^
+                                     $sbox7[ $b1        & 0x3F] ^ $sbox8[ $b2        & 0x3F] ^ ' . $l . ';
+                        ';
+                        // end of "the Feistel (F) function"
+
+                        // swap L & R
+                        list($l, $r) = array($r, $l);
+                    }
+                    list($l, $r) = array($r, $l);
+                }
 
-            $keys[] = $temp;
-        }
+                // Perform the inverse IP permutation.
+                $crypt_block[$c].= '$in =
+                    ($shuffleinvip[($l >> 24) & 0xFF] & "\x80\x80\x80\x80\x80\x80\x80\x80") |
+                    ($shuffleinvip[($r >> 24) & 0xFF] & "\x40\x40\x40\x40\x40\x40\x40\x40") |
+                    ($shuffleinvip[($l >> 16) & 0xFF] & "\x20\x20\x20\x20\x20\x20\x20\x20") |
+                    ($shuffleinvip[($r >> 16) & 0xFF] & "\x10\x10\x10\x10\x10\x10\x10\x10") |
+                    ($shuffleinvip[($l >>  8) & 0xFF] & "\x08\x08\x08\x08\x08\x08\x08\x08") |
+                    ($shuffleinvip[($r >>  8) & 0xFF] & "\x04\x04\x04\x04\x04\x04\x04\x04") |
+                    ($shuffleinvip[ $l        & 0xFF] & "\x02\x02\x02\x02\x02\x02\x02\x02") |
+                    ($shuffleinvip[ $r        & 0xFF] & "\x01\x01\x01\x01\x01\x01\x01\x01");
+                ';
+            }
 
-        $temp = array(
-            CRYPT_DES_ENCRYPT => $keys,
-            CRYPT_DES_DECRYPT => array_reverse($keys)
-        );
+            // Creates the inline-crypt function
+            $lambda_functions[$code_hash] = $this->_createInlineCryptFunction(
+                array(
+                   'init_crypt'    => $init_crypt,
+                   'init_encrypt'  => $init_encrypt,
+                   'init_decrypt'  => $init_decrypt,
+                   'encrypt_block' => $crypt_block[self::ENCRYPT],
+                   'decrypt_block' => $crypt_block[self::DECRYPT]
+                )
+            );
+        }
 
-        return $temp;
+        // Set the inline-crypt function as callback in: $this->inline_crypt
+        $this->inline_crypt = $lambda_functions[$code_hash];
     }
 }
-
-// vim: ts=4:sw=4:et:
-// vim6: fdl=1:
diff --git a/lib/phpseclib/Crypt/Hash.php b/lib/phpseclib/Crypt/Hash.php
index 1a878e2..6ae0132 100644
--- a/lib/phpseclib/Crypt/Hash.php
+++ b/lib/phpseclib/Crypt/Hash.php
@@ -1,27 +1,26 @@
 <?php
-/* vim: set expandtab tabstop=4 shiftwidth=4 softtabstop=4: */
 
 /**
  * Pure-PHP implementations of keyed-hash message authentication codes (HMACs) and various cryptographic hashing functions.
  *
  * Uses hash() or mhash() if available and an internal implementation, otherwise.  Currently supports the following:
  *
- * md2, md5, md5-96, sha1, sha1-96, sha256, sha384, and sha512
+ * md2, md5, md5-96, sha1, sha1-96, sha256, sha256-96, sha384, and sha512, sha512-96
  *
- * If {@link Crypt_Hash::setKey() setKey()} is called, {@link Crypt_Hash::hash() hash()} will return the HMAC as opposed to
+ * If {@link self::setKey() setKey()} is called, {@link self::hash() hash()} will return the HMAC as opposed to
  * the hash.  If no valid algorithm is provided, sha1 will be used.
  *
- * PHP versions 4 and 5
+ * PHP version 5
  *
- * {@internal The variable names are the same as those in 
+ * {@internal The variable names are the same as those in
  * {@link http://tools.ietf.org/html/rfc2104#section-2 RFC2104}.}}
  *
  * Here's a short example of how to use this library:
  * <code>
  * <?php
- *    include('Crypt/Hash.php');
+ *    include 'vendor/autoload.php';
  *
- *    $hash = new Crypt_Hash('sha1');
+ *    $hash = new \phpseclib\Crypt\Hash('sha1');
  *
  *    $hash->setKey('abcdefg');
  *
@@ -29,62 +28,59 @@
  * ?>
  * </code>
  *
- * LICENSE: This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA  02111-1307  USA
- *
- * @category   Crypt
- * @package    Crypt_Hash
- * @author     Jim Wigginton <terrafrost@php.net>
- * @copyright  MMVII Jim Wigginton
- * @license    http://www.gnu.org/licenses/lgpl.txt
- * @version    $Id: Hash.php,v 1.6 2009/11/23 23:37:07 terrafrost Exp $
- * @link       http://phpseclib.sourceforge.net
+ * @category  Crypt
+ * @package   Hash
+ * @author    Jim Wigginton <terrafrost@php.net>
+ * @copyright 2007 Jim Wigginton
+ * @license   http://www.opensource.org/licenses/mit-license.html  MIT License
+ * @link      http://phpseclib.sourceforge.net
  */
 
-/**#@+
- * @access private
- * @see Crypt_Hash::Crypt_Hash()
- */
-/**
- * Toggles the internal implementation
- */
-define('CRYPT_HASH_MODE_INTERNAL', 1);
-/**
- * Toggles the mhash() implementation, which has been deprecated on PHP 5.3.0+.
- */
-define('CRYPT_HASH_MODE_MHASH',    2);
-/**
- * Toggles the hash() implementation, which works on PHP 5.1.2+.
- */
-define('CRYPT_HASH_MODE_HASH',     3);
-/**#@-*/
+namespace phpseclib\Crypt;
+
+use phpseclib\Math\BigInteger;
 
 /**
  * Pure-PHP implementations of keyed-hash message authentication codes (HMACs) and various cryptographic hashing functions.
  *
+ * @package Hash
  * @author  Jim Wigginton <terrafrost@php.net>
- * @version 0.1.0
  * @access  public
- * @package Crypt_Hash
  */
-class Crypt_Hash {
+class Hash
+{
+    /**#@+
+     * @access private
+     * @see \phpseclib\Crypt\Hash::__construct()
+     */
+    /**
+     * Toggles the internal implementation
+     */
+    const MODE_INTERNAL = 1;
+    /**
+     * Toggles the mhash() implementation, which has been deprecated on PHP 5.3.0+.
+     */
+    const MODE_MHASH = 2;
+    /**
+     * Toggles the hash() implementation, which works on PHP 5.1.2+.
+     */
+    const MODE_HASH = 3;
+    /**#@-*/
+
+    /**
+     * Hash Parameter
+     *
+     * @see self::setHash()
+     * @var int
+     * @access private
+     */
+    var $hashParam;
+
     /**
      * Byte-length of compression blocks / key (Internal HMAC)
      *
-     * @see Crypt_Hash::setAlgorithm()
-     * @var Integer
+     * @see self::setAlgorithm()
+     * @var int
      * @access private
      */
     var $b;
@@ -92,8 +88,8 @@ class Crypt_Hash {
     /**
      * Byte-length of hash output (Internal HMAC)
      *
-     * @see Crypt_Hash::setHash()
-     * @var Integer
+     * @see self::setHash()
+     * @var int
      * @access private
      */
     var $l = false;
@@ -101,8 +97,8 @@ class Crypt_Hash {
     /**
      * Hash Algorithm
      *
-     * @see Crypt_Hash::setHash()
-     * @var String
+     * @see self::setHash()
+     * @var string
      * @access private
      */
     var $hash;
@@ -110,17 +106,17 @@ class Crypt_Hash {
     /**
      * Key
      *
-     * @see Crypt_Hash::setKey()
-     * @var String
+     * @see self::setKey()
+     * @var string
      * @access private
      */
-    var $key = '';
+    var $key = false;
 
     /**
      * Outer XOR (Internal HMAC)
      *
-     * @see Crypt_Hash::setKey()
-     * @var String
+     * @see self::setKey()
+     * @var string
      * @access private
      */
     var $opad;
@@ -128,8 +124,8 @@ class Crypt_Hash {
     /**
      * Inner XOR (Internal HMAC)
      *
-     * @see Crypt_Hash::setKey()
-     * @var String
+     * @see self::setKey()
+     * @var string
      * @access private
      */
     var $ipad;
@@ -137,22 +133,22 @@ class Crypt_Hash {
     /**
      * Default Constructor.
      *
-     * @param optional String $hash
-     * @return Crypt_Hash
+     * @param string $hash
+     * @return \phpseclib\Crypt\Hash
      * @access public
      */
-    function Crypt_Hash($hash = 'sha1')
+    function __construct($hash = 'sha1')
     {
-        if ( !defined('CRYPT_HASH_MODE') ) {
+        if (!defined('CRYPT_HASH_MODE')) {
             switch (true) {
                 case extension_loaded('hash'):
-                    define('CRYPT_HASH_MODE', CRYPT_HASH_MODE_HASH);
+                    define('CRYPT_HASH_MODE', self::MODE_HASH);
                     break;
                 case extension_loaded('mhash'):
-                    define('CRYPT_HASH_MODE', CRYPT_HASH_MODE_MHASH);
+                    define('CRYPT_HASH_MODE', self::MODE_MHASH);
                     break;
                 default:
-                    define('CRYPT_HASH_MODE', CRYPT_HASH_MODE_INTERNAL);
+                    define('CRYPT_HASH_MODE', self::MODE_INTERNAL);
             }
         }
 
@@ -165,24 +161,41 @@ class Crypt_Hash {
      * Keys can be of any length.
      *
      * @access public
-     * @param String $key
+     * @param string $key
      */
-    function setKey($key)
+    function setKey($key = false)
     {
         $this->key = $key;
     }
 
     /**
+     * Gets the hash function.
+     *
+     * As set by the constructor or by the setHash() method.
+     *
+     * @access public
+     * @return string
+     */
+    function getHash()
+    {
+        return $this->hashParam;
+    }
+
+    /**
      * Sets the hash function.
      *
      * @access public
-     * @param String $hash
+     * @param string $hash
      */
     function setHash($hash)
     {
+        $this->hashParam = $hash = strtolower($hash);
         switch ($hash) {
             case 'md5-96':
             case 'sha1-96':
+            case 'sha256-96':
+            case 'sha512-96':
+                $hash = substr($hash, 0, -3);
                 $this->l = 12; // 96 / 8 = 12
                 break;
             case 'md2':
@@ -204,45 +217,43 @@ class Crypt_Hash {
 
         switch ($hash) {
             case 'md2':
-                $mode = CRYPT_HASH_MODE_INTERNAL;
+                $mode = CRYPT_HASH_MODE == self::MODE_HASH && in_array('md2', hash_algos()) ?
+                    self::MODE_HASH : self::MODE_INTERNAL;
                 break;
             case 'sha384':
             case 'sha512':
-                $mode = CRYPT_HASH_MODE == CRYPT_HASH_MODE_MHASH ? CRYPT_HASH_MODE_INTERNAL : CRYPT_HASH_MODE;
+                $mode = CRYPT_HASH_MODE == self::MODE_MHASH ? self::MODE_INTERNAL : CRYPT_HASH_MODE;
                 break;
             default:
                 $mode = CRYPT_HASH_MODE;
         }
 
-        switch ( $mode ) {
-            case CRYPT_HASH_MODE_MHASH:
+        switch ($mode) {
+            case self::MODE_MHASH:
                 switch ($hash) {
                     case 'md5':
-                    case 'md5-96':
                         $this->hash = MHASH_MD5;
                         break;
                     case 'sha256':
                         $this->hash = MHASH_SHA256;
                         break;
                     case 'sha1':
-                    case 'sha1-96':
                     default:
                         $this->hash = MHASH_SHA1;
                 }
                 return;
-            case CRYPT_HASH_MODE_HASH:
+            case self::MODE_HASH:
                 switch ($hash) {
                     case 'md5':
-                    case 'md5-96':
                         $this->hash = 'md5';
                         return;
+                    case 'md2':
                     case 'sha256':
                     case 'sha384':
                     case 'sha512':
                         $this->hash = $hash;
                         return;
                     case 'sha1':
-                    case 'sha1-96':
                     default:
                         $this->hash = 'sha1';
                 }
@@ -251,28 +262,26 @@ class Crypt_Hash {
 
         switch ($hash) {
             case 'md2':
-                 $this->b = 16;
-                 $this->hash = array($this, '_md2');
-                 break;
+                $this->b = 16;
+                $this->hash = array($this, '_md2');
+                break;
             case 'md5':
-            case 'md5-96':
-                 $this->b = 64;
-                 $this->hash = array($this, '_md5');
-                 break;
+                $this->b = 64;
+                $this->hash = array($this, '_md5');
+                break;
             case 'sha256':
-                 $this->b = 64;
-                 $this->hash = array($this, '_sha256');
-                 break;
+                $this->b = 64;
+                $this->hash = array($this, '_sha256');
+                break;
             case 'sha384':
             case 'sha512':
-                 $this->b = 128;
-                 $this->hash = array($this, '_sha512');
-                 break;
+                $this->b = 128;
+                $this->hash = array($this, '_sha512');
+                break;
             case 'sha1':
-            case 'sha1-96':
             default:
-                 $this->b = 64;
-                 $this->hash = array($this, '_sha1');
+                $this->b = 64;
+                $this->hash = array($this, '_sha1');
         }
 
         $this->ipad = str_repeat(chr(0x36), $this->b);
@@ -283,27 +292,27 @@ class Crypt_Hash {
      * Compute the HMAC.
      *
      * @access public
-     * @param String $text
-     * @return String
+     * @param string $text
+     * @return string
      */
     function hash($text)
     {
-        $mode = is_array($this->hash) ? CRYPT_HASH_MODE_INTERNAL : CRYPT_HASH_MODE;
+        $mode = is_array($this->hash) ? self::MODE_INTERNAL : CRYPT_HASH_MODE;
 
-        if (!empty($this->key)) {
-            switch ( $mode ) {
-                case CRYPT_HASH_MODE_MHASH:
+        if (!empty($this->key) || is_string($this->key)) {
+            switch ($mode) {
+                case self::MODE_MHASH:
                     $output = mhash($this->hash, $text, $this->key);
                     break;
-                case CRYPT_HASH_MODE_HASH:
+                case self::MODE_HASH:
                     $output = hash_hmac($this->hash, $text, $this->key, true);
                     break;
-                case CRYPT_HASH_MODE_INTERNAL:
+                case self::MODE_INTERNAL:
                     /* "Applications that use keys longer than B bytes will first hash the key using H and then use the
                         resultant L byte string as the actual key to HMAC."
 
                         -- http://tools.ietf.org/html/rfc2104#section-2 */
-                    $key = strlen($this->key) > $this->b ? call_user_func($this->$hash, $this->key) : $this->key;
+                    $key = strlen($this->key) > $this->b ? call_user_func($this->hash, $this->key) : $this->key;
 
                     $key    = str_pad($key, $this->b, chr(0));      // step 1
                     $temp   = $this->ipad ^ $key;                   // step 2
@@ -314,14 +323,14 @@ class Crypt_Hash {
                     $output = call_user_func($this->hash, $output); // step 7
             }
         } else {
-            switch ( $mode ) {
-                case CRYPT_HASH_MODE_MHASH:
+            switch ($mode) {
+                case self::MODE_MHASH:
                     $output = mhash($this->hash, $text);
                     break;
-                case CRYPT_HASH_MODE_HASH:
+                case self::MODE_HASH:
                     $output = hash($this->hash, $text, true);
                     break;
-                case CRYPT_HASH_MODE_INTERNAL:
+                case self::MODE_INTERNAL:
                     $output = call_user_func($this->hash, $text);
             }
         }
@@ -332,8 +341,8 @@ class Crypt_Hash {
     /**
      * Returns the hash length (in bytes)
      *
-     * @access private
-     * @return Integer
+     * @access public
+     * @return int
      */
     function getLength()
     {
@@ -344,7 +353,7 @@ class Crypt_Hash {
      * Wrapper for MD5
      *
      * @access private
-     * @param String $text
+     * @param string $m
      */
     function _md5($m)
     {
@@ -355,7 +364,7 @@ class Crypt_Hash {
      * Wrapper for SHA1
      *
      * @access private
-     * @param String $text
+     * @param string $m
      */
     function _sha1($m)
     {
@@ -368,7 +377,7 @@ class Crypt_Hash {
      * See {@link http://tools.ietf.org/html/rfc1319 RFC1319}.
      *
      * @access private
-     * @param String $text
+     * @param string $m
      */
     function _md2($m)
     {
@@ -404,7 +413,10 @@ class Crypt_Hash {
         $l = chr(0);
         for ($i = 0; $i < $length; $i+= 16) {
             for ($j = 0; $j < 16; $j++) {
-                $c[$j] = chr($s[ord($m[$i + $j] ^ $l)]);
+                // RFC1319 incorrectly states that C[j] should be set to S[c xor L]
+                //$c[$j] = chr($s[ord($m[$i + $j] ^ $l)]);
+                // per <http://www.rfc-editor.org/errata_search.php?rfc=1319>, however, C[j] should be set to S[c xor L] xor C[j]
+                $c[$j] = chr($s[ord($m[$i + $j] ^ $l)] ^ ord($c[$j]));
                 $l = $c[$j];
             }
         }
@@ -441,7 +453,7 @@ class Crypt_Hash {
      * See {@link http://en.wikipedia.org/wiki/SHA_hash_functions#SHA-256_.28a_SHA-2_variant.29_pseudocode SHA-256 (a SHA-2 variant) pseudocode - Wikipedia}.
      *
      * @access private
-     * @param String $text
+     * @param string $m
      */
     function _sha256($m)
     {
@@ -485,14 +497,15 @@ class Crypt_Hash {
 
             // Extend the sixteen 32-bit words into sixty-four 32-bit words
             for ($i = 16; $i < 64; $i++) {
+                // @codingStandardsIgnoreStart
                 $s0 = $this->_rightRotate($w[$i - 15],  7) ^
                       $this->_rightRotate($w[$i - 15], 18) ^
                       $this->_rightShift( $w[$i - 15],  3);
                 $s1 = $this->_rightRotate($w[$i - 2], 17) ^
                       $this->_rightRotate($w[$i - 2], 19) ^
                       $this->_rightShift( $w[$i - 2], 10);
+                // @codingStandardsIgnoreEnd
                 $w[$i] = $this->_add($w[$i - 16], $s0, $w[$i - 7], $s1);
-
             }
 
             // Initialize hash value for this chunk
@@ -546,31 +559,27 @@ class Crypt_Hash {
      * Pure-PHP implementation of SHA384 and SHA512
      *
      * @access private
-     * @param String $text
+     * @param string $m
      */
     function _sha512($m)
     {
-        if (!class_exists('Math_BigInteger')) {
-            require_once('Math/BigInteger.php');
-        }
-
         static $init384, $init512, $k;
 
         if (!isset($k)) {
             // Initialize variables
             $init384 = array( // initial values for SHA384
-                'cbbb9d5dc1059ed8', '629a292a367cd507', '9159015a3070dd17', '152fecd8f70e5939', 
+                'cbbb9d5dc1059ed8', '629a292a367cd507', '9159015a3070dd17', '152fecd8f70e5939',
                 '67332667ffc00b31', '8eb44a8768581511', 'db0c2e0d64f98fa7', '47b5481dbefa4fa4'
             );
             $init512 = array( // initial values for SHA512
-                '6a09e667f3bcc908', 'bb67ae8584caa73b', '3c6ef372fe94f82b', 'a54ff53a5f1d36f1', 
+                '6a09e667f3bcc908', 'bb67ae8584caa73b', '3c6ef372fe94f82b', 'a54ff53a5f1d36f1',
                 '510e527fade682d1', '9b05688c2b3e6c1f', '1f83d9abfb41bd6b', '5be0cd19137e2179'
             );
 
             for ($i = 0; $i < 8; $i++) {
-                $init384[$i] = new Math_BigInteger($init384[$i], 16);
+                $init384[$i] = new BigInteger($init384[$i], 16);
                 $init384[$i]->setPrecision(64);
-                $init512[$i] = new Math_BigInteger($init512[$i], 16);
+                $init512[$i] = new BigInteger($init512[$i], 16);
                 $init512[$i]->setPrecision(64);
             }
 
@@ -600,7 +609,7 @@ class Crypt_Hash {
             );
 
             for ($i = 0; $i < 80; $i++) {
-                $k[$i] = new Math_BigInteger($k[$i], 16);
+                $k[$i] = new BigInteger($k[$i], 16);
             }
         }
 
@@ -619,7 +628,7 @@ class Crypt_Hash {
         foreach ($chunks as $chunk) {
             $w = array();
             for ($i = 0; $i < 16; $i++) {
-                $temp = new Math_BigInteger($this->_string_shift($chunk, 8), 256);
+                $temp = new BigInteger($this->_string_shift($chunk, 8), 256);
                 $temp->setPrecision(64);
                 $w[] = $temp;
             }
@@ -715,7 +724,7 @@ class Crypt_Hash {
         }
 
         // Produce the final hash value (big-endian)
-        // (Crypt_Hash::hash() trims the output for hashes but not for HMACs.  as such, we trim the output here)
+        // (\phpseclib\Crypt\Hash::hash() trims the output for hashes but not for HMACs.  as such, we trim the output here)
         $temp = $hash[0]->toBytes() . $hash[1]->toBytes() . $hash[2]->toBytes() . $hash[3]->toBytes() .
                 $hash[4]->toBytes() . $hash[5]->toBytes();
         if ($this->l != 48) {
@@ -729,10 +738,10 @@ class Crypt_Hash {
      * Right Rotate
      *
      * @access private
-     * @param Integer $int
-     * @param Integer $amt
-     * @see _sha256()
-     * @return Integer
+     * @param int $int
+     * @param int $amt
+     * @see self::_sha256()
+     * @return int
      */
     function _rightRotate($int, $amt)
     {
@@ -745,10 +754,10 @@ class Crypt_Hash {
      * Right Shift
      *
      * @access private
-     * @param Integer $int
-     * @param Integer $amt
-     * @see _sha256()
-     * @return Integer
+     * @param int $int
+     * @param int $amt
+     * @see self::_sha256()
+     * @return int
      */
     function _rightShift($int, $amt)
     {
@@ -760,9 +769,9 @@ class Crypt_Hash {
      * Not
      *
      * @access private
-     * @param Integer $int
-     * @see _sha256()
-     * @return Integer
+     * @param int $int
+     * @see self::_sha256()
+     * @return int
      */
     function _not($int)
     {
@@ -773,12 +782,11 @@ class Crypt_Hash {
      * Add
      *
      * _sha256() adds multiple unsigned 32-bit integers.  Since PHP doesn't support unsigned integers and since the
-     * possibility of overflow exists, care has to be taken.  Math_BigInteger() could be used but this should be faster.
+     * possibility of overflow exists, care has to be taken.  BigInteger could be used but this should be faster.
      *
-     * @param String $string
-     * @param optional Integer $index
-     * @return String
-     * @see _sha256()
+     * @param int $...
+     * @return int
+     * @see self::_sha256()
      * @access private
      */
     function _add()
@@ -794,7 +802,12 @@ class Crypt_Hash {
             $result+= $argument < 0 ? ($argument & 0x7FFFFFFF) + 0x80000000 : $argument;
         }
 
-        return fmod($result, $mod);
+        if ((php_uname('m') & "\xDF\xDF\xDF") != 'ARM') {
+            return fmod($result, $mod);
+        }
+
+        return (fmod($result, 0x80000000) & 0x7FFFFFFF) |
+            ((fmod(floor($result / 0x80000000), 2) & 1) << 31);
     }
 
     /**
@@ -802,9 +815,9 @@ class Crypt_Hash {
      *
      * Inspired by array_shift
      *
-     * @param String $string
-     * @param optional Integer $index
-     * @return String
+     * @param string $string
+     * @param int $index
+     * @return string
      * @access private
      */
     function _string_shift(&$string, $index = 1)
diff --git a/lib/phpseclib/Crypt/RC2.php b/lib/phpseclib/Crypt/RC2.php
new file mode 100644
index 0000000..b2b9d48
--- /dev/null
+++ b/lib/phpseclib/Crypt/RC2.php
@@ -0,0 +1,688 @@
+<?php
+
+/**
+ * Pure-PHP implementation of RC2.
+ *
+ * Uses mcrypt, if available, and an internal implementation, otherwise.
+ *
+ * PHP version 5
+ *
+ * Useful resources are as follows:
+ *
+ *  - {@link http://tools.ietf.org/html/rfc2268}
+ *
+ * Here's a short example of how to use this library:
+ * <code>
+ * <?php
+ *    include 'vendor/autoload.php';
+ *
+ *    $rc2 = new \phpseclib\Crypt\RC2();
+ *
+ *    $rc2->setKey('abcdefgh');
+ *
+ *    $plaintext = str_repeat('a', 1024);
+ *
+ *    echo $rc2->decrypt($rc2->encrypt($plaintext));
+ * ?>
+ * </code>
+ *
+ * @category Crypt
+ * @package  RC2
+ * @author   Patrick Monnerat <pm@datasphere.ch>
+ * @license  http://www.opensource.org/licenses/mit-license.html  MIT License
+ * @link     http://phpseclib.sourceforge.net
+ */
+
+namespace phpseclib\Crypt;
+
+/**
+ * Pure-PHP implementation of RC2.
+ *
+ * @package RC2
+ * @access  public
+ */
+class RC2 extends Base
+{
+    /**
+     * Block Length of the cipher
+     *
+     * @see \phpseclib\Crypt\Base::block_size
+     * @var int
+     * @access private
+     */
+    var $block_size = 8;
+
+    /**
+     * The Key
+     *
+     * @see \phpseclib\Crypt\Base::key
+     * @see self::setKey()
+     * @var string
+     * @access private
+     */
+    var $key;
+
+    /**
+     * The Original (unpadded) Key
+     *
+     * @see \phpseclib\Crypt\Base::key
+     * @see self::setKey()
+     * @see self::encrypt()
+     * @see self::decrypt()
+     * @var string
+     * @access private
+     */
+    var $orig_key;
+
+    /**
+     * Don't truncate / null pad key
+     *
+     * @see \phpseclib\Crypt\Base::_clearBuffers()
+     * @var bool
+     * @access private
+     */
+    var $skip_key_adjustment = true;
+
+    /**
+     * Key Length (in bytes)
+     *
+     * @see \phpseclib\Crypt\RC2::setKeyLength()
+     * @var int
+     * @access private
+     */
+    var $key_length = 16; // = 128 bits
+
+    /**
+     * The mcrypt specific name of the cipher
+     *
+     * @see \phpseclib\Crypt\Base::cipher_name_mcrypt
+     * @var string
+     * @access private
+     */
+    var $cipher_name_mcrypt = 'rc2';
+
+    /**
+     * Optimizing value while CFB-encrypting
+     *
+     * @see \phpseclib\Crypt\Base::cfb_init_len
+     * @var int
+     * @access private
+     */
+    var $cfb_init_len = 500;
+
+    /**
+     * The key length in bits.
+     *
+     * @see self::setKeyLength()
+     * @see self::setKey()
+     * @var int
+     * @access private
+     * @internal Should be in range [1..1024].
+     * @internal Changing this value after setting the key has no effect.
+     */
+    var $default_key_length = 1024;
+
+    /**
+     * The key length in bits.
+     *
+     * @see self::isValidEnine()
+     * @see self::setKey()
+     * @var int
+     * @access private
+     * @internal Should be in range [1..1024].
+     */
+    var $current_key_length;
+
+    /**
+     * The Key Schedule
+     *
+     * @see self::_setupKey()
+     * @var array
+     * @access private
+     */
+    var $keys;
+
+    /**
+     * Key expansion randomization table.
+     * Twice the same 256-value sequence to save a modulus in key expansion.
+     *
+     * @see self::setKey()
+     * @var array
+     * @access private
+     */
+    var $pitable = array(
+        0xD9, 0x78, 0xF9, 0xC4, 0x19, 0xDD, 0xB5, 0xED,
+        0x28, 0xE9, 0xFD, 0x79, 0x4A, 0xA0, 0xD8, 0x9D,
+        0xC6, 0x7E, 0x37, 0x83, 0x2B, 0x76, 0x53, 0x8E,
+        0x62, 0x4C, 0x64, 0x88, 0x44, 0x8B, 0xFB, 0xA2,
+        0x17, 0x9A, 0x59, 0xF5, 0x87, 0xB3, 0x4F, 0x13,
+        0x61, 0x45, 0x6D, 0x8D, 0x09, 0x81, 0x7D, 0x32,
+        0xBD, 0x8F, 0x40, 0xEB, 0x86, 0xB7, 0x7B, 0x0B,
+        0xF0, 0x95, 0x21, 0x22, 0x5C, 0x6B, 0x4E, 0x82,
+        0x54, 0xD6, 0x65, 0x93, 0xCE, 0x60, 0xB2, 0x1C,
+        0x73, 0x56, 0xC0, 0x14, 0xA7, 0x8C, 0xF1, 0xDC,
+        0x12, 0x75, 0xCA, 0x1F, 0x3B, 0xBE, 0xE4, 0xD1,
+        0x42, 0x3D, 0xD4, 0x30, 0xA3, 0x3C, 0xB6, 0x26,
+        0x6F, 0xBF, 0x0E, 0xDA, 0x46, 0x69, 0x07, 0x57,
+        0x27, 0xF2, 0x1D, 0x9B, 0xBC, 0x94, 0x43, 0x03,
+        0xF8, 0x11, 0xC7, 0xF6, 0x90, 0xEF, 0x3E, 0xE7,
+        0x06, 0xC3, 0xD5, 0x2F, 0xC8, 0x66, 0x1E, 0xD7,
+        0x08, 0xE8, 0xEA, 0xDE, 0x80, 0x52, 0xEE, 0xF7,
+        0x84, 0xAA, 0x72, 0xAC, 0x35, 0x4D, 0x6A, 0x2A,
+        0x96, 0x1A, 0xD2, 0x71, 0x5A, 0x15, 0x49, 0x74,
+        0x4B, 0x9F, 0xD0, 0x5E, 0x04, 0x18, 0xA4, 0xEC,
+        0xC2, 0xE0, 0x41, 0x6E, 0x0F, 0x51, 0xCB, 0xCC,
+        0x24, 0x91, 0xAF, 0x50, 0xA1, 0xF4, 0x70, 0x39,
+        0x99, 0x7C, 0x3A, 0x85, 0x23, 0xB8, 0xB4, 0x7A,
+        0xFC, 0x02, 0x36, 0x5B, 0x25, 0x55, 0x97, 0x31,
+        0x2D, 0x5D, 0xFA, 0x98, 0xE3, 0x8A, 0x92, 0xAE,
+        0x05, 0xDF, 0x29, 0x10, 0x67, 0x6C, 0xBA, 0xC9,
+        0xD3, 0x00, 0xE6, 0xCF, 0xE1, 0x9E, 0xA8, 0x2C,
+        0x63, 0x16, 0x01, 0x3F, 0x58, 0xE2, 0x89, 0xA9,
+        0x0D, 0x38, 0x34, 0x1B, 0xAB, 0x33, 0xFF, 0xB0,
+        0xBB, 0x48, 0x0C, 0x5F, 0xB9, 0xB1, 0xCD, 0x2E,
+        0xC5, 0xF3, 0xDB, 0x47, 0xE5, 0xA5, 0x9C, 0x77,
+        0x0A, 0xA6, 0x20, 0x68, 0xFE, 0x7F, 0xC1, 0xAD,
+        0xD9, 0x78, 0xF9, 0xC4, 0x19, 0xDD, 0xB5, 0xED,
+        0x28, 0xE9, 0xFD, 0x79, 0x4A, 0xA0, 0xD8, 0x9D,
+        0xC6, 0x7E, 0x37, 0x83, 0x2B, 0x76, 0x53, 0x8E,
+        0x62, 0x4C, 0x64, 0x88, 0x44, 0x8B, 0xFB, 0xA2,
+        0x17, 0x9A, 0x59, 0xF5, 0x87, 0xB3, 0x4F, 0x13,
+        0x61, 0x45, 0x6D, 0x8D, 0x09, 0x81, 0x7D, 0x32,
+        0xBD, 0x8F, 0x40, 0xEB, 0x86, 0xB7, 0x7B, 0x0B,
+        0xF0, 0x95, 0x21, 0x22, 0x5C, 0x6B, 0x4E, 0x82,
+        0x54, 0xD6, 0x65, 0x93, 0xCE, 0x60, 0xB2, 0x1C,
+        0x73, 0x56, 0xC0, 0x14, 0xA7, 0x8C, 0xF1, 0xDC,
+        0x12, 0x75, 0xCA, 0x1F, 0x3B, 0xBE, 0xE4, 0xD1,
+        0x42, 0x3D, 0xD4, 0x30, 0xA3, 0x3C, 0xB6, 0x26,
+        0x6F, 0xBF, 0x0E, 0xDA, 0x46, 0x69, 0x07, 0x57,
+        0x27, 0xF2, 0x1D, 0x9B, 0xBC, 0x94, 0x43, 0x03,
+        0xF8, 0x11, 0xC7, 0xF6, 0x90, 0xEF, 0x3E, 0xE7,
+        0x06, 0xC3, 0xD5, 0x2F, 0xC8, 0x66, 0x1E, 0xD7,
+        0x08, 0xE8, 0xEA, 0xDE, 0x80, 0x52, 0xEE, 0xF7,
+        0x84, 0xAA, 0x72, 0xAC, 0x35, 0x4D, 0x6A, 0x2A,
+        0x96, 0x1A, 0xD2, 0x71, 0x5A, 0x15, 0x49, 0x74,
+        0x4B, 0x9F, 0xD0, 0x5E, 0x04, 0x18, 0xA4, 0xEC,
+        0xC2, 0xE0, 0x41, 0x6E, 0x0F, 0x51, 0xCB, 0xCC,
+        0x24, 0x91, 0xAF, 0x50, 0xA1, 0xF4, 0x70, 0x39,
+        0x99, 0x7C, 0x3A, 0x85, 0x23, 0xB8, 0xB4, 0x7A,
+        0xFC, 0x02, 0x36, 0x5B, 0x25, 0x55, 0x97, 0x31,
+        0x2D, 0x5D, 0xFA, 0x98, 0xE3, 0x8A, 0x92, 0xAE,
+        0x05, 0xDF, 0x29, 0x10, 0x67, 0x6C, 0xBA, 0xC9,
+        0xD3, 0x00, 0xE6, 0xCF, 0xE1, 0x9E, 0xA8, 0x2C,
+        0x63, 0x16, 0x01, 0x3F, 0x58, 0xE2, 0x89, 0xA9,
+        0x0D, 0x38, 0x34, 0x1B, 0xAB, 0x33, 0xFF, 0xB0,
+        0xBB, 0x48, 0x0C, 0x5F, 0xB9, 0xB1, 0xCD, 0x2E,
+        0xC5, 0xF3, 0xDB, 0x47, 0xE5, 0xA5, 0x9C, 0x77,
+        0x0A, 0xA6, 0x20, 0x68, 0xFE, 0x7F, 0xC1, 0xAD
+    );
+
+    /**
+     * Inverse key expansion randomization table.
+     *
+     * @see self::setKey()
+     * @var array
+     * @access private
+     */
+    var $invpitable = array(
+        0xD1, 0xDA, 0xB9, 0x6F, 0x9C, 0xC8, 0x78, 0x66,
+        0x80, 0x2C, 0xF8, 0x37, 0xEA, 0xE0, 0x62, 0xA4,
+        0xCB, 0x71, 0x50, 0x27, 0x4B, 0x95, 0xD9, 0x20,
+        0x9D, 0x04, 0x91, 0xE3, 0x47, 0x6A, 0x7E, 0x53,
+        0xFA, 0x3A, 0x3B, 0xB4, 0xA8, 0xBC, 0x5F, 0x68,
+        0x08, 0xCA, 0x8F, 0x14, 0xD7, 0xC0, 0xEF, 0x7B,
+        0x5B, 0xBF, 0x2F, 0xE5, 0xE2, 0x8C, 0xBA, 0x12,
+        0xE1, 0xAF, 0xB2, 0x54, 0x5D, 0x59, 0x76, 0xDB,
+        0x32, 0xA2, 0x58, 0x6E, 0x1C, 0x29, 0x64, 0xF3,
+        0xE9, 0x96, 0x0C, 0x98, 0x19, 0x8D, 0x3E, 0x26,
+        0xAB, 0xA5, 0x85, 0x16, 0x40, 0xBD, 0x49, 0x67,
+        0xDC, 0x22, 0x94, 0xBB, 0x3C, 0xC1, 0x9B, 0xEB,
+        0x45, 0x28, 0x18, 0xD8, 0x1A, 0x42, 0x7D, 0xCC,
+        0xFB, 0x65, 0x8E, 0x3D, 0xCD, 0x2A, 0xA3, 0x60,
+        0xAE, 0x93, 0x8A, 0x48, 0x97, 0x51, 0x15, 0xF7,
+        0x01, 0x0B, 0xB7, 0x36, 0xB1, 0x2E, 0x11, 0xFD,
+        0x84, 0x2D, 0x3F, 0x13, 0x88, 0xB3, 0x34, 0x24,
+        0x1B, 0xDE, 0xC5, 0x1D, 0x4D, 0x2B, 0x17, 0x31,
+        0x74, 0xA9, 0xC6, 0x43, 0x6D, 0x39, 0x90, 0xBE,
+        0xC3, 0xB0, 0x21, 0x6B, 0xF6, 0x0F, 0xD5, 0x99,
+        0x0D, 0xAC, 0x1F, 0x5C, 0x9E, 0xF5, 0xF9, 0x4C,
+        0xD6, 0xDF, 0x89, 0xE4, 0x8B, 0xFF, 0xC7, 0xAA,
+        0xE7, 0xED, 0x46, 0x25, 0xB6, 0x06, 0x5E, 0x35,
+        0xB5, 0xEC, 0xCE, 0xE8, 0x6C, 0x30, 0x55, 0x61,
+        0x4A, 0xFE, 0xA0, 0x79, 0x03, 0xF0, 0x10, 0x72,
+        0x7C, 0xCF, 0x52, 0xA6, 0xA7, 0xEE, 0x44, 0xD3,
+        0x9A, 0x57, 0x92, 0xD0, 0x5A, 0x7A, 0x41, 0x7F,
+        0x0E, 0x00, 0x63, 0xF2, 0x4F, 0x05, 0x83, 0xC9,
+        0xA1, 0xD4, 0xDD, 0xC4, 0x56, 0xF4, 0xD2, 0x77,
+        0x81, 0x09, 0x82, 0x33, 0x9F, 0x07, 0x86, 0x75,
+        0x38, 0x4E, 0x69, 0xF1, 0xAD, 0x23, 0x73, 0x87,
+        0x70, 0x02, 0xC2, 0x1E, 0xB8, 0x0A, 0xFC, 0xE6
+    );
+
+    /**
+     * Test for engine validity
+     *
+     * This is mainly just a wrapper to set things up for \phpseclib\Crypt\Base::isValidEngine()
+     *
+     * @see \phpseclib\Crypt\Base::__construct()
+     * @param int $engine
+     * @access public
+     * @return bool
+     */
+    function isValidEngine($engine)
+    {
+        switch ($engine) {
+            case self::ENGINE_OPENSSL:
+                if ($this->current_key_length != 128 || strlen($this->orig_key) < 16) {
+                    return false;
+                }
+                $this->cipher_name_openssl_ecb = 'rc2-ecb';
+                $this->cipher_name_openssl = 'rc2-' . $this->_openssl_translate_mode();
+        }
+
+        return parent::isValidEngine($engine);
+    }
+
+    /**
+     * Sets the key length.
+     *
+     * Valid key lengths are 8 to 1024.
+     * Calling this function after setting the key has no effect until the next
+     *  \phpseclib\Crypt\RC2::setKey() call.
+     *
+     * @access public
+     * @param int $length in bits
+     */
+    function setKeyLength($length)
+    {
+        if ($length < 8) {
+            $this->default_key_length = 1;
+        } elseif ($length > 1024) {
+            $this->default_key_length = 128;
+        } else {
+            $this->default_key_length = $length;
+        }
+        $this->current_key_length = $this->default_key_length;
+
+        parent::setKeyLength($length);
+    }
+
+    /**
+     * Returns the current key length
+     *
+     * @access public
+     * @return int
+     */
+    function getKeyLength()
+    {
+        return $this->current_key_length;
+    }
+
+    /**
+     * Sets the key.
+     *
+     * Keys can be of any length. RC2, itself, uses 8 to 1024 bit keys (eg.
+     * strlen($key) <= 128), however, we only use the first 128 bytes if $key
+     * has more then 128 bytes in it, and set $key to a single null byte if
+     * it is empty.
+     *
+     * If the key is not explicitly set, it'll be assumed to be a single
+     * null byte.
+     *
+     * @see \phpseclib\Crypt\Base::setKey()
+     * @access public
+     * @param string $key
+     * @param int $t1 optional Effective key length in bits.
+     */
+    function setKey($key, $t1 = 0)
+    {
+        $this->orig_key = $key;
+
+        if ($t1 <= 0) {
+            $t1 = $this->default_key_length;
+        } elseif ($t1 > 1024) {
+            $t1 = 1024;
+        }
+        $this->current_key_length = $t1;
+        // Key byte count should be 1..128.
+        $key = strlen($key) ? substr($key, 0, 128) : "\x00";
+        $t = strlen($key);
+
+        // The mcrypt RC2 implementation only supports effective key length
+        // of 1024 bits. It is however possible to handle effective key
+        // lengths in range 1..1024 by expanding the key and applying
+        // inverse pitable mapping to the first byte before submitting it
+        // to mcrypt.
+
+        // Key expansion.
+        $l = array_values(unpack('C*', $key));
+        $t8 = ($t1 + 7) >> 3;
+        $tm = 0xFF >> (8 * $t8 - $t1);
+
+        // Expand key.
+        $pitable = $this->pitable;
+        for ($i = $t; $i < 128; $i++) {
+            $l[$i] = $pitable[$l[$i - 1] + $l[$i - $t]];
+        }
+        $i = 128 - $t8;
+        $l[$i] = $pitable[$l[$i] & $tm];
+        while ($i--) {
+            $l[$i] = $pitable[$l[$i + 1] ^ $l[$i + $t8]];
+        }
+
+        // Prepare the key for mcrypt.
+        $l[0] = $this->invpitable[$l[0]];
+        array_unshift($l, 'C*');
+
+        parent::setKey(call_user_func_array('pack', $l));
+    }
+
+    /**
+     * Encrypts a message.
+     *
+     * Mostly a wrapper for \phpseclib\Crypt\Base::encrypt, with some additional OpenSSL handling code
+     *
+     * @see self::decrypt()
+     * @access public
+     * @param string $plaintext
+     * @return string $ciphertext
+     */
+    function encrypt($plaintext)
+    {
+        if ($this->engine == self::ENGINE_OPENSSL) {
+            $temp = $this->key;
+            $this->key = $this->orig_key;
+            $result = parent::encrypt($plaintext);
+            $this->key = $temp;
+            return $result;
+        }
+
+        return parent::encrypt($plaintext);
+    }
+
+    /**
+     * Decrypts a message.
+     *
+     * Mostly a wrapper for \phpseclib\Crypt\Base::decrypt, with some additional OpenSSL handling code
+     *
+     * @see self::encrypt()
+     * @access public
+     * @param string $ciphertext
+     * @return string $plaintext
+     */
+    function decrypt($ciphertext)
+    {
+        if ($this->engine == self::ENGINE_OPENSSL) {
+            $temp = $this->key;
+            $this->key = $this->orig_key;
+            $result = parent::decrypt($ciphertext);
+            $this->key = $temp;
+            return $result;
+        }
+
+        return parent::decrypt($ciphertext);
+    }
+
+    /**
+     * Encrypts a block
+     *
+     * @see \phpseclib\Crypt\Base::_encryptBlock()
+     * @see \phpseclib\Crypt\Base::encrypt()
+     * @access private
+     * @param string $in
+     * @return string
+     */
+    function _encryptBlock($in)
+    {
+        list($r0, $r1, $r2, $r3) = array_values(unpack('v*', $in));
+        $keys = $this->keys;
+        $limit = 20;
+        $actions = array($limit => 44, 44 => 64);
+        $j = 0;
+
+        for (;;) {
+            // Mixing round.
+            $r0 = (($r0 + $keys[$j++] + ((($r1 ^ $r2) & $r3) ^ $r1)) & 0xFFFF) << 1;
+            $r0 |= $r0 >> 16;
+            $r1 = (($r1 + $keys[$j++] + ((($r2 ^ $r3) & $r0) ^ $r2)) & 0xFFFF) << 2;
+            $r1 |= $r1 >> 16;
+            $r2 = (($r2 + $keys[$j++] + ((($r3 ^ $r0) & $r1) ^ $r3)) & 0xFFFF) << 3;
+            $r2 |= $r2 >> 16;
+            $r3 = (($r3 + $keys[$j++] + ((($r0 ^ $r1) & $r2) ^ $r0)) & 0xFFFF) << 5;
+            $r3 |= $r3 >> 16;
+
+            if ($j === $limit) {
+                if ($limit === 64) {
+                    break;
+                }
+
+                // Mashing round.
+                $r0 += $keys[$r3 & 0x3F];
+                $r1 += $keys[$r0 & 0x3F];
+                $r2 += $keys[$r1 & 0x3F];
+                $r3 += $keys[$r2 & 0x3F];
+                $limit = $actions[$limit];
+            }
+        }
+
+        return pack('vvvv', $r0, $r1, $r2, $r3);
+    }
+
+    /**
+     * Decrypts a block
+     *
+     * @see \phpseclib\Crypt\Base::_decryptBlock()
+     * @see \phpseclib\Crypt\Base::decrypt()
+     * @access private
+     * @param string $in
+     * @return string
+     */
+    function _decryptBlock($in)
+    {
+        list($r0, $r1, $r2, $r3) = array_values(unpack('v*', $in));
+        $keys = $this->keys;
+        $limit = 44;
+        $actions = array($limit => 20, 20 => 0);
+        $j = 64;
+
+        for (;;) {
+            // R-mixing round.
+            $r3 = ($r3 | ($r3 << 16)) >> 5;
+            $r3 = ($r3 - $keys[--$j] - ((($r0 ^ $r1) & $r2) ^ $r0)) & 0xFFFF;
+            $r2 = ($r2 | ($r2 << 16)) >> 3;
+            $r2 = ($r2 - $keys[--$j] - ((($r3 ^ $r0) & $r1) ^ $r3)) & 0xFFFF;
+            $r1 = ($r1 | ($r1 << 16)) >> 2;
+            $r1 = ($r1 - $keys[--$j] - ((($r2 ^ $r3) & $r0) ^ $r2)) & 0xFFFF;
+            $r0 = ($r0 | ($r0 << 16)) >> 1;
+            $r0 = ($r0 - $keys[--$j] - ((($r1 ^ $r2) & $r3) ^ $r1)) & 0xFFFF;
+
+            if ($j === $limit) {
+                if ($limit === 0) {
+                    break;
+                }
+
+                // R-mashing round.
+                $r3 = ($r3 - $keys[$r2 & 0x3F]) & 0xFFFF;
+                $r2 = ($r2 - $keys[$r1 & 0x3F]) & 0xFFFF;
+                $r1 = ($r1 - $keys[$r0 & 0x3F]) & 0xFFFF;
+                $r0 = ($r0 - $keys[$r3 & 0x3F]) & 0xFFFF;
+                $limit = $actions[$limit];
+            }
+        }
+
+        return pack('vvvv', $r0, $r1, $r2, $r3);
+    }
+
+    /**
+     * Setup the \phpseclib\Crypt\Base::ENGINE_MCRYPT $engine
+     *
+     * @see \phpseclib\Crypt\Base::_setupMcrypt()
+     * @access private
+     */
+    function _setupMcrypt()
+    {
+        if (!isset($this->key)) {
+            $this->setKey('');
+        }
+
+        parent::_setupMcrypt();
+    }
+
+    /**
+     * Creates the key schedule
+     *
+     * @see \phpseclib\Crypt\Base::_setupKey()
+     * @access private
+     */
+    function _setupKey()
+    {
+        if (!isset($this->key)) {
+            $this->setKey('');
+        }
+
+        // Key has already been expanded in \phpseclib\Crypt\RC2::setKey():
+        // Only the first value must be altered.
+        $l = unpack('Ca/Cb/v*', $this->key);
+        array_unshift($l, $this->pitable[$l['a']] | ($l['b'] << 8));
+        unset($l['a']);
+        unset($l['b']);
+        $this->keys = $l;
+    }
+
+    /**
+     * Setup the performance-optimized function for de/encrypt()
+     *
+     * @see \phpseclib\Crypt\Base::_setupInlineCrypt()
+     * @access private
+     */
+    function _setupInlineCrypt()
+    {
+        $lambda_functions =& self::_getLambdaFunctions();
+
+        // The first 10 generated $lambda_functions will use the $keys hardcoded as integers
+        // for the mixing rounds, for better inline crypt performance [~20% faster].
+        // But for memory reason we have to limit those ultra-optimized $lambda_functions to an amount of 10.
+        // (Currently, for Crypt_RC2, one generated $lambda_function cost on php5.5@32bit ~60kb unfreeable mem and ~100kb on php5.5@64bit)
+        $gen_hi_opt_code = (bool)(count($lambda_functions) < 10);
+
+        // Generation of a unique hash for our generated code
+        $code_hash = "Crypt_RC2, {$this->mode}";
+        if ($gen_hi_opt_code) {
+            $code_hash = str_pad($code_hash, 32) . $this->_hashInlineCryptFunction($this->key);
+        }
+
+        // Is there a re-usable $lambda_functions in there?
+        // If not, we have to create it.
+        if (!isset($lambda_functions[$code_hash])) {
+            // Init code for both, encrypt and decrypt.
+            $init_crypt = '$keys = $self->keys;';
+
+            switch (true) {
+                case $gen_hi_opt_code:
+                    $keys = $this->keys;
+                default:
+                    $keys = array();
+                    foreach ($this->keys as $k => $v) {
+                        $keys[$k] = '$keys[' . $k . ']';
+                    }
+            }
+
+            // $in is the current 8 bytes block which has to be en/decrypt
+            $encrypt_block = $decrypt_block = '
+                $in = unpack("v4", $in);
+                $r0 = $in[1];
+                $r1 = $in[2];
+                $r2 = $in[3];
+                $r3 = $in[4];
+            ';
+
+            // Create code for encryption.
+            $limit = 20;
+            $actions = array($limit => 44, 44 => 64);
+            $j = 0;
+
+            for (;;) {
+                // Mixing round.
+                $encrypt_block .= '
+                    $r0 = (($r0 + ' . $keys[$j++] . ' +
+                           ((($r1 ^ $r2) & $r3) ^ $r1)) & 0xFFFF) << 1;
+                    $r0 |= $r0 >> 16;
+                    $r1 = (($r1 + ' . $keys[$j++] . ' +
+                           ((($r2 ^ $r3) & $r0) ^ $r2)) & 0xFFFF) << 2;
+                    $r1 |= $r1 >> 16;
+                    $r2 = (($r2 + ' . $keys[$j++] . ' +
+                           ((($r3 ^ $r0) & $r1) ^ $r3)) & 0xFFFF) << 3;
+                    $r2 |= $r2 >> 16;
+                    $r3 = (($r3 + ' . $keys[$j++] . ' +
+                           ((($r0 ^ $r1) & $r2) ^ $r0)) & 0xFFFF) << 5;
+                    $r3 |= $r3 >> 16;';
+
+                if ($j === $limit) {
+                    if ($limit === 64) {
+                        break;
+                    }
+
+                    // Mashing round.
+                    $encrypt_block .= '
+                        $r0 += $keys[$r3 & 0x3F];
+                        $r1 += $keys[$r0 & 0x3F];
+                        $r2 += $keys[$r1 & 0x3F];
+                        $r3 += $keys[$r2 & 0x3F];';
+                    $limit = $actions[$limit];
+                }
+            }
+
+            $encrypt_block .= '$in = pack("v4", $r0, $r1, $r2, $r3);';
+
+            // Create code for decryption.
+            $limit = 44;
+            $actions = array($limit => 20, 20 => 0);
+            $j = 64;
+
+            for (;;) {
+                // R-mixing round.
+                $decrypt_block .= '
+                    $r3 = ($r3 | ($r3 << 16)) >> 5;
+                    $r3 = ($r3 - ' . $keys[--$j] . ' -
+                           ((($r0 ^ $r1) & $r2) ^ $r0)) & 0xFFFF;
+                    $r2 = ($r2 | ($r2 << 16)) >> 3;
+                    $r2 = ($r2 - ' . $keys[--$j] . ' -
+                           ((($r3 ^ $r0) & $r1) ^ $r3)) & 0xFFFF;
+                    $r1 = ($r1 | ($r1 << 16)) >> 2;
+                    $r1 = ($r1 - ' . $keys[--$j] . ' -
+                           ((($r2 ^ $r3) & $r0) ^ $r2)) & 0xFFFF;
+                    $r0 = ($r0 | ($r0 << 16)) >> 1;
+                    $r0 = ($r0 - ' . $keys[--$j] . ' -
+                           ((($r1 ^ $r2) & $r3) ^ $r1)) & 0xFFFF;';
+
+                if ($j === $limit) {
+                    if ($limit === 0) {
+                        break;
+                    }
+
+                    // R-mashing round.
+                    $decrypt_block .= '
+                        $r3 = ($r3 - $keys[$r2 & 0x3F]) & 0xFFFF;
+                        $r2 = ($r2 - $keys[$r1 & 0x3F]) & 0xFFFF;
+                        $r1 = ($r1 - $keys[$r0 & 0x3F]) & 0xFFFF;
+                        $r0 = ($r0 - $keys[$r3 & 0x3F]) & 0xFFFF;';
+                    $limit = $actions[$limit];
+                }
+            }
+
+            $decrypt_block .= '$in = pack("v4", $r0, $r1, $r2, $r3);';
+
+            // Creates the inline-crypt function
+            $lambda_functions[$code_hash] = $this->_createInlineCryptFunction(
+                array(
+                   'init_crypt'    => $init_crypt,
+                   'encrypt_block' => $encrypt_block,
+                   'decrypt_block' => $decrypt_block
+                )
+            );
+        }
+
+        // Set the inline-crypt function as callback in: $this->inline_crypt
+        $this->inline_crypt = $lambda_functions[$code_hash];
+    }
+}
diff --git a/lib/phpseclib/Crypt/RC4.php b/lib/phpseclib/Crypt/RC4.php
index c67cb96..25e4ff8 100644
--- a/lib/phpseclib/Crypt/RC4.php
+++ b/lib/phpseclib/Crypt/RC4.php
@@ -1,12 +1,11 @@
 <?php
-/* vim: set expandtab tabstop=4 shiftwidth=4 softtabstop=4: */
 
 /**
  * Pure-PHP implementation of RC4.
  *
  * Uses mcrypt, if available, and an internal implementation, otherwise.
  *
- * PHP versions 4 and 5
+ * PHP version 5
  *
  * Useful resources are as follows:
  *
@@ -14,14 +13,14 @@
  *  - {@link http://en.wikipedia.org/wiki/RC4 - Wikipedia: RC4}
  *
  * RC4 is also known as ARCFOUR or ARC4.  The reason is elaborated upon at Wikipedia.  This class is named RC4 and not
- * ARCFOUR or ARC4 because RC4 is how it is refered to in the SSH1 specification.
+ * ARCFOUR or ARC4 because RC4 is how it is referred to in the SSH1 specification.
  *
  * Here's a short example of how to use this library:
  * <code>
  * <?php
- *    include('Crypt/RC4.php');
+ *    include 'vendor/autoload.php';
  *
- *    $rc4 = new Crypt_RC4();
+ *    $rc4 = new \phpseclib\Crypt\RC4();
  *
  *    $rc4->setKey('abcdefgh');
  *
@@ -35,198 +34,137 @@
  * ?>
  * </code>
  *
- * LICENSE: This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA  02111-1307  USA
- *
- * @category   Crypt
- * @package    Crypt_RC4
- * @author     Jim Wigginton <terrafrost@php.net>
- * @copyright  MMVII Jim Wigginton
- * @license    http://www.gnu.org/licenses/lgpl.txt
- * @version    $Id: RC4.php,v 1.8 2009/06/09 04:00:38 terrafrost Exp $
- * @link       http://phpseclib.sourceforge.net
+ * @category  Crypt
+ * @package   RC4
+ * @author    Jim Wigginton <terrafrost@php.net>
+ * @copyright 2007 Jim Wigginton
+ * @license   http://www.opensource.org/licenses/mit-license.html  MIT License
+ * @link      http://phpseclib.sourceforge.net
  */
 
-/**#@+
- * @access private
- * @see Crypt_RC4::Crypt_RC4()
- */
-/**
- * Toggles the internal implementation
- */
-define('CRYPT_RC4_MODE_INTERNAL', 1);
-/**
- * Toggles the mcrypt implementation
- */
-define('CRYPT_RC4_MODE_MCRYPT', 2);
-/**#@-*/
-
-/**#@+
- * @access private
- * @see Crypt_RC4::_crypt()
- */
-define('CRYPT_RC4_ENCRYPT', 0);
-define('CRYPT_RC4_DECRYPT', 1);
-/**#@-*/
+namespace phpseclib\Crypt;
 
 /**
  * Pure-PHP implementation of RC4.
  *
+ * @package RC4
  * @author  Jim Wigginton <terrafrost@php.net>
- * @version 0.1.0
  * @access  public
- * @package Crypt_RC4
  */
-class Crypt_RC4 {
-    /**
-     * The Key
-     *
-     * @see Crypt_RC4::setKey()
-     * @var String
+class RC4 extends Base
+{
+    /**#@+
      * @access private
-     */
-    var $key = "\0";
+     * @see \phpseclib\Crypt\RC4::_crypt()
+    */
+    const ENCRYPT = 0;
+    const DECRYPT = 1;
+    /**#@-*/
 
     /**
-     * The Key Stream for encryption
+     * Block Length of the cipher
      *
-     * If CRYPT_RC4_MODE == CRYPT_RC4_MODE_MCRYPT, this will be equal to the mcrypt object
+     * RC4 is a stream cipher
+     * so we the block_size to 0
      *
-     * @see Crypt_RC4::setKey()
-     * @var Array
+     * @see \phpseclib\Crypt\Base::block_size
+     * @var int
      * @access private
      */
-    var $encryptStream = false;
+    var $block_size = 0;
 
     /**
-     * The Key Stream for decryption
-     *
-     * If CRYPT_RC4_MODE == CRYPT_RC4_MODE_MCRYPT, this will be equal to the mcrypt object
+     * Key Length (in bytes)
      *
-     * @see Crypt_RC4::setKey()
-     * @var Array
+     * @see \phpseclib\Crypt\RC4::setKeyLength()
+     * @var int
      * @access private
      */
-    var $decryptStream = false;
+    var $key_length = 128; // = 1024 bits
 
     /**
-     * The $i and $j indexes for encryption
+     * The mcrypt specific name of the cipher
      *
-     * @see Crypt_RC4::_crypt()
-     * @var Integer
+     * @see \phpseclib\Crypt\Base::cipher_name_mcrypt
+     * @var string
      * @access private
      */
-    var $encryptIndex = 0;
+    var $cipher_name_mcrypt = 'arcfour';
 
     /**
-     * The $i and $j indexes for decryption
+     * Holds whether performance-optimized $inline_crypt() can/should be used.
      *
-     * @see Crypt_RC4::_crypt()
-     * @var Integer
+     * @see \phpseclib\Crypt\Base::inline_crypt
+     * @var mixed
      * @access private
      */
-    var $decryptIndex = 0;
+    var $use_inline_crypt = false; // currently not available
 
     /**
-     * MCrypt parameters
+     * The Key
      *
-     * @see Crypt_RC4::setMCrypt()
-     * @var Array
+     * @see self::setKey()
+     * @var string
      * @access private
      */
-    var $mcrypt = array('', '');
+    var $key;
 
     /**
-     * The Encryption Algorithm
-     *
-     * Only used if CRYPT_RC4_MODE == CRYPT_RC4_MODE_MCRYPT.  Only possible values are MCRYPT_RC4 or MCRYPT_ARCFOUR.
+     * The Key Stream for decryption and encryption
      *
-     * @see Crypt_RC4::Crypt_RC4()
-     * @var Integer
+     * @see self::setKey()
+     * @var array
      * @access private
      */
-    var $mode;
+    var $stream;
 
     /**
      * Default Constructor.
      *
      * Determines whether or not the mcrypt extension should be used.
      *
-     * @param optional Integer $mode
-     * @return Crypt_RC4
+     * @see \phpseclib\Crypt\Base::__construct()
+     * @return \phpseclib\Crypt\RC4
      * @access public
      */
-    function Crypt_RC4()
+    function __construct()
     {
-        if ( !defined('CRYPT_RC4_MODE') ) {
-            switch (true) {
-                case extension_loaded('mcrypt') && (defined('MCRYPT_ARCFOUR') || defined('MCRYPT_RC4')):
-                    // i'd check to see if rc4 was supported, by doing in_array('arcfour', mcrypt_list_algorithms('')),
-                    // but since that can be changed after the object has been created, there doesn't seem to be
-                    // a lot of point...
-                    define('CRYPT_RC4_MODE', CRYPT_RC4_MODE_MCRYPT);
-                    break;
-                default:
-                    define('CRYPT_RC4_MODE', CRYPT_RC4_MODE_INTERNAL);
-            }
-        }
-
-        switch ( CRYPT_RC4_MODE ) {
-            case CRYPT_RC4_MODE_MCRYPT:
-                switch (true) {
-                    case defined('MCRYPT_ARCFOUR'):
-                        $this->mode = MCRYPT_ARCFOUR;
-                        break;
-                    case defined('MCRYPT_RC4');
-                        $this->mode = MCRYPT_RC4;
-                }
-        }
+        parent::__construct(Base::MODE_STREAM);
     }
 
     /**
-     * Sets the key.
+     * Test for engine validity
      *
-     * Keys can be between 1 and 256 bytes long.  If they are longer then 256 bytes, the first 256 bytes will
-     * be used.  If no key is explicitly set, it'll be assumed to be a single null byte.
+     * This is mainly just a wrapper to set things up for \phpseclib\Crypt\Base::isValidEngine()
      *
+     * @see \phpseclib\Crypt\Base::__construct()
+     * @param int $engine
      * @access public
-     * @param String $key
+     * @return bool
      */
-    function setKey($key)
+    function isValidEngine($engine)
     {
-        $this->key = $key;
-
-        if ( CRYPT_RC4_MODE == CRYPT_RC4_MODE_MCRYPT ) {
-            return;
-        }
-
-        $keyLength = strlen($key);
-        $keyStream = array();
-        for ($i = 0; $i < 256; $i++) {
-            $keyStream[$i] = $i;
-        }
-        $j = 0;
-        for ($i = 0; $i < 256; $i++) {
-            $j = ($j + $keyStream[$i] + ord($key[$i % $keyLength])) & 255;
-            $temp = $keyStream[$i];
-            $keyStream[$i] = $keyStream[$j];
-            $keyStream[$j] = $temp;
+        if ($engine == Base::ENGINE_OPENSSL) {
+            if (version_compare(PHP_VERSION, '5.3.7') >= 0) {
+                $this->cipher_name_openssl = 'rc4-40';
+            } else {
+                switch (strlen($this->key)) {
+                    case 5:
+                        $this->cipher_name_openssl = 'rc4-40';
+                        break;
+                    case 8:
+                        $this->cipher_name_openssl = 'rc4-64';
+                        break;
+                    case 16:
+                        $this->cipher_name_openssl = 'rc4';
+                        break;
+                    default:
+                        return false;
+                }
+            }
         }
 
-        $this->encryptIndex = $this->decryptIndex = array(0, 0);
-        $this->encryptStream = $this->decryptStream = $keyStream;
+        return parent::isValidEngine($engine);
     }
 
     /**
@@ -244,8 +182,8 @@ class Crypt_RC4 {
      * {@link http://www.rsa.com/rsalabs/node.asp?id=2009 http://www.rsa.com/rsalabs/node.asp?id=2009}
      * {@link http://en.wikipedia.org/wiki/Related_key_attack http://en.wikipedia.org/wiki/Related_key_attack}
      *
-     * @param String $iv
-     * @see Crypt_RC4::setKey()
+     * @param string $iv
+     * @see self::setKey()
      * @access public
      */
     function setIV($iv)
@@ -253,241 +191,152 @@ class Crypt_RC4 {
     }
 
     /**
-     * Sets MCrypt parameters. (optional)
+     * Sets the key length
      *
-     * If MCrypt is being used, empty strings will be used, unless otherwise specified.
+     * Keys can be between 1 and 256 bytes long.
      *
-     * @link http://php.net/function.mcrypt-module-open#function.mcrypt-module-open
      * @access public
-     * @param optional Integer $algorithm_directory
-     * @param optional Integer $mode_directory
+     * @param int $length
      */
-    function setMCrypt($algorithm_directory = '', $mode_directory = '')
+    function setKeyLength($length)
     {
-        if ( CRYPT_RC4_MODE == CRYPT_RC4_MODE_MCRYPT ) {
-            $this->mcrypt = array($algorithm_directory, $mode_directory);
-            $this->_closeMCrypt();
+        if ($length < 8) {
+            $this->key_length = 1;
+        } elseif ($length > 2048) {
+            $this->key_length = 256;
+        } else {
+            $this->key_length = $length >> 3;
         }
+
+        parent::setKeyLength($length);
     }
 
     /**
      * Encrypts a message.
      *
-     * @see Crypt_RC4::_crypt()
+     * @see \phpseclib\Crypt\Base::decrypt()
+     * @see self::_crypt()
      * @access public
-     * @param String $plaintext
+     * @param string $plaintext
+     * @return string $ciphertext
      */
     function encrypt($plaintext)
     {
-        return $this->_crypt($plaintext, CRYPT_RC4_ENCRYPT);
+        if ($this->engine != Base::ENGINE_INTERNAL) {
+            return parent::encrypt($plaintext);
+        }
+        return $this->_crypt($plaintext, self::ENCRYPT);
     }
 
     /**
      * Decrypts a message.
      *
      * $this->decrypt($this->encrypt($plaintext)) == $this->encrypt($this->encrypt($plaintext)).
-     * Atleast if the continuous buffer is disabled.
+     * At least if the continuous buffer is disabled.
      *
-     * @see Crypt_RC4::_crypt()
+     * @see \phpseclib\Crypt\Base::encrypt()
+     * @see self::_crypt()
      * @access public
-     * @param String $ciphertext
+     * @param string $ciphertext
+     * @return string $plaintext
      */
     function decrypt($ciphertext)
     {
-        return $this->_crypt($ciphertext, CRYPT_RC4_DECRYPT);
+        if ($this->engine != Base::ENGINE_INTERNAL) {
+            return parent::decrypt($ciphertext);
+        }
+        return $this->_crypt($ciphertext, self::DECRYPT);
     }
 
     /**
-     * Encrypts or decrypts a message.
+     * Encrypts a block
      *
-     * @see Crypt_RC4::encrypt()
-     * @see Crypt_RC4::decrypt()
      * @access private
-     * @param String $text
-     * @param Integer $mode
+     * @param string $in
      */
-    function _crypt($text, $mode)
+    function _encryptBlock($in)
     {
-        if ( CRYPT_RC4_MODE == CRYPT_RC4_MODE_MCRYPT ) {
-            $keyStream = $mode == CRYPT_RC4_ENCRYPT ? 'encryptStream' : 'decryptStream';
-
-            if ($this->$keyStream === false) {
-                $this->$keyStream = mcrypt_module_open($this->mode, $this->mcrypt[0], MCRYPT_MODE_STREAM, $this->mcrypt[1]);
-                mcrypt_generic_init($this->$keyStream, $this->key, '');
-            } else if (!$this->continuousBuffer) {
-                mcrypt_generic_init($this->$keyStream, $this->key, '');
-            }
-            $newText = mcrypt_generic($this->$keyStream, $text);
-            if (!$this->continuousBuffer) {
-                mcrypt_generic_deinit($this->$keyStream);
-            }
-
-            return $newText;
-        }
-
-        if ($this->encryptStream === false) {
-            $this->setKey($this->key);
-        }
-
-        switch ($mode) {
-            case CRYPT_RC4_ENCRYPT:
-                $keyStream = $this->encryptStream;
-                list($i, $j) = $this->encryptIndex;
-                break;
-            case CRYPT_RC4_DECRYPT:
-                $keyStream = $this->decryptStream;
-                list($i, $j) = $this->decryptIndex;
-        }
-
-        $newText = '';
-        for ($k = 0; $k < strlen($text); $k++) {
-            $i = ($i + 1) & 255;
-            $j = ($j + $keyStream[$i]) & 255;
-            $temp = $keyStream[$i];
-            $keyStream[$i] = $keyStream[$j];
-            $keyStream[$j] = $temp;
-            $temp = $keyStream[($keyStream[$i] + $keyStream[$j]) & 255];
-            $newText.= chr(ord($text[$k]) ^ $temp);
-        }
-
-        if ($this->continuousBuffer) {
-            switch ($mode) {
-                case CRYPT_RC4_ENCRYPT:
-                    $this->encryptStream = $keyStream;
-                    $this->encryptIndex = array($i, $j);
-                    break;
-                case CRYPT_RC4_DECRYPT:
-                    $this->decryptStream = $keyStream;
-                    $this->decryptIndex = array($i, $j);
-            }
-        }
-
-        return $newText;
+        // RC4 does not utilize this method
     }
 
     /**
-     * Treat consecutive "packets" as if they are a continuous buffer.
-     *
-     * Say you have a 16-byte plaintext $plaintext.  Using the default behavior, the two following code snippets
-     * will yield different outputs:
-     *
-     * <code>
-     *    echo $rc4->encrypt(substr($plaintext, 0, 8));
-     *    echo $rc4->encrypt(substr($plaintext, 8, 8));
-     * </code>
-     * <code>
-     *    echo $rc4->encrypt($plaintext);
-     * </code>
+     * Decrypts a block
      *
-     * The solution is to enable the continuous buffer.  Although this will resolve the above discrepancy, it creates
-     * another, as demonstrated with the following:
-     *
-     * <code>
-     *    $rc4->encrypt(substr($plaintext, 0, 8));
-     *    echo $rc4->decrypt($des->encrypt(substr($plaintext, 8, 8)));
-     * </code>
-     * <code>
-     *    echo $rc4->decrypt($des->encrypt(substr($plaintext, 8, 8)));
-     * </code>
-     *
-     * With the continuous buffer disabled, these would yield the same output.  With it enabled, they yield different
-     * outputs.  The reason is due to the fact that the initialization vector's change after every encryption /
-     * decryption round when the continuous buffer is enabled.  When it's disabled, they remain constant.
-     *
-     * Put another way, when the continuous buffer is enabled, the state of the Crypt_DES() object changes after each
-     * encryption / decryption round, whereas otherwise, it'd remain constant.  For this reason, it's recommended that
-     * continuous buffers not be used.  They do offer better security and are, in fact, sometimes required (SSH uses them),
-     * however, they are also less intuitive and more likely to cause you problems.
-     *
-     * @see Crypt_RC4::disableContinuousBuffer()
-     * @access public
+     * @access private
+     * @param string $in
      */
-    function enableContinuousBuffer()
+    function _decryptBlock($in)
     {
-        $this->continuousBuffer = true;
+        // RC4 does not utilize this method
     }
 
     /**
-     * Treat consecutive packets as if they are a discontinuous buffer.
-     *
-     * The default behavior.
+     * Setup the key (expansion)
      *
-     * @see Crypt_RC4::enableContinuousBuffer()
-     * @access public
+     * @see \phpseclib\Crypt\Base::_setupKey()
+     * @access private
      */
-    function disableContinuousBuffer()
+    function _setupKey()
     {
-        if ( CRYPT_RC4_MODE == CRYPT_RC4_MODE_INTERNAL ) {
-            $this->encryptIndex = $this->decryptIndex = array(0, 0);
-            $this->setKey($this->key);
+        $key = $this->key;
+        $keyLength = strlen($key);
+        $keyStream = range(0, 255);
+        $j = 0;
+        for ($i = 0; $i < 256; $i++) {
+            $j = ($j + $keyStream[$i] + ord($key[$i % $keyLength])) & 255;
+            $temp = $keyStream[$i];
+            $keyStream[$i] = $keyStream[$j];
+            $keyStream[$j] = $temp;
         }
 
-        $this->continuousBuffer = false;
+        $this->stream = array();
+        $this->stream[self::DECRYPT] = $this->stream[self::ENCRYPT] = array(
+            0, // index $i
+            0, // index $j
+            $keyStream
+        );
     }
 
     /**
-     * Dummy function.
-     *
-     * Since RC4 is a stream cipher and not a block cipher, no padding is necessary.  The only reason this function is
-     * included is so that you can switch between a block cipher and a stream cipher transparently.
-     *
-     * @see Crypt_RC4::disablePadding()
-     * @access public
-     */
-    function enablePadding()
-    {
-    }
-
-    /**
-     * Dummy function.
-     *
-     * @see Crypt_RC4::enablePadding()
-     * @access public
-     */
-    function disablePadding()
-    {
-    }
-
-    /**
-     * Class destructor.
-     *
-     * Will be called, automatically, if you're using PHP5.  If you're using PHP4, call it yourself.  Only really
-     * needs to be called if mcrypt is being used.
+     * Encrypts or decrypts a message.
      *
-     * @access public
+     * @see self::encrypt()
+     * @see self::decrypt()
+     * @access private
+     * @param string $text
+     * @param int $mode
+     * @return string $text
      */
-    function __destruct()
+    function _crypt($text, $mode)
     {
-        if ( CRYPT_RC4_MODE == CRYPT_RC4_MODE_MCRYPT ) {
-            $this->_closeMCrypt();
+        if ($this->changed) {
+            $this->_setup();
+            $this->changed = false;
         }
-    }
-
-    /**
-     * Properly close the MCrypt objects.
-     *
-     * @access prviate
-     */
-    function _closeMCrypt()
-    {
-        if ( $this->encryptStream !== false ) {
-            if ( $this->continuousBuffer ) {
-                mcrypt_generic_deinit($this->encryptStream);
-            }
-
-            mcrypt_module_close($this->encryptStream);
 
-            $this->encryptStream = false;
+        $stream = &$this->stream[$mode];
+        if ($this->continuousBuffer) {
+            $i = &$stream[0];
+            $j = &$stream[1];
+            $keyStream = &$stream[2];
+        } else {
+            $i = $stream[0];
+            $j = $stream[1];
+            $keyStream = $stream[2];
         }
 
-        if ( $this->decryptStream !== false ) {
-            if ( $this->continuousBuffer ) {
-                mcrypt_generic_deinit($this->decryptStream);
-            }
-
-            mcrypt_module_close($this->decryptStream);
+        $len = strlen($text);
+        for ($k = 0; $k < $len; ++$k) {
+            $i = ($i + 1) & 255;
+            $ksi = $keyStream[$i];
+            $j = ($j + $ksi) & 255;
+            $ksj = $keyStream[$j];
 
-            $this->decryptStream = false;
+            $keyStream[$i] = $ksj;
+            $keyStream[$j] = $ksi;
+            $text[$k] = $text[$k] ^ chr($keyStream[($ksj + $ksi) & 255]);
         }
+
+        return $text;
     }
 }
diff --git a/lib/phpseclib/Crypt/RSA.php b/lib/phpseclib/Crypt/RSA.php
index 4d352ca..c15e86d 100644
--- a/lib/phpseclib/Crypt/RSA.php
+++ b/lib/phpseclib/Crypt/RSA.php
@@ -1,17 +1,16 @@
 <?php
-/* vim: set expandtab tabstop=4 shiftwidth=4 softtabstop=4: */
 
 /**
  * Pure-PHP PKCS#1 (v2.1) compliant implementation of RSA.
  *
- * PHP versions 4 and 5
+ * PHP version 5
  *
  * Here's an example of how to encrypt and decrypt text with this library:
  * <code>
  * <?php
- *    include('Crypt/RSA.php');
+ *    include 'vendor/autoload.php';
  *
- *    $rsa = new Crypt_RSA();
+ *    $rsa = new \phpseclib\Crypt\RSA();
  *    extract($rsa->createKey());
  *
  *    $plaintext = 'terrafrost';
@@ -27,9 +26,9 @@
  * Here's an example of how to create signatures and verify signatures with this library:
  * <code>
  * <?php
- *    include('Crypt/RSA.php');
+ *    include 'vendor/autoload.php';
  *
- *    $rsa = new Crypt_RSA();
+ *    $rsa = new \phpseclib\Crypt\RSA();
  *    extract($rsa->createKey());
  *
  *    $plaintext = 'terrafrost';
@@ -42,180 +41,211 @@
  * ?>
  * </code>
  *
- * LICENSE: This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA  02111-1307  USA
- *
- * @category   Crypt
- * @package    Crypt_RSA
- * @author     Jim Wigginton <terrafrost@php.net>
- * @copyright  MMIX Jim Wigginton
- * @license    http://www.gnu.org/licenses/lgpl.txt
- * @version    $Id: RSA.php,v 1.15 2010/04/10 15:57:02 terrafrost Exp $
- * @link       http://phpseclib.sourceforge.net
+ * @category  Crypt
+ * @package   RSA
+ * @author    Jim Wigginton <terrafrost@php.net>
+ * @copyright 2009 Jim Wigginton
+ * @license   http://www.opensource.org/licenses/mit-license.html  MIT License
+ * @link      http://phpseclib.sourceforge.net
  */
 
-/**
- * Include Math_BigInteger
- */
-require_once('Math/BigInteger.php');
+namespace phpseclib\Crypt;
 
-/**
- * Include Crypt_Random
- */
-require_once('Crypt/Random.php');
-
-/**
- * Include Crypt_Hash
- */
-require_once('Crypt/Hash.php');
+use phpseclib\Math\BigInteger;
 
-/**#@+
- * @access public
- * @see Crypt_RSA::encrypt()
- * @see Crypt_RSA::decrypt()
- */
-/**
- * Use {@link http://en.wikipedia.org/wiki/Optimal_Asymmetric_Encryption_Padding Optimal Asymmetric Encryption Padding}
- * (OAEP) for encryption / decryption.
- *
- * Uses sha1 by default.
- *
- * @see Crypt_RSA::setHash()
- * @see Crypt_RSA::setMGFHash()
- */
-define('CRYPT_RSA_ENCRYPTION_OAEP',  1);
-/**
- * Use PKCS#1 padding.
- *
- * Although CRYPT_RSA_ENCRYPTION_OAEP offers more security, including PKCS#1 padding is necessary for purposes of backwards
- * compatability with protocols (like SSH-1) written before OAEP's introduction.
- */
-define('CRYPT_RSA_ENCRYPTION_PKCS1', 2);
-/**#@-*/
-
-/**#@+
- * @access public
- * @see Crypt_RSA::sign()
- * @see Crypt_RSA::verify()
- * @see Crypt_RSA::setHash()
- */
-/**
- * Use the Probabilistic Signature Scheme for signing
- *
- * Uses sha1 by default.
- *
- * @see Crypt_RSA::setSaltLength()
- * @see Crypt_RSA::setMGFHash()
- */
-define('CRYPT_RSA_SIGNATURE_PSS',  1);
 /**
- * Use the PKCS#1 scheme by default.
+ * Pure-PHP PKCS#1 compliant implementation of RSA.
  *
- * Although CRYPT_RSA_SIGNATURE_PSS offers more security, including PKCS#1 signing is necessary for purposes of backwards
- * compatability with protocols (like SSH-2) written before PSS's introduction.
+ * @package RSA
+ * @author  Jim Wigginton <terrafrost@php.net>
+ * @access  public
  */
-define('CRYPT_RSA_SIGNATURE_PKCS1', 2);
-/**#@-*/
+class RSA
+{
+    /**#@+
+     * @access public
+     * @see self::encrypt()
+     * @see self::decrypt()
+     */
+    /**
+     * Use {@link http://en.wikipedia.org/wiki/Optimal_Asymmetric_Encryption_Padding Optimal Asymmetric Encryption Padding}
+     * (OAEP) for encryption / decryption.
+     *
+     * Uses sha1 by default.
+     *
+     * @see self::setHash()
+     * @see self::setMGFHash()
+     */
+    const ENCRYPTION_OAEP = 1;
+    /**
+     * Use PKCS#1 padding.
+     *
+     * Although self::ENCRYPTION_OAEP offers more security, including PKCS#1 padding is necessary for purposes of backwards
+     * compatibility with protocols (like SSH-1) written before OAEP's introduction.
+     */
+    const ENCRYPTION_PKCS1 = 2;
+    /**
+     * Do not use any padding
+     *
+     * Although this method is not recommended it can none-the-less sometimes be useful if you're trying to decrypt some legacy
+     * stuff, if you're trying to diagnose why an encrypted message isn't decrypting, etc.
+     */
+    const ENCRYPTION_NONE = 3;
+    /**#@-*/
 
-/**#@+
- * @access private
- * @see Crypt_RSA::createKey()
- */
-/**
- * ASN1 Integer
- */
-define('CRYPT_RSA_ASN1_INTEGER',   2);
-/**
- * ASN1 Sequence (with the constucted bit set)
- */
-define('CRYPT_RSA_ASN1_SEQUENCE', 48);
-/**#@-*/
+    /**#@+
+     * @access public
+     * @see self::sign()
+     * @see self::verify()
+     * @see self::setHash()
+    */
+    /**
+     * Use the Probabilistic Signature Scheme for signing
+     *
+     * Uses sha1 by default.
+     *
+     * @see self::setSaltLength()
+     * @see self::setMGFHash()
+     */
+    const SIGNATURE_PSS = 1;
+    /**
+     * Use the PKCS#1 scheme by default.
+     *
+     * Although self::SIGNATURE_PSS offers more security, including PKCS#1 signing is necessary for purposes of backwards
+     * compatibility with protocols (like SSH-2) written before PSS's introduction.
+     */
+    const SIGNATURE_PKCS1 = 2;
+    /**#@-*/
 
-/**#@+
- * @access private
- * @see Crypt_RSA::Crypt_RSA()
- */
-/**
- * To use the pure-PHP implementation
- */
-define('CRYPT_RSA_MODE_INTERNAL', 1);
-/**
- * To use the OpenSSL library
- *
- * (if enabled; otherwise, the internal implementation will be used)
- */
-define('CRYPT_RSA_MODE_OPENSSL', 2);
-/**#@-*/
+    /**#@+
+     * @access private
+     * @see \phpseclib\Crypt\RSA::createKey()
+    */
+    /**
+     * ASN1 Integer
+     */
+    const ASN1_INTEGER = 2;
+    /**
+     * ASN1 Bit String
+     */
+    const ASN1_BITSTRING = 3;
+    /**
+     * ASN1 Octet String
+     */
+    const ASN1_OCTETSTRING = 4;
+    /**
+     * ASN1 Object Identifier
+     */
+    const ASN1_OBJECT = 6;
+    /**
+     * ASN1 Sequence (with the constucted bit set)
+     */
+    const ASN1_SEQUENCE = 48;
+    /**#@-*/
 
-/**#@+
- * @access public
- * @see Crypt_RSA::createKey()
- * @see Crypt_RSA::setPrivateKeyFormat()
- */
-/**
- * PKCS#1 formatted private key
- *
- * Used by OpenSSH
- */
-define('CRYPT_RSA_PRIVATE_FORMAT_PKCS1', 0);
-/**#@-*/
+    /**#@+
+     * @access private
+     * @see \phpseclib\Crypt\RSA::__construct()
+    */
+    /**
+     * To use the pure-PHP implementation
+     */
+    const MODE_INTERNAL = 1;
+    /**
+     * To use the OpenSSL library
+     *
+     * (if enabled; otherwise, the internal implementation will be used)
+     */
+    const MODE_OPENSSL = 2;
+    /**#@-*/
 
-/**#@+
- * @access public
- * @see Crypt_RSA::createKey()
- * @see Crypt_RSA::setPublicKeyFormat()
- */
-/**
- * Raw public key
- *
- * An array containing two Math_BigInteger objects.
- *
- * The exponent can be indexed with any of the following:
- *
- * 0, e, exponent, publicExponent
- *
- * The modulus can be indexed with any of the following:
- *
- * 1, n, modulo, modulus
- */
-define('CRYPT_RSA_PUBLIC_FORMAT_RAW', 1);
-/**
- * PKCS#1 formatted public key
- */
-define('CRYPT_RSA_PUBLIC_FORMAT_PKCS1', 2);
-/**
- * OpenSSH formatted public key
- *
- * Place in $HOME/.ssh/authorized_keys
- */
-define('CRYPT_RSA_PUBLIC_FORMAT_OPENSSH', 3);
-/**#@-*/
+    /**#@+
+     * @access public
+     * @see \phpseclib\Crypt\RSA::createKey()
+     * @see \phpseclib\Crypt\RSA::setPrivateKeyFormat()
+    */
+    /**
+     * PKCS#1 formatted private key
+     *
+     * Used by OpenSSH
+     */
+    const PRIVATE_FORMAT_PKCS1 = 0;
+    /**
+     * PuTTY formatted private key
+     */
+    const PRIVATE_FORMAT_PUTTY = 1;
+    /**
+     * XML formatted private key
+     */
+    const PRIVATE_FORMAT_XML = 2;
+    /**
+     * PKCS#8 formatted private key
+     */
+    const PRIVATE_FORMAT_PKCS8 = 8;
+    /**#@-*/
+
+    /**#@+
+     * @access public
+     * @see \phpseclib\Crypt\RSA::createKey()
+     * @see \phpseclib\Crypt\RSA::setPublicKeyFormat()
+    */
+    /**
+     * Raw public key
+     *
+     * An array containing two \phpseclib\Math\BigInteger objects.
+     *
+     * The exponent can be indexed with any of the following:
+     *
+     * 0, e, exponent, publicExponent
+     *
+     * The modulus can be indexed with any of the following:
+     *
+     * 1, n, modulo, modulus
+     */
+    const PUBLIC_FORMAT_RAW = 3;
+    /**
+     * PKCS#1 formatted public key (raw)
+     *
+     * Used by File/X509.php
+     *
+     * Has the following header:
+     *
+     * -----BEGIN RSA PUBLIC KEY-----
+     *
+     * Analogous to ssh-keygen's pem format (as specified by -m)
+     */
+    const PUBLIC_FORMAT_PKCS1 = 4;
+    const PUBLIC_FORMAT_PKCS1_RAW = 4;
+    /**
+     * XML formatted public key
+     */
+    const PUBLIC_FORMAT_XML = 5;
+    /**
+     * OpenSSH formatted public key
+     *
+     * Place in $HOME/.ssh/authorized_keys
+     */
+    const PUBLIC_FORMAT_OPENSSH = 6;
+    /**
+     * PKCS#1 formatted public key (encapsulated)
+     *
+     * Used by PHP's openssl_public_encrypt() and openssl's rsautl (when -pubin is set)
+     *
+     * Has the following header:
+     *
+     * -----BEGIN PUBLIC KEY-----
+     *
+     * Analogous to ssh-keygen's pkcs8 format (as specified by -m). Although PKCS8
+     * is specific to private keys it's basically creating a DER-encoded wrapper
+     * for keys. This just extends that same concept to public keys (much like ssh-keygen)
+     */
+    const PUBLIC_FORMAT_PKCS8 = 7;
+    /**#@-*/
 
-/**
- * Pure-PHP PKCS#1 compliant implementation of RSA.
- *
- * @author  Jim Wigginton <terrafrost@php.net>
- * @version 0.1.0
- * @access  public
- * @package Crypt_RSA
- */
-class Crypt_RSA {
     /**
      * Precomputed Zero
      *
-     * @var Array
+     * @var \phpseclib\Math\BigInteger
      * @access private
      */
     var $zero;
@@ -223,7 +253,7 @@ class Crypt_RSA {
     /**
      * Precomputed One
      *
-     * @var Array
+     * @var \phpseclib\Math\BigInteger
      * @access private
      */
     var $one;
@@ -231,23 +261,23 @@ class Crypt_RSA {
     /**
      * Private Key Format
      *
-     * @var Integer
+     * @var int
      * @access private
      */
-    var $privateKeyFormat = CRYPT_RSA_PRIVATE_FORMAT_PKCS1;
+    var $privateKeyFormat = self::PRIVATE_FORMAT_PKCS1;
 
     /**
      * Public Key Format
      *
-     * @var Integer
+     * @var int
      * @access public
      */
-    var $publicKeyFormat = CRYPT_RSA_PUBLIC_FORMAT_PKCS1;
+    var $publicKeyFormat = self::PUBLIC_FORMAT_PKCS8;
 
     /**
      * Modulus (ie. n)
      *
-     * @var Math_BigInteger
+     * @var \phpseclib\Math\BigInteger
      * @access private
      */
     var $modulus;
@@ -255,7 +285,7 @@ class Crypt_RSA {
     /**
      * Modulus length
      *
-     * @var Math_BigInteger
+     * @var \phpseclib\Math\BigInteger
      * @access private
      */
     var $k;
@@ -263,7 +293,7 @@ class Crypt_RSA {
     /**
      * Exponent (ie. e or d)
      *
-     * @var Math_BigInteger
+     * @var \phpseclib\Math\BigInteger
      * @access private
      */
     var $exponent;
@@ -271,7 +301,7 @@ class Crypt_RSA {
     /**
      * Primes for Chinese Remainder Theorem (ie. p and q)
      *
-     * @var Array
+     * @var array
      * @access private
      */
     var $primes;
@@ -279,7 +309,7 @@ class Crypt_RSA {
     /**
      * Exponents for Chinese Remainder Theorem (ie. dP and dQ)
      *
-     * @var Array
+     * @var array
      * @access private
      */
     var $exponents;
@@ -287,7 +317,7 @@ class Crypt_RSA {
     /**
      * Coefficients for Chinese Remainder Theorem (ie. qInv)
      *
-     * @var Array
+     * @var array
      * @access private
      */
     var $coefficients;
@@ -295,7 +325,7 @@ class Crypt_RSA {
     /**
      * Hash name
      *
-     * @var String
+     * @var string
      * @access private
      */
     var $hashName;
@@ -303,7 +333,7 @@ class Crypt_RSA {
     /**
      * Hash function
      *
-     * @var Crypt_Hash
+     * @var \phpseclib\Crypt\Hash
      * @access private
      */
     var $hash;
@@ -311,7 +341,7 @@ class Crypt_RSA {
     /**
      * Length of hash function output
      *
-     * @var Integer
+     * @var int
      * @access private
      */
     var $hLen;
@@ -319,7 +349,7 @@ class Crypt_RSA {
     /**
      * Length of salt
      *
-     * @var Integer
+     * @var int
      * @access private
      */
     var $sLen;
@@ -327,7 +357,7 @@ class Crypt_RSA {
     /**
      * Hash function for the Mask Generation Function
      *
-     * @var Crypt_Hash
+     * @var \phpseclib\Crypt\Hash
      * @access private
      */
     var $mgfHash;
@@ -335,7 +365,7 @@ class Crypt_RSA {
     /**
      * Length of MGF hash function output
      *
-     * @var Integer
+     * @var int
      * @access private
      */
     var $mgfHLen;
@@ -343,23 +373,23 @@ class Crypt_RSA {
     /**
      * Encryption mode
      *
-     * @var Integer
+     * @var int
      * @access private
      */
-    var $encryptionMode = CRYPT_RSA_ENCRYPTION_OAEP;
+    var $encryptionMode = self::ENCRYPTION_OAEP;
 
     /**
      * Signature mode
      *
-     * @var Integer
+     * @var int
      * @access private
      */
-    var $signatureMode = CRYPT_RSA_SIGNATURE_PSS;
+    var $signatureMode = self::SIGNATURE_PSS;
 
     /**
      * Public Exponent
      *
-     * @var Mixed
+     * @var mixed
      * @access private
      */
     var $publicExponent = false;
@@ -367,40 +397,127 @@ class Crypt_RSA {
     /**
      * Password
      *
-     * @var String
+     * @var string
+     * @access private
+     */
+    var $password = false;
+
+    /**
+     * Components
+     *
+     * For use with parsing XML formatted keys.  PHP's XML Parser functions use utilized - instead of PHP's DOM functions -
+     * because PHP's XML Parser functions work on PHP4 whereas PHP's DOM functions - although surperior - don't.
+     *
+     * @see self::_start_element_handler()
+     * @var array
+     * @access private
+     */
+    var $components = array();
+
+    /**
+     * Current String
+     *
+     * For use with parsing XML formatted keys.
+     *
+     * @see self::_character_handler()
+     * @see self::_stop_element_handler()
+     * @var mixed
+     * @access private
+     */
+    var $current;
+
+    /**
+     * OpenSSL configuration file name.
+     *
+     * Set to null to use system configuration file.
+     * @see self::createKey()
+     * @var mixed
+     * @Access public
+     */
+    var $configFile;
+
+    /**
+     * Public key comment field.
+     *
+     * @var string
      * @access private
      */
-    var $password = '';
+    var $comment = 'phpseclib-generated-key';
 
     /**
      * The constructor
      *
      * If you want to make use of the openssl extension, you'll need to set the mode manually, yourself.  The reason
-     * Crypt_RSA doesn't do it is because OpenSSL doesn't fail gracefully.  openssl_pkey_new(), in particular, requires
+     * \phpseclib\Crypt\RSA doesn't do it is because OpenSSL doesn't fail gracefully.  openssl_pkey_new(), in particular, requires
      * openssl.cnf be present somewhere and, unfortunately, the only real way to find out is too late.
      *
-     * @return Crypt_RSA
+     * @return \phpseclib\Crypt\RSA
      * @access public
      */
-    function Crypt_RSA()
+    function __construct()
     {
-        if ( !defined('CRYPT_RSA_MODE') ) {
+        $this->configFile = dirname(__FILE__) . '/../openssl.cnf';
+
+        if (!defined('CRYPT_RSA_MODE')) {
             switch (true) {
-                //case extension_loaded('openssl') && version_compare(PHP_VERSION, '4.2.0', '>='):
-                //    define('CRYPT_RSA_MODE', CRYPT_RSA_MODE_OPENSSL);
-                //    break;
+                // Math/BigInteger's openssl requirements are a little less stringent than Crypt/RSA's. in particular,
+                // Math/BigInteger doesn't require an openssl.cfg file whereas Crypt/RSA does. so if Math/BigInteger
+                // can't use OpenSSL it can be pretty trivially assumed, then, that Crypt/RSA can't either.
+                case defined('MATH_BIGINTEGER_OPENSSL_DISABLE'):
+                    define('CRYPT_RSA_MODE', self::MODE_INTERNAL);
+                    break;
+                case extension_loaded('openssl') && file_exists($this->configFile):
+                    // some versions of XAMPP have mismatched versions of OpenSSL which causes it not to work
+                    $versions = array();
+
+                    // avoid generating errors (even with suppression) when phpinfo() is disabled (common in production systems)
+                    if (strpos(ini_get('disable_functions'), 'phpinfo') === false) {
+                        ob_start();
+                        @phpinfo();
+                        $content = ob_get_contents();
+                        ob_end_clean();
+
+                        preg_match_all('#OpenSSL (Header|Library) Version(.*)#im', $content, $matches);
+
+                        if (!empty($matches[1])) {
+                            for ($i = 0; $i < count($matches[1]); $i++) {
+                                $fullVersion = trim(str_replace('=>', '', strip_tags($matches[2][$i])));
+
+                                // Remove letter part in OpenSSL version
+                                if (!preg_match('/(\d+\.\d+\.\d+)/i', $fullVersion, $m)) {
+                                    $versions[$matches[1][$i]] = $fullVersion;
+                                } else {
+                                    $versions[$matches[1][$i]] = $m[0];
+                                }
+                            }
+                        }
+                    }
+
+                    // it doesn't appear that OpenSSL versions were reported upon until PHP 5.3+
+                    switch (true) {
+                        case !isset($versions['Header']):
+                        case !isset($versions['Library']):
+                        case $versions['Header'] == $versions['Library']:
+                        case version_compare($versions['Header'], '1.0.0') >= 0 && version_compare($versions['Library'], '1.0.0') >= 0:
+                            define('CRYPT_RSA_MODE', self::MODE_OPENSSL);
+                            break;
+                        default:
+                            define('CRYPT_RSA_MODE', self::MODE_INTERNAL);
+                            define('MATH_BIGINTEGER_OPENSSL_DISABLE', true);
+                    }
+                    break;
                 default:
-                    define('CRYPT_RSA_MODE', CRYPT_RSA_MODE_INTERNAL);
+                    define('CRYPT_RSA_MODE', self::MODE_INTERNAL);
             }
         }
 
-        $this->zero = new Math_BigInteger();
-        $this->one = new Math_BigInteger(1);
+        $this->zero = new BigInteger();
+        $this->one = new BigInteger(1);
 
-        $this->hash = new Crypt_Hash('sha1');
+        $this->hash = new Hash('sha1');
         $this->hLen = $this->hash->getLength();
         $this->hashName = 'sha1';
-        $this->mgfHash = new Crypt_Hash('sha1');
+        $this->mgfHash = new Hash('sha1');
         $this->mgfHLen = $this->mgfHash->getLength();
     }
 
@@ -411,24 +528,45 @@ class Crypt_RSA {
      *  - 'privatekey': The private key.
      *  - 'publickey':  The public key.
      *  - 'partialkey': A partially computed key (if the execution time exceeded $timeout).
-     *                  Will need to be passed back to Crypt_RSA::createKey() as the third parameter for further processing.
+     *                  Will need to be passed back to \phpseclib\Crypt\RSA::createKey() as the third parameter for further processing.
      *
      * @access public
-     * @param optional Integer $bits
-     * @param optional Integer $timeout
-     * @param optional Math_BigInteger $p
+     * @param int $bits
+     * @param int $timeout
+     * @param array $p
      */
     function createKey($bits = 1024, $timeout = false, $partial = array())
     {
-        if ( CRYPT_RSA_MODE == CRYPT_RSA_MODE_OPENSSL ) {
-            $rsa = openssl_pkey_new(array('private_key_bits' => $bits));
-            openssl_pkey_export($rsa, $privatekey);
+        if (!defined('CRYPT_RSA_EXPONENT')) {
+            // http://en.wikipedia.org/wiki/65537_%28number%29
+            define('CRYPT_RSA_EXPONENT', '65537');
+        }
+        // per <http://cseweb.ucsd.edu/~hovav/dist/survey.pdf#page=5>, this number ought not result in primes smaller
+        // than 256 bits. as a consequence if the key you're trying to create is 1024 bits and you've set CRYPT_RSA_SMALLEST_PRIME
+        // to 384 bits then you're going to get a 384 bit prime and a 640 bit prime (384 + 1024 % 384). at least if
+        // CRYPT_RSA_MODE is set to self::MODE_INTERNAL. if CRYPT_RSA_MODE is set to self::MODE_OPENSSL then
+        // CRYPT_RSA_SMALLEST_PRIME is ignored (ie. multi-prime RSA support is more intended as a way to speed up RSA key
+        // generation when there's a chance neither gmp nor OpenSSL are installed)
+        if (!defined('CRYPT_RSA_SMALLEST_PRIME')) {
+            define('CRYPT_RSA_SMALLEST_PRIME', 4096);
+        }
+
+        // OpenSSL uses 65537 as the exponent and requires RSA keys be 384 bits minimum
+        if (CRYPT_RSA_MODE == self::MODE_OPENSSL && $bits >= 384 && CRYPT_RSA_EXPONENT == 65537) {
+            $config = array();
+            if (isset($this->configFile)) {
+                $config['config'] = $this->configFile;
+            }
+            $rsa = openssl_pkey_new(array('private_key_bits' => $bits) + $config);
+            openssl_pkey_export($rsa, $privatekey, null, $config);
             $publickey = openssl_pkey_get_details($rsa);
             $publickey = $publickey['key'];
 
-            if ($this->privateKeyFormat != CRYPT_RSA_PRIVATE_FORMAT_PKCS1) {
-                $privatekey = call_user_func_array(array($this, '_convertPrivateKey'), array_values($this->_parseKey($privatekey, CRYPT_RSA_PRIVATE_FORMAT_PKCS1)));
-                $publickey = call_user_func_array(array($this, '_convertPublicKey'), array_values($this->_parseKey($publickey, CRYPT_RSA_PUBLIC_FORMAT_PKCS1)));
+            $privatekey = call_user_func_array(array($this, '_convertPrivateKey'), array_values($this->_parseKey($privatekey, self::PRIVATE_FORMAT_PKCS1)));
+            $publickey = call_user_func_array(array($this, '_convertPublicKey'), array_values($this->_parseKey($publickey, self::PUBLIC_FORMAT_PKCS1)));
+
+            // clear the buffer of error strings stemming from a minimalistic openssl.cnf
+            while (openssl_error_string() !== false) {
             }
 
             return array(
@@ -440,25 +578,12 @@ class Crypt_RSA {
 
         static $e;
         if (!isset($e)) {
-            if (!defined('CRYPT_RSA_EXPONENT')) {
-                // http://en.wikipedia.org/wiki/65537_%28number%29
-                define('CRYPT_RSA_EXPONENT', '65537');
-            }
-            if (!defined('CRYPT_RSA_COMMENT')) {
-                define('CRYPT_RSA_COMMENT', 'phpseclib-generated-key');
-            }
-            // per <http://cseweb.ucsd.edu/~hovav/dist/survey.pdf#page=5>, this number ought not result in primes smaller
-            // than 256 bits.
-            if (!defined('CRYPT_RSA_SMALLEST_PRIME')) {
-                define('CRYPT_RSA_SMALLEST_PRIME', 4096);
-            }
-
-            $e = new Math_BigInteger(CRYPT_RSA_EXPONENT);
+            $e = new BigInteger(CRYPT_RSA_EXPONENT);
         }
 
         extract($this->_generateMinMax($bits));
         $absoluteMin = $min;
-        $temp = $bits >> 1;
+        $temp = $bits >> 1; // divide by two to see how many bits P and Q would be
         if ($temp > CRYPT_RSA_SMALLEST_PRIME) {
             $num_primes = floor($bits / CRYPT_RSA_SMALLEST_PRIME);
             $temp = CRYPT_RSA_SMALLEST_PRIME;
@@ -469,8 +594,7 @@ class Crypt_RSA {
         $finalMax = $max;
         extract($this->_generateMinMax($temp));
 
-        $generator = new Math_BigInteger();
-        $generator->setRandomGenerator('crypt_random');
+        $generator = new BigInteger();
 
         $n = $this->one->copy();
         if (!empty($partial)) {
@@ -492,16 +616,16 @@ class Crypt_RSA {
                     $timeout-= time() - $start;
                     $start = time();
                     if ($timeout <= 0) {
-                        return serialize(array(
+                        return array(
                             'privatekey' => '',
                             'publickey'  => '',
-                            'partialkey' => array(
+                            'partialkey' => serialize(array(
                                 'primes' => $primes,
                                 'coefficients' => $coefficients,
                                 'lcm' => $lcm,
                                 'exponents' => $exponents
-                            )
-                        ));
+                            ))
+                        );
                     }
                 }
 
@@ -516,15 +640,22 @@ class Crypt_RSA {
                 }
 
                 if ($primes[$i] === false) { // if we've reached the timeout
-                    return array(
-                        'privatekey' => '',
-                        'publickey'  => '',
-                        'partialkey' => empty($primes) ? '' : serialize(array(
-                            'primes' => array_slice($primes, 0, $i - 1),
+                    if (count($primes) > 1) {
+                        $partialkey = '';
+                    } else {
+                        array_pop($primes);
+                        $partialkey = serialize(array(
+                            'primes' => $primes,
                             'coefficients' => $coefficients,
                             'lcm' => $lcm,
                             'exponents' => $exponents
-                        ))
+                        ));
+                    }
+
+                    return array(
+                        'privatekey' => '',
+                        'publickey'  => '',
+                        'partialkey' => $partialkey
                     );
                 }
 
@@ -546,12 +677,12 @@ class Crypt_RSA {
                 $exponents[$i] = $e->modInverse($temp);
             }
 
-            list($lcm) = $lcm['top']->divide($lcm['bottom']);
-            $gcd = $lcm->gcd($e);
+            list($temp) = $lcm['top']->divide($lcm['bottom']);
+            $gcd = $temp->gcd($e);
             $i0 = 1;
         } while (!$gcd->equals($this->one));
 
-        $d = $e->modInverse($lcm);
+        $d = $e->modInverse($temp);
 
         $coefficients[2] = $primes[2]->modInverse($primes[1]);
 
@@ -580,32 +711,119 @@ class Crypt_RSA {
      * Convert a private key to the appropriate format.
      *
      * @access private
-     * @see setPrivateKeyFormat()
-     * @param String $RSAPrivateKey
-     * @return String
+     * @see self::setPrivateKeyFormat()
+     * @param string $RSAPrivateKey
+     * @return string
      */
     function _convertPrivateKey($n, $e, $d, $primes, $exponents, $coefficients)
     {
+        $signed = $this->privateKeyFormat != self::PRIVATE_FORMAT_XML;
         $num_primes = count($primes);
         $raw = array(
             'version' => $num_primes == 2 ? chr(0) : chr(1), // two-prime vs. multi
-            'modulus' => $n->toBytes(true),
-            'publicExponent' => $e->toBytes(true),
-            'privateExponent' => $d->toBytes(true),
-            'prime1' => $primes[1]->toBytes(true),
-            'prime2' => $primes[2]->toBytes(true),
-            'exponent1' => $exponents[1]->toBytes(true),
-            'exponent2' => $exponents[2]->toBytes(true),
-            'coefficient' => $coefficients[2]->toBytes(true)
+            'modulus' => $n->toBytes($signed),
+            'publicExponent' => $e->toBytes($signed),
+            'privateExponent' => $d->toBytes($signed),
+            'prime1' => $primes[1]->toBytes($signed),
+            'prime2' => $primes[2]->toBytes($signed),
+            'exponent1' => $exponents[1]->toBytes($signed),
+            'exponent2' => $exponents[2]->toBytes($signed),
+            'coefficient' => $coefficients[2]->toBytes($signed)
         );
 
         // if the format in question does not support multi-prime rsa and multi-prime rsa was used,
         // call _convertPublicKey() instead.
         switch ($this->privateKeyFormat) {
-            default: // eg. CRYPT_RSA_PRIVATE_FORMAT_PKCS1
+            case self::PRIVATE_FORMAT_XML:
+                if ($num_primes != 2) {
+                    return false;
+                }
+                return "<RSAKeyValue>\r\n" .
+                       '  <Modulus>' . base64_encode($raw['modulus']) . "</Modulus>\r\n" .
+                       '  <Exponent>' . base64_encode($raw['publicExponent']) . "</Exponent>\r\n" .
+                       '  <P>' . base64_encode($raw['prime1']) . "</P>\r\n" .
+                       '  <Q>' . base64_encode($raw['prime2']) . "</Q>\r\n" .
+                       '  <DP>' . base64_encode($raw['exponent1']) . "</DP>\r\n" .
+                       '  <DQ>' . base64_encode($raw['exponent2']) . "</DQ>\r\n" .
+                       '  <InverseQ>' . base64_encode($raw['coefficient']) . "</InverseQ>\r\n" .
+                       '  <D>' . base64_encode($raw['privateExponent']) . "</D>\r\n" .
+                       '</RSAKeyValue>';
+                break;
+            case self::PRIVATE_FORMAT_PUTTY:
+                if ($num_primes != 2) {
+                    return false;
+                }
+                $key = "PuTTY-User-Key-File-2: ssh-rsa\r\nEncryption: ";
+                $encryption = (!empty($this->password) || is_string($this->password)) ? 'aes256-cbc' : 'none';
+                $key.= $encryption;
+                $key.= "\r\nComment: " . $this->comment . "\r\n";
+                $public = pack(
+                    'Na*Na*Na*',
+                    strlen('ssh-rsa'),
+                    'ssh-rsa',
+                    strlen($raw['publicExponent']),
+                    $raw['publicExponent'],
+                    strlen($raw['modulus']),
+                    $raw['modulus']
+                );
+                $source = pack(
+                    'Na*Na*Na*Na*',
+                    strlen('ssh-rsa'),
+                    'ssh-rsa',
+                    strlen($encryption),
+                    $encryption,
+                    strlen($this->comment),
+                    $this->comment,
+                    strlen($public),
+                    $public
+                );
+                $public = base64_encode($public);
+                $key.= "Public-Lines: " . ((strlen($public) + 63) >> 6) . "\r\n";
+                $key.= chunk_split($public, 64);
+                $private = pack(
+                    'Na*Na*Na*Na*',
+                    strlen($raw['privateExponent']),
+                    $raw['privateExponent'],
+                    strlen($raw['prime1']),
+                    $raw['prime1'],
+                    strlen($raw['prime2']),
+                    $raw['prime2'],
+                    strlen($raw['coefficient']),
+                    $raw['coefficient']
+                );
+                if (empty($this->password) && !is_string($this->password)) {
+                    $source.= pack('Na*', strlen($private), $private);
+                    $hashkey = 'putty-private-key-file-mac-key';
+                } else {
+                    $private.= Random::string(16 - (strlen($private) & 15));
+                    $source.= pack('Na*', strlen($private), $private);
+                    $sequence = 0;
+                    $symkey = '';
+                    while (strlen($symkey) < 32) {
+                        $temp = pack('Na*', $sequence++, $this->password);
+                        $symkey.= pack('H*', sha1($temp));
+                    }
+                    $symkey = substr($symkey, 0, 32);
+                    $crypto = new AES();
+
+                    $crypto->setKey($symkey);
+                    $crypto->disablePadding();
+                    $private = $crypto->encrypt($private);
+                    $hashkey = 'putty-private-key-file-mac-key' . $this->password;
+                }
+
+                $private = base64_encode($private);
+                $key.= 'Private-Lines: ' . ((strlen($private) + 63) >> 6) . "\r\n";
+                $key.= chunk_split($private, 64);
+                $hash = new Hash('sha1');
+                $hash->setKey(pack('H*', sha1($hashkey)));
+                $key.= 'Private-MAC: ' . bin2hex($hash->hash($source)) . "\r\n";
+
+                return $key;
+            default: // eg. self::PRIVATE_FORMAT_PKCS1
                 $components = array();
                 foreach ($raw as $name => $value) {
-                    $components[$name] = pack('Ca*a*', CRYPT_RSA_ASN1_INTEGER, $this->_encodeLength(strlen($value)), $value);
+                    $components[$name] = pack('Ca*a*', self::ASN1_INTEGER, $this->_encodeLength(strlen($value)), $value);
                 }
 
                 $RSAPrivateKey = implode('', $components);
@@ -620,24 +838,85 @@ class Crypt_RSA {
                         //     exponent          INTEGER,  -- di
                         //     coefficient       INTEGER   -- ti
                         // }
-                        $OtherPrimeInfo = pack('Ca*a*', CRYPT_RSA_ASN1_INTEGER, $this->_encodeLength(strlen($primes[$i]->toBytes(true))), $primes[$i]->toBytes(true));
-                        $OtherPrimeInfo.= pack('Ca*a*', CRYPT_RSA_ASN1_INTEGER, $this->_encodeLength(strlen($exponents[$i]->toBytes(true))), $exponents[$i]->toBytes(true));
-                        $OtherPrimeInfo.= pack('Ca*a*', CRYPT_RSA_ASN1_INTEGER, $this->_encodeLength(strlen($coefficients[$i]->toBytes(true))), $coefficients[$i]->toBytes(true));
-                        $OtherPrimeInfos.= pack('Ca*a*', CRYPT_RSA_ASN1_SEQUENCE, $this->_encodeLength(strlen($OtherPrimeInfo)), $OtherPrimeInfo);
+                        $OtherPrimeInfo = pack('Ca*a*', self::ASN1_INTEGER, $this->_encodeLength(strlen($primes[$i]->toBytes(true))), $primes[$i]->toBytes(true));
+                        $OtherPrimeInfo.= pack('Ca*a*', self::ASN1_INTEGER, $this->_encodeLength(strlen($exponents[$i]->toBytes(true))), $exponents[$i]->toBytes(true));
+                        $OtherPrimeInfo.= pack('Ca*a*', self::ASN1_INTEGER, $this->_encodeLength(strlen($coefficients[$i]->toBytes(true))), $coefficients[$i]->toBytes(true));
+                        $OtherPrimeInfos.= pack('Ca*a*', self::ASN1_SEQUENCE, $this->_encodeLength(strlen($OtherPrimeInfo)), $OtherPrimeInfo);
                     }
-                    $RSAPrivateKey.= pack('Ca*a*', CRYPT_RSA_ASN1_SEQUENCE, $this->_encodeLength(strlen($OtherPrimeInfos)), $OtherPrimeInfos);
+                    $RSAPrivateKey.= pack('Ca*a*', self::ASN1_SEQUENCE, $this->_encodeLength(strlen($OtherPrimeInfos)), $OtherPrimeInfos);
                 }
 
-                $RSAPrivateKey = pack('Ca*a*', CRYPT_RSA_ASN1_SEQUENCE, $this->_encodeLength(strlen($RSAPrivateKey)), $RSAPrivateKey);
+                $RSAPrivateKey = pack('Ca*a*', self::ASN1_SEQUENCE, $this->_encodeLength(strlen($RSAPrivateKey)), $RSAPrivateKey);
+
+                if ($this->privateKeyFormat == self::PRIVATE_FORMAT_PKCS8) {
+                    $rsaOID = pack('H*', '300d06092a864886f70d0101010500'); // hex version of MA0GCSqGSIb3DQEBAQUA
+                    $RSAPrivateKey = pack(
+                        'Ca*a*Ca*a*',
+                        self::ASN1_INTEGER,
+                        "\01\00",
+                        $rsaOID,
+                        4,
+                        $this->_encodeLength(strlen($RSAPrivateKey)),
+                        $RSAPrivateKey
+                    );
+                    $RSAPrivateKey = pack('Ca*a*', self::ASN1_SEQUENCE, $this->_encodeLength(strlen($RSAPrivateKey)), $RSAPrivateKey);
+                    if (!empty($this->password) || is_string($this->password)) {
+                        $salt = Random::string(8);
+                        $iterationCount = 2048;
+
+                        $crypto = new DES();
+                        $crypto->setPassword($this->password, 'pbkdf1', 'md5', $salt, $iterationCount);
+                        $RSAPrivateKey = $crypto->encrypt($RSAPrivateKey);
+
+                        $parameters = pack(
+                            'Ca*a*Ca*N',
+                            self::ASN1_OCTETSTRING,
+                            $this->_encodeLength(strlen($salt)),
+                            $salt,
+                            self::ASN1_INTEGER,
+                            $this->_encodeLength(4),
+                            $iterationCount
+                        );
+                        $pbeWithMD5AndDES_CBC = "\x2a\x86\x48\x86\xf7\x0d\x01\x05\x03";
+
+                        $encryptionAlgorithm = pack(
+                            'Ca*a*Ca*a*',
+                            self::ASN1_OBJECT,
+                            $this->_encodeLength(strlen($pbeWithMD5AndDES_CBC)),
+                            $pbeWithMD5AndDES_CBC,
+                            self::ASN1_SEQUENCE,
+                            $this->_encodeLength(strlen($parameters)),
+                            $parameters
+                        );
+
+                        $RSAPrivateKey = pack(
+                            'Ca*a*Ca*a*',
+                            self::ASN1_SEQUENCE,
+                            $this->_encodeLength(strlen($encryptionAlgorithm)),
+                            $encryptionAlgorithm,
+                            self::ASN1_OCTETSTRING,
+                            $this->_encodeLength(strlen($RSAPrivateKey)),
+                            $RSAPrivateKey
+                        );
+
+                        $RSAPrivateKey = pack('Ca*a*', self::ASN1_SEQUENCE, $this->_encodeLength(strlen($RSAPrivateKey)), $RSAPrivateKey);
+
+                        $RSAPrivateKey = "-----BEGIN ENCRYPTED PRIVATE KEY-----\r\n" .
+                                         chunk_split(base64_encode($RSAPrivateKey), 64) .
+                                         '-----END ENCRYPTED PRIVATE KEY-----';
+                    } else {
+                        $RSAPrivateKey = "-----BEGIN PRIVATE KEY-----\r\n" .
+                                         chunk_split(base64_encode($RSAPrivateKey), 64) .
+                                         '-----END PRIVATE KEY-----';
+                    }
+                    return $RSAPrivateKey;
+                }
 
-                if (!empty($this->password)) {
-                    $iv = $this->_random(8);
+                if (!empty($this->password) || is_string($this->password)) {
+                    $iv = Random::string(8);
                     $symkey = pack('H*', md5($this->password . $iv)); // symkey is short for symmetric key
                     $symkey.= substr(pack('H*', md5($symkey . $this->password . $iv)), 0, 8);
-                    if (!class_exists('Crypt_TripleDES')) {
-                        require_once('Crypt/TripleDES.php');
-                    }
-                    $des = new Crypt_TripleDES();
+                    $des = new TripleDES();
                     $des->setKey($symkey);
                     $des->setIV($iv);
                     $iv = strtoupper(bin2hex($iv));
@@ -645,11 +924,11 @@ class Crypt_RSA {
                                      "Proc-Type: 4,ENCRYPTED\r\n" .
                                      "DEK-Info: DES-EDE3-CBC,$iv\r\n" .
                                      "\r\n" .
-                                     chunk_split(base64_encode($des->encrypt($RSAPrivateKey))) .
+                                     chunk_split(base64_encode($des->encrypt($RSAPrivateKey)), 64) .
                                      '-----END RSA PRIVATE KEY-----';
                 } else {
                     $RSAPrivateKey = "-----BEGIN RSA PRIVATE KEY-----\r\n" .
-                                     chunk_split(base64_encode($RSAPrivateKey)) .
+                                     chunk_split(base64_encode($RSAPrivateKey), 64) .
                                      '-----END RSA PRIVATE KEY-----';
                 }
 
@@ -661,46 +940,75 @@ class Crypt_RSA {
      * Convert a public key to the appropriate format
      *
      * @access private
-     * @see setPublicKeyFormat()
-     * @param String $RSAPrivateKey
-     * @return String
+     * @see self::setPublicKeyFormat()
+     * @param string $RSAPrivateKey
+     * @return string
      */
     function _convertPublicKey($n, $e)
     {
-        $modulus = $n->toBytes(true);
-        $publicExponent = $e->toBytes(true);
+        $signed = $this->publicKeyFormat != self::PUBLIC_FORMAT_XML;
+
+        $modulus = $n->toBytes($signed);
+        $publicExponent = $e->toBytes($signed);
 
         switch ($this->publicKeyFormat) {
-            case CRYPT_RSA_PUBLIC_FORMAT_RAW:
+            case self::PUBLIC_FORMAT_RAW:
                 return array('e' => $e->copy(), 'n' => $n->copy());
-            case CRYPT_RSA_PUBLIC_FORMAT_OPENSSH:
+            case self::PUBLIC_FORMAT_XML:
+                return "<RSAKeyValue>\r\n" .
+                       '  <Modulus>' . base64_encode($modulus) . "</Modulus>\r\n" .
+                       '  <Exponent>' . base64_encode($publicExponent) . "</Exponent>\r\n" .
+                       '</RSAKeyValue>';
+                break;
+            case self::PUBLIC_FORMAT_OPENSSH:
                 // from <http://tools.ietf.org/html/rfc4253#page-15>:
                 // string    "ssh-rsa"
                 // mpint     e
                 // mpint     n
                 $RSAPublicKey = pack('Na*Na*Na*', strlen('ssh-rsa'), 'ssh-rsa', strlen($publicExponent), $publicExponent, strlen($modulus), $modulus);
-                $RSAPublicKey = 'ssh-rsa ' . base64_encode($RSAPublicKey) . ' ' . CRYPT_RSA_COMMENT;
+                $RSAPublicKey = 'ssh-rsa ' . base64_encode($RSAPublicKey) . ' ' . $this->comment;
 
                 return $RSAPublicKey;
-            default: // eg. CRYPT_RSA_PUBLIC_FORMAT_PKCS1
+            default: // eg. self::PUBLIC_FORMAT_PKCS1_RAW or self::PUBLIC_FORMAT_PKCS1
                 // from <http://tools.ietf.org/html/rfc3447#appendix-A.1.1>:
                 // RSAPublicKey ::= SEQUENCE {
                 //     modulus           INTEGER,  -- n
                 //     publicExponent    INTEGER   -- e
                 // }
                 $components = array(
-                    'modulus' => pack('Ca*a*', CRYPT_RSA_ASN1_INTEGER, $this->_encodeLength(strlen($modulus)), $modulus),
-                    'publicExponent' => pack('Ca*a*', CRYPT_RSA_ASN1_INTEGER, $this->_encodeLength(strlen($publicExponent)), $publicExponent)
+                    'modulus' => pack('Ca*a*', self::ASN1_INTEGER, $this->_encodeLength(strlen($modulus)), $modulus),
+                    'publicExponent' => pack('Ca*a*', self::ASN1_INTEGER, $this->_encodeLength(strlen($publicExponent)), $publicExponent)
                 );
 
-                $RSAPublicKey = pack('Ca*a*a*',
-                    CRYPT_RSA_ASN1_SEQUENCE, $this->_encodeLength(strlen($components['modulus']) + strlen($components['publicExponent'])),
-                    $components['modulus'], $components['publicExponent']
+                $RSAPublicKey = pack(
+                    'Ca*a*a*',
+                    self::ASN1_SEQUENCE,
+                    $this->_encodeLength(strlen($components['modulus']) + strlen($components['publicExponent'])),
+                    $components['modulus'],
+                    $components['publicExponent']
                 );
 
-                $RSAPublicKey = "-----BEGIN PUBLIC KEY-----\r\n" .
-                                 chunk_split(base64_encode($RSAPublicKey)) .
-                                 '-----END PUBLIC KEY-----';
+                if ($this->publicKeyFormat == self::PUBLIC_FORMAT_PKCS1_RAW) {
+                    $RSAPublicKey = "-----BEGIN RSA PUBLIC KEY-----\r\n" .
+                                    chunk_split(base64_encode($RSAPublicKey), 64) .
+                                    '-----END RSA PUBLIC KEY-----';
+                } else {
+                    // sequence(oid(1.2.840.113549.1.1.1), null)) = rsaEncryption.
+                    $rsaOID = pack('H*', '300d06092a864886f70d0101010500'); // hex version of MA0GCSqGSIb3DQEBAQUA
+                    $RSAPublicKey = chr(0) . $RSAPublicKey;
+                    $RSAPublicKey = chr(3) . $this->_encodeLength(strlen($RSAPublicKey)) . $RSAPublicKey;
+
+                    $RSAPublicKey = pack(
+                        'Ca*a*',
+                        self::ASN1_SEQUENCE,
+                        $this->_encodeLength(strlen($rsaOID . $RSAPublicKey)),
+                        $rsaOID . $RSAPublicKey
+                    );
+
+                    $RSAPublicKey = "-----BEGIN PUBLIC KEY-----\r\n" .
+                                     chunk_split(base64_encode($RSAPublicKey), 64) .
+                                     '-----END PUBLIC KEY-----';
+                }
 
                 return $RSAPublicKey;
         }
@@ -710,16 +1018,20 @@ class Crypt_RSA {
      * Break a public or private key down into its constituant components
      *
      * @access private
-     * @see _convertPublicKey()
-     * @see _convertPrivateKey()
-     * @param String $key
-     * @param Integer $type
-     * @return Array
+     * @see self::_convertPublicKey()
+     * @see self::_convertPrivateKey()
+     * @param string $key
+     * @param int $type
+     * @return array
      */
     function _parseKey($key, $type)
     {
+        if ($type != self::PUBLIC_FORMAT_RAW && !is_string($key)) {
+            return false;
+        }
+
         switch ($type) {
-            case CRYPT_RSA_PUBLIC_FORMAT_RAW:
+            case self::PUBLIC_FORMAT_RAW:
                 if (!is_array($key)) {
                     return false;
                 }
@@ -750,9 +1062,10 @@ class Crypt_RSA {
                     case isset($key[1]):
                         $components['modulus'] = $key[1]->copy();
                 }
-                return $components;
-            case CRYPT_RSA_PRIVATE_FORMAT_PKCS1:
-            case CRYPT_RSA_PUBLIC_FORMAT_PKCS1:
+                return isset($components['modulus']) && isset($components['publicExponent']) ? $components : false;
+            case self::PRIVATE_FORMAT_PKCS1:
+            case self::PRIVATE_FORMAT_PKCS8:
+            case self::PUBLIC_FORMAT_PKCS1:
                 /* Although PKCS#1 proposes a format that public and private keys can use, encrypting them is
                    "outside the scope" of PKCS#1.  PKCS#1 then refers you to PKCS#12 and PKCS#15 if you're wanting to
                    protect private keys, however, that's not what OpenSSL* does.  OpenSSL protects private keys by adding
@@ -764,31 +1077,37 @@ class Crypt_RSA {
                    DES-EDE3-CBC as an algorithm, however, is not discussed anywhere, near as I can tell.
                    DES-CBC and DES-EDE are discussed in RFC1423, however, DES-EDE3-CBC isn't, nor is its key derivation
                    function.  As is, the definitive authority on this encoding scheme isn't the IETF but rather OpenSSL's
-                   own implementation.  ie. the implementation *is* the standard and any bugs that may exist in that 
+                   own implementation.  ie. the implementation *is* the standard and any bugs that may exist in that
                    implementation are part of the standard, as well.
 
                    * OpenSSL is the de facto standard.  It's utilized by OpenSSH and other projects */
                 if (preg_match('#DEK-Info: (.+),(.+)#', $key, $matches)) {
                     $iv = pack('H*', trim($matches[2]));
-                    $symkey = pack('H*', md5($this->password . $iv)); // symkey is short for symmetric key
-                    $symkey.= substr(pack('H*', md5($symkey . $this->password . $iv)), 0, 8);
-                    $ciphertext = preg_replace('#.+(\r|\n|\r\n)\1|[\r\n]|-.+-#s', '', $key);
-                    $ciphertext = preg_match('#^[a-zA-Z\d/+]*={0,2}$#', $ciphertext) ? base64_decode($ciphertext) : false;
+                    $symkey = pack('H*', md5($this->password . substr($iv, 0, 8))); // symkey is short for symmetric key
+                    $symkey.= pack('H*', md5($symkey . $this->password . substr($iv, 0, 8)));
+                    // remove the Proc-Type / DEK-Info sections as they're no longer needed
+                    $key = preg_replace('#^(?:Proc-Type|DEK-Info): .*#m', '', $key);
+                    $ciphertext = $this->_extractBER($key);
                     if ($ciphertext === false) {
                         $ciphertext = $key;
                     }
                     switch ($matches[1]) {
+                        case 'AES-256-CBC':
+                            $crypto = new AES();
+                            break;
+                        case 'AES-128-CBC':
+                            $symkey = substr($symkey, 0, 16);
+                            $crypto = new AES();
+                            break;
+                        case 'DES-EDE3-CFB':
+                            $crypto = new TripleDES(Base::MODE_CFB);
+                            break;
                         case 'DES-EDE3-CBC':
-                            if (!class_exists('Crypt_TripleDES')) {
-                                require_once('Crypt/TripleDES.php');
-                            }
-                            $crypto = new Crypt_TripleDES();
+                            $symkey = substr($symkey, 0, 24);
+                            $crypto = new TripleDES();
                             break;
                         case 'DES-CBC':
-                            if (!class_exists('Crypt_DES')) {
-                                require_once('Crypt/DES.php');
-                            }
-                            $crypto = new Crypt_DES();
+                            $crypto = new DES();
                             break;
                         default:
                             return false;
@@ -797,8 +1116,7 @@ class Crypt_RSA {
                     $crypto->setIV($iv);
                     $decoded = $crypto->decrypt($ciphertext);
                 } else {
-                    $decoded = preg_replace('#-.+-|[\r\n]#', '', $key);
-                    $decoded = preg_match('#^[a-zA-Z\d/+]*={0,2}$#', $decoded) ? base64_decode($decoded) : false;
+                    $decoded = $this->_extractBER($key);
                 }
 
                 if ($decoded !== false) {
@@ -807,7 +1125,7 @@ class Crypt_RSA {
 
                 $components = array();
 
-                if (ord($this->_string_shift($key)) != CRYPT_RSA_ASN1_SEQUENCE) {
+                if (ord($this->_string_shift($key)) != self::ASN1_SEQUENCE) {
                     return false;
                 }
                 if ($this->_decodeLength($key) != strlen($key)) {
@@ -815,7 +1133,66 @@ class Crypt_RSA {
                 }
 
                 $tag = ord($this->_string_shift($key));
-                if ($tag == CRYPT_RSA_ASN1_SEQUENCE) {
+                /* intended for keys for which OpenSSL's asn1parse returns the following:
+
+                    0:d=0  hl=4 l= 631 cons: SEQUENCE
+                    4:d=1  hl=2 l=   1 prim:  INTEGER           :00
+                    7:d=1  hl=2 l=  13 cons:  SEQUENCE
+                    9:d=2  hl=2 l=   9 prim:   OBJECT            :rsaEncryption
+                   20:d=2  hl=2 l=   0 prim:   NULL
+                   22:d=1  hl=4 l= 609 prim:  OCTET STRING
+
+                   ie. PKCS8 keys*/
+
+                if ($tag == self::ASN1_INTEGER && substr($key, 0, 3) == "\x01\x00\x30") {
+                    $this->_string_shift($key, 3);
+                    $tag = self::ASN1_SEQUENCE;
+                }
+
+                if ($tag == self::ASN1_SEQUENCE) {
+                    $temp = $this->_string_shift($key, $this->_decodeLength($key));
+                    if (ord($this->_string_shift($temp)) != self::ASN1_OBJECT) {
+                        return false;
+                    }
+                    $length = $this->_decodeLength($temp);
+                    switch ($this->_string_shift($temp, $length)) {
+                        case "\x2a\x86\x48\x86\xf7\x0d\x01\x01\x01": // rsaEncryption
+                            break;
+                        case "\x2a\x86\x48\x86\xf7\x0d\x01\x05\x03": // pbeWithMD5AndDES-CBC
+                            /*
+                               PBEParameter ::= SEQUENCE {
+                                   salt OCTET STRING (SIZE(8)),
+                                   iterationCount INTEGER }
+                            */
+                            if (ord($this->_string_shift($temp)) != self::ASN1_SEQUENCE) {
+                                return false;
+                            }
+                            if ($this->_decodeLength($temp) != strlen($temp)) {
+                                return false;
+                            }
+                            $this->_string_shift($temp); // assume it's an octet string
+                            $salt = $this->_string_shift($temp, $this->_decodeLength($temp));
+                            if (ord($this->_string_shift($temp)) != self::ASN1_INTEGER) {
+                                return false;
+                            }
+                            $this->_decodeLength($temp);
+                            list(, $iterationCount) = unpack('N', str_pad($temp, 4, chr(0), STR_PAD_LEFT));
+                            $this->_string_shift($key); // assume it's an octet string
+                            $length = $this->_decodeLength($key);
+                            if (strlen($key) != $length) {
+                                return false;
+                            }
+
+                            $crypto = new DES();
+                            $crypto->setPassword($this->password, 'pbkdf1', 'md5', $salt, $iterationCount);
+                            $key = $crypto->decrypt($key);
+                            if ($key === false) {
+                                return false;
+                            }
+                            return $this->_parseKey($key, self::PRIVATE_FORMAT_PKCS1);
+                        default:
+                            return false;
+                    }
                     /* intended for keys for which OpenSSL's asn1parse returns the following:
 
                         0:d=0  hl=4 l= 290 cons: SEQUENCE
@@ -823,14 +1200,15 @@ class Crypt_RSA {
                         6:d=2  hl=2 l=   9 prim:   OBJECT            :rsaEncryption
                        17:d=2  hl=2 l=   0 prim:   NULL
                        19:d=1  hl=4 l= 271 prim:  BIT STRING */
-                    $this->_string_shift($key, $this->_decodeLength($key));
-                    $this->_string_shift($key); // skip over the BIT STRING tag
-                    $this->_decodeLength($key); // skip over the BIT STRING length
+                    $tag = ord($this->_string_shift($key)); // skip over the BIT STRING / OCTET STRING tag
+                    $this->_decodeLength($key); // skip over the BIT STRING / OCTET STRING length
                     // "The initial octet shall encode, as an unsigned binary integer wtih bit 1 as the least significant bit, the number of
-                    //  unused bits in teh final subsequent octet. The number shall be in the range zero to seven."
+                    //  unused bits in the final subsequent octet. The number shall be in the range zero to seven."
                     //  -- http://www.itu.int/ITU-T/studygroups/com17/languages/X.690-0207.pdf (section 8.6.2.2)
-                    $this->_string_shift($key);
-                    if (ord($this->_string_shift($key)) != CRYPT_RSA_ASN1_SEQUENCE) {
+                    if ($tag == self::ASN1_BITSTRING) {
+                        $this->_string_shift($key);
+                    }
+                    if (ord($this->_string_shift($key)) != self::ASN1_SEQUENCE) {
                         return false;
                     }
                     if ($this->_decodeLength($key) != strlen($key)) {
@@ -838,114 +1216,381 @@ class Crypt_RSA {
                     }
                     $tag = ord($this->_string_shift($key));
                 }
-                if ($tag != CRYPT_RSA_ASN1_INTEGER) {
+                if ($tag != self::ASN1_INTEGER) {
                     return false;
                 }
 
                 $length = $this->_decodeLength($key);
                 $temp = $this->_string_shift($key, $length);
                 if (strlen($temp) != 1 || ord($temp) > 2) {
-                    $components['modulus'] = new Math_BigInteger($temp, -256);
-                    $this->_string_shift($key); // skip over CRYPT_RSA_ASN1_INTEGER
+                    $components['modulus'] = new BigInteger($temp, 256);
+                    $this->_string_shift($key); // skip over self::ASN1_INTEGER
                     $length = $this->_decodeLength($key);
-                    $components[$type == CRYPT_RSA_PUBLIC_FORMAT_PKCS1 ? 'publicExponent' : 'privateExponent'] = new Math_BigInteger($this->_string_shift($key, $length), -256);
+                    $components[$type == self::PUBLIC_FORMAT_PKCS1 ? 'publicExponent' : 'privateExponent'] = new BigInteger($this->_string_shift($key, $length), 256);
 
                     return $components;
                 }
-                if (ord($this->_string_shift($key)) != CRYPT_RSA_ASN1_INTEGER) {
+                if (ord($this->_string_shift($key)) != self::ASN1_INTEGER) {
                     return false;
                 }
                 $length = $this->_decodeLength($key);
-                $components['modulus'] = new Math_BigInteger($this->_string_shift($key, $length), -256);
+                $components['modulus'] = new BigInteger($this->_string_shift($key, $length), 256);
                 $this->_string_shift($key);
                 $length = $this->_decodeLength($key);
-                $components['publicExponent'] = new Math_BigInteger($this->_string_shift($key, $length), -256);
+                $components['publicExponent'] = new BigInteger($this->_string_shift($key, $length), 256);
                 $this->_string_shift($key);
                 $length = $this->_decodeLength($key);
-                $components['privateExponent'] = new Math_BigInteger($this->_string_shift($key, $length), -256);
+                $components['privateExponent'] = new BigInteger($this->_string_shift($key, $length), 256);
                 $this->_string_shift($key);
                 $length = $this->_decodeLength($key);
-                $components['primes'] = array(1 => new Math_BigInteger($this->_string_shift($key, $length), -256));
+                $components['primes'] = array(1 => new BigInteger($this->_string_shift($key, $length), 256));
                 $this->_string_shift($key);
                 $length = $this->_decodeLength($key);
-                $components['primes'][] = new Math_BigInteger($this->_string_shift($key, $length), -256);
+                $components['primes'][] = new BigInteger($this->_string_shift($key, $length), 256);
                 $this->_string_shift($key);
                 $length = $this->_decodeLength($key);
-                $components['exponents'] = array(1 => new Math_BigInteger($this->_string_shift($key, $length), -256));
+                $components['exponents'] = array(1 => new BigInteger($this->_string_shift($key, $length), 256));
                 $this->_string_shift($key);
                 $length = $this->_decodeLength($key);
-                $components['exponents'][] = new Math_BigInteger($this->_string_shift($key, $length), -256);
+                $components['exponents'][] = new BigInteger($this->_string_shift($key, $length), 256);
                 $this->_string_shift($key);
                 $length = $this->_decodeLength($key);
-                $components['coefficients'] = array(2 => new Math_BigInteger($this->_string_shift($key, $length), -256));
+                $components['coefficients'] = array(2 => new BigInteger($this->_string_shift($key, $length), 256));
 
                 if (!empty($key)) {
-                    if (ord($this->_string_shift($key)) != CRYPT_RSA_ASN1_SEQUENCE) {
+                    if (ord($this->_string_shift($key)) != self::ASN1_SEQUENCE) {
                         return false;
                     }
                     $this->_decodeLength($key);
                     while (!empty($key)) {
-                        if (ord($this->_string_shift($key)) != CRYPT_RSA_ASN1_SEQUENCE) {
+                        if (ord($this->_string_shift($key)) != self::ASN1_SEQUENCE) {
                             return false;
                         }
                         $this->_decodeLength($key);
                         $key = substr($key, 1);
                         $length = $this->_decodeLength($key);
-                        $components['primes'][] = new Math_BigInteger($this->_string_shift($key, $length), -256);
+                        $components['primes'][] = new BigInteger($this->_string_shift($key, $length), 256);
                         $this->_string_shift($key);
                         $length = $this->_decodeLength($key);
-                        $components['exponents'][] = new Math_BigInteger($this->_string_shift($key, $length), -256);
+                        $components['exponents'][] = new BigInteger($this->_string_shift($key, $length), 256);
                         $this->_string_shift($key);
                         $length = $this->_decodeLength($key);
-                        $components['coefficients'][] = new Math_BigInteger($this->_string_shift($key, $length), -256);
+                        $components['coefficients'][] = new BigInteger($this->_string_shift($key, $length), 256);
+                    }
+                }
+
+                return $components;
+            case self::PUBLIC_FORMAT_OPENSSH:
+                $parts = explode(' ', $key, 3);
+
+                $key = isset($parts[1]) ? base64_decode($parts[1]) : false;
+                if ($key === false) {
+                    return false;
+                }
+
+                $comment = isset($parts[2]) ? $parts[2] : false;
+
+                $cleanup = substr($key, 0, 11) == "\0\0\0\7ssh-rsa";
+
+                if (strlen($key) <= 4) {
+                    return false;
+                }
+                extract(unpack('Nlength', $this->_string_shift($key, 4)));
+                $publicExponent = new BigInteger($this->_string_shift($key, $length), -256);
+                if (strlen($key) <= 4) {
+                    return false;
+                }
+                extract(unpack('Nlength', $this->_string_shift($key, 4)));
+                $modulus = new BigInteger($this->_string_shift($key, $length), -256);
+
+                if ($cleanup && strlen($key)) {
+                    if (strlen($key) <= 4) {
+                        return false;
                     }
+                    extract(unpack('Nlength', $this->_string_shift($key, 4)));
+                    $realModulus = new BigInteger($this->_string_shift($key, $length), -256);
+                    return strlen($key) ? false : array(
+                        'modulus' => $realModulus,
+                        'publicExponent' => $modulus,
+                        'comment' => $comment
+                    );
+                } else {
+                    return strlen($key) ? false : array(
+                        'modulus' => $modulus,
+                        'publicExponent' => $publicExponent,
+                        'comment' => $comment
+                    );
+                }
+            // http://www.w3.org/TR/xmldsig-core/#sec-RSAKeyValue
+            // http://en.wikipedia.org/wiki/XML_Signature
+            case self::PRIVATE_FORMAT_XML:
+            case self::PUBLIC_FORMAT_XML:
+                $this->components = array();
+
+                $xml = xml_parser_create('UTF-8');
+                xml_set_object($xml, $this);
+                xml_set_element_handler($xml, '_start_element_handler', '_stop_element_handler');
+                xml_set_character_data_handler($xml, '_data_handler');
+                // add <xml></xml> to account for "dangling" tags like <BitStrength>...</BitStrength> that are sometimes added
+                if (!xml_parse($xml, '<xml>' . $key . '</xml>')) {
+                    return false;
+                }
+
+                return isset($this->components['modulus']) && isset($this->components['publicExponent']) ? $this->components : false;
+            // from PuTTY's SSHPUBK.C
+            case self::PRIVATE_FORMAT_PUTTY:
+                $components = array();
+                $key = preg_split('#\r\n|\r|\n#', $key);
+                $type = trim(preg_replace('#PuTTY-User-Key-File-2: (.+)#', '$1', $key[0]));
+                if ($type != 'ssh-rsa') {
+                    return false;
+                }
+                $encryption = trim(preg_replace('#Encryption: (.+)#', '$1', $key[1]));
+                $comment = trim(preg_replace('#Comment: (.+)#', '$1', $key[2]));
+
+                $publicLength = trim(preg_replace('#Public-Lines: (\d+)#', '$1', $key[3]));
+                $public = base64_decode(implode('', array_map('trim', array_slice($key, 4, $publicLength))));
+                $public = substr($public, 11);
+                extract(unpack('Nlength', $this->_string_shift($public, 4)));
+                $components['publicExponent'] = new BigInteger($this->_string_shift($public, $length), -256);
+                extract(unpack('Nlength', $this->_string_shift($public, 4)));
+                $components['modulus'] = new BigInteger($this->_string_shift($public, $length), -256);
+
+                $privateLength = trim(preg_replace('#Private-Lines: (\d+)#', '$1', $key[$publicLength + 4]));
+                $private = base64_decode(implode('', array_map('trim', array_slice($key, $publicLength + 5, $privateLength))));
+
+                switch ($encryption) {
+                    case 'aes256-cbc':
+                        $symkey = '';
+                        $sequence = 0;
+                        while (strlen($symkey) < 32) {
+                            $temp = pack('Na*', $sequence++, $this->password);
+                            $symkey.= pack('H*', sha1($temp));
+                        }
+                        $symkey = substr($symkey, 0, 32);
+                        $crypto = new AES();
+                }
+
+                if ($encryption != 'none') {
+                    $crypto->setKey($symkey);
+                    $crypto->disablePadding();
+                    $private = $crypto->decrypt($private);
+                    if ($private === false) {
+                        return false;
+                    }
+                }
+
+                extract(unpack('Nlength', $this->_string_shift($private, 4)));
+                if (strlen($private) < $length) {
+                    return false;
+                }
+                $components['privateExponent'] = new BigInteger($this->_string_shift($private, $length), -256);
+                extract(unpack('Nlength', $this->_string_shift($private, 4)));
+                if (strlen($private) < $length) {
+                    return false;
+                }
+                $components['primes'] = array(1 => new BigInteger($this->_string_shift($private, $length), -256));
+                extract(unpack('Nlength', $this->_string_shift($private, 4)));
+                if (strlen($private) < $length) {
+                    return false;
                 }
+                $components['primes'][] = new BigInteger($this->_string_shift($private, $length), -256);
 
-                return $components;
-            case CRYPT_RSA_PUBLIC_FORMAT_OPENSSH:
-                $key = base64_decode(preg_replace('#^ssh-rsa | .+$#', '', $key));
-                if ($key === false) {
+                $temp = $components['primes'][1]->subtract($this->one);
+                $components['exponents'] = array(1 => $components['publicExponent']->modInverse($temp));
+                $temp = $components['primes'][2]->subtract($this->one);
+                $components['exponents'][] = $components['publicExponent']->modInverse($temp);
+
+                extract(unpack('Nlength', $this->_string_shift($private, 4)));
+                if (strlen($private) < $length) {
                     return false;
                 }
+                $components['coefficients'] = array(2 => new BigInteger($this->_string_shift($private, $length), -256));
 
-                $cleanup = substr($key, 0, 11) == "\0\0\0\7ssh-rsa";
+                return $components;
+        }
+    }
 
-                extract(unpack('Nlength', $this->_string_shift($key, 4)));
-                $publicExponent = new Math_BigInteger($this->_string_shift($key, $length), -256);
-                extract(unpack('Nlength', $this->_string_shift($key, 4)));
-                $modulus = new Math_BigInteger($this->_string_shift($key, $length), -256);
+    /**
+     * Returns the key size
+     *
+     * More specifically, this returns the size of the modulo in bits.
+     *
+     * @access public
+     * @return int
+     */
+    function getSize()
+    {
+        return !isset($this->modulus) ? 0 : strlen($this->modulus->toBits());
+    }
 
-                if ($cleanup && strlen($key)) {
-                    extract(unpack('Nlength', $this->_string_shift($key, 4)));
-                    return array(
-                        'modulus' => new Math_BigInteger($this->_string_shift($key, $length), -256),
-                        'publicExponent' => $modulus
-                    );
-                } else {
-                    return array(
-                        'modulus' => $modulus,
-                        'publicExponent' => $publicExponent
-                    );
-                }
+    /**
+     * Start Element Handler
+     *
+     * Called by xml_set_element_handler()
+     *
+     * @access private
+     * @param resource $parser
+     * @param string $name
+     * @param array $attribs
+     */
+    function _start_element_handler($parser, $name, $attribs)
+    {
+        //$name = strtoupper($name);
+        switch ($name) {
+            case 'MODULUS':
+                $this->current = &$this->components['modulus'];
+                break;
+            case 'EXPONENT':
+                $this->current = &$this->components['publicExponent'];
+                break;
+            case 'P':
+                $this->current = &$this->components['primes'][1];
+                break;
+            case 'Q':
+                $this->current = &$this->components['primes'][2];
+                break;
+            case 'DP':
+                $this->current = &$this->components['exponents'][1];
+                break;
+            case 'DQ':
+                $this->current = &$this->components['exponents'][2];
+                break;
+            case 'INVERSEQ':
+                $this->current = &$this->components['coefficients'][2];
+                break;
+            case 'D':
+                $this->current = &$this->components['privateExponent'];
+        }
+        $this->current = '';
+    }
+
+    /**
+     * Stop Element Handler
+     *
+     * Called by xml_set_element_handler()
+     *
+     * @access private
+     * @param resource $parser
+     * @param string $name
+     */
+    function _stop_element_handler($parser, $name)
+    {
+        if (isset($this->current)) {
+            $this->current = new BigInteger(base64_decode($this->current), 256);
+            unset($this->current);
         }
     }
 
     /**
+     * Data Handler
+     *
+     * Called by xml_set_character_data_handler()
+     *
+     * @access private
+     * @param resource $parser
+     * @param string $data
+     */
+    function _data_handler($parser, $data)
+    {
+        if (!isset($this->current) || is_object($this->current)) {
+            return;
+        }
+        $this->current.= trim($data);
+    }
+
+    /**
      * Loads a public or private key
      *
      * Returns true on success and false on failure (ie. an incorrect password was provided or the key was malformed)
      *
      * @access public
-     * @param String $key
-     * @param Integer $type optional
+     * @param string $key
+     * @param int $type optional
      */
-    function loadKey($key, $type = CRYPT_RSA_PRIVATE_FORMAT_PKCS1)
+    function loadKey($key, $type = false)
     {
-        $components = $this->_parseKey($key, $type);
+        if ($key instanceof RSA) {
+            $this->privateKeyFormat = $key->privateKeyFormat;
+            $this->publicKeyFormat = $key->publicKeyFormat;
+            $this->k = $key->k;
+            $this->hLen = $key->hLen;
+            $this->sLen = $key->sLen;
+            $this->mgfHLen = $key->mgfHLen;
+            $this->encryptionMode = $key->encryptionMode;
+            $this->signatureMode = $key->signatureMode;
+            $this->password = $key->password;
+            $this->configFile = $key->configFile;
+            $this->comment = $key->comment;
+
+            if (is_object($key->hash)) {
+                $this->hash = new Hash($key->hash->getHash());
+            }
+            if (is_object($key->mgfHash)) {
+                $this->mgfHash = new Hash($key->mgfHash->getHash());
+            }
+
+            if (is_object($key->modulus)) {
+                $this->modulus = $key->modulus->copy();
+            }
+            if (is_object($key->exponent)) {
+                $this->exponent = $key->exponent->copy();
+            }
+            if (is_object($key->publicExponent)) {
+                $this->publicExponent = $key->publicExponent->copy();
+            }
+
+            $this->primes = array();
+            $this->exponents = array();
+            $this->coefficients = array();
+
+            foreach ($this->primes as $prime) {
+                $this->primes[] = $prime->copy();
+            }
+            foreach ($this->exponents as $exponent) {
+                $this->exponents[] = $exponent->copy();
+            }
+            foreach ($this->coefficients as $coefficient) {
+                $this->coefficients[] = $coefficient->copy();
+            }
+
+            return true;
+        }
+
+        if ($type === false) {
+            $types = array(
+                self::PUBLIC_FORMAT_RAW,
+                self::PRIVATE_FORMAT_PKCS1,
+                self::PRIVATE_FORMAT_XML,
+                self::PRIVATE_FORMAT_PUTTY,
+                self::PUBLIC_FORMAT_OPENSSH
+            );
+            foreach ($types as $type) {
+                $components = $this->_parseKey($key, $type);
+                if ($components !== false) {
+                    break;
+                }
+            }
+        } else {
+            $components = $this->_parseKey($key, $type);
+        }
+
         if ($components === false) {
+            $this->comment = null;
+            $this->modulus = null;
+            $this->k = null;
+            $this->exponent = null;
+            $this->primes = null;
+            $this->exponents = null;
+            $this->coefficients = null;
+            $this->publicExponent = null;
+
             return false;
         }
 
+        if (isset($components['comment']) && $components['comment'] !== false) {
+            $this->comment = $components['comment'];
+        }
         $this->modulus = $components['modulus'];
         $this->k = strlen($this->modulus->toBytes());
         $this->exponent = isset($components['privateExponent']) ? $components['privateExponent'] : $components['publicExponent'];
@@ -961,6 +1606,19 @@ class Crypt_RSA {
             $this->publicExponent = false;
         }
 
+        switch ($type) {
+            case self::PUBLIC_FORMAT_OPENSSH:
+            case self::PUBLIC_FORMAT_RAW:
+                $this->setPublicKey();
+                break;
+            case self::PRIVATE_FORMAT_PKCS1:
+                switch (true) {
+                    case strpos($key, '-BEGIN PUBLIC KEY-') !== false:
+                    case strpos($key, '-BEGIN RSA PUBLIC KEY-') !== false:
+                        $this->setPublicKey();
+                }
+        }
+
         return true;
     }
 
@@ -968,14 +1626,14 @@ class Crypt_RSA {
      * Sets the password
      *
      * Private keys can be encrypted with a password.  To unset the password, pass in the empty string or false.
-     * Or rather, pass in $password such that empty($password) is true.
+     * Or rather, pass in $password such that empty($password) && !is_string($password) is true.
      *
-     * @see createKey()
-     * @see loadKey()
+     * @see self::createKey()
+     * @see self::loadKey()
      * @access public
-     * @param String $password
+     * @param string $password
      */
-    function setPassword($password)
+    function setPassword($password = false)
     {
         $this->password = $password;
     }
@@ -987,25 +1645,96 @@ class Crypt_RSA {
      * used in certain contexts.  For example, in SSH-2, RSA authentication works by sending the public key along with a
      * message signed by the private key to the server.  The SSH-2 server looks the public key up in an index of public keys
      * and if it's present then proceeds to verify the signature.  Problem is, if your private key doesn't include the public
-     * exponent this won't work unless you manually add the public exponent.
+     * exponent this won't work unless you manually add the public exponent. phpseclib tries to guess if the key being used
+     * is the public key but in the event that it guesses incorrectly you might still want to explicitly set the key as being
+     * public.
      *
      * Do note that when a new key is loaded the index will be cleared.
      *
      * Returns true on success, false on failure
      *
-     * @see getPublicKey()
+     * @see self::getPublicKey()
      * @access public
-     * @param String $key
-     * @param Integer $type optional
-     * @return Boolean
+     * @param string $key optional
+     * @param int $type optional
+     * @return bool
      */
-    function setPublicKey($key, $type = CRYPT_RSA_PUBLIC_FORMAT_PKCS1)
+    function setPublicKey($key = false, $type = false)
     {
-        $components = $this->_parseKey($key, $type);
-        if (empty($this->modulus) || !$this->modulus->equals($components['modulus'])) {
+        // if a public key has already been loaded return false
+        if (!empty($this->publicExponent)) {
+            return false;
+        }
+
+        if ($key === false && !empty($this->modulus)) {
+            $this->publicExponent = $this->exponent;
+            return true;
+        }
+
+        if ($type === false) {
+            $types = array(
+                self::PUBLIC_FORMAT_RAW,
+                self::PUBLIC_FORMAT_PKCS1,
+                self::PUBLIC_FORMAT_XML,
+                self::PUBLIC_FORMAT_OPENSSH
+            );
+            foreach ($types as $type) {
+                $components = $this->_parseKey($key, $type);
+                if ($components !== false) {
+                    break;
+                }
+            }
+        } else {
+            $components = $this->_parseKey($key, $type);
+        }
+
+        if ($components === false) {
             return false;
         }
+
+        if (empty($this->modulus) || !$this->modulus->equals($components['modulus'])) {
+            $this->modulus = $components['modulus'];
+            $this->exponent = $this->publicExponent = $components['publicExponent'];
+            return true;
+        }
+
         $this->publicExponent = $components['publicExponent'];
+
+        return true;
+    }
+
+    /**
+     * Defines the private key
+     *
+     * If phpseclib guessed a private key was a public key and loaded it as such it might be desirable to force
+     * phpseclib to treat the key as a private key. This function will do that.
+     *
+     * Do note that when a new key is loaded the index will be cleared.
+     *
+     * Returns true on success, false on failure
+     *
+     * @see self::getPublicKey()
+     * @access public
+     * @param string $key optional
+     * @param int $type optional
+     * @return bool
+     */
+    function setPrivateKey($key = false, $type = false)
+    {
+        if ($key === false && !empty($this->publicExponent)) {
+            $this->publicExponent = false;
+            return true;
+        }
+
+        $rsa = new RSA();
+        if (!$rsa->loadKey($key, $type)) {
+            return false;
+        }
+        $rsa->publicExponent = false;
+
+        // don't overwrite the old key if the new key is invalid
+        $this->loadKey($rsa);
+        return true;
     }
 
     /**
@@ -1015,12 +1744,12 @@ class Crypt_RSA {
      * or if the public key was set via setPublicKey().  If the currently loaded key is supposed to be the public key this
      * function won't return it since this library, for the most part, doesn't distinguish between public and private keys.
      *
-     * @see getPublicKey()
+     * @see self::getPublicKey()
      * @access public
-     * @param String $key
-     * @param Integer $type optional
+     * @param string $key
+     * @param int $type optional
      */
-    function getPublicKey($type = CRYPT_RSA_PUBLIC_FORMAT_PKCS1)
+    function getPublicKey($type = self::PUBLIC_FORMAT_PKCS8)
     {
         if (empty($this->modulus) || empty($this->publicExponent)) {
             return false;
@@ -1034,11 +1763,123 @@ class Crypt_RSA {
     }
 
     /**
+     * Returns the public key's fingerprint
+     *
+     * The public key's fingerprint is returned, which is equivalent to running `ssh-keygen -lf rsa.pub`. If there is
+     * no public key currently loaded, false is returned.
+     * Example output (md5): "c1:b1:30:29:d7:b8:de:6c:97:77:10:d7:46:41:63:87" (as specified by RFC 4716)
+     *
+     * @access public
+     * @param string $algorithm The hashing algorithm to be used. Valid options are 'md5' and 'sha256'. False is returned
+     * for invalid values.
+     * @return mixed
+     */
+    function getPublicKeyFingerprint($algorithm = 'md5')
+    {
+        if (empty($this->modulus) || empty($this->publicExponent)) {
+            return false;
+        }
+
+        $modulus = $this->modulus->toBytes(true);
+        $publicExponent = $this->publicExponent->toBytes(true);
+
+        $RSAPublicKey = pack('Na*Na*Na*', strlen('ssh-rsa'), 'ssh-rsa', strlen($publicExponent), $publicExponent, strlen($modulus), $modulus);
+
+        switch ($algorithm) {
+            case 'sha256':
+                $hash = new Hash('sha256');
+                $base = base64_encode($hash->hash($RSAPublicKey));
+                return substr($base, 0, strlen($base) - 1);
+            case 'md5':
+                return substr(chunk_split(md5($RSAPublicKey), 2, ':'), 0, -1);
+            default:
+                return false;
+        }
+    }
+
+    /**
+     * Returns the private key
+     *
+     * The private key is only returned if the currently loaded key contains the constituent prime numbers.
+     *
+     * @see self::getPublicKey()
+     * @access public
+     * @param string $key
+     * @param int $type optional
+     * @return mixed
+     */
+    function getPrivateKey($type = self::PUBLIC_FORMAT_PKCS1)
+    {
+        if (empty($this->primes)) {
+            return false;
+        }
+
+        $oldFormat = $this->privateKeyFormat;
+        $this->privateKeyFormat = $type;
+        $temp = $this->_convertPrivateKey($this->modulus, $this->publicExponent, $this->exponent, $this->primes, $this->exponents, $this->coefficients);
+        $this->privateKeyFormat = $oldFormat;
+        return $temp;
+    }
+
+    /**
+     * Returns a minimalistic private key
+     *
+     * Returns the private key without the prime number constituants.  Structurally identical to a public key that
+     * hasn't been set as the public key
+     *
+     * @see self::getPrivateKey()
+     * @access private
+     * @param string $key
+     * @param int $type optional
+     */
+    function _getPrivatePublicKey($mode = self::PUBLIC_FORMAT_PKCS8)
+    {
+        if (empty($this->modulus) || empty($this->exponent)) {
+            return false;
+        }
+
+        $oldFormat = $this->publicKeyFormat;
+        $this->publicKeyFormat = $mode;
+        $temp = $this->_convertPublicKey($this->modulus, $this->exponent);
+        $this->publicKeyFormat = $oldFormat;
+        return $temp;
+    }
+
+    /**
+     *  __toString() magic method
+     *
+     * @access public
+     * @return string
+     */
+    function __toString()
+    {
+        $key = $this->getPrivateKey($this->privateKeyFormat);
+        if ($key !== false) {
+            return $key;
+        }
+        $key = $this->_getPrivatePublicKey($this->publicKeyFormat);
+        return $key !== false ? $key : '';
+    }
+
+    /**
+     *  __clone() magic method
+     *
+     * @access public
+     * @return Crypt_RSA
+     */
+    function __clone()
+    {
+        $key = new RSA();
+        $key->loadKey($this);
+        return $key;
+    }
+
+    /**
      * Generates the smallest and largest numbers requiring $bits bits
      *
      * @access private
-     * @param Integer $bits
-     * @return Array
+     * @param int $bits
+     * @return array
      */
     function _generateMinMax($bits)
     {
@@ -1054,8 +1895,8 @@ class Crypt_RSA {
         }
 
         return array(
-            'min' => new Math_BigInteger($min, 256),
-            'max' => new Math_BigInteger($max, 256)
+            'min' => new BigInteger($min, 256),
+            'max' => new BigInteger($max, 256)
         );
     }
 
@@ -1063,16 +1904,16 @@ class Crypt_RSA {
      * DER-decode the length
      *
      * DER supports lengths up to (2**8)**127, however, we'll only support lengths up to (2**8)**4.  See
-     * {@link http://itu.int/ITU-T/studygroups/com17/languages/X.690-0207.pdf#p=13 X.690 � 8.1.3} for more information.
+     * {@link http://itu.int/ITU-T/studygroups/com17/languages/X.690-0207.pdf#p=13 X.690 paragraph 8.1.3} for more information.
      *
      * @access private
-     * @param String $string
-     * @return Integer
+     * @param string $string
+     * @return int
      */
     function _decodeLength(&$string)
     {
         $length = ord($this->_string_shift($string));
-        if ( $length & 0x80 ) { // definite length, long form
+        if ($length & 0x80) { // definite length, long form
             $length&= 0x7F;
             $temp = $this->_string_shift($string, $length);
             list(, $length) = unpack('N', substr(str_pad($temp, 4, chr(0), STR_PAD_LEFT), -4));
@@ -1084,11 +1925,11 @@ class Crypt_RSA {
      * DER-encode the length
      *
      * DER supports lengths up to (2**8)**127, however, we'll only support lengths up to (2**8)**4.  See
-     * {@link http://itu.int/ITU-T/studygroups/com17/languages/X.690-0207.pdf#p=13 X.690 � 8.1.3} for more information.
+     * {@link http://itu.int/ITU-T/studygroups/com17/languages/X.690-0207.pdf#p=13 X.690 paragraph 8.1.3} for more information.
      *
      * @access private
-     * @param Integer $length
-     * @return String
+     * @param int $length
+     * @return string
      */
     function _encodeLength($length)
     {
@@ -1105,9 +1946,9 @@ class Crypt_RSA {
      *
      * Inspired by array_shift
      *
-     * @param String $string
-     * @param optional Integer $index
-     * @return String
+     * @param string $string
+     * @param int $index
+     * @return string
      * @access private
      */
     function _string_shift(&$string, $index = 1)
@@ -1120,9 +1961,9 @@ class Crypt_RSA {
     /**
      * Determines the private key format
      *
-     * @see createKey()
+     * @see self::createKey()
      * @access public
-     * @param Integer $format
+     * @param int $format
      */
     function setPrivateKeyFormat($format)
     {
@@ -1132,9 +1973,9 @@ class Crypt_RSA {
     /**
      * Determines the public key format
      *
-     * @see createKey()
+     * @see self::createKey()
      * @access public
-     * @param Integer $format
+     * @param int $format
      */
     function setPublicKeyFormat($format)
     {
@@ -1144,15 +1985,15 @@ class Crypt_RSA {
     /**
      * Determines which hashing function should be used
      *
-     * Used with signature production / verification and (if the encryption mode is CRYPT_RSA_ENCRYPTION_OAEP) encryption and
+     * Used with signature production / verification and (if the encryption mode is self::ENCRYPTION_OAEP) encryption and
      * decryption.  If $hash isn't supported, sha1 is used.
      *
      * @access public
-     * @param String $hash
+     * @param string $hash
      */
     function setHash($hash)
     {
-        // Crypt_Hash supports algorithms that PKCS#1 doesn't support.  md5-96 and sha1-96, for example.
+        // \phpseclib\Crypt\Hash supports algorithms that PKCS#1 doesn't support.  md5-96 and sha1-96, for example.
         switch ($hash) {
             case 'md2':
             case 'md5':
@@ -1160,11 +2001,11 @@ class Crypt_RSA {
             case 'sha256':
             case 'sha384':
             case 'sha512':
-                $this->hash = new Crypt_Hash($hash);
+                $this->hash = new Hash($hash);
                 $this->hashName = $hash;
                 break;
             default:
-                $this->hash = new Crypt_Hash('sha1');
+                $this->hash = new Hash('sha1');
                 $this->hashName = 'sha1';
         }
         $this->hLen = $this->hash->getLength();
@@ -1173,15 +2014,15 @@ class Crypt_RSA {
     /**
      * Determines which hashing function should be used for the mask generation function
      *
-     * The mask generation function is used by CRYPT_RSA_ENCRYPTION_OAEP and CRYPT_RSA_SIGNATURE_PSS and although it's
+     * The mask generation function is used by self::ENCRYPTION_OAEP and self::SIGNATURE_PSS and although it's
      * best if Hash and MGFHash are set to the same thing this is not a requirement.
      *
      * @access public
-     * @param String $hash
+     * @param string $hash
      */
     function setMGFHash($hash)
     {
-        // Crypt_Hash supports algorithms that PKCS#1 doesn't support.  md5-96 and sha1-96, for example.
+        // \phpseclib\Crypt\Hash supports algorithms that PKCS#1 doesn't support.  md5-96 and sha1-96, for example.
         switch ($hash) {
             case 'md2':
             case 'md5':
@@ -1189,10 +2030,10 @@ class Crypt_RSA {
             case 'sha256':
             case 'sha384':
             case 'sha512':
-                $this->mgfHash = new Crypt_Hash($hash);
+                $this->mgfHash = new Hash($hash);
                 break;
             default:
-                $this->mgfHash = new Crypt_Hash('sha1');
+                $this->mgfHash = new Hash('sha1');
         }
         $this->mgfHLen = $this->mgfHash->getLength();
     }
@@ -1206,7 +2047,7 @@ class Crypt_RSA {
      *    of the hash function Hash) and 0.
      *
      * @access public
-     * @param Integer $format
+     * @param int $format
      */
     function setSaltLength($sLen)
     {
@@ -1214,45 +2055,20 @@ class Crypt_RSA {
     }
 
     /**
-     * Generates a random string x bytes long
-     *
-     * @access public
-     * @param Integer $bytes
-     * @param optional Integer $nonzero
-     * @return String
-     */
-    function _random($bytes, $nonzero = false)
-    {
-        $temp = '';
-        if ($nonzero) {
-            for ($i = 0; $i < $bytes; $i++) {
-                $temp.= chr(crypt_random(1, 255));
-            }
-        } else {
-            $ints = ($bytes + 1) >> 2;
-            for ($i = 0; $i < $ints; $i++) {
-                $temp.= pack('N', crypt_random());
-            }
-            $temp = substr($temp, 0, $bytes);
-        }
-        return $temp;
-    }
-
-    /**
      * Integer-to-Octet-String primitive
      *
      * See {@link http://tools.ietf.org/html/rfc3447#section-4.1 RFC3447#section-4.1}.
      *
      * @access private
-     * @param Math_BigInteger $x
-     * @param Integer $xLen
-     * @return String
+     * @param \phpseclib\Math\BigInteger $x
+     * @param int $xLen
+     * @return string
      */
     function _i2osp($x, $xLen)
     {
         $x = $x->toBytes();
         if (strlen($x) > $xLen) {
-            user_error('Integer too large', E_USER_NOTICE);
+            user_error('Integer too large');
             return false;
         }
         return str_pad($x, $xLen, chr(0), STR_PAD_LEFT);
@@ -1264,12 +2080,12 @@ class Crypt_RSA {
      * See {@link http://tools.ietf.org/html/rfc3447#section-4.2 RFC3447#section-4.2}.
      *
      * @access private
-     * @param String $x
-     * @return Math_BigInteger
+     * @param string $x
+     * @return \phpseclib\Math\BigInteger
      */
     function _os2ip($x)
     {
-        return new Math_BigInteger($x, 256);
+        return new BigInteger($x, 256);
     }
 
     /**
@@ -1278,13 +2094,19 @@ class Crypt_RSA {
      * See {@link http://tools.ietf.org/html/rfc3447#section-5.1.1 RFC3447#section-5.1.2}.
      *
      * @access private
-     * @param Math_BigInteger $x
-     * @return Math_BigInteger
+     * @param \phpseclib\Math\BigInteger $x
+     * @return \phpseclib\Math\BigInteger
      */
     function _exponentiate($x)
     {
-        if (empty($this->primes) || empty($this->coefficients) || empty($this->exponents)) {
-            return $x->modPow($this->exponent, $this->modulus);
+        switch (true) {
+            case empty($this->primes):
+            case $this->primes[1]->equals($this->zero):
+            case empty($this->coefficients):
+            case $this->coefficients[2]->equals($this->zero):
+            case empty($this->exponents):
+            case $this->exponents[1]->equals($this->zero):
+                return $x->modPow($this->exponent, $this->modulus);
         }
 
         $num_primes = count($this->primes);
@@ -1319,8 +2141,7 @@ class Crypt_RSA {
                 }
             }
 
-            $one = new Math_BigInteger(1);
-            $one->setRandomGenerator('crypt_random');
+            $one = new BigInteger(1);
 
             $r = $one->random($one, $smallest->subtract($one));
 
@@ -1357,15 +2178,14 @@ class Crypt_RSA {
      * Returns $x->modPow($this->exponents[$i], $this->primes[$i])
      *
      * @access private
-     * @param Math_BigInteger $x
-     * @param Math_BigInteger $r
-     * @param Integer $i
-     * @return Math_BigInteger
+     * @param \phpseclib\Math\BigInteger $x
+     * @param \phpseclib\Math\BigInteger $r
+     * @param int $i
+     * @return \phpseclib\Math\BigInteger
      */
     function _blind($x, $r, $i)
     {
         $x = $x->multiply($r->modPow($this->publicExponent, $this->primes[$i]));
-
         $x = $x->modPow($this->exponents[$i], $this->primes[$i]);
 
         $r = $r->modInverse($this->primes[$i]);
@@ -1376,18 +2196,46 @@ class Crypt_RSA {
     }
 
     /**
+     * Performs blinded RSA equality testing
+     *
+     * Protects against a particular type of timing attack described.
+     *
+     * See {@link http://codahale.com/a-lesson-in-timing-attacks/ A Lesson In Timing Attacks (or, Don't use MessageDigest.isEquals)}
+     *
+     * Thanks for the heads up singpolyma!
+     *
+     * @access private
+     * @param string $x
+     * @param string $y
+     * @return bool
+     */
+    function _equals($x, $y)
+    {
+        if (strlen($x) != strlen($y)) {
+            return false;
+        }
+
+        $result = 0;
+        for ($i = 0; $i < strlen($x); $i++) {
+            $result |= ord($x[$i]) ^ ord($y[$i]);
+        }
+
+        return $result == 0;
+    }
+
+    /**
      * RSAEP
      *
      * See {@link http://tools.ietf.org/html/rfc3447#section-5.1.1 RFC3447#section-5.1.1}.
      *
      * @access private
-     * @param Math_BigInteger $m
-     * @return Math_BigInteger
+     * @param \phpseclib\Math\BigInteger $m
+     * @return \phpseclib\Math\BigInteger
      */
     function _rsaep($m)
     {
         if ($m->compare($this->zero) < 0 || $m->compare($this->modulus) > 0) {
-            user_error('Message representative out of range', E_USER_NOTICE);
+            user_error('Message representative out of range');
             return false;
         }
         return $this->_exponentiate($m);
@@ -1399,13 +2247,13 @@ class Crypt_RSA {
      * See {@link http://tools.ietf.org/html/rfc3447#section-5.1.2 RFC3447#section-5.1.2}.
      *
      * @access private
-     * @param Math_BigInteger $c
-     * @return Math_BigInteger
+     * @param \phpseclib\Math\BigInteger $c
+     * @return \phpseclib\Math\BigInteger
      */
     function _rsadp($c)
     {
         if ($c->compare($this->zero) < 0 || $c->compare($this->modulus) > 0) {
-            user_error('Ciphertext representative out of range', E_USER_NOTICE);
+            user_error('Ciphertext representative out of range');
             return false;
         }
         return $this->_exponentiate($c);
@@ -1417,13 +2265,13 @@ class Crypt_RSA {
      * See {@link http://tools.ietf.org/html/rfc3447#section-5.2.1 RFC3447#section-5.2.1}.
      *
      * @access private
-     * @param Math_BigInteger $m
-     * @return Math_BigInteger
+     * @param \phpseclib\Math\BigInteger $m
+     * @return \phpseclib\Math\BigInteger
      */
     function _rsasp1($m)
     {
         if ($m->compare($this->zero) < 0 || $m->compare($this->modulus) > 0) {
-            user_error('Message representative out of range', E_USER_NOTICE);
+            user_error('Message representative out of range');
             return false;
         }
         return $this->_exponentiate($m);
@@ -1435,13 +2283,13 @@ class Crypt_RSA {
      * See {@link http://tools.ietf.org/html/rfc3447#section-5.2.2 RFC3447#section-5.2.2}.
      *
      * @access private
-     * @param Math_BigInteger $s
-     * @return Math_BigInteger
+     * @param \phpseclib\Math\BigInteger $s
+     * @return \phpseclib\Math\BigInteger
      */
     function _rsavp1($s)
     {
         if ($s->compare($this->zero) < 0 || $s->compare($this->modulus) > 0) {
-            user_error('Signature representative out of range', E_USER_NOTICE);
+            user_error('Signature representative out of range');
             return false;
         }
         return $this->_exponentiate($s);
@@ -1453,9 +2301,9 @@ class Crypt_RSA {
      * See {@link http://tools.ietf.org/html/rfc3447#appendix-B.2.1 RFC3447#appendix-B.2.1}.
      *
      * @access private
-     * @param String $mgfSeed
-     * @param Integer $mgfLen
-     * @return String
+     * @param string $mgfSeed
+     * @param int $mgfLen
+     * @return string
      */
     function _mgf1($mgfSeed, $maskLen)
     {
@@ -1478,9 +2326,9 @@ class Crypt_RSA {
      * {http://en.wikipedia.org/wiki/Optimal_Asymmetric_Encryption_Padding OAES}.
      *
      * @access private
-     * @param String $m
-     * @param String $l
-     * @return String
+     * @param string $m
+     * @param string $l
+     * @return string
      */
     function _rsaes_oaep_encrypt($m, $l = '')
     {
@@ -1492,7 +2340,7 @@ class Crypt_RSA {
         // be output.
 
         if ($mLen > $this->k - 2 * $this->hLen - 2) {
-            user_error('Message too long', E_USER_NOTICE);
+            user_error('Message too long');
             return false;
         }
 
@@ -1501,7 +2349,7 @@ class Crypt_RSA {
         $lHash = $this->hash->hash($l);
         $ps = str_repeat(chr(0), $this->k - $mLen - 2 * $this->hLen - 2);
         $db = $lHash . $ps . chr(1) . $m;
-        $seed = $this->_random($this->hLen);
+        $seed = Random::string($this->hLen);
         $dbMask = $this->_mgf1($seed, $this->k - $this->hLen - 1);
         $maskedDB = $db ^ $dbMask;
         $seedMask = $this->_mgf1($maskedDB, $this->hLen);
@@ -1524,7 +2372,7 @@ class Crypt_RSA {
      *
      * See {@link http://tools.ietf.org/html/rfc3447#section-7.1.2 RFC3447#section-7.1.2}.  The fact that the error
      * messages aren't distinguishable from one another hinders debugging, but, to quote from RFC3447#section-7.1.2:
-     * 
+     *
      *    Note.  Care must be taken to ensure that an opponent cannot
      *    distinguish the different error conditions in Step 3.g, whether by
      *    error message or timing, or, more generally, learn partial
@@ -1541,9 +2389,9 @@ class Crypt_RSA {
      *    this document.
      *
      * @access private
-     * @param String $c
-     * @param String $l
-     * @return String
+     * @param string $c
+     * @param string $l
+     * @return string
      */
     function _rsaes_oaep_decrypt($c, $l = '')
     {
@@ -1553,7 +2401,7 @@ class Crypt_RSA {
         // be output.
 
         if (strlen($c) != $this->k || $this->k < 2 * $this->hLen + 2) {
-            user_error('Decryption error', E_USER_NOTICE);
+            user_error('Decryption error');
             return false;
         }
 
@@ -1562,7 +2410,7 @@ class Crypt_RSA {
         $c = $this->_os2ip($c);
         $m = $this->_rsadp($c);
         if ($m === false) {
-            user_error('Decryption error', E_USER_NOTICE);
+            user_error('Decryption error');
             return false;
         }
         $em = $this->_i2osp($m, $this->k);
@@ -1579,13 +2427,13 @@ class Crypt_RSA {
         $db = $maskedDB ^ $dbMask;
         $lHash2 = substr($db, 0, $this->hLen);
         $m = substr($db, $this->hLen);
-        if ($lHash != $lHash2) {
-            user_error('Decryption error', E_USER_NOTICE);
+        if (!$this->_equals($lHash, $lHash2)) {
+            user_error('Decryption error');
             return false;
         }
         $m = ltrim($m, chr(0));
         if (ord($m[0]) != 1) {
-            user_error('Decryption error', E_USER_NOTICE);
+            user_error('Decryption error');
             return false;
         }
 
@@ -1595,13 +2443,29 @@ class Crypt_RSA {
     }
 
     /**
+     * Raw Encryption / Decryption
+     *
+     * Doesn't use padding and is not recommended.
+     *
+     * @access private
+     * @param string $m
+     * @return string
+     */
+    function _raw_encrypt($m)
+    {
+        $temp = $this->_os2ip($m);
+        $temp = $this->_rsaep($temp);
+        return  $this->_i2osp($temp, $this->k);
+    }
+
+    /**
      * RSAES-PKCS1-V1_5-ENCRYPT
      *
      * See {@link http://tools.ietf.org/html/rfc3447#section-7.2.1 RFC3447#section-7.2.1}.
      *
      * @access private
-     * @param String $m
-     * @return String
+     * @param string $m
+     * @return string
      */
     function _rsaes_pkcs1_v1_5_encrypt($m)
     {
@@ -1610,14 +2474,27 @@ class Crypt_RSA {
         // Length checking
 
         if ($mLen > $this->k - 11) {
-            user_error('Message too long', E_USER_NOTICE);
+            user_error('Message too long');
             return false;
         }
 
         // EME-PKCS1-v1_5 encoding
 
-        $ps = $this->_random($this->k - $mLen - 3, true);
-        $em = chr(0) . chr(2) . $ps . chr(0) . $m;
+        $psLen = $this->k - $mLen - 3;
+        $ps = '';
+        while (strlen($ps) != $psLen) {
+            $temp = Random::string($psLen - strlen($ps));
+            $temp = str_replace("\x00", '', $temp);
+            $ps.= $temp;
+        }
+        $type = 2;
+        // see the comments of _rsaes_pkcs1_v1_5_decrypt() to understand why this is being done
+        if (defined('CRYPT_RSA_PKCS15_COMPAT') && (!isset($this->publicExponent) || $this->exponent !== $this->publicExponent)) {
+            $type = 1;
+            // "The padding string PS shall consist of k-3-||D|| octets. ... for block type 01, they shall have value FF"
+            $ps = str_repeat("\xFF", $psLen);
+        }
+        $em = chr(0) . chr($type) . $ps . chr(0) . $m;
 
         // RSA encryption
         $m = $this->_os2ip($em);
@@ -1634,27 +2511,27 @@ class Crypt_RSA {
      *
      * See {@link http://tools.ietf.org/html/rfc3447#section-7.2.2 RFC3447#section-7.2.2}.
      *
-     * For compatability purposes, this function departs slightly from the description given in RFC3447.
+     * For compatibility purposes, this function departs slightly from the description given in RFC3447.
      * The reason being that RFC2313#section-8.1 (PKCS#1 v1.5) states that ciphertext's encrypted by the
      * private key should have the second byte set to either 0 or 1 and that ciphertext's encrypted by the
      * public key should have the second byte set to 2.  In RFC3447 (PKCS#1 v2.1), the second byte is supposed
-     * to be 2 regardless of which key is used.  for compatability purposes, we'll just check to make sure the
+     * to be 2 regardless of which key is used.  For compatibility purposes, we'll just check to make sure the
      * second byte is 2 or less.  If it is, we'll accept the decrypted string as valid.
      *
-     * As a consequence of this, a private key encrypted ciphertext produced with Crypt_RSA may not decrypt
+     * As a consequence of this, a private key encrypted ciphertext produced with \phpseclib\Crypt\RSA may not decrypt
      * with a strictly PKCS#1 v1.5 compliant RSA implementation.  Public key encrypted ciphertext's should but
      * not private key encrypted ciphertext's.
      *
      * @access private
-     * @param String $c
-     * @return String
+     * @param string $c
+     * @return string
      */
     function _rsaes_pkcs1_v1_5_decrypt($c)
     {
         // Length checking
 
         if (strlen($c) != $this->k) { // or if k < 11
-            user_error('Decryption error', E_USER_NOTICE);
+            user_error('Decryption error');
             return false;
         }
 
@@ -1662,8 +2539,9 @@ class Crypt_RSA {
 
         $c = $this->_os2ip($c);
         $m = $this->_rsadp($c);
+
         if ($m === false) {
-            user_error('Decryption error', E_USER_NOTICE);
+            user_error('Decryption error');
             return false;
         }
         $em = $this->_i2osp($m, $this->k);
@@ -1671,7 +2549,7 @@ class Crypt_RSA {
         // EME-PKCS1-v1_5 decoding
 
         if (ord($em[0]) != 0 || ord($em[1]) > 2) {
-            user_error('Decryption error', E_USER_NOTICE);
+            user_error('Decryption error');
             return false;
         }
 
@@ -1679,7 +2557,7 @@ class Crypt_RSA {
         $m = substr($em, strlen($ps) + 3);
 
         if (strlen($ps) < 8) {
-            user_error('Decryption error', E_USER_NOTICE);
+            user_error('Decryption error');
             return false;
         }
 
@@ -1694,8 +2572,8 @@ class Crypt_RSA {
      * See {@link http://tools.ietf.org/html/rfc3447#section-9.1.1 RFC3447#section-9.1.1}.
      *
      * @access private
-     * @param String $m
-     * @param Integer $emBits
+     * @param string $m
+     * @param int $emBits
      */
     function _emsa_pss_encode($m, $emBits)
     {
@@ -1703,15 +2581,15 @@ class Crypt_RSA {
         // be output.
 
         $emLen = ($emBits + 1) >> 3; // ie. ceil($emBits / 8)
-        $sLen = $this->sLen == false ? $this->hLen : $this->sLen;
+        $sLen = $this->sLen !== null ? $this->sLen : $this->hLen;
 
         $mHash = $this->hash->hash($m);
         if ($emLen < $this->hLen + $sLen + 2) {
-            user_error('Encoding error', E_USER_NOTICE);
+            user_error('Encoding error');
             return false;
         }
 
-        $salt = $this->_random($sLen);
+        $salt = Random::string($sLen);
         $m2 = "\0\0\0\0\0\0\0\0" . $mHash . $salt;
         $h = $this->hash->hash($m2);
         $ps = str_repeat(chr(0), $emLen - $sLen - $this->hLen - 2);
@@ -1730,10 +2608,10 @@ class Crypt_RSA {
      * See {@link http://tools.ietf.org/html/rfc3447#section-9.1.2 RFC3447#section-9.1.2}.
      *
      * @access private
-     * @param String $m
-     * @param String $em
-     * @param Integer $emBits
-     * @return String
+     * @param string $m
+     * @param string $em
+     * @param int $emBits
+     * @return string
      */
     function _emsa_pss_verify($m, $em, $emBits)
     {
@@ -1741,7 +2619,7 @@ class Crypt_RSA {
         // be output.
 
         $emLen = ($emBits + 1) >> 3; // ie. ceil($emBits / 8);
-        $sLen = $this->sLen == false ? $this->hLen : $this->sLen;
+        $sLen = $this->sLen !== null ? $this->sLen : $this->hLen;
 
         $mHash = $this->hash->hash($m);
         if ($emLen < $this->hLen + $sLen + 2) {
@@ -1752,8 +2630,8 @@ class Crypt_RSA {
             return false;
         }
 
-        $maskedDB = substr($em, 0, $em - $this->hLen - 1);
-        $h = substr($em, $em - $this->hLen - 1, $this->hLen);
+        $maskedDB = substr($em, 0, -$this->hLen - 1);
+        $h = substr($em, -$this->hLen - 1, $this->hLen);
         $temp = chr(0xFF << ($emBits & 7));
         if ((~$maskedDB[0] & $temp) != $temp) {
             return false;
@@ -1768,7 +2646,7 @@ class Crypt_RSA {
         $salt = substr($db, $temp + 1); // should be $sLen long
         $m2 = "\0\0\0\0\0\0\0\0" . $mHash . $salt;
         $h2 = $this->hash->hash($m2);
-        return $h == $h2;
+        return $this->_equals($h, $h2);
     }
 
     /**
@@ -1777,8 +2655,8 @@ class Crypt_RSA {
      * See {@link http://tools.ietf.org/html/rfc3447#section-8.1.1 RFC3447#section-8.1.1}.
      *
      * @access private
-     * @param String $m
-     * @return String
+     * @param string $m
+     * @return string
      */
     function _rsassa_pss_sign($m)
     {
@@ -1803,16 +2681,16 @@ class Crypt_RSA {
      * See {@link http://tools.ietf.org/html/rfc3447#section-8.1.2 RFC3447#section-8.1.2}.
      *
      * @access private
-     * @param String $m
-     * @param String $s
-     * @return String
+     * @param string $m
+     * @param string $s
+     * @return string
      */
     function _rsassa_pss_verify($m, $s)
     {
         // Length checking
 
         if (strlen($s) != $this->k) {
-            user_error('Invalid signature', E_USER_NOTICE);
+            user_error('Invalid signature');
             return false;
         }
 
@@ -1823,12 +2701,12 @@ class Crypt_RSA {
         $s2 = $this->_os2ip($s);
         $m2 = $this->_rsavp1($s2);
         if ($m2 === false) {
-            user_error('Invalid signature', E_USER_NOTICE);
+            user_error('Invalid signature');
             return false;
         }
         $em = $this->_i2osp($m2, $modBits >> 3);
         if ($em === false) {
-            user_error('Invalid signature', E_USER_NOTICE);
+            user_error('Invalid signature');
             return false;
         }
 
@@ -1843,9 +2721,9 @@ class Crypt_RSA {
      * See {@link http://tools.ietf.org/html/rfc3447#section-9.2 RFC3447#section-9.2}.
      *
      * @access private
-     * @param String $m
-     * @param Integer $emLen
-     * @return String
+     * @param string $m
+     * @param int $emLen
+     * @return string
      */
     function _emsa_pkcs1_v1_5_encode($m, $emLen)
     {
@@ -1878,7 +2756,7 @@ class Crypt_RSA {
         $tLen = strlen($t);
 
         if ($emLen < $tLen + 11) {
-            user_error('Intended encoded message length too short', E_USER_NOTICE);
+            user_error('Intended encoded message length too short');
             return false;
         }
 
@@ -1895,8 +2773,8 @@ class Crypt_RSA {
      * See {@link http://tools.ietf.org/html/rfc3447#section-8.2.1 RFC3447#section-8.2.1}.
      *
      * @access private
-     * @param String $m
-     * @return String
+     * @param string $m
+     * @return string
      */
     function _rsassa_pkcs1_v1_5_sign($m)
     {
@@ -1904,7 +2782,7 @@ class Crypt_RSA {
 
         $em = $this->_emsa_pkcs1_v1_5_encode($m, $this->k);
         if ($em === false) {
-            user_error('RSA modulus too short', E_USER_NOTICE);
+            user_error('RSA modulus too short');
             return false;
         }
 
@@ -1925,15 +2803,15 @@ class Crypt_RSA {
      * See {@link http://tools.ietf.org/html/rfc3447#section-8.2.2 RFC3447#section-8.2.2}.
      *
      * @access private
-     * @param String $m
-     * @return String
+     * @param string $m
+     * @return string
      */
     function _rsassa_pkcs1_v1_5_verify($m, $s)
     {
         // Length checking
 
         if (strlen($s) != $this->k) {
-            user_error('Invalid signature', E_USER_NOTICE);
+            user_error('Invalid signature');
             return false;
         }
 
@@ -1942,12 +2820,12 @@ class Crypt_RSA {
         $s = $this->_os2ip($s);
         $m2 = $this->_rsavp1($s);
         if ($m2 === false) {
-            user_error('Invalid signature', E_USER_NOTICE);
+            user_error('Invalid signature');
             return false;
         }
         $em = $this->_i2osp($m2, $this->k);
         if ($em === false) {
-            user_error('Invalid signature', E_USER_NOTICE);
+            user_error('Invalid signature');
             return false;
         }
 
@@ -1955,22 +2833,21 @@ class Crypt_RSA {
 
         $em2 = $this->_emsa_pkcs1_v1_5_encode($m, $this->k);
         if ($em2 === false) {
-            user_error('RSA modulus too short', E_USER_NOTICE);
+            user_error('RSA modulus too short');
             return false;
         }
 
         // Compare
-
-        return $em === $em2;
+        return $this->_equals($em, $em2);
     }
 
     /**
      * Set Encryption Mode
      *
-     * Valid values include CRYPT_RSA_ENCRYPTION_OAEP and CRYPT_RSA_ENCRYPTION_PKCS1.
+     * Valid values include self::ENCRYPTION_OAEP and self::ENCRYPTION_PKCS1.
      *
      * @access public
-     * @param Integer $mode
+     * @param int $mode
      */
     function setEncryptionMode($mode)
     {
@@ -1980,10 +2857,10 @@ class Crypt_RSA {
     /**
      * Set Signature Mode
      *
-     * Valid values include CRYPT_RSA_SIGNATURE_PSS and CRYPT_RSA_SIGNATURE_PKCS1
+     * Valid values include self::SIGNATURE_PSS and self::SIGNATURE_PKCS1
      *
      * @access public
-     * @param Integer $mode
+     * @param int $mode
      */
     function setSignatureMode($mode)
     {
@@ -1991,21 +2868,50 @@ class Crypt_RSA {
     }
 
     /**
+     * Set public key comment.
+     *
+     * @access public
+     * @param string $comment
+     */
+    function setComment($comment)
+    {
+        $this->comment = $comment;
+    }
+
+    /**
+     * Get public key comment.
+     *
+     * @access public
+     * @return string
+     */
+    function getComment()
+    {
+        return $this->comment;
+    }
+
+    /**
      * Encryption
      *
-     * Both CRYPT_RSA_ENCRYPTION_OAEP and CRYPT_RSA_ENCRYPTION_PKCS1 both place limits on how long $plaintext can be.
+     * Both self::ENCRYPTION_OAEP and self::ENCRYPTION_PKCS1 both place limits on how long $plaintext can be.
      * If $plaintext exceeds those limits it will be broken up so that it does and the resultant ciphertext's will
      * be concatenated together.
      *
-     * @see decrypt()
+     * @see self::decrypt()
      * @access public
-     * @param String $plaintext
-     * @return String
+     * @param string $plaintext
+     * @return string
      */
     function encrypt($plaintext)
     {
         switch ($this->encryptionMode) {
-            case CRYPT_RSA_ENCRYPTION_PKCS1:
+            case self::ENCRYPTION_NONE:
+                $plaintext = str_split($plaintext, $this->k);
+                $ciphertext = '';
+                foreach ($plaintext as $m) {
+                    $ciphertext.= $this->_raw_encrypt($m);
+                }
+                return $ciphertext;
+            case self::ENCRYPTION_PKCS1:
                 $length = $this->k - 11;
                 if ($length <= 0) {
                     return false;
@@ -2017,7 +2923,7 @@ class Crypt_RSA {
                     $ciphertext.= $this->_rsaes_pkcs1_v1_5_encrypt($m);
                 }
                 return $ciphertext;
-            //case CRYPT_RSA_ENCRYPTION_OAEP:
+            //case self::ENCRYPTION_OAEP:
             default:
                 $length = $this->k - 2 * $this->hLen - 2;
                 if ($length <= 0) {
@@ -2036,10 +2942,10 @@ class Crypt_RSA {
     /**
      * Decryption
      *
-     * @see encrypt()
+     * @see self::encrypt()
      * @access public
-     * @param String $plaintext
-     * @return String
+     * @param string $plaintext
+     * @return string
      */
     function decrypt($ciphertext)
     {
@@ -2048,13 +2954,18 @@ class Crypt_RSA {
         }
 
         $ciphertext = str_split($ciphertext, $this->k);
+        $ciphertext[count($ciphertext) - 1] = str_pad($ciphertext[count($ciphertext) - 1], $this->k, chr(0), STR_PAD_LEFT);
+
         $plaintext = '';
 
         switch ($this->encryptionMode) {
-            case CRYPT_RSA_ENCRYPTION_PKCS1:
+            case self::ENCRYPTION_NONE:
+                $decrypt = '_raw_encrypt';
+                break;
+            case self::ENCRYPTION_PKCS1:
                 $decrypt = '_rsaes_pkcs1_v1_5_decrypt';
                 break;
-            //case CRYPT_RSA_ENCRYPTION_OAEP:
+            //case self::ENCRYPTION_OAEP:
             default:
                 $decrypt = '_rsaes_oaep_decrypt';
         }
@@ -2073,10 +2984,10 @@ class Crypt_RSA {
     /**
      * Create a signature
      *
-     * @see verify()
+     * @see self::verify()
      * @access public
-     * @param String $message
-     * @return String
+     * @param string $message
+     * @return string
      */
     function sign($message)
     {
@@ -2085,9 +2996,9 @@ class Crypt_RSA {
         }
 
         switch ($this->signatureMode) {
-            case CRYPT_RSA_SIGNATURE_PKCS1:
+            case self::SIGNATURE_PKCS1:
                 return $this->_rsassa_pkcs1_v1_5_sign($message);
-            //case CRYPT_RSA_SIGNATURE_PSS:
+            //case self::SIGNATURE_PSS:
             default:
                 return $this->_rsassa_pss_sign($message);
         }
@@ -2096,11 +3007,11 @@ class Crypt_RSA {
     /**
      * Verifies a signature
      *
-     * @see sign()
+     * @see self::sign()
      * @access public
-     * @param String $message
-     * @param String $signature
-     * @return Boolean
+     * @param string $message
+     * @param string $signature
+     * @return bool
      */
     function verify($message, $signature)
     {
@@ -2109,11 +3020,38 @@ class Crypt_RSA {
         }
 
         switch ($this->signatureMode) {
-            case CRYPT_RSA_SIGNATURE_PKCS1:
+            case self::SIGNATURE_PKCS1:
                 return $this->_rsassa_pkcs1_v1_5_verify($message, $signature);
-            //case CRYPT_RSA_SIGNATURE_PSS:
+            //case self::SIGNATURE_PSS:
             default:
                 return $this->_rsassa_pss_verify($message, $signature);
         }
     }
+
+    /**
+     * Extract raw BER from Base64 encoding
+     *
+     * @access private
+     * @param string $str
+     * @return string
+     */
+    function _extractBER($str)
+    {
+        /* X.509 certs are assumed to be base64 encoded but sometimes they'll have additional things in them
+         * above and beyond the ceritificate.
+         * ie. some may have the following preceding the -----BEGIN CERTIFICATE----- line:
+         *
+         * Bag Attributes
+         *     localKeyID: 01 00 00 00
+         * subject=/O=organization/OU=org unit/CN=common name
+         * issuer=/O=organization/CN=common name
+         */
+        $temp = preg_replace('#.*?^-+[^-]+-+[\r\n ]*$#ms', '', $str, 1);
+        // remove the -----BEGIN CERTIFICATE----- and -----END CERTIFICATE----- stuff
+        $temp = preg_replace('#-+[^-]+-+#', '', $temp);
+        // remove new lines
+        $temp = str_replace(array("\r", "\n", ' '), '', $temp);
+        $temp = preg_match('#^[a-zA-Z\d/+]*={0,2}$#', $temp) ? base64_decode($temp) : false;
+        return $temp != false ? $temp : $str;
+    }
 }
diff --git a/lib/phpseclib/Crypt/Random.php b/lib/phpseclib/Crypt/Random.php
index e8902d9..01e34cc 100644
--- a/lib/phpseclib/Crypt/Random.php
+++ b/lib/phpseclib/Crypt/Random.php
@@ -1,129 +1,274 @@
 <?php
-/* vim: set expandtab tabstop=4 shiftwidth=4 softtabstop=4: */
 
 /**
  * Random Number Generator
  *
- * PHP versions 4 and 5
+ * PHP version 5
  *
  * Here's a short example of how to use this library:
  * <code>
  * <?php
- *    include('Crypt/Random.php');
+ *    include 'vendor/autoload.php';
  *
- *    echo crypt_random();
+ *    echo bin2hex(\phpseclib\Crypt\Random::string(8));
  * ?>
  * </code>
  *
- * LICENSE: This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA  02111-1307  USA
- *
- * @category   Crypt
- * @package    Crypt_Random
- * @author     Jim Wigginton <terrafrost@php.net>
- * @copyright  MMVII Jim Wigginton
- * @license    http://www.gnu.org/licenses/lgpl.txt
- * @version    $Id: Random.php,v 1.9 2010/04/24 06:40:48 terrafrost Exp $
- * @link       http://phpseclib.sourceforge.net
+ * @category  Crypt
+ * @package   Random
+ * @author    Jim Wigginton <terrafrost@php.net>
+ * @copyright 2007 Jim Wigginton
+ * @license   http://www.opensource.org/licenses/mit-license.html  MIT License
+ * @link      http://phpseclib.sourceforge.net
  */
 
+namespace phpseclib\Crypt;
+
 /**
- * Generate a random value.
- *
- * On 32-bit machines, the largest distance that can exist between $min and $max is 2**31.
- * If $min and $max are farther apart than that then the last ($max - range) numbers.
- *
- * Depending on how this is being used, it may be worth while to write a replacement.  For example,
- * a PHP-based web app that stores its data in an SQL database can collect more entropy than this function
- * can.
+ * Pure-PHP Random Number Generator
  *
- * @param optional Integer $min
- * @param optional Integer $max
- * @return Integer
- * @access public
+ * @package Random
+ * @author  Jim Wigginton <terrafrost@php.net>
+ * @access  public
  */
-function crypt_random($min = 0, $max = 0x7FFFFFFF)
+class Random
 {
-    if ($min == $max) {
-        return $min;
-    }
+    /**
+     * Generate a random string.
+     *
+     * Although microoptimizations are generally discouraged as they impair readability this function is ripe with
+     * microoptimizations because this function has the potential of being called a huge number of times.
+     * eg. for RSA key generation.
+     *
+     * @param int $length
+     * @return string
+     */
+    static function string($length)
+    {
+        if (!$length) {
+            return '';
+        }
 
-    // see http://en.wikipedia.org/wiki//dev/random
-    // if open_basedir is enabled file_exists() will ouput an "open_basedir restriction in effect" warning,
-    // so we suppress it.
-    if (@file_exists('/dev/urandom')) {
-        static $fp;
-        if (!$fp) {
-            $fp = fopen('/dev/urandom', 'rb');
+        if (version_compare(PHP_VERSION, '7.0.0', '>=')) {
+            try {
+                return \random_bytes($length);
+            } catch (\Throwable $e) {
+                // If a sufficient source of randomness is unavailable, random_bytes() will throw an
+                // object that implements the Throwable interface (Exception, TypeError, Error).
+                // We don't actually need to do anything here. The string() method should just continue
+                // as normal. Note, however, that if we don't have a sufficient source of randomness for
+                // random_bytes(), most of the other calls here will fail too, so we'll end up using
+                // the PHP implementation.
+            }
         }
-        extract(unpack('Nrandom', fread($fp, 4)));
 
-        // say $min = 0 and $max = 3.  if we didn't do abs() then we could have stuff like this:
-        // -4 % 3 + 0 = -1, even though -1 < $min
-        return abs($random) % ($max - $min) + $min;
-    }
+        if (strtoupper(substr(PHP_OS, 0, 3)) === 'WIN') {
+            // method 1. prior to PHP 5.3 this would call rand() on windows hence the function_exists('class_alias') call.
+            // ie. class_alias is a function that was introduced in PHP 5.3
+            if (extension_loaded('mcrypt') && function_exists('class_alias')) {
+                return @mcrypt_create_iv($length);
+            }
+            // method 2. openssl_random_pseudo_bytes was introduced in PHP 5.3.0 but prior to PHP 5.3.4 there was,
+            // to quote <http://php.net/ChangeLog-5.php#5.3.4>, "possible blocking behavior". as of 5.3.4
+            // openssl_random_pseudo_bytes and mcrypt_create_iv do the exact same thing on Windows. ie. they both
+            // call php_win32_get_random_bytes():
+            //
+            // https://github.com/php/php-src/blob/7014a0eb6d1611151a286c0ff4f2238f92c120d6/ext/openssl/openssl.c#L5008
+            // https://github.com/php/php-src/blob/7014a0eb6d1611151a286c0ff4f2238f92c120d6/ext/mcrypt/mcrypt.c#L1392
+            //
+            // php_win32_get_random_bytes() is defined thusly:
+            //
+            // https://github.com/php/php-src/blob/7014a0eb6d1611151a286c0ff4f2238f92c120d6/win32/winutil.c#L80
+            //
+            // we're calling it, all the same, in the off chance that the mcrypt extension is not available
+            if (extension_loaded('openssl') && version_compare(PHP_VERSION, '5.3.4', '>=')) {
+                return openssl_random_pseudo_bytes($length);
+            }
+        } else {
+            // method 1. the fastest
+            if (extension_loaded('openssl')) {
+                return openssl_random_pseudo_bytes($length);
+            }
+            // method 2
+            static $fp = true;
+            if ($fp === true) {
+                // warning's will be output unles the error suppression operator is used. errors such as
+                // "open_basedir restriction in effect", "Permission denied", "No such file or directory", etc.
+                $fp = @fopen('/dev/urandom', 'rb');
+            }
+            if ($fp !== true && $fp !== false) { // surprisingly faster than !is_bool() or is_resource()
+                return fread($fp, $length);
+            }
+            // method 3. pretty much does the same thing as method 2 per the following url:
+            // https://github.com/php/php-src/blob/7014a0eb6d1611151a286c0ff4f2238f92c120d6/ext/mcrypt/mcrypt.c#L1391
+            // surprisingly slower than method 2. maybe that's because mcrypt_create_iv does a bunch of error checking that we're
+            // not doing. regardless, this'll only be called if this PHP script couldn't open /dev/urandom due to open_basedir
+            // restrictions or some such
+            if (extension_loaded('mcrypt')) {
+                return @mcrypt_create_iv($length, MCRYPT_DEV_URANDOM);
+            }
+        }
+        // at this point we have no choice but to use a pure-PHP CSPRNG
 
-    /* Prior to PHP 4.2.0, mt_srand() had to be called before mt_rand() could be called.
-       Prior to PHP 5.2.6, mt_rand()'s automatic seeding was subpar, as elaborated here:
+        // cascade entropy across multiple PHP instances by fixing the session and collecting all
+        // environmental variables, including the previous session data and the current session
+        // data.
+        //
+        // mt_rand seeds itself by looking at the PID and the time, both of which are (relatively)
+        // easy to guess at. linux uses mouse clicks, keyboard timings, etc, as entropy sources, but
+        // PHP isn't low level to be able to use those as sources and on a web server there's not likely
+        // going to be a ton of keyboard or mouse action. web servers do have one thing that we can use
+        // however, a ton of people visiting the website. obviously you don't want to base your seeding
+        // soley on parameters a potential attacker sends but (1) not everything in $_SERVER is controlled
+        // by the user and (2) this isn't just looking at the data sent by the current user - it's based
+        // on the data sent by all users. one user requests the page and a hash of their info is saved.
+        // another user visits the page and the serialization of their data is utilized along with the
+        // server envirnment stuff and a hash of the previous http request data (which itself utilizes
+        // a hash of the session data before that). certainly an attacker should be assumed to have
+        // full control over his own http requests. he, however, is not going to have control over
+        // everyone's http requests.
+        static $crypto = false, $v;
+        if ($crypto === false) {
+            // save old session data
+            $old_session_id = session_id();
+            $old_use_cookies = ini_get('session.use_cookies');
+            $old_session_cache_limiter = session_cache_limiter();
+            $_OLD_SESSION = isset($_SESSION) ? $_SESSION : false;
+            if ($old_session_id != '') {
+                session_write_close();
+            }
 
-       http://www.suspekt.org/2008/08/17/mt_srand-and-not-so-random-numbers/
+            session_id(1);
+            ini_set('session.use_cookies', 0);
+            session_cache_limiter('');
+            session_start();
 
-       The seeding routine is pretty much ripped from PHP's own internal GENERATE_SEED() macro:
+            $v = $seed = $_SESSION['seed'] = pack('H*', sha1(
+                (isset($_SERVER) ? phpseclib_safe_serialize($_SERVER) : '') .
+                (isset($_POST) ? phpseclib_safe_serialize($_POST) : '') .
+                (isset($_GET) ? phpseclib_safe_serialize($_GET) : '') .
+                (isset($_COOKIE) ? phpseclib_safe_serialize($_COOKIE) : '') .
+                phpseclib_safe_serialize($GLOBALS) .
+                phpseclib_safe_serialize($_SESSION) .
+                phpseclib_safe_serialize($_OLD_SESSION)
+            ));
+            if (!isset($_SESSION['count'])) {
+                $_SESSION['count'] = 0;
+            }
+            $_SESSION['count']++;
 
-       http://svn.php.net/viewvc/php/php-src/branches/PHP_5_3_2/ext/standard/php_rand.h?view=markup */
-    if (version_compare(PHP_VERSION, '5.2.5', '<=')) { 
-        static $seeded;
-        if (!isset($seeded)) {
-            $seeded = true;
-            mt_srand(fmod(time() * getmypid(), 0x7FFFFFFF) ^ fmod(1000000 * lcg_value(), 0x7FFFFFFF));
-        }
-    }
+            session_write_close();
+
+            // restore old session data
+            if ($old_session_id != '') {
+                session_id($old_session_id);
+                session_start();
+                ini_set('session.use_cookies', $old_use_cookies);
+                session_cache_limiter($old_session_cache_limiter);
+            } else {
+                if ($_OLD_SESSION !== false) {
+                    $_SESSION = $_OLD_SESSION;
+                    unset($_OLD_SESSION);
+                } else {
+                    unset($_SESSION);
+                }
+            }
 
-    static $crypto;
+            // in SSH2 a shared secret and an exchange hash are generated through the key exchange process.
+            // the IV client to server is the hash of that "nonce" with the letter A and for the encryption key it's the letter C.
+            // if the hash doesn't produce enough a key or an IV that's long enough concat successive hashes of the
+            // original hash and the current hash. we'll be emulating that. for more info see the following URL:
+            //
+            // http://tools.ietf.org/html/rfc4253#section-7.2
+            //
+            // see the is_string($crypto) part for an example of how to expand the keys
+            $key = pack('H*', sha1($seed . 'A'));
+            $iv = pack('H*', sha1($seed . 'C'));
 
-    // The CSPRNG's Yarrow and Fortuna periodically reseed.  This function can be reseeded by hitting F5
-    // in the browser and reloading the page.
+            // ciphers are used as per the nist.gov link below. also, see this link:
+            //
+            // http://en.wikipedia.org/wiki/Cryptographically_secure_pseudorandom_number_generator#Designs_based_on_cryptographic_primitives
+            switch (true) {
+                case class_exists('\phpseclib\Crypt\AES'):
+                    $crypto = new AES(Base::MODE_CTR);
+                    break;
+                case class_exists('\phpseclib\Crypt\Twofish'):
+                    $crypto = new Twofish(Base::MODE_CTR);
+                    break;
+                case class_exists('\phpseclib\Crypt\Blowfish'):
+                    $crypto = new Blowfish(Base::MODE_CTR);
+                    break;
+                case class_exists('\phpseclib\Crypt\TripleDES'):
+                    $crypto = new TripleDES(Base::MODE_CTR);
+                    break;
+                case class_exists('\phpseclib\Crypt\DES'):
+                    $crypto = new DES(Base::MODE_CTR);
+                    break;
+                case class_exists('\phpseclib\Crypt\RC4'):
+                    $crypto = new RC4();
+                    break;
+                default:
+                    user_error(__CLASS__ . ' requires at least one symmetric cipher be loaded');
+                    return false;
+            }
 
-    if (!isset($crypto)) {
-        $key = $iv = '';
-        for ($i = 0; $i < 8; $i++) {
-            $key.= pack('n', mt_rand(0, 0xFFFF));
-            $iv .= pack('n', mt_rand(0, 0xFFFF));
+            $crypto->setKey($key);
+            $crypto->setIV($iv);
+            $crypto->enableContinuousBuffer();
         }
-        switch (true) {
-            case class_exists('Crypt_AES'):
-                $crypto = new Crypt_AES(CRYPT_AES_MODE_CTR);
-                break;
-            case class_exists('Crypt_TripleDES'):
-                $crypto = new Crypt_TripleDES(CRYPT_DES_MODE_CTR);
-                break;
-            case class_exists('Crypt_DES'):
-                $crypto = new Crypt_DES(CRYPT_DES_MODE_CTR);
-                break;
-            case class_exists('Crypt_RC4'):
-                $crypto = new Crypt_RC4();
-                break;
-            default:
-                extract(unpack('Nrandom', pack('H*', sha1(mt_rand(0, 0x7FFFFFFF)))));
-                return abs($random) % ($max - $min) + $min;
+
+        //return $crypto->encrypt(str_repeat("\0", $length));
+
+        // the following is based off of ANSI X9.31:
+        //
+        // http://csrc.nist.gov/groups/STM/cavp/documents/rng/931rngext.pdf
+        //
+        // OpenSSL uses that same standard for it's random numbers:
+        //
+        // http://www.opensource.apple.com/source/OpenSSL/OpenSSL-38/openssl/fips-1.0/rand/fips_rand.c
+        // (do a search for "ANS X9.31 A.2.4")
+        $result = '';
+        while (strlen($result) < $length) {
+            $i = $crypto->encrypt(microtime()); // strlen(microtime()) == 21
+            $r = $crypto->encrypt($i ^ $v); // strlen($v) == 20
+            $v = $crypto->encrypt($r ^ $i); // strlen($r) == 20
+            $result.= $r;
         }
-        $crypto->setKey($key);
-        $crypto->setIV($iv);
-        $crypto->enableContinuousBuffer();
+        return substr($result, 0, $length);
     }
+}
 
-    extract(unpack('Nrandom', $crypto->encrypt("\0\0\0\0")));
-    return abs($random) % ($max - $min) + $min;
+if (!function_exists('phpseclib_safe_serialize')) {
+    /**
+     * Safely serialize variables
+     *
+     * If a class has a private __sleep() method it'll give a fatal error on PHP 5.2 and earlier.
+     * PHP 5.3 will emit a warning.
+     *
+     * @param mixed $arr
+     * @access public
+     */
+    function phpseclib_safe_serialize(&$arr)
+    {
+        if (is_object($arr)) {
+            return '';
+        }
+        if (!is_array($arr)) {
+            return serialize($arr);
+        }
+        // prevent circular array recursion
+        if (isset($arr['__phpseclib_marker'])) {
+            return '';
+        }
+        $safearr = array();
+        $arr['__phpseclib_marker'] = true;
+        foreach (array_keys($arr) as $key) {
+            // do not recurse on the '__phpseclib_marker' key itself, for smaller memory usage
+            if ($key !== '__phpseclib_marker') {
+                $safearr[$key] = phpseclib_safe_serialize($arr[$key]);
+            }
+        }
+        unset($arr['__phpseclib_marker']);
+        return serialize($safearr);
+    }
 }
diff --git a/lib/phpseclib/Crypt/Rijndael.php b/lib/phpseclib/Crypt/Rijndael.php
index 922fd12..3648a19 100644
--- a/lib/phpseclib/Crypt/Rijndael.php
+++ b/lib/phpseclib/Crypt/Rijndael.php
@@ -1,36 +1,36 @@
 <?php
-/* vim: set expandtab tabstop=4 shiftwidth=4 softtabstop=4: */
 
 /**
  * Pure-PHP implementation of Rijndael.
  *
- * Does not use mcrypt, even when available, for reasons that are explained below.
+ * Uses mcrypt, if available/possible, and an internal implementation, otherwise.
  *
- * PHP versions 4 and 5
+ * PHP version 5
  *
- * If {@link Crypt_Rijndael::setBlockLength() setBlockLength()} isn't called, it'll be assumed to be 128 bits.  If 
- * {@link Crypt_Rijndael::setKeyLength() setKeyLength()} isn't called, it'll be calculated from 
- * {@link Crypt_Rijndael::setKey() setKey()}.  ie. if the key is 128-bits, the key length will be 128-bits.  If it's 
- * 136-bits it'll be null-padded to 160-bits and 160 bits will be the key length until 
- * {@link Crypt_Rijndael::setKey() setKey()} is called, again, at which point, it'll be recalculated.
+ * If {@link self::setBlockLength() setBlockLength()} isn't called, it'll be assumed to be 128 bits.  If
+ * {@link self::setKeyLength() setKeyLength()} isn't called, it'll be calculated from
+ * {@link self::setKey() setKey()}.  ie. if the key is 128-bits, the key length will be 128-bits.  If it's
+ * 136-bits it'll be null-padded to 192-bits and 192 bits will be the key length until
+ * {@link self::setKey() setKey()} is called, again, at which point, it'll be recalculated.
  *
  * Not all Rijndael implementations may support 160-bits or 224-bits as the block length / key length.  mcrypt, for example,
  * does not.  AES, itself, only supports block lengths of 128 and key lengths of 128, 192, and 256.
  * {@link http://csrc.nist.gov/archive/aes/rijndael/Rijndael-ammended.pdf#page=10 Rijndael-ammended.pdf#page=10} defines the
  * algorithm for block lengths of 192 and 256 but not for block lengths / key lengths of 160 and 224.  Indeed, 160 and 224
- * are first defined as valid key / block lengths in 
- * {@link http://csrc.nist.gov/archive/aes/rijndael/Rijndael-ammended.pdf#page=44 Rijndael-ammended.pdf#page=44}: 
+ * are first defined as valid key / block lengths in
+ * {@link http://csrc.nist.gov/archive/aes/rijndael/Rijndael-ammended.pdf#page=44 Rijndael-ammended.pdf#page=44}:
  * Extensions: Other block and Cipher Key lengths.
+ * Note: Use of 160/224-bit Keys must be explicitly set by setKeyLength(160) respectively setKeyLength(224).
  *
- * {@internal The variable names are the same as those in 
+ * {@internal The variable names are the same as those in
  * {@link http://www.csrc.nist.gov/publications/fips/fips197/fips-197.pdf#page=10 fips-197.pdf#page=10}.}}
  *
  * Here's a short example of how to use this library:
  * <code>
  * <?php
- *    include('Crypt/Rijndael.php');
+ *    include 'vendor/autoload.php';
  *
- *    $rijndael = new Crypt_Rijndael();
+ *    $rijndael = new \phpseclib\Crypt\Rijndael();
  *
  *    $rijndael->setKey('abcdefghijklmnop');
  *
@@ -44,168 +44,56 @@
  * ?>
  * </code>
  *
- * LICENSE: This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA  02111-1307  USA
- *
- * @category   Crypt
- * @package    Crypt_Rijndael
- * @author     Jim Wigginton <terrafrost@php.net>
- * @copyright  MMVIII Jim Wigginton
- * @license    http://www.gnu.org/licenses/lgpl.txt
- * @version    $Id: Rijndael.php,v 1.12 2010/02/09 06:10:26 terrafrost Exp $
- * @link       http://phpseclib.sourceforge.net
+ * @category  Crypt
+ * @package   Rijndael
+ * @author    Jim Wigginton <terrafrost@php.net>
+ * @copyright 2008 Jim Wigginton
+ * @license   http://www.opensource.org/licenses/mit-license.html  MIT License
+ * @link      http://phpseclib.sourceforge.net
  */
 
-/**#@+
- * @access public
- * @see Crypt_Rijndael::encrypt()
- * @see Crypt_Rijndael::decrypt()
- */
-/**
- * Encrypt / decrypt using the Counter mode.
- *
- * Set to -1 since that's what Crypt/Random.php uses to index the CTR mode.
- *
- * @link http://en.wikipedia.org/wiki/Block_cipher_modes_of_operation#Counter_.28CTR.29
- */
-define('CRYPT_RIJNDAEL_MODE_CTR', -1);
-/**
- * Encrypt / decrypt using the Electronic Code Book mode.
- *
- * @link http://en.wikipedia.org/wiki/Block_cipher_modes_of_operation#Electronic_codebook_.28ECB.29
- */
-define('CRYPT_RIJNDAEL_MODE_ECB', 1);
-/**
- * Encrypt / decrypt using the Code Book Chaining mode.
- *
- * @link http://en.wikipedia.org/wiki/Block_cipher_modes_of_operation#Cipher-block_chaining_.28CBC.29
- */
-define('CRYPT_RIJNDAEL_MODE_CBC', 2);
-/**#@-*/
-
-/**#@+
- * @access private
- * @see Crypt_Rijndael::Crypt_Rijndael()
- */
-/**
- * Toggles the internal implementation
- */
-define('CRYPT_RIJNDAEL_MODE_INTERNAL', 1);
-/**
- * Toggles the mcrypt implementation
- */
-define('CRYPT_RIJNDAEL_MODE_MCRYPT', 2);
-/**#@-*/
+namespace phpseclib\Crypt;
 
 /**
  * Pure-PHP implementation of Rijndael.
  *
+ * @package Rijndael
  * @author  Jim Wigginton <terrafrost@php.net>
- * @version 0.1.0
  * @access  public
- * @package Crypt_Rijndael
  */
-class Crypt_Rijndael {
-    /**
-     * The Encryption Mode
-     *
-     * @see Crypt_Rijndael::Crypt_Rijndael()
-     * @var Integer
-     * @access private
-     */
-    var $mode;
-
-    /**
-     * The Key
-     *
-     * @see Crypt_Rijndael::setKey()
-     * @var String
-     * @access private
-     */
-    var $key = "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0";
-
-    /**
-     * The Initialization Vector
-     *
-     * @see Crypt_Rijndael::setIV()
-     * @var String
-     * @access private
-     */
-    var $iv = '';
-
-    /**
-     * A "sliding" Initialization Vector
-     *
-     * @see Crypt_Rijndael::enableContinuousBuffer()
-     * @var String
-     * @access private
-     */
-    var $encryptIV = '';
-
+class Rijndael extends Base
+{
     /**
-     * A "sliding" Initialization Vector
+     * The mcrypt specific name of the cipher
      *
-     * @see Crypt_Rijndael::enableContinuousBuffer()
-     * @var String
-     * @access private
-     */
-    var $decryptIV = '';
-
-    /**
-     * Continuous Buffer status
+     * Mcrypt is useable for 128/192/256-bit $block_size/$key_length. For 160/224 not.
+     * \phpseclib\Crypt\Rijndael determines automatically whether mcrypt is useable
+     * or not for the current $block_size/$key_length.
+     * In case of, $cipher_name_mcrypt will be set dynamically at run time accordingly.
      *
-     * @see Crypt_Rijndael::enableContinuousBuffer()
-     * @var Boolean
+     * @see \phpseclib\Crypt\Base::cipher_name_mcrypt
+     * @see \phpseclib\Crypt\Base::engine
+     * @see self::isValidEngine()
+     * @var string
      * @access private
      */
-    var $continuousBuffer = false;
+    var $cipher_name_mcrypt = 'rijndael-128';
 
     /**
-     * Padding status
+     * The default salt used by setPassword()
      *
-     * @see Crypt_Rijndael::enablePadding()
-     * @var Boolean
+     * @see \phpseclib\Crypt\Base::password_default_salt
+     * @see \phpseclib\Crypt\Base::setPassword()
+     * @var string
      * @access private
      */
-    var $padding = true;
-
-    /**
-     * Does the key schedule need to be (re)calculated?
-     *
-     * @see setKey()
-     * @see setBlockLength()
-     * @see setKeyLength()
-     * @var Boolean
-     * @access private
-     */
-    var $changed = true;
-
-    /**
-     * Has the key length explicitly been set or should it be derived from the key, itself?
-     *
-     * @see setKeyLength()
-     * @var Boolean
-     * @access private
-     */
-    var $explicit_key_length = false;
+    var $password_default_salt = 'phpseclib';
 
     /**
      * The Key Schedule
      *
-     * @see _setup()
-     * @var Array
+     * @see self::_setup()
+     * @var array
      * @access private
      */
     var $w;
@@ -213,55 +101,43 @@ class Crypt_Rijndael {
     /**
      * The Inverse Key Schedule
      *
-     * @see _setup()
-     * @var Array
+     * @see self::_setup()
+     * @var array
      * @access private
      */
     var $dw;
 
     /**
-     * The Block Length
-     *
-     * @see setBlockLength()
-     * @var Integer
-     * @access private
-     * @internal The max value is 32, the min value is 16.  All valid values are multiples of 4.  Exists in conjunction with
-     *     $Nb because we need this value and not $Nb to pad strings appropriately.  
-     */
-    var $block_size = 16;
-
-    /**
      * The Block Length divided by 32
      *
-     * @see setBlockLength()
-     * @var Integer
+     * @see self::setBlockLength()
+     * @var int
      * @access private
-     * @internal The max value is 256 / 32 = 8, the min value is 128 / 32 = 4.  Exists in conjunction with $block_size 
-     *    because the encryption / decryption / key schedule creation requires this number and not $block_size.  We could 
+     * @internal The max value is 256 / 32 = 8, the min value is 128 / 32 = 4.  Exists in conjunction with $block_size
+     *    because the encryption / decryption / key schedule creation requires this number and not $block_size.  We could
      *    derive this from $block_size or vice versa, but that'd mean we'd have to do multiple shift operations, so in lieu
      *    of that, we'll just precompute it once.
-     *
      */
     var $Nb = 4;
 
     /**
-     * The Key Length
+     * The Key Length (in bytes)
      *
-     * @see setKeyLength()
-     * @var Integer
+     * @see self::setKeyLength()
+     * @var int
      * @access private
-     * @internal The max value is 256 / 8 = 32, the min value is 128 / 8 = 16.  Exists in conjunction with $key_size
-     *    because the encryption / decryption / key schedule creation requires this number and not $key_size.  We could 
-     *    derive this from $key_size or vice versa, but that'd mean we'd have to do multiple shift operations, so in lieu
+     * @internal The max value is 256 / 8 = 32, the min value is 128 / 8 = 16.  Exists in conjunction with $Nk
+     *    because the encryption / decryption / key schedule creation requires this number and not $key_length.  We could
+     *    derive this from $key_length or vice versa, but that'd mean we'd have to do multiple shift operations, so in lieu
      *    of that, we'll just precompute it once.
      */
-    var $key_size = 16;
+    var $key_length = 16;
 
     /**
      * The Key Length divided by 32
      *
-     * @see setKeyLength()
-     * @var Integer
+     * @see self::setKeyLength()
+     * @var int
      * @access private
      * @internal The max value is 256 / 32 = 8, the min value is 128 / 32 = 4
      */
@@ -270,7 +146,7 @@ class Crypt_Rijndael {
     /**
      * The Number of Rounds
      *
-     * @var Integer
+     * @var int
      * @access private
      * @internal The max value is 14, the min value is 10.
      */
@@ -279,493 +155,183 @@ class Crypt_Rijndael {
     /**
      * Shift offsets
      *
-     * @var Array
+     * @var array
      * @access private
      */
     var $c;
 
     /**
-     * Precomputed mixColumns table
-     *
-     * @see Crypt_Rijndael()
-     * @var Array
-     * @access private
-     */
-    var $t0;
-
-    /**
-     * Precomputed mixColumns table
-     *
-     * @see Crypt_Rijndael()
-     * @var Array
-     * @access private
-     */
-    var $t1;
-
-    /**
-     * Precomputed mixColumns table
-     *
-     * @see Crypt_Rijndael()
-     * @var Array
-     * @access private
-     */
-    var $t2;
-
-    /**
-     * Precomputed mixColumns table
-     *
-     * @see Crypt_Rijndael()
-     * @var Array
-     * @access private
-     */
-    var $t3;
-
-    /**
-     * Precomputed invMixColumns table
+     * Holds the last used key- and block_size information
      *
-     * @see Crypt_Rijndael()
-     * @var Array
+     * @var array
      * @access private
      */
-    var $dt0;
+    var $kl;
 
     /**
-     * Precomputed invMixColumns table
+     * Sets the key length.
      *
-     * @see Crypt_Rijndael()
-     * @var Array
-     * @access private
-     */
-    var $dt1;
-
-    /**
-     * Precomputed invMixColumns table
+     * Valid key lengths are 128, 160, 192, 224, and 256.  If the length is less than 128, it will be rounded up to
+     * 128.  If the length is greater than 128 and invalid, it will be rounded down to the closest valid amount.
      *
-     * @see Crypt_Rijndael()
-     * @var Array
-     * @access private
-     */
-    var $dt2;
-
-    /**
-     * Precomputed invMixColumns table
+     * Note: phpseclib extends Rijndael (and AES) for using 160- and 224-bit keys but they are officially not defined
+     *       and the most (if not all) implementations are not able using 160/224-bit keys but round/pad them up to
+     *       192/256 bits as, for example, mcrypt will do.
      *
-     * @see Crypt_Rijndael()
-     * @var Array
-     * @access private
-     */
-    var $dt3;
-
-    /**
-     * Default Constructor.
+     *       That said, if you want be compatible with other Rijndael and AES implementations,
+     *       you should not setKeyLength(160) or setKeyLength(224).
      *
-     * Determines whether or not the mcrypt extension should be used.  $mode should only, at present, be
-     * CRYPT_RIJNDAEL_MODE_ECB or CRYPT_RIJNDAEL_MODE_CBC.  If not explictly set, CRYPT_RIJNDAEL_MODE_CBC will be used.
+     * Additional: In case of 160- and 224-bit keys, phpseclib will/can, for that reason, not use
+     *             the mcrypt php extension, even if available.
+     *             This results then in slower encryption.
      *
-     * @param optional Integer $mode
-     * @return Crypt_Rijndael
      * @access public
+     * @param int $length
      */
-    function Crypt_Rijndael($mode = CRYPT_RIJNDAEL_MODE_CBC)
+    function setKeyLength($length)
     {
-        switch ($mode) {
-            case CRYPT_RIJNDAEL_MODE_ECB:
-            case CRYPT_RIJNDAEL_MODE_CBC:
-            case CRYPT_RIJNDAEL_MODE_CTR:
-                $this->mode = $mode;
+        switch (true) {
+            case $length <= 128:
+                $this->key_length = 16;
+                break;
+            case $length <= 160:
+                $this->key_length = 20;
+                break;
+            case $length <= 192:
+                $this->key_length = 24;
+                break;
+            case $length <= 224:
+                $this->key_length = 28;
                 break;
             default:
-                $this->mode = CRYPT_RIJNDAEL_MODE_CBC;
-        }
-
-        $t3 = &$this->t3;
-        $t2 = &$this->t2;
-        $t1 = &$this->t1;
-        $t0 = &$this->t0;
-
-        $dt3 = &$this->dt3;
-        $dt2 = &$this->dt2;
-        $dt1 = &$this->dt1;
-        $dt0 = &$this->dt0;
-
-        // according to <http://csrc.nist.gov/archive/aes/rijndael/Rijndael-ammended.pdf#page=19> (section 5.2.1), 
-        // precomputed tables can be used in the mixColumns phase.  in that example, they're assigned t0...t3, so
-        // those are the names we'll use.
-        $t3 = array(
-            0x6363A5C6, 0x7C7C84F8, 0x777799EE, 0x7B7B8DF6, 0xF2F20DFF, 0x6B6BBDD6, 0x6F6FB1DE, 0xC5C55491, 
-            0x30305060, 0x01010302, 0x6767A9CE, 0x2B2B7D56, 0xFEFE19E7, 0xD7D762B5, 0xABABE64D, 0x76769AEC, 
-            0xCACA458F, 0x82829D1F, 0xC9C94089, 0x7D7D87FA, 0xFAFA15EF, 0x5959EBB2, 0x4747C98E, 0xF0F00BFB, 
-            0xADADEC41, 0xD4D467B3, 0xA2A2FD5F, 0xAFAFEA45, 0x9C9CBF23, 0xA4A4F753, 0x727296E4, 0xC0C05B9B, 
-            0xB7B7C275, 0xFDFD1CE1, 0x9393AE3D, 0x26266A4C, 0x36365A6C, 0x3F3F417E, 0xF7F702F5, 0xCCCC4F83, 
-            0x34345C68, 0xA5A5F451, 0xE5E534D1, 0xF1F108F9, 0x717193E2, 0xD8D873AB, 0x31315362, 0x15153F2A, 
-            0x04040C08, 0xC7C75295, 0x23236546, 0xC3C35E9D, 0x18182830, 0x9696A137, 0x05050F0A, 0x9A9AB52F, 
-            0x0707090E, 0x12123624, 0x80809B1B, 0xE2E23DDF, 0xEBEB26CD, 0x2727694E, 0xB2B2CD7F, 0x75759FEA, 
-            0x09091B12, 0x83839E1D, 0x2C2C7458, 0x1A1A2E34, 0x1B1B2D36, 0x6E6EB2DC, 0x5A5AEEB4, 0xA0A0FB5B, 
-            0x5252F6A4, 0x3B3B4D76, 0xD6D661B7, 0xB3B3CE7D, 0x29297B52, 0xE3E33EDD, 0x2F2F715E, 0x84849713, 
-            0x5353F5A6, 0xD1D168B9, 0x00000000, 0xEDED2CC1, 0x20206040, 0xFCFC1FE3, 0xB1B1C879, 0x5B5BEDB6, 
-            0x6A6ABED4, 0xCBCB468D, 0xBEBED967, 0x39394B72, 0x4A4ADE94, 0x4C4CD498, 0x5858E8B0, 0xCFCF4A85, 
-            0xD0D06BBB, 0xEFEF2AC5, 0xAAAAE54F, 0xFBFB16ED, 0x4343C586, 0x4D4DD79A, 0x33335566, 0x85859411, 
-            0x4545CF8A, 0xF9F910E9, 0x02020604, 0x7F7F81FE, 0x5050F0A0, 0x3C3C4478, 0x9F9FBA25, 0xA8A8E34B, 
-            0x5151F3A2, 0xA3A3FE5D, 0x4040C080, 0x8F8F8A05, 0x9292AD3F, 0x9D9DBC21, 0x38384870, 0xF5F504F1, 
-            0xBCBCDF63, 0xB6B6C177, 0xDADA75AF, 0x21216342, 0x10103020, 0xFFFF1AE5, 0xF3F30EFD, 0xD2D26DBF, 
-            0xCDCD4C81, 0x0C0C1418, 0x13133526, 0xECEC2FC3, 0x5F5FE1BE, 0x9797A235, 0x4444CC88, 0x1717392E, 
-            0xC4C45793, 0xA7A7F255, 0x7E7E82FC, 0x3D3D477A, 0x6464ACC8, 0x5D5DE7BA, 0x19192B32, 0x737395E6, 
-            0x6060A0C0, 0x81819819, 0x4F4FD19E, 0xDCDC7FA3, 0x22226644, 0x2A2A7E54, 0x9090AB3B, 0x8888830B, 
-            0x4646CA8C, 0xEEEE29C7, 0xB8B8D36B, 0x14143C28, 0xDEDE79A7, 0x5E5EE2BC, 0x0B0B1D16, 0xDBDB76AD, 
-            0xE0E03BDB, 0x32325664, 0x3A3A4E74, 0x0A0A1E14, 0x4949DB92, 0x06060A0C, 0x24246C48, 0x5C5CE4B8, 
-            0xC2C25D9F, 0xD3D36EBD, 0xACACEF43, 0x6262A6C4, 0x9191A839, 0x9595A431, 0xE4E437D3, 0x79798BF2, 
-            0xE7E732D5, 0xC8C8438B, 0x3737596E, 0x6D6DB7DA, 0x8D8D8C01, 0xD5D564B1, 0x4E4ED29C, 0xA9A9E049, 
-            0x6C6CB4D8, 0x5656FAAC, 0xF4F407F3, 0xEAEA25CF, 0x6565AFCA, 0x7A7A8EF4, 0xAEAEE947, 0x08081810, 
-            0xBABAD56F, 0x787888F0, 0x25256F4A, 0x2E2E725C, 0x1C1C2438, 0xA6A6F157, 0xB4B4C773, 0xC6C65197, 
-            0xE8E823CB, 0xDDDD7CA1, 0x74749CE8, 0x1F1F213E, 0x4B4BDD96, 0xBDBDDC61, 0x8B8B860D, 0x8A8A850F, 
-            0x707090E0, 0x3E3E427C, 0xB5B5C471, 0x6666AACC, 0x4848D890, 0x03030506, 0xF6F601F7, 0x0E0E121C, 
-            0x6161A3C2, 0x35355F6A, 0x5757F9AE, 0xB9B9D069, 0x86869117, 0xC1C15899, 0x1D1D273A, 0x9E9EB927, 
-            0xE1E138D9, 0xF8F813EB, 0x9898B32B, 0x11113322, 0x6969BBD2, 0xD9D970A9, 0x8E8E8907, 0x9494A733, 
-            0x9B9BB62D, 0x1E1E223C, 0x87879215, 0xE9E920C9, 0xCECE4987, 0x5555FFAA, 0x28287850, 0xDFDF7AA5, 
-            0x8C8C8F03, 0xA1A1F859, 0x89898009, 0x0D0D171A, 0xBFBFDA65, 0xE6E631D7, 0x4242C684, 0x6868B8D0, 
-            0x4141C382, 0x9999B029, 0x2D2D775A, 0x0F0F111E, 0xB0B0CB7B, 0x5454FCA8, 0xBBBBD66D, 0x16163A2C
-        );
-
-        $dt3 = array(
-            0xF4A75051, 0x4165537E, 0x17A4C31A, 0x275E963A, 0xAB6BCB3B, 0x9D45F11F, 0xFA58ABAC, 0xE303934B, 
-            0x30FA5520, 0x766DF6AD, 0xCC769188, 0x024C25F5, 0xE5D7FC4F, 0x2ACBD7C5, 0x35448026, 0x62A38FB5, 
-            0xB15A49DE, 0xBA1B6725, 0xEA0E9845, 0xFEC0E15D, 0x2F7502C3, 0x4CF01281, 0x4697A38D, 0xD3F9C66B, 
-            0x8F5FE703, 0x929C9515, 0x6D7AEBBF, 0x5259DA95, 0xBE832DD4, 0x7421D358, 0xE0692949, 0xC9C8448E, 
-            0xC2896A75, 0x8E7978F4, 0x583E6B99, 0xB971DD27, 0xE14FB6BE, 0x88AD17F0, 0x20AC66C9, 0xCE3AB47D, 
-            0xDF4A1863, 0x1A3182E5, 0x51336097, 0x537F4562, 0x6477E0B1, 0x6BAE84BB, 0x81A01CFE, 0x082B94F9, 
-            0x48685870, 0x45FD198F, 0xDE6C8794, 0x7BF8B752, 0x73D323AB, 0x4B02E272, 0x1F8F57E3, 0x55AB2A66, 
-            0xEB2807B2, 0xB5C2032F, 0xC57B9A86, 0x3708A5D3, 0x2887F230, 0xBFA5B223, 0x036ABA02, 0x16825CED, 
-            0xCF1C2B8A, 0x79B492A7, 0x07F2F0F3, 0x69E2A14E, 0xDAF4CD65, 0x05BED506, 0x34621FD1, 0xA6FE8AC4, 
-            0x2E539D34, 0xF355A0A2, 0x8AE13205, 0xF6EB75A4, 0x83EC390B, 0x60EFAA40, 0x719F065E, 0x6E1051BD, 
-            0x218AF93E, 0xDD063D96, 0x3E05AEDD, 0xE6BD464D, 0x548DB591, 0xC45D0571, 0x06D46F04, 0x5015FF60, 
-            0x98FB2419, 0xBDE997D6, 0x4043CC89, 0xD99E7767, 0xE842BDB0, 0x898B8807, 0x195B38E7, 0xC8EEDB79, 
-            0x7C0A47A1, 0x420FE97C, 0x841EC9F8, 0x00000000, 0x80868309, 0x2BED4832, 0x1170AC1E, 0x5A724E6C, 
-            0x0EFFFBFD, 0x8538560F, 0xAED51E3D, 0x2D392736, 0x0FD9640A, 0x5CA62168, 0x5B54D19B, 0x362E3A24, 
-            0x0A67B10C, 0x57E70F93, 0xEE96D2B4, 0x9B919E1B, 0xC0C54F80, 0xDC20A261, 0x774B695A, 0x121A161C, 
-            0x93BA0AE2, 0xA02AE5C0, 0x22E0433C, 0x1B171D12, 0x090D0B0E, 0x8BC7ADF2, 0xB6A8B92D, 0x1EA9C814, 
-            0xF1198557, 0x75074CAF, 0x99DDBBEE, 0x7F60FDA3, 0x01269FF7, 0x72F5BC5C, 0x663BC544, 0xFB7E345B, 
-            0x4329768B, 0x23C6DCCB, 0xEDFC68B6, 0xE4F163B8, 0x31DCCAD7, 0x63851042, 0x97224013, 0xC6112084, 
-            0x4A247D85, 0xBB3DF8D2, 0xF93211AE, 0x29A16DC7, 0x9E2F4B1D, 0xB230F3DC, 0x8652EC0D, 0xC1E3D077, 
-            0xB3166C2B, 0x70B999A9, 0x9448FA11, 0xE9642247, 0xFC8CC4A8, 0xF03F1AA0, 0x7D2CD856, 0x3390EF22, 
-            0x494EC787, 0x38D1C1D9, 0xCAA2FE8C, 0xD40B3698, 0xF581CFA6, 0x7ADE28A5, 0xB78E26DA, 0xADBFA43F, 
-            0x3A9DE42C, 0x78920D50, 0x5FCC9B6A, 0x7E466254, 0x8D13C2F6, 0xD8B8E890, 0x39F75E2E, 0xC3AFF582, 
-            0x5D80BE9F, 0xD0937C69, 0xD52DA96F, 0x2512B3CF, 0xAC993BC8, 0x187DA710, 0x9C636EE8, 0x3BBB7BDB, 
-            0x267809CD, 0x5918F46E, 0x9AB701EC, 0x4F9AA883, 0x956E65E6, 0xFFE67EAA, 0xBCCF0821, 0x15E8E6EF, 
-            0xE79BD9BA, 0x6F36CE4A, 0x9F09D4EA, 0xB07CD629, 0xA4B2AF31, 0x3F23312A, 0xA59430C6, 0xA266C035, 
-            0x4EBC3774, 0x82CAA6FC, 0x90D0B0E0, 0xA7D81533, 0x04984AF1, 0xECDAF741, 0xCD500E7F, 0x91F62F17, 
-            0x4DD68D76, 0xEFB04D43, 0xAA4D54CC, 0x9604DFE4, 0xD1B5E39E, 0x6A881B4C, 0x2C1FB8C1, 0x65517F46, 
-            0x5EEA049D, 0x8C355D01, 0x877473FA, 0x0B412EFB, 0x671D5AB3, 0xDBD25292, 0x105633E9, 0xD647136D, 
-            0xD7618C9A, 0xA10C7A37, 0xF8148E59, 0x133C89EB, 0xA927EECE, 0x61C935B7, 0x1CE5EDE1, 0x47B13C7A, 
-            0xD2DF599C, 0xF2733F55, 0x14CE7918, 0xC737BF73, 0xF7CDEA53, 0xFDAA5B5F, 0x3D6F14DF, 0x44DB8678, 
-            0xAFF381CA, 0x68C43EB9, 0x24342C38, 0xA3405FC2, 0x1DC37216, 0xE2250CBC, 0x3C498B28, 0x0D9541FF, 
-            0xA8017139, 0x0CB3DE08, 0xB4E49CD8, 0x56C19064, 0xCB84617B, 0x32B670D5, 0x6C5C7448, 0xB85742D0
-        );
-
-        for ($i = 0; $i < 256; $i++) {
-            $t2[$i <<  8] = (($t3[$i] <<  8) & 0xFFFFFF00) | (($t3[$i] >> 24) & 0x000000FF);
-            $t1[$i << 16] = (($t3[$i] << 16) & 0xFFFF0000) | (($t3[$i] >> 16) & 0x0000FFFF);
-            $t0[$i << 24] = (($t3[$i] << 24) & 0xFF000000) | (($t3[$i] >>  8) & 0x00FFFFFF);
-
-            $dt2[$i <<  8] = (($this->dt3[$i] <<  8) & 0xFFFFFF00) | (($dt3[$i] >> 24) & 0x000000FF);
-            $dt1[$i << 16] = (($this->dt3[$i] << 16) & 0xFFFF0000) | (($dt3[$i] >> 16) & 0x0000FFFF);
-            $dt0[$i << 24] = (($this->dt3[$i] << 24) & 0xFF000000) | (($dt3[$i] >>  8) & 0x00FFFFFF);
-        }
-    }
-
-    /**
-     * Sets the key.
-     *
-     * Keys can be of any length.  Rijndael, itself, requires the use of a key that's between 128-bits and 256-bits long and
-     * whose length is a multiple of 32.  If the key is less than 256-bits and the key length isn't set, we round the length
-     * up to the closest valid key length, padding $key with null bytes.  If the key is more than 256-bits, we trim the
-     * excess bits.
-     *
-     * If the key is not explicitly set, it'll be assumed to be all null bytes.
-     *
-     * @access public
-     * @param String $key
-     */
-    function setKey($key)
-    {
-        $this->key = $key;
-        $this->changed = true;
-    }
-
-    /**
-     * Sets the initialization vector. (optional)
-     *
-     * SetIV is not required when CRYPT_RIJNDAEL_MODE_ECB is being used.  If not explictly set, it'll be assumed
-     * to be all zero's.
-     *
-     * @access public
-     * @param String $iv
-     */
-    function setIV($iv)
-    {
-        $this->encryptIV = $this->decryptIV = $this->iv = str_pad(substr($iv, 0, $this->block_size), $this->block_size, chr(0));;
-    }
-
-    /**
-     * Sets the key length
-     *
-     * Valid key lengths are 128, 160, 192, 224, and 256.  If the length is less than 128, it will be rounded up to
-     * 128.  If the length is greater then 128 and invalid, it will be rounded down to the closest valid amount.
-     *
-     * @access public
-     * @param Integer $length
-     */
-    function setKeyLength($length)
-    {
-        $length >>= 5;
-        if ($length > 8) {
-            $length = 8;
-        } else if ($length < 4) {
-            $length = 4;
+                $this->key_length = 32;
         }
-        $this->Nk = $length;
-        $this->key_size = $length << 2;
 
-        $this->explicit_key_length = true;
-        $this->changed = true;
+        parent::setKeyLength($length);
     }
 
     /**
      * Sets the block length
      *
      * Valid block lengths are 128, 160, 192, 224, and 256.  If the length is less than 128, it will be rounded up to
-     * 128.  If the length is greater then 128 and invalid, it will be rounded down to the closest valid amount.
+     * 128.  If the length is greater than 128 and invalid, it will be rounded down to the closest valid amount.
      *
      * @access public
-     * @param Integer $length
+     * @param int $length
      */
     function setBlockLength($length)
     {
         $length >>= 5;
         if ($length > 8) {
             $length = 8;
-        } else if ($length < 4) {
+        } elseif ($length < 4) {
             $length = 4;
         }
         $this->Nb = $length;
         $this->block_size = $length << 2;
         $this->changed = true;
+        $this->_setEngine();
     }
 
     /**
-     * Generate CTR XOR encryption key
+     * Test for engine validity
      *
-     * Encrypt the output of this and XOR it against the ciphertext / plaintext to get the
-     * plaintext / ciphertext in CTR mode.
+     * This is mainly just a wrapper to set things up for \phpseclib\Crypt\Base::isValidEngine()
      *
-     * @see Crypt_Rijndael::decrypt()
-     * @see Crypt_Rijndael::encrypt()
+     * @see \phpseclib\Crypt\Base::__construct()
+     * @param int $engine
      * @access public
-     * @param Integer $length
-     * @param String $iv
+     * @return bool
      */
-    function _generate_xor($length, &$iv)
+    function isValidEngine($engine)
     {
-        $xor = '';
-        $block_size = $this->block_size;
-        $num_blocks = floor(($length + ($block_size - 1)) / $block_size);
-        for ($i = 0; $i < $num_blocks; $i++) {
-            $xor.= $iv;
-            for ($j = 4; $j <= $block_size; $j+=4) {
-                $temp = substr($iv, -$j, 4);
-                switch ($temp) {
-                    case "\xFF\xFF\xFF\xFF":
-                        $iv = substr_replace($iv, "\x00\x00\x00\x00", -$j, 4);
-                        break;
-                    case "\x7F\xFF\xFF\xFF":
-                        $iv = substr_replace($iv, "\x80\x00\x00\x00", -$j, 4);
-                        break 2;
-                    default:
-                        extract(unpack('Ncount', $temp));
-                        $iv = substr_replace($iv, pack('N', $count + 1), -$j, 4);
-                        break 2;
-                }
-            }
-        }
-
-        return $xor;
-    }
-
-    /**
-     * Encrypts a message.
-     *
-     * $plaintext will be padded with additional bytes such that it's length is a multiple of the block size.  Other Rjindael
-     * implementations may or may not pad in the same manner.  Other common approaches to padding and the reasons why it's
-     * necessary are discussed in the following
-     * URL:
-     *
-     * {@link http://www.di-mgt.com.au/cryptopad.html http://www.di-mgt.com.au/cryptopad.html}
-     *
-     * An alternative to padding is to, separately, send the length of the file.  This is what SSH, in fact, does.
-     * strlen($plaintext) will still need to be a multiple of 8, however, arbitrary values can be added to make it that
-     * length.
-     *
-     * @see Crypt_Rijndael::decrypt()
-     * @access public
-     * @param String $plaintext
-     */
-    function encrypt($plaintext)
-    {
-        $this->_setup();
-        if ($this->mode != CRYPT_RIJNDAEL_MODE_CTR) {
-            $plaintext = $this->_pad($plaintext);
-        }
-
-        $block_size = $this->block_size;
-        $ciphertext = '';
-        switch ($this->mode) {
-            case CRYPT_RIJNDAEL_MODE_ECB:
-                for ($i = 0; $i < strlen($plaintext); $i+=$block_size) {
-                    $ciphertext.= $this->_encryptBlock(substr($plaintext, $i, $block_size));
+        switch ($engine) {
+            case self::ENGINE_OPENSSL:
+                if ($this->block_size != 16) {
+                    return false;
                 }
+                $this->cipher_name_openssl_ecb = 'aes-' . ($this->key_length << 3) . '-ecb';
+                $this->cipher_name_openssl = 'aes-' . ($this->key_length << 3) . '-' . $this->_openssl_translate_mode();
                 break;
-            case CRYPT_RIJNDAEL_MODE_CBC:
-                $xor = $this->encryptIV;
-                for ($i = 0; $i < strlen($plaintext); $i+=$block_size) {
-                    $block = substr($plaintext, $i, $block_size);
-                    $block = $this->_encryptBlock($block ^ $xor);
-                    $xor = $block;
-                    $ciphertext.= $block;
-                }
-                if ($this->continuousBuffer) {
-                    $this->encryptIV = $xor;
-                }
-                break;
-            case CRYPT_RIJNDAEL_MODE_CTR:
-                $xor = $this->encryptIV;
-                for ($i = 0; $i < strlen($plaintext); $i+=$block_size) {
-                    $block = substr($plaintext, $i, $block_size);
-                    $key = $this->_encryptBlock($this->_generate_xor($block_size, $xor));
-                    $ciphertext.= $block ^ $key;
-                }
-                if ($this->continuousBuffer) {
-                    $this->encryptIV = $xor;
+            case self::ENGINE_MCRYPT:
+                $this->cipher_name_mcrypt = 'rijndael-' . ($this->block_size << 3);
+                if ($this->key_length % 8) { // is it a 160/224-bit key?
+                    // mcrypt is not usable for them, only for 128/192/256-bit keys
+                    return false;
                 }
         }
 
-        return $ciphertext;
-    }
-
-    /**
-     * Decrypts a message.
-     *
-     * If strlen($ciphertext) is not a multiple of the block size, null bytes will be added to the end of the string until
-     * it is.
-     *
-     * @see Crypt_Rijndael::encrypt()
-     * @access public
-     * @param String $ciphertext
-     */
-    function decrypt($ciphertext)
-    {
-        $this->_setup();
-
-        if ($this->mode != CRYPT_RIJNDAEL_MODE_CTR) {
-            // we pad with chr(0) since that's what mcrypt_generic does.  to quote from http://php.net/function.mcrypt-generic :
-            // "The data is padded with "\0" to make sure the length of the data is n * blocksize."
-            $ciphertext = str_pad($ciphertext, (strlen($ciphertext) + $this->block_size - 1) % $this->block_size, chr(0));
-        }
-
-        $block_size = $this->block_size;
-        $plaintext = '';
-        switch ($this->mode) {
-            case CRYPT_RIJNDAEL_MODE_ECB:
-                for ($i = 0; $i < strlen($ciphertext); $i+=$block_size) {
-                    $plaintext.= $this->_decryptBlock(substr($ciphertext, $i, $block_size));
-                }
-                break;
-            case CRYPT_RIJNDAEL_MODE_CBC:
-                $xor = $this->decryptIV;
-                for ($i = 0; $i < strlen($ciphertext); $i+=$block_size) {
-                    $block = substr($ciphertext, $i, $block_size);
-                    $plaintext.= $this->_decryptBlock($block) ^ $xor;
-                    $xor = $block;
-                }
-                if ($this->continuousBuffer) {
-                    $this->decryptIV = $xor;
-                }
-                break;
-            case CRYPT_RIJNDAEL_MODE_CTR:
-                $xor = $this->decryptIV;
-                for ($i = 0; $i < strlen($ciphertext); $i+=$block_size) {
-                    $block = substr($ciphertext, $i, $block_size);
-                    $key = $this->_encryptBlock($this->_generate_xor($block_size, $xor));
-                    $plaintext.= $block ^ $key;
-                }
-                if ($this->continuousBuffer) {
-                    $this->decryptIV = $xor;
-                }
-        }
-
-        return $this->mode != CRYPT_RIJNDAEL_MODE_CTR ? $this->_unpad($plaintext) : $plaintext;
+        return parent::isValidEngine($engine);
     }
 
     /**
      * Encrypts a block
      *
      * @access private
-     * @param String $in
-     * @return String
+     * @param string $in
+     * @return string
      */
     function _encryptBlock($in)
     {
+        static $tables;
+        if (empty($tables)) {
+            $tables = &$this->_getTables();
+        }
+        $t0   = $tables[0];
+        $t1   = $tables[1];
+        $t2   = $tables[2];
+        $t3   = $tables[3];
+        $sbox = $tables[4];
+
         $state = array();
-        $words = unpack('N*word', $in);
+        $words = unpack('N*', $in);
 
+        $c = $this->c;
         $w = $this->w;
-        $t0 = $this->t0;
-        $t1 = $this->t1;
-        $t2 = $this->t2;
-        $t3 = $this->t3;
         $Nb = $this->Nb;
         $Nr = $this->Nr;
-        $c = $this->c;
 
         // addRoundKey
-        $i = 0;
+        $wc = $Nb - 1;
         foreach ($words as $word) {
-            $state[] = $word ^ $w[0][$i++];
+            $state[] = $word ^ $w[++$wc];
         }
 
-        // fips-197.pdf#page=19, "Figure 5. Pseudo Code for the Cipher", states that this loop has four components - 
-        // subBytes, shiftRows, mixColumns, and addRoundKey. fips-197.pdf#page=30, "Implementation Suggestions Regarding 
+        // fips-197.pdf#page=19, "Figure 5. Pseudo Code for the Cipher", states that this loop has four components -
+        // subBytes, shiftRows, mixColumns, and addRoundKey. fips-197.pdf#page=30, "Implementation Suggestions Regarding
         // Various Platforms" suggests that performs enhanced implementations are described in Rijndael-ammended.pdf.
         // Rijndael-ammended.pdf#page=20, "Implementation aspects / 32-bit processor", discusses such an optimization.
-        // Unfortunately, the description given there is not quite correct.  Per aes.spec.v316.pdf#page=19 [1], 
+        // Unfortunately, the description given there is not quite correct.  Per aes.spec.v316.pdf#page=19 [1],
         // equation (7.4.7) is supposed to use addition instead of subtraction, so we'll do that here, as well.
 
         // [1] http://fp.gladman.plus.com/cryptography_technology/rijndael/aes.spec.v316.pdf
         $temp = array();
-        for ($round = 1; $round < $Nr; $round++) {
+        for ($round = 1; $round < $Nr; ++$round) {
             $i = 0; // $c[0] == 0
             $j = $c[1];
             $k = $c[2];
             $l = $c[3];
 
-            while ($i < $this->Nb) {
-                $temp[$i] = $t0[$state[$i] & 0xFF000000] ^ 
-                            $t1[$state[$j] & 0x00FF0000] ^ 
-                            $t2[$state[$k] & 0x0000FF00] ^ 
-                            $t3[$state[$l] & 0x000000FF] ^ 
-                            $w[$round][$i];
-                $i++;
+            while ($i < $Nb) {
+                $temp[$i] = $t0[$state[$i] >> 24 & 0x000000FF] ^
+                            $t1[$state[$j] >> 16 & 0x000000FF] ^
+                            $t2[$state[$k] >>  8 & 0x000000FF] ^
+                            $t3[$state[$l]       & 0x000000FF] ^
+                            $w[++$wc];
+                ++$i;
                 $j = ($j + 1) % $Nb;
                 $k = ($k + 1) % $Nb;
                 $l = ($l + 1) % $Nb;
             }
-
-            for ($i = 0; $i < $Nb; $i++) {
-                $state[$i] = $temp[$i];
-            }
+            $state = $temp;
         }
 
         // subWord
-        for ($i = 0; $i < $Nb; $i++) {
-            $state[$i] = $this->_subWord($state[$i]);
+        for ($i = 0; $i < $Nb; ++$i) {
+            $state[$i] =   $sbox[$state[$i]       & 0x000000FF]        |
+                          ($sbox[$state[$i] >>  8 & 0x000000FF] <<  8) |
+                          ($sbox[$state[$i] >> 16 & 0x000000FF] << 16) |
+                          ($sbox[$state[$i] >> 24 & 0x000000FF] << 24);
         }
 
         // shiftRows + addRoundKey
@@ -773,74 +339,84 @@ class Crypt_Rijndael {
         $j = $c[1];
         $k = $c[2];
         $l = $c[3];
-        while ($i < $this->Nb) {
-            $temp[$i] = ($state[$i] & 0xFF000000) ^ 
-                        ($state[$j] & 0x00FF0000) ^ 
-                        ($state[$k] & 0x0000FF00) ^ 
+        while ($i < $Nb) {
+            $temp[$i] = ($state[$i] & 0xFF000000) ^
+                        ($state[$j] & 0x00FF0000) ^
+                        ($state[$k] & 0x0000FF00) ^
                         ($state[$l] & 0x000000FF) ^
-                         $w[$Nr][$i];
-            $i++;
+                         $w[$i];
+            ++$i;
             $j = ($j + 1) % $Nb;
             $k = ($k + 1) % $Nb;
             $l = ($l + 1) % $Nb;
         }
-        $state = $temp;
-
-        array_unshift($state, 'N*');
 
-        return call_user_func_array('pack', $state);
+        switch ($Nb) {
+            case 8:
+                return pack('N*', $temp[0], $temp[1], $temp[2], $temp[3], $temp[4], $temp[5], $temp[6], $temp[7]);
+            case 7:
+                return pack('N*', $temp[0], $temp[1], $temp[2], $temp[3], $temp[4], $temp[5], $temp[6]);
+            case 6:
+                return pack('N*', $temp[0], $temp[1], $temp[2], $temp[3], $temp[4], $temp[5]);
+            case 5:
+                return pack('N*', $temp[0], $temp[1], $temp[2], $temp[3], $temp[4]);
+            default:
+                return pack('N*', $temp[0], $temp[1], $temp[2], $temp[3]);
+        }
     }
 
     /**
      * Decrypts a block
      *
      * @access private
-     * @param String $in
-     * @return String
+     * @param string $in
+     * @return string
      */
     function _decryptBlock($in)
     {
+        static $invtables;
+        if (empty($invtables)) {
+            $invtables = &$this->_getInvTables();
+        }
+        $dt0   = $invtables[0];
+        $dt1   = $invtables[1];
+        $dt2   = $invtables[2];
+        $dt3   = $invtables[3];
+        $isbox = $invtables[4];
+
         $state = array();
-        $words = unpack('N*word', $in);
+        $words = unpack('N*', $in);
 
-        $num_states = count($state);
+        $c  = $this->c;
         $dw = $this->dw;
-        $dt0 = $this->dt0;
-        $dt1 = $this->dt1;
-        $dt2 = $this->dt2;
-        $dt3 = $this->dt3;
         $Nb = $this->Nb;
         $Nr = $this->Nr;
-        $c = $this->c;
 
         // addRoundKey
-        $i = 0;
+        $wc = $Nb - 1;
         foreach ($words as $word) {
-            $state[] = $word ^ $dw[$Nr][$i++];
+            $state[] = $word ^ $dw[++$wc];
         }
 
         $temp = array();
-        for ($round = $Nr - 1; $round > 0; $round--) {
+        for ($round = $Nr - 1; $round > 0; --$round) {
             $i = 0; // $c[0] == 0
             $j = $Nb - $c[1];
             $k = $Nb - $c[2];
             $l = $Nb - $c[3];
 
             while ($i < $Nb) {
-                $temp[$i] = $dt0[$state[$i] & 0xFF000000] ^ 
-                            $dt1[$state[$j] & 0x00FF0000] ^ 
-                            $dt2[$state[$k] & 0x0000FF00] ^ 
-                            $dt3[$state[$l] & 0x000000FF] ^ 
-                            $dw[$round][$i];
-                $i++;
+                $temp[$i] = $dt0[$state[$i] >> 24 & 0x000000FF] ^
+                            $dt1[$state[$j] >> 16 & 0x000000FF] ^
+                            $dt2[$state[$k] >>  8 & 0x000000FF] ^
+                            $dt3[$state[$l]       & 0x000000FF] ^
+                            $dw[++$wc];
+                ++$i;
                 $j = ($j + 1) % $Nb;
                 $k = ($k + 1) % $Nb;
                 $l = ($l + 1) % $Nb;
             }
-
-            for ($i = 0; $i < $Nb; $i++) {
-                $state[$i] = $temp[$i];
-            }
+            $state = $temp;
         }
 
         // invShiftRows + invSubWord + addRoundKey
@@ -850,33 +426,42 @@ class Crypt_Rijndael {
         $l = $Nb - $c[3];
 
         while ($i < $Nb) {
-            $temp[$i] = $dw[0][$i] ^ 
-                        $this->_invSubWord(($state[$i] & 0xFF000000) | 
-                                           ($state[$j] & 0x00FF0000) | 
-                                           ($state[$k] & 0x0000FF00) | 
-                                           ($state[$l] & 0x000000FF));
-            $i++;
+            $word = ($state[$i] & 0xFF000000) |
+                    ($state[$j] & 0x00FF0000) |
+                    ($state[$k] & 0x0000FF00) |
+                    ($state[$l] & 0x000000FF);
+
+            $temp[$i] = $dw[$i] ^ ($isbox[$word       & 0x000000FF]        |
+                                  ($isbox[$word >>  8 & 0x000000FF] <<  8) |
+                                  ($isbox[$word >> 16 & 0x000000FF] << 16) |
+                                  ($isbox[$word >> 24 & 0x000000FF] << 24));
+            ++$i;
             $j = ($j + 1) % $Nb;
             $k = ($k + 1) % $Nb;
             $l = ($l + 1) % $Nb;
         }
 
-        $state = $temp;
-
-        array_unshift($state, 'N*');
-
-        return call_user_func_array('pack', $state);
+        switch ($Nb) {
+            case 8:
+                return pack('N*', $temp[0], $temp[1], $temp[2], $temp[3], $temp[4], $temp[5], $temp[6], $temp[7]);
+            case 7:
+                return pack('N*', $temp[0], $temp[1], $temp[2], $temp[3], $temp[4], $temp[5], $temp[6]);
+            case 6:
+                return pack('N*', $temp[0], $temp[1], $temp[2], $temp[3], $temp[4], $temp[5]);
+            case 5:
+                return pack('N*', $temp[0], $temp[1], $temp[2], $temp[3], $temp[4]);
+            default:
+                return pack('N*', $temp[0], $temp[1], $temp[2], $temp[3]);
+        }
     }
 
     /**
-     * Setup Rijndael
-     *
-     * Validates all the variables and calculates $Nr - the number of rounds that need to be performed - and $w - the key
-     * key schedule.
+     * Setup the key (expansion)
      *
+     * @see \phpseclib\Crypt\Base::_setupKey()
      * @access private
      */
-    function _setup()
+    function _setupKey()
     {
         // Each number in $rcon is equal to the previous number multiplied by two in Rijndael's finite field.
         // See http://en.wikipedia.org/wiki/Finite_field_arithmetic#Multiplicative_inverse
@@ -889,25 +474,13 @@ class Crypt_Rijndael {
             0x7D000000, 0xFA000000, 0xEF000000, 0xC5000000, 0x91000000
         );
 
-        if (!$this->changed) {
+        if (isset($this->kl['key']) && $this->key === $this->kl['key'] && $this->key_length === $this->kl['key_length'] && $this->block_size === $this->kl['block_size']) {
+            // already expanded
             return;
         }
+        $this->kl = array('key' => $this->key, 'key_length' => $this->key_length, 'block_size' => $this->block_size);
 
-        if (!$this->explicit_key_length) {
-            // we do >> 2, here, and not >> 5, as we do above, since strlen($this->key) tells us the number of bytes - not bits
-            $length = strlen($this->key) >> 2;
-            if ($length > 8) {
-                $length = 8;
-            } else if ($length < 4) {
-                $length = 4;
-            }
-            $this->Nk = $length;
-            $this->key_size = $length << 2;
-        }
-
-        $this->key = str_pad(substr($this->key, 0, $this->key_size), $this->key_size, chr(0));
-        $this->encryptIV = $this->decryptIV = $this->iv = str_pad(substr($this->iv, 0, $this->block_size), $this->block_size, chr(0));
-
+        $this->Nk = $this->key_length >> 2;
         // see Rijndael-ammended.pdf#page=44
         $this->Nr = max($this->Nk, $this->Nb) + 6;
 
@@ -928,9 +501,7 @@ class Crypt_Rijndael {
                 $this->c = array(0, 1, 3, 4);
         }
 
-        $key = $this->key;
-
-        $w = array_values(unpack('N*words', $key));
+        $w = array_values(unpack('N*words', $this->key));
 
         $length = $this->Nb * ($this->Nr + 1);
         for ($i = $this->Nk; $i < $length; $i++) {
@@ -942,7 +513,7 @@ class Crypt_Rijndael {
                 // with 0xFFFFFFFF (or 0xFFFFFF00) on a 32-bit machine is unnecessary, but on a 64-bit machine, it is.
                 $temp = (($temp << 8) & 0xFFFFFF00) | (($temp >> 24) & 0x000000FF); // rotWord
                 $temp = $this->_subWord($temp) ^ $rcon[$i / $this->Nk];
-            } else if ($this->Nk > 6 && $i % $this->Nk == 4) {
+            } elseif ($this->Nk > 6 && $i % $this->Nk == 4) {
                 $temp = $this->_subWord($temp);
             }
             $w[$i] = $w[$i - $this->Nk] ^ $temp;
@@ -950,12 +521,13 @@ class Crypt_Rijndael {
 
         // convert the key schedule from a vector of $Nb * ($Nr + 1) length to a matrix with $Nr + 1 rows and $Nb columns
         // and generate the inverse key schedule.  more specifically,
-        // according to <http://csrc.nist.gov/archive/aes/rijndael/Rijndael-ammended.pdf#page=23> (section 5.3.3), 
+        // according to <http://csrc.nist.gov/archive/aes/rijndael/Rijndael-ammended.pdf#page=23> (section 5.3.3),
         // "The key expansion for the Inverse Cipher is defined as follows:
         //        1. Apply the Key Expansion.
         //        2. Apply InvMixColumn to all Round Keys except the first and the last one."
         // also, see fips-197.pdf#page=27, "5.3.5 Equivalent Inverse Cipher"
-        $temp = array();
+        list($dt0, $dt1, $dt2, $dt3) = $this->_getInvTables();
+        $temp = $this->w = $this->dw = array();
         for ($i = $row = $col = 0; $i < $length; $i++, $col++) {
             if ($col == $this->Nb) {
                 if ($row == 0) {
@@ -965,10 +537,10 @@ class Crypt_Rijndael {
                     $j = 0;
                     while ($j < $this->Nb) {
                         $dw = $this->_subWord($this->w[$row][$j]);
-                        $temp[$j] = $this->dt0[$dw & 0xFF000000] ^ 
-                                    $this->dt1[$dw & 0x00FF0000] ^ 
-                                    $this->dt2[$dw & 0x0000FF00] ^ 
-                                    $this->dt3[$dw & 0x000000FF];
+                        $temp[$j] = $dt0[$dw >> 24 & 0x000000FF] ^
+                                    $dt1[$dw >> 16 & 0x000000FF] ^
+                                    $dt2[$dw >>  8 & 0x000000FF] ^
+                                    $dt3[$dw       & 0x000000FF];
                         $j++;
                     }
                     $this->dw[$row] = $temp;
@@ -982,261 +554,383 @@ class Crypt_Rijndael {
 
         $this->dw[$row] = $this->w[$row];
 
-        $this->changed = false;
+        // Converting to 1-dim key arrays (both ascending)
+        $this->dw = array_reverse($this->dw);
+        $w  = array_pop($this->w);
+        $dw = array_pop($this->dw);
+        foreach ($this->w as $r => $wr) {
+            foreach ($wr as $c => $wc) {
+                $w[]  = $wc;
+                $dw[] = $this->dw[$r][$c];
+            }
+        }
+        $this->w  = $w;
+        $this->dw = $dw;
     }
 
     /**
      * Performs S-Box substitutions
      *
      * @access private
+     * @param int $word
      */
     function _subWord($word)
     {
-        static $sbox0, $sbox1, $sbox2, $sbox3;
-
-        if (empty($sbox0)) {
-            $sbox0 = array(
-                0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76,
-                0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0,
-                0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15,
-                0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75,
-                0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84,
-                0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF,
-                0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8,
-                0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2,
-                0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73,
-                0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB,
-                0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79,
-                0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08,
-                0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A,
-                0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E,
-                0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF,
-                0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16
-            );
-
-            $sbox1 = array();
-            $sbox2 = array();
-            $sbox3 = array();
-
-            for ($i = 0; $i < 256; $i++) {
-                $sbox1[$i <<  8] = $sbox0[$i] <<  8;
-                $sbox2[$i << 16] = $sbox0[$i] << 16;
-                $sbox3[$i << 24] = $sbox0[$i] << 24;
-            }
+        static $sbox;
+        if (empty($sbox)) {
+            list(, , , , $sbox) = $this->_getTables();
         }
 
-        return $sbox0[$word & 0x000000FF] | 
-               $sbox1[$word & 0x0000FF00] | 
-               $sbox2[$word & 0x00FF0000] | 
-               $sbox3[$word & 0xFF000000];
+        return  $sbox[$word       & 0x000000FF]        |
+               ($sbox[$word >>  8 & 0x000000FF] <<  8) |
+               ($sbox[$word >> 16 & 0x000000FF] << 16) |
+               ($sbox[$word >> 24 & 0x000000FF] << 24);
     }
 
     /**
-     * Performs inverse S-Box substitutions
+     * Provides the mixColumns and sboxes tables
      *
+     * @see self::_encryptBlock()
+     * @see self::_setupInlineCrypt()
+     * @see self::_subWord()
      * @access private
+     * @return array &$tables
      */
-    function _invSubWord($word)
+    function &_getTables()
     {
-        static $sbox0, $sbox1, $sbox2, $sbox3;
-
-        if (empty($sbox0)) {
-            $sbox0 = array(
-                0x52, 0x09, 0x6A, 0xD5, 0x30, 0x36, 0xA5, 0x38, 0xBF, 0x40, 0xA3, 0x9E, 0x81, 0xF3, 0xD7, 0xFB,
-                0x7C, 0xE3, 0x39, 0x82, 0x9B, 0x2F, 0xFF, 0x87, 0x34, 0x8E, 0x43, 0x44, 0xC4, 0xDE, 0xE9, 0xCB,
-                0x54, 0x7B, 0x94, 0x32, 0xA6, 0xC2, 0x23, 0x3D, 0xEE, 0x4C, 0x95, 0x0B, 0x42, 0xFA, 0xC3, 0x4E,
-                0x08, 0x2E, 0xA1, 0x66, 0x28, 0xD9, 0x24, 0xB2, 0x76, 0x5B, 0xA2, 0x49, 0x6D, 0x8B, 0xD1, 0x25,
-                0x72, 0xF8, 0xF6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xD4, 0xA4, 0x5C, 0xCC, 0x5D, 0x65, 0xB6, 0x92,
-                0x6C, 0x70, 0x48, 0x50, 0xFD, 0xED, 0xB9, 0xDA, 0x5E, 0x15, 0x46, 0x57, 0xA7, 0x8D, 0x9D, 0x84,
-                0x90, 0xD8, 0xAB, 0x00, 0x8C, 0xBC, 0xD3, 0x0A, 0xF7, 0xE4, 0x58, 0x05, 0xB8, 0xB3, 0x45, 0x06,
-                0xD0, 0x2C, 0x1E, 0x8F, 0xCA, 0x3F, 0x0F, 0x02, 0xC1, 0xAF, 0xBD, 0x03, 0x01, 0x13, 0x8A, 0x6B,
-                0x3A, 0x91, 0x11, 0x41, 0x4F, 0x67, 0xDC, 0xEA, 0x97, 0xF2, 0xCF, 0xCE, 0xF0, 0xB4, 0xE6, 0x73,
-                0x96, 0xAC, 0x74, 0x22, 0xE7, 0xAD, 0x35, 0x85, 0xE2, 0xF9, 0x37, 0xE8, 0x1C, 0x75, 0xDF, 0x6E,
-                0x47, 0xF1, 0x1A, 0x71, 0x1D, 0x29, 0xC5, 0x89, 0x6F, 0xB7, 0x62, 0x0E, 0xAA, 0x18, 0xBE, 0x1B,
-                0xFC, 0x56, 0x3E, 0x4B, 0xC6, 0xD2, 0x79, 0x20, 0x9A, 0xDB, 0xC0, 0xFE, 0x78, 0xCD, 0x5A, 0xF4,
-                0x1F, 0xDD, 0xA8, 0x33, 0x88, 0x07, 0xC7, 0x31, 0xB1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xEC, 0x5F,
-                0x60, 0x51, 0x7F, 0xA9, 0x19, 0xB5, 0x4A, 0x0D, 0x2D, 0xE5, 0x7A, 0x9F, 0x93, 0xC9, 0x9C, 0xEF,
-                0xA0, 0xE0, 0x3B, 0x4D, 0xAE, 0x2A, 0xF5, 0xB0, 0xC8, 0xEB, 0xBB, 0x3C, 0x83, 0x53, 0x99, 0x61,
-                0x17, 0x2B, 0x04, 0x7E, 0xBA, 0x77, 0xD6, 0x26, 0xE1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0C, 0x7D
-            );
-
-            $sbox1 = array();
-            $sbox2 = array();
-            $sbox3 = array();
-
-            for ($i = 0; $i < 256; $i++) {
-                $sbox1[$i <<  8] = $sbox0[$i] <<  8;
-                $sbox2[$i << 16] = $sbox0[$i] << 16;
-                $sbox3[$i << 24] = $sbox0[$i] << 24;
+        static $tables;
+        if (empty($tables)) {
+            // according to <http://csrc.nist.gov/archive/aes/rijndael/Rijndael-ammended.pdf#page=19> (section 5.2.1),
+            // precomputed tables can be used in the mixColumns phase. in that example, they're assigned t0...t3, so
+            // those are the names we'll use.
+            $t3 = array_map('intval', array(
+                // with array_map('intval', ...) we ensure we have only int's and not
+                // some slower floats converted by php automatically on high values
+                0x6363A5C6, 0x7C7C84F8, 0x777799EE, 0x7B7B8DF6, 0xF2F20DFF, 0x6B6BBDD6, 0x6F6FB1DE, 0xC5C55491,
+                0x30305060, 0x01010302, 0x6767A9CE, 0x2B2B7D56, 0xFEFE19E7, 0xD7D762B5, 0xABABE64D, 0x76769AEC,
+                0xCACA458F, 0x82829D1F, 0xC9C94089, 0x7D7D87FA, 0xFAFA15EF, 0x5959EBB2, 0x4747C98E, 0xF0F00BFB,
+                0xADADEC41, 0xD4D467B3, 0xA2A2FD5F, 0xAFAFEA45, 0x9C9CBF23, 0xA4A4F753, 0x727296E4, 0xC0C05B9B,
+                0xB7B7C275, 0xFDFD1CE1, 0x9393AE3D, 0x26266A4C, 0x36365A6C, 0x3F3F417E, 0xF7F702F5, 0xCCCC4F83,
+                0x34345C68, 0xA5A5F451, 0xE5E534D1, 0xF1F108F9, 0x717193E2, 0xD8D873AB, 0x31315362, 0x15153F2A,
+                0x04040C08, 0xC7C75295, 0x23236546, 0xC3C35E9D, 0x18182830, 0x9696A137, 0x05050F0A, 0x9A9AB52F,
+                0x0707090E, 0x12123624, 0x80809B1B, 0xE2E23DDF, 0xEBEB26CD, 0x2727694E, 0xB2B2CD7F, 0x75759FEA,
+                0x09091B12, 0x83839E1D, 0x2C2C7458, 0x1A1A2E34, 0x1B1B2D36, 0x6E6EB2DC, 0x5A5AEEB4, 0xA0A0FB5B,
+                0x5252F6A4, 0x3B3B4D76, 0xD6D661B7, 0xB3B3CE7D, 0x29297B52, 0xE3E33EDD, 0x2F2F715E, 0x84849713,
+                0x5353F5A6, 0xD1D168B9, 0x00000000, 0xEDED2CC1, 0x20206040, 0xFCFC1FE3, 0xB1B1C879, 0x5B5BEDB6,
+                0x6A6ABED4, 0xCBCB468D, 0xBEBED967, 0x39394B72, 0x4A4ADE94, 0x4C4CD498, 0x5858E8B0, 0xCFCF4A85,
+                0xD0D06BBB, 0xEFEF2AC5, 0xAAAAE54F, 0xFBFB16ED, 0x4343C586, 0x4D4DD79A, 0x33335566, 0x85859411,
+                0x4545CF8A, 0xF9F910E9, 0x02020604, 0x7F7F81FE, 0x5050F0A0, 0x3C3C4478, 0x9F9FBA25, 0xA8A8E34B,
+                0x5151F3A2, 0xA3A3FE5D, 0x4040C080, 0x8F8F8A05, 0x9292AD3F, 0x9D9DBC21, 0x38384870, 0xF5F504F1,
+                0xBCBCDF63, 0xB6B6C177, 0xDADA75AF, 0x21216342, 0x10103020, 0xFFFF1AE5, 0xF3F30EFD, 0xD2D26DBF,
+                0xCDCD4C81, 0x0C0C1418, 0x13133526, 0xECEC2FC3, 0x5F5FE1BE, 0x9797A235, 0x4444CC88, 0x1717392E,
+                0xC4C45793, 0xA7A7F255, 0x7E7E82FC, 0x3D3D477A, 0x6464ACC8, 0x5D5DE7BA, 0x19192B32, 0x737395E6,
+                0x6060A0C0, 0x81819819, 0x4F4FD19E, 0xDCDC7FA3, 0x22226644, 0x2A2A7E54, 0x9090AB3B, 0x8888830B,
+                0x4646CA8C, 0xEEEE29C7, 0xB8B8D36B, 0x14143C28, 0xDEDE79A7, 0x5E5EE2BC, 0x0B0B1D16, 0xDBDB76AD,
+                0xE0E03BDB, 0x32325664, 0x3A3A4E74, 0x0A0A1E14, 0x4949DB92, 0x06060A0C, 0x24246C48, 0x5C5CE4B8,
+                0xC2C25D9F, 0xD3D36EBD, 0xACACEF43, 0x6262A6C4, 0x9191A839, 0x9595A431, 0xE4E437D3, 0x79798BF2,
+                0xE7E732D5, 0xC8C8438B, 0x3737596E, 0x6D6DB7DA, 0x8D8D8C01, 0xD5D564B1, 0x4E4ED29C, 0xA9A9E049,
+                0x6C6CB4D8, 0x5656FAAC, 0xF4F407F3, 0xEAEA25CF, 0x6565AFCA, 0x7A7A8EF4, 0xAEAEE947, 0x08081810,
+                0xBABAD56F, 0x787888F0, 0x25256F4A, 0x2E2E725C, 0x1C1C2438, 0xA6A6F157, 0xB4B4C773, 0xC6C65197,
+                0xE8E823CB, 0xDDDD7CA1, 0x74749CE8, 0x1F1F213E, 0x4B4BDD96, 0xBDBDDC61, 0x8B8B860D, 0x8A8A850F,
+                0x707090E0, 0x3E3E427C, 0xB5B5C471, 0x6666AACC, 0x4848D890, 0x03030506, 0xF6F601F7, 0x0E0E121C,
+                0x6161A3C2, 0x35355F6A, 0x5757F9AE, 0xB9B9D069, 0x86869117, 0xC1C15899, 0x1D1D273A, 0x9E9EB927,
+                0xE1E138D9, 0xF8F813EB, 0x9898B32B, 0x11113322, 0x6969BBD2, 0xD9D970A9, 0x8E8E8907, 0x9494A733,
+                0x9B9BB62D, 0x1E1E223C, 0x87879215, 0xE9E920C9, 0xCECE4987, 0x5555FFAA, 0x28287850, 0xDFDF7AA5,
+                0x8C8C8F03, 0xA1A1F859, 0x89898009, 0x0D0D171A, 0xBFBFDA65, 0xE6E631D7, 0x4242C684, 0x6868B8D0,
+                0x4141C382, 0x9999B029, 0x2D2D775A, 0x0F0F111E, 0xB0B0CB7B, 0x5454FCA8, 0xBBBBD66D, 0x16163A2C
+            ));
+
+            foreach ($t3 as $t3i) {
+                $t0[] = (($t3i << 24) & 0xFF000000) | (($t3i >>  8) & 0x00FFFFFF);
+                $t1[] = (($t3i << 16) & 0xFFFF0000) | (($t3i >> 16) & 0x0000FFFF);
+                $t2[] = (($t3i <<  8) & 0xFFFFFF00) | (($t3i >> 24) & 0x000000FF);
             }
-        }
-
-        return $sbox0[$word & 0x000000FF] | 
-               $sbox1[$word & 0x0000FF00] | 
-               $sbox2[$word & 0x00FF0000] | 
-               $sbox3[$word & 0xFF000000];
-    }
 
-    /**
-     * Pad "packets".
-     *
-     * Rijndael works by encrypting between sixteen and thirty-two bytes at a time, provided that number is also a multiple
-     * of four.  If you ever need to encrypt or decrypt something that isn't of the proper length, it becomes necessary to
-     * pad the input so that it is of the proper length.
-     *
-     * Padding is enabled by default.  Sometimes, however, it is undesirable to pad strings.  Such is the case in SSH,
-     * where "packets" are padded with random bytes before being encrypted.  Unpad these packets and you risk stripping
-     * away characters that shouldn't be stripped away. (SSH knows how many bytes are added because the length is
-     * transmitted separately)
-     *
-     * @see Crypt_Rijndael::disablePadding()
-     * @access public
-     */
-    function enablePadding()
-    {
-        $this->padding = true;
+            $tables = array(
+                // The Precomputed mixColumns tables t0 - t3
+                $t0,
+                $t1,
+                $t2,
+                $t3,
+                // The SubByte S-Box
+                array(
+                    0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76,
+                    0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0,
+                    0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15,
+                    0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75,
+                    0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84,
+                    0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF,
+                    0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8,
+                    0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2,
+                    0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73,
+                    0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB,
+                    0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79,
+                    0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08,
+                    0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A,
+                    0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E,
+                    0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF,
+                    0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16
+                )
+            );
+        }
+        return $tables;
     }
 
     /**
-     * Do not pad packets.
+     * Provides the inverse mixColumns and inverse sboxes tables
      *
-     * @see Crypt_Rijndael::enablePadding()
-     * @access public
+     * @see self::_decryptBlock()
+     * @see self::_setupInlineCrypt()
+     * @see self::_setupKey()
+     * @access private
+     * @return array &$tables
      */
-    function disablePadding()
+    function &_getInvTables()
     {
-        $this->padding = false;
+        static $tables;
+        if (empty($tables)) {
+            $dt3 = array_map('intval', array(
+                0xF4A75051, 0x4165537E, 0x17A4C31A, 0x275E963A, 0xAB6BCB3B, 0x9D45F11F, 0xFA58ABAC, 0xE303934B,
+                0x30FA5520, 0x766DF6AD, 0xCC769188, 0x024C25F5, 0xE5D7FC4F, 0x2ACBD7C5, 0x35448026, 0x62A38FB5,
+                0xB15A49DE, 0xBA1B6725, 0xEA0E9845, 0xFEC0E15D, 0x2F7502C3, 0x4CF01281, 0x4697A38D, 0xD3F9C66B,
+                0x8F5FE703, 0x929C9515, 0x6D7AEBBF, 0x5259DA95, 0xBE832DD4, 0x7421D358, 0xE0692949, 0xC9C8448E,
+                0xC2896A75, 0x8E7978F4, 0x583E6B99, 0xB971DD27, 0xE14FB6BE, 0x88AD17F0, 0x20AC66C9, 0xCE3AB47D,
+                0xDF4A1863, 0x1A3182E5, 0x51336097, 0x537F4562, 0x6477E0B1, 0x6BAE84BB, 0x81A01CFE, 0x082B94F9,
+                0x48685870, 0x45FD198F, 0xDE6C8794, 0x7BF8B752, 0x73D323AB, 0x4B02E272, 0x1F8F57E3, 0x55AB2A66,
+                0xEB2807B2, 0xB5C2032F, 0xC57B9A86, 0x3708A5D3, 0x2887F230, 0xBFA5B223, 0x036ABA02, 0x16825CED,
+                0xCF1C2B8A, 0x79B492A7, 0x07F2F0F3, 0x69E2A14E, 0xDAF4CD65, 0x05BED506, 0x34621FD1, 0xA6FE8AC4,
+                0x2E539D34, 0xF355A0A2, 0x8AE13205, 0xF6EB75A4, 0x83EC390B, 0x60EFAA40, 0x719F065E, 0x6E1051BD,
+                0x218AF93E, 0xDD063D96, 0x3E05AEDD, 0xE6BD464D, 0x548DB591, 0xC45D0571, 0x06D46F04, 0x5015FF60,
+                0x98FB2419, 0xBDE997D6, 0x4043CC89, 0xD99E7767, 0xE842BDB0, 0x898B8807, 0x195B38E7, 0xC8EEDB79,
+                0x7C0A47A1, 0x420FE97C, 0x841EC9F8, 0x00000000, 0x80868309, 0x2BED4832, 0x1170AC1E, 0x5A724E6C,
+                0x0EFFFBFD, 0x8538560F, 0xAED51E3D, 0x2D392736, 0x0FD9640A, 0x5CA62168, 0x5B54D19B, 0x362E3A24,
+                0x0A67B10C, 0x57E70F93, 0xEE96D2B4, 0x9B919E1B, 0xC0C54F80, 0xDC20A261, 0x774B695A, 0x121A161C,
+                0x93BA0AE2, 0xA02AE5C0, 0x22E0433C, 0x1B171D12, 0x090D0B0E, 0x8BC7ADF2, 0xB6A8B92D, 0x1EA9C814,
+                0xF1198557, 0x75074CAF, 0x99DDBBEE, 0x7F60FDA3, 0x01269FF7, 0x72F5BC5C, 0x663BC544, 0xFB7E345B,
+                0x4329768B, 0x23C6DCCB, 0xEDFC68B6, 0xE4F163B8, 0x31DCCAD7, 0x63851042, 0x97224013, 0xC6112084,
+                0x4A247D85, 0xBB3DF8D2, 0xF93211AE, 0x29A16DC7, 0x9E2F4B1D, 0xB230F3DC, 0x8652EC0D, 0xC1E3D077,
+                0xB3166C2B, 0x70B999A9, 0x9448FA11, 0xE9642247, 0xFC8CC4A8, 0xF03F1AA0, 0x7D2CD856, 0x3390EF22,
+                0x494EC787, 0x38D1C1D9, 0xCAA2FE8C, 0xD40B3698, 0xF581CFA6, 0x7ADE28A5, 0xB78E26DA, 0xADBFA43F,
+                0x3A9DE42C, 0x78920D50, 0x5FCC9B6A, 0x7E466254, 0x8D13C2F6, 0xD8B8E890, 0x39F75E2E, 0xC3AFF582,
+                0x5D80BE9F, 0xD0937C69, 0xD52DA96F, 0x2512B3CF, 0xAC993BC8, 0x187DA710, 0x9C636EE8, 0x3BBB7BDB,
+                0x267809CD, 0x5918F46E, 0x9AB701EC, 0x4F9AA883, 0x956E65E6, 0xFFE67EAA, 0xBCCF0821, 0x15E8E6EF,
+                0xE79BD9BA, 0x6F36CE4A, 0x9F09D4EA, 0xB07CD629, 0xA4B2AF31, 0x3F23312A, 0xA59430C6, 0xA266C035,
+                0x4EBC3774, 0x82CAA6FC, 0x90D0B0E0, 0xA7D81533, 0x04984AF1, 0xECDAF741, 0xCD500E7F, 0x91F62F17,
+                0x4DD68D76, 0xEFB04D43, 0xAA4D54CC, 0x9604DFE4, 0xD1B5E39E, 0x6A881B4C, 0x2C1FB8C1, 0x65517F46,
+                0x5EEA049D, 0x8C355D01, 0x877473FA, 0x0B412EFB, 0x671D5AB3, 0xDBD25292, 0x105633E9, 0xD647136D,
+                0xD7618C9A, 0xA10C7A37, 0xF8148E59, 0x133C89EB, 0xA927EECE, 0x61C935B7, 0x1CE5EDE1, 0x47B13C7A,
+                0xD2DF599C, 0xF2733F55, 0x14CE7918, 0xC737BF73, 0xF7CDEA53, 0xFDAA5B5F, 0x3D6F14DF, 0x44DB8678,
+                0xAFF381CA, 0x68C43EB9, 0x24342C38, 0xA3405FC2, 0x1DC37216, 0xE2250CBC, 0x3C498B28, 0x0D9541FF,
+                0xA8017139, 0x0CB3DE08, 0xB4E49CD8, 0x56C19064, 0xCB84617B, 0x32B670D5, 0x6C5C7448, 0xB85742D0
+            ));
+
+            foreach ($dt3 as $dt3i) {
+                $dt0[] = (($dt3i << 24) & 0xFF000000) | (($dt3i >>  8) & 0x00FFFFFF);
+                $dt1[] = (($dt3i << 16) & 0xFFFF0000) | (($dt3i >> 16) & 0x0000FFFF);
+                $dt2[] = (($dt3i <<  8) & 0xFFFFFF00) | (($dt3i >> 24) & 0x000000FF);
+            };
+
+            $tables = array(
+                // The Precomputed inverse mixColumns tables dt0 - dt3
+                $dt0,
+                $dt1,
+                $dt2,
+                $dt3,
+                // The inverse SubByte S-Box
+                array(
+                    0x52, 0x09, 0x6A, 0xD5, 0x30, 0x36, 0xA5, 0x38, 0xBF, 0x40, 0xA3, 0x9E, 0x81, 0xF3, 0xD7, 0xFB,
+                    0x7C, 0xE3, 0x39, 0x82, 0x9B, 0x2F, 0xFF, 0x87, 0x34, 0x8E, 0x43, 0x44, 0xC4, 0xDE, 0xE9, 0xCB,
+                    0x54, 0x7B, 0x94, 0x32, 0xA6, 0xC2, 0x23, 0x3D, 0xEE, 0x4C, 0x95, 0x0B, 0x42, 0xFA, 0xC3, 0x4E,
+                    0x08, 0x2E, 0xA1, 0x66, 0x28, 0xD9, 0x24, 0xB2, 0x76, 0x5B, 0xA2, 0x49, 0x6D, 0x8B, 0xD1, 0x25,
+                    0x72, 0xF8, 0xF6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xD4, 0xA4, 0x5C, 0xCC, 0x5D, 0x65, 0xB6, 0x92,
+                    0x6C, 0x70, 0x48, 0x50, 0xFD, 0xED, 0xB9, 0xDA, 0x5E, 0x15, 0x46, 0x57, 0xA7, 0x8D, 0x9D, 0x84,
+                    0x90, 0xD8, 0xAB, 0x00, 0x8C, 0xBC, 0xD3, 0x0A, 0xF7, 0xE4, 0x58, 0x05, 0xB8, 0xB3, 0x45, 0x06,
+                    0xD0, 0x2C, 0x1E, 0x8F, 0xCA, 0x3F, 0x0F, 0x02, 0xC1, 0xAF, 0xBD, 0x03, 0x01, 0x13, 0x8A, 0x6B,
+                    0x3A, 0x91, 0x11, 0x41, 0x4F, 0x67, 0xDC, 0xEA, 0x97, 0xF2, 0xCF, 0xCE, 0xF0, 0xB4, 0xE6, 0x73,
+                    0x96, 0xAC, 0x74, 0x22, 0xE7, 0xAD, 0x35, 0x85, 0xE2, 0xF9, 0x37, 0xE8, 0x1C, 0x75, 0xDF, 0x6E,
+                    0x47, 0xF1, 0x1A, 0x71, 0x1D, 0x29, 0xC5, 0x89, 0x6F, 0xB7, 0x62, 0x0E, 0xAA, 0x18, 0xBE, 0x1B,
+                    0xFC, 0x56, 0x3E, 0x4B, 0xC6, 0xD2, 0x79, 0x20, 0x9A, 0xDB, 0xC0, 0xFE, 0x78, 0xCD, 0x5A, 0xF4,
+                    0x1F, 0xDD, 0xA8, 0x33, 0x88, 0x07, 0xC7, 0x31, 0xB1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xEC, 0x5F,
+                    0x60, 0x51, 0x7F, 0xA9, 0x19, 0xB5, 0x4A, 0x0D, 0x2D, 0xE5, 0x7A, 0x9F, 0x93, 0xC9, 0x9C, 0xEF,
+                    0xA0, 0xE0, 0x3B, 0x4D, 0xAE, 0x2A, 0xF5, 0xB0, 0xC8, 0xEB, 0xBB, 0x3C, 0x83, 0x53, 0x99, 0x61,
+                    0x17, 0x2B, 0x04, 0x7E, 0xBA, 0x77, 0xD6, 0x26, 0xE1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0C, 0x7D
+                )
+            );
+        }
+        return $tables;
     }
 
     /**
-     * Pads a string
-     *
-     * Pads a string using the RSA PKCS padding standards so that its length is a multiple of the blocksize.
-     * $block_size - (strlen($text) % $block_size) bytes are added, each of which is equal to 
-     * chr($block_size - (strlen($text) % $block_size)
+     * Setup the performance-optimized function for de/encrypt()
      *
-     * If padding is disabled and $text is not a multiple of the blocksize, the string will be padded regardless
-     * and padding will, hence forth, be enabled.
-     *
-     * @see Crypt_Rijndael::_unpad()
+     * @see \phpseclib\Crypt\Base::_setupInlineCrypt()
      * @access private
      */
-    function _pad($text)
+    function _setupInlineCrypt()
     {
-        $length = strlen($text);
-
-        if (!$this->padding) {
-            if ($length % $this->block_size == 0) {
-                return $text;
-            } else {
-                user_error("The plaintext's length ($length) is not a multiple of the block size ({$this->block_size})", E_USER_NOTICE);
-                $this->padding = true;
-            }
-        }
+        // Note: _setupInlineCrypt() will be called only if $this->changed === true
+        // So here we are'nt under the same heavy timing-stress as we are in _de/encryptBlock() or de/encrypt().
+        // However...the here generated function- $code, stored as php callback in $this->inline_crypt, must work as fast as even possible.
 
-        $pad = $this->block_size - ($length % $this->block_size);
+        $lambda_functions =& self::_getLambdaFunctions();
 
-        return str_pad($text, $length + $pad, chr($pad));
-    }
+        // We create max. 10 hi-optimized code for memory reason. Means: For each $key one ultra fast inline-crypt function.
+        // (Currently, for Crypt_Rijndael/AES, one generated $lambda_function cost on php5.5@32bit ~80kb unfreeable mem and ~130kb on php5.5@64bit)
+        // After that, we'll still create very fast optimized code but not the hi-ultimative code, for each $mode one.
+        $gen_hi_opt_code = (bool)(count($lambda_functions) < 10);
 
-    /**
-     * Unpads a string.
-     *
-     * If padding is enabled and the reported padding length is invalid the encryption key will be assumed to be wrong
-     * and false will be returned.
-     *
-     * @see Crypt_Rijndael::_pad()
-     * @access private
-     */
-    function _unpad($text)
-    {
-        if (!$this->padding) {
-            return $text;
+        // Generation of a uniqe hash for our generated code
+        $code_hash = "Crypt_Rijndael, {$this->mode}, {$this->Nr}, {$this->Nb}";
+        if ($gen_hi_opt_code) {
+            $code_hash = str_pad($code_hash, 32) . $this->_hashInlineCryptFunction($this->key);
         }
 
-        $length = ord($text[strlen($text) - 1]);
+        if (!isset($lambda_functions[$code_hash])) {
+            switch (true) {
+                case $gen_hi_opt_code:
+                    // The hi-optimized $lambda_functions will use the key-words hardcoded for better performance.
+                    $w  = $this->w;
+                    $dw = $this->dw;
+                    $init_encrypt = '';
+                    $init_decrypt = '';
+                    break;
+                default:
+                    for ($i = 0, $cw = count($this->w); $i < $cw; ++$i) {
+                        $w[]  = '$w['  . $i . ']';
+                        $dw[] = '$dw[' . $i . ']';
+                    }
+                    $init_encrypt = '$w  = $self->w;';
+                    $init_decrypt = '$dw = $self->dw;';
+            }
 
-        if (!$length || $length > $this->block_size) {
-            return false;
-        }
+            $Nr = $this->Nr;
+            $Nb = $this->Nb;
+            $c  = $this->c;
 
-        return substr($text, 0, -$length);
-    }
+            // Generating encrypt code:
+            $init_encrypt.= '
+                static $tables;
+                if (empty($tables)) {
+                    $tables = &$self->_getTables();
+                }
+                $t0   = $tables[0];
+                $t1   = $tables[1];
+                $t2   = $tables[2];
+                $t3   = $tables[3];
+                $sbox = $tables[4];
+            ';
+
+            $s  = 'e';
+            $e  = 's';
+            $wc = $Nb - 1;
+
+            // Preround: addRoundKey
+            $encrypt_block = '$in = unpack("N*", $in);'."\n";
+            for ($i = 0; $i < $Nb; ++$i) {
+                $encrypt_block .= '$s'.$i.' = $in['.($i + 1).'] ^ '.$w[++$wc].";\n";
+            }
 
-    /**
-     * Treat consecutive "packets" as if they are a continuous buffer.
-     *
-     * Say you have a 32-byte plaintext $plaintext.  Using the default behavior, the two following code snippets
-     * will yield different outputs:
-     *
-     * <code>
-     *    echo $rijndael->encrypt(substr($plaintext,  0, 16));
-     *    echo $rijndael->encrypt(substr($plaintext, 16, 16));
-     * </code>
-     * <code>
-     *    echo $rijndael->encrypt($plaintext);
-     * </code>
-     *
-     * The solution is to enable the continuous buffer.  Although this will resolve the above discrepancy, it creates
-     * another, as demonstrated with the following:
-     *
-     * <code>
-     *    $rijndael->encrypt(substr($plaintext, 0, 16));
-     *    echo $rijndael->decrypt($des->encrypt(substr($plaintext, 16, 16)));
-     * </code>
-     * <code>
-     *    echo $rijndael->decrypt($des->encrypt(substr($plaintext, 16, 16)));
-     * </code>
-     *
-     * With the continuous buffer disabled, these would yield the same output.  With it enabled, they yield different
-     * outputs.  The reason is due to the fact that the initialization vector's change after every encryption /
-     * decryption round when the continuous buffer is enabled.  When it's disabled, they remain constant.
-     *
-     * Put another way, when the continuous buffer is enabled, the state of the Crypt_Rijndael() object changes after each
-     * encryption / decryption round, whereas otherwise, it'd remain constant.  For this reason, it's recommended that
-     * continuous buffers not be used.  They do offer better security and are, in fact, sometimes required (SSH uses them),
-     * however, they are also less intuitive and more likely to cause you problems.
-     *
-     * @see Crypt_Rijndael::disableContinuousBuffer()
-     * @access public
-     */
-    function enableContinuousBuffer()
-    {
-        $this->continuousBuffer = true;
-    }
+            // Mainrounds: shiftRows + subWord + mixColumns + addRoundKey
+            for ($round = 1; $round < $Nr; ++$round) {
+                list($s, $e) = array($e, $s);
+                for ($i = 0; $i < $Nb; ++$i) {
+                    $encrypt_block.=
+                        '$'.$e.$i.' =
+                        $t0[($'.$s.$i                  .' >> 24) & 0xff] ^
+                        $t1[($'.$s.(($i + $c[1]) % $Nb).' >> 16) & 0xff] ^
+                        $t2[($'.$s.(($i + $c[2]) % $Nb).' >>  8) & 0xff] ^
+                        $t3[ $'.$s.(($i + $c[3]) % $Nb).'        & 0xff] ^
+                        '.$w[++$wc].";\n";
+                }
+            }
 
-    /**
-     * Treat consecutive packets as if they are a discontinuous buffer.
-     *
-     * The default behavior.
-     *
-     * @see Crypt_Rijndael::enableContinuousBuffer()
-     * @access public
-     */
-    function disableContinuousBuffer()
-    {
-        $this->continuousBuffer = false;
-        $this->encryptIV = $this->iv;
-        $this->decryptIV = $this->iv;
-    }
+            // Finalround: subWord + shiftRows + addRoundKey
+            for ($i = 0; $i < $Nb; ++$i) {
+                $encrypt_block.=
+                    '$'.$e.$i.' =
+                     $sbox[ $'.$e.$i.'        & 0xff]        |
+                    ($sbox[($'.$e.$i.' >>  8) & 0xff] <<  8) |
+                    ($sbox[($'.$e.$i.' >> 16) & 0xff] << 16) |
+                    ($sbox[($'.$e.$i.' >> 24) & 0xff] << 24);'."\n";
+            }
+            $encrypt_block .= '$in = pack("N*"'."\n";
+            for ($i = 0; $i < $Nb; ++$i) {
+                $encrypt_block.= ',
+                    ($'.$e.$i                  .' & '.((int)0xFF000000).') ^
+                    ($'.$e.(($i + $c[1]) % $Nb).' &         0x00FF0000   ) ^
+                    ($'.$e.(($i + $c[2]) % $Nb).' &         0x0000FF00   ) ^
+                    ($'.$e.(($i + $c[3]) % $Nb).' &         0x000000FF   ) ^
+                    '.$w[$i]."\n";
+            }
+            $encrypt_block .= ');';
 
-    /**
-     * String Shift
-     *
-     * Inspired by array_shift
-     *
-     * @param String $string
-     * @param optional Integer $index
-     * @return String
-     * @access private
-     */
-    function _string_shift(&$string, $index = 1)
-    {
-        $substr = substr($string, 0, $index);
-        $string = substr($string, $index);
-        return $substr;
+            // Generating decrypt code:
+            $init_decrypt.= '
+                static $invtables;
+                if (empty($invtables)) {
+                    $invtables = &$self->_getInvTables();
+                }
+                $dt0   = $invtables[0];
+                $dt1   = $invtables[1];
+                $dt2   = $invtables[2];
+                $dt3   = $invtables[3];
+                $isbox = $invtables[4];
+            ';
+
+            $s  = 'e';
+            $e  = 's';
+            $wc = $Nb - 1;
+
+            // Preround: addRoundKey
+            $decrypt_block = '$in = unpack("N*", $in);'."\n";
+            for ($i = 0; $i < $Nb; ++$i) {
+                $decrypt_block .= '$s'.$i.' = $in['.($i + 1).'] ^ '.$dw[++$wc].';'."\n";
+            }
+
+            // Mainrounds: shiftRows + subWord + mixColumns + addRoundKey
+            for ($round = 1; $round < $Nr; ++$round) {
+                list($s, $e) = array($e, $s);
+                for ($i = 0; $i < $Nb; ++$i) {
+                    $decrypt_block.=
+                        '$'.$e.$i.' =
+                        $dt0[($'.$s.$i                        .' >> 24) & 0xff] ^
+                        $dt1[($'.$s.(($Nb + $i - $c[1]) % $Nb).' >> 16) & 0xff] ^
+                        $dt2[($'.$s.(($Nb + $i - $c[2]) % $Nb).' >>  8) & 0xff] ^
+                        $dt3[ $'.$s.(($Nb + $i - $c[3]) % $Nb).'        & 0xff] ^
+                        '.$dw[++$wc].";\n";
+                }
+            }
+
+            // Finalround: subWord + shiftRows + addRoundKey
+            for ($i = 0; $i < $Nb; ++$i) {
+                $decrypt_block.=
+                    '$'.$e.$i.' =
+                     $isbox[ $'.$e.$i.'        & 0xff]        |
+                    ($isbox[($'.$e.$i.' >>  8) & 0xff] <<  8) |
+                    ($isbox[($'.$e.$i.' >> 16) & 0xff] << 16) |
+                    ($isbox[($'.$e.$i.' >> 24) & 0xff] << 24);'."\n";
+            }
+            $decrypt_block .= '$in = pack("N*"'."\n";
+            for ($i = 0; $i < $Nb; ++$i) {
+                $decrypt_block.= ',
+                    ($'.$e.$i.                        ' & '.((int)0xFF000000).') ^
+                    ($'.$e.(($Nb + $i - $c[1]) % $Nb).' &         0x00FF0000   ) ^
+                    ($'.$e.(($Nb + $i - $c[2]) % $Nb).' &         0x0000FF00   ) ^
+                    ($'.$e.(($Nb + $i - $c[3]) % $Nb).' &         0x000000FF   ) ^
+                    '.$dw[$i]."\n";
+            }
+            $decrypt_block .= ');';
+
+            $lambda_functions[$code_hash] = $this->_createInlineCryptFunction(
+                array(
+                   'init_crypt'    => '',
+                   'init_encrypt'  => $init_encrypt,
+                   'init_decrypt'  => $init_decrypt,
+                   'encrypt_block' => $encrypt_block,
+                   'decrypt_block' => $decrypt_block
+                )
+            );
+        }
+        $this->inline_crypt = $lambda_functions[$code_hash];
     }
 }
-
-// vim: ts=4:sw=4:et:
-// vim6: fdl=1:
diff --git a/lib/phpseclib/Crypt/TripleDES.php b/lib/phpseclib/Crypt/TripleDES.php
index 2a66b3e..a2c4166 100644
--- a/lib/phpseclib/Crypt/TripleDES.php
+++ b/lib/phpseclib/Crypt/TripleDES.php
@@ -1,19 +1,18 @@
 <?php
-/* vim: set expandtab tabstop=4 shiftwidth=4 softtabstop=4: */
 
 /**
  * Pure-PHP implementation of Triple DES.
  *
  * Uses mcrypt, if available, and an internal implementation, otherwise.  Operates in the EDE3 mode (encrypt-decrypt-encrypt).
  *
- * PHP versions 4 and 5
+ * PHP version 5
  *
  * Here's a short example of how to use this library:
  * <code>
  * <?php
- *    include('Crypt/TripleDES.php');
+ *    include 'vendor/autoload.php';
  *
- *    $des = new Crypt_TripleDES();
+ *    $des = new \phpseclib\Crypt\TripleDES();
  *
  *    $des->setKey('abcdefghijklmnopqrstuvwx');
  *
@@ -27,511 +26,314 @@
  * ?>
  * </code>
  *
- * LICENSE: This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA  02111-1307  USA
- *
- * @category   Crypt
- * @package    Crypt_TripleDES
- * @author     Jim Wigginton <terrafrost@php.net>
- * @copyright  MMVII Jim Wigginton
- * @license    http://www.gnu.org/licenses/lgpl.txt
- * @version    $Id: TripleDES.php,v 1.13 2010/02/26 03:40:25 terrafrost Exp $
- * @link       http://phpseclib.sourceforge.net
- */
-
-/**
- * Include Crypt_DES
- */
-require_once 'DES.php';
-
-/**
- * Encrypt / decrypt using inner chaining
- *
- * Inner chaining is used by SSH-1 and is generally considered to be less secure then outer chaining (CRYPT_DES_MODE_CBC3).
+ * @category  Crypt
+ * @package   TripleDES
+ * @author    Jim Wigginton <terrafrost@php.net>
+ * @copyright 2007 Jim Wigginton
+ * @license   http://www.opensource.org/licenses/mit-license.html  MIT License
+ * @link      http://phpseclib.sourceforge.net
  */
-define('CRYPT_DES_MODE_3CBC', 3);
 
-/**
- * Encrypt / decrypt using outer chaining
- *
- * Outer chaining is used by SSH-2 and when the mode is set to CRYPT_DES_MODE_CBC.
- */
-define('CRYPT_DES_MODE_CBC3', CRYPT_DES_MODE_CBC);
+namespace phpseclib\Crypt;
 
 /**
  * Pure-PHP implementation of Triple DES.
  *
+ * @package TripleDES
  * @author  Jim Wigginton <terrafrost@php.net>
- * @version 0.1.0
  * @access  public
- * @package Crypt_TerraDES
  */
-class Crypt_TripleDES {
+class TripleDES extends DES
+{
     /**
-     * The Three Keys
+     * Encrypt / decrypt using inner chaining
      *
-     * @see Crypt_TripleDES::setKey()
-     * @var String
-     * @access private
+     * Inner chaining is used by SSH-1 and is generally considered to be less secure then outer chaining (self::MODE_CBC3).
      */
-    var $key = "\0\0\0\0\0\0\0\0";
+    const MODE_3CBC = -2;
 
     /**
-     * The Encryption Mode
+     * Encrypt / decrypt using outer chaining
      *
-     * @see Crypt_TripleDES::Crypt_TripleDES()
-     * @var Integer
-     * @access private
+     * Outer chaining is used by SSH-2 and when the mode is set to \phpseclib\Crypt\Base::MODE_CBC.
      */
-    var $mode = CRYPT_DES_MODE_CBC;
+    const MODE_CBC3 = Base::MODE_CBC;
 
     /**
-     * Continuous Buffer status
+     * Key Length (in bytes)
      *
-     * @see Crypt_TripleDES::enableContinuousBuffer()
-     * @var Boolean
+     * @see \phpseclib\Crypt\TripleDES::setKeyLength()
+     * @var int
      * @access private
      */
-    var $continuousBuffer = false;
+    var $key_length = 24;
 
     /**
-     * Padding status
+     * The default salt used by setPassword()
      *
-     * @see Crypt_TripleDES::enablePadding()
-     * @var Boolean
+     * @see \phpseclib\Crypt\Base::password_default_salt
+     * @see \phpseclib\Crypt\Base::setPassword()
+     * @var string
      * @access private
      */
-    var $padding = true;
+    var $password_default_salt = 'phpseclib';
 
     /**
-     * The Initialization Vector
+     * The mcrypt specific name of the cipher
      *
-     * @see Crypt_TripleDES::setIV()
-     * @var String
+     * @see \phpseclib\Crypt\DES::cipher_name_mcrypt
+     * @see \phpseclib\Crypt\Base::cipher_name_mcrypt
+     * @var string
      * @access private
      */
-    var $iv = "\0\0\0\0\0\0\0\0";
+    var $cipher_name_mcrypt = 'tripledes';
 
     /**
-     * A "sliding" Initialization Vector
+     * Optimizing value while CFB-encrypting
      *
-     * @see Crypt_TripleDES::enableContinuousBuffer()
-     * @var String
+     * @see \phpseclib\Crypt\Base::cfb_init_len
+     * @var int
      * @access private
      */
-    var $encryptIV = "\0\0\0\0\0\0\0\0";
+    var $cfb_init_len = 750;
 
     /**
-     * A "sliding" Initialization Vector
+     * max possible size of $key
      *
-     * @see Crypt_TripleDES::enableContinuousBuffer()
-     * @var String
+     * @see self::setKey()
+     * @see \phpseclib\Crypt\DES::setKey()
+     * @var string
      * @access private
      */
-    var $decryptIV = "\0\0\0\0\0\0\0\0";
+    var $key_length_max = 24;
 
     /**
-     * The Crypt_DES objects
+     * Internal flag whether using self::MODE_3CBC or not
      *
-     * @var Array
+     * @var bool
      * @access private
      */
-    var $des;
+    var $mode_3cbc;
 
     /**
-     * mcrypt resource for encryption
+     * The \phpseclib\Crypt\DES objects
      *
-     * The mcrypt resource can be recreated every time something needs to be created or it can be created just once.
-     * Since mcrypt operates in continuous mode, by default, it'll need to be recreated when in non-continuous mode.
+     * Used only if $mode_3cbc === true
      *
-     * @see Crypt_AES::encrypt()
-     * @var String
+     * @var array
      * @access private
      */
-    var $enmcrypt;
+    var $des;
 
     /**
-     * mcrypt resource for decryption
+     * Default Constructor.
      *
-     * The mcrypt resource can be recreated every time something needs to be created or it can be created just once.
-     * Since mcrypt operates in continuous mode, by default, it'll need to be recreated when in non-continuous mode.
+     * Determines whether or not the mcrypt extension should be used.
      *
-     * @see Crypt_AES::decrypt()
-     * @var String
-     * @access private
-     */
-    var $demcrypt;
-
-    /**
-     * Does the (en|de)mcrypt resource need to be (re)initialized?
+     * $mode could be:
      *
-     * @see setKey()
-     * @see setIV()
-     * @var Boolean
-     * @access private
-     */
-    var $changed = true;
-
-    /**
-     * Default Constructor.
+     * - \phpseclib\Crypt\Base::MODE_ECB
+     *
+     * - \phpseclib\Crypt\Base::MODE_CBC
+     *
+     * - \phpseclib\Crypt\Base::MODE_CTR
+     *
+     * - \phpseclib\Crypt\Base::MODE_CFB
      *
-     * Determines whether or not the mcrypt extension should be used.  $mode should only, at present, be
-     * CRYPT_DES_MODE_ECB or CRYPT_DES_MODE_CBC.  If not explictly set, CRYPT_DES_MODE_CBC will be used.
+     * - \phpseclib\Crypt\Base::MODE_OFB
      *
-     * @param optional Integer $mode
-     * @return Crypt_TripleDES
+     * - \phpseclib\Crypt\TripleDES::MODE_3CBC
+     *
+     * If not explicitly set, \phpseclib\Crypt\Base::MODE_CBC will be used.
+     *
+     * @see \phpseclib\Crypt\DES::__construct()
+     * @see \phpseclib\Crypt\Base::__construct()
+     * @param int $mode
      * @access public
      */
-    function Crypt_TripleDES($mode = CRYPT_DES_MODE_CBC)
+    function __construct($mode = Base::MODE_CBC)
     {
-        if ( !defined('CRYPT_DES_MODE') ) {
-            switch (true) {
-                case extension_loaded('mcrypt'):
-                    // i'd check to see if des was supported, by doing in_array('des', mcrypt_list_algorithms('')),
-                    // but since that can be changed after the object has been created, there doesn't seem to be
-                    // a lot of point...
-                    define('CRYPT_DES_MODE', CRYPT_DES_MODE_MCRYPT);
-                    break;
-                default:
-                    define('CRYPT_DES_MODE', CRYPT_DES_MODE_INTERNAL);
-            }
-        }
-
-        if ( $mode == CRYPT_DES_MODE_3CBC ) {
-            $this->mode = CRYPT_DES_MODE_3CBC;
-            $this->des = array(
-                new Crypt_DES(CRYPT_DES_MODE_CBC),
-                new Crypt_DES(CRYPT_DES_MODE_CBC),
-                new Crypt_DES(CRYPT_DES_MODE_CBC)
-            );
-
-            // we're going to be doing the padding, ourselves, so disable it in the Crypt_DES objects
-            $this->des[0]->disablePadding();
-            $this->des[1]->disablePadding();
-            $this->des[2]->disablePadding();
-
-            return;
-        }
-
-        switch ( CRYPT_DES_MODE ) {
-            case CRYPT_DES_MODE_MCRYPT:
-                switch ($mode) {
-                    case CRYPT_DES_MODE_ECB:
-                        $this->mode = MCRYPT_MODE_ECB;
-                        break;
-                    case CRYPT_DES_MODE_CTR:
-                        $this->mode = 'ctr';
-                        break;
-                    case CRYPT_DES_MODE_CBC:
-                    default:
-                        $this->mode = MCRYPT_MODE_CBC;
-                }
-
-                break;
-            default:
+        switch ($mode) {
+            // In case of self::MODE_3CBC, we init as CRYPT_DES_MODE_CBC
+            // and additional flag us internally as 3CBC
+            case self::MODE_3CBC:
+                parent::__construct(Base::MODE_CBC);
+                $this->mode_3cbc = true;
+
+                // This three $des'es will do the 3CBC work (if $key > 64bits)
                 $this->des = array(
-                    new Crypt_DES(CRYPT_DES_MODE_ECB),
-                    new Crypt_DES(CRYPT_DES_MODE_ECB),
-                    new Crypt_DES(CRYPT_DES_MODE_ECB)
+                    new DES(Base::MODE_CBC),
+                    new DES(Base::MODE_CBC),
+                    new DES(Base::MODE_CBC),
                 );
- 
-                // we're going to be doing the padding, ourselves, so disable it in the Crypt_DES objects
+
+                // we're going to be doing the padding, ourselves, so disable it in the \phpseclib\Crypt\DES objects
                 $this->des[0]->disablePadding();
                 $this->des[1]->disablePadding();
                 $this->des[2]->disablePadding();
-
-                switch ($mode) {
-                    case CRYPT_DES_MODE_ECB:
-                    case CRYPT_DES_MODE_CTR:
-                    case CRYPT_DES_MODE_CBC:
-                        $this->mode = $mode;
-                        break;
-                    default:
-                        $this->mode = CRYPT_DES_MODE_CBC;
-                }
+                break;
+            // If not 3CBC, we init as usual
+            default:
+                parent::__construct($mode);
         }
     }
 
     /**
-     * Sets the key.
-     *
-     * Keys can be of any length.  Triple DES, itself, can use 128-bit (eg. strlen($key) == 16) or
-     * 192-bit (eg. strlen($key) == 24) keys.  This function pads and truncates $key as appropriate.
+     * Test for engine validity
      *
-     * DES also requires that every eighth bit be a parity bit, however, we'll ignore that.
-     *
-     * If the key is not explicitly set, it'll be assumed to be all zero's.
+     * This is mainly just a wrapper to set things up for \phpseclib\Crypt\Base::isValidEngine()
      *
+     * @see \phpseclib\Crypt\Base::__construct()
+     * @param int $engine
      * @access public
-     * @param String $key
+     * @return bool
      */
-    function setKey($key)
+    function isValidEngine($engine)
     {
-        $length = strlen($key);
-        if ($length > 8) {
-            $key = str_pad($key, 24, chr(0));
-            // if $key is between 64 and 128-bits, use the first 64-bits as the last, per this:
-            // http://php.net/function.mcrypt-encrypt#47973
-            //$key = $length <= 16 ? substr_replace($key, substr($key, 0, 8), 16) : substr($key, 0, 24);
-        }
-        $this->key = $key;
-        switch (true) {
-            case CRYPT_DES_MODE == CRYPT_DES_MODE_INTERNAL:
-            case $this->mode == CRYPT_DES_MODE_3CBC:
-                $this->des[0]->setKey(substr($key,  0, 8));
-                $this->des[1]->setKey(substr($key,  8, 8));
-                $this->des[2]->setKey(substr($key, 16, 8));
+        if ($engine == self::ENGINE_OPENSSL) {
+            $this->cipher_name_openssl_ecb = 'des-ede3';
+            $mode = $this->_openssl_translate_mode();
+            $this->cipher_name_openssl = $mode == 'ecb' ? 'des-ede3' : 'des-ede3-' . $mode;
         }
-        $this->changed = true;
+
+        return parent::isValidEngine($engine);
     }
 
     /**
      * Sets the initialization vector. (optional)
      *
-     * SetIV is not required when CRYPT_DES_MODE_ECB is being used.  If not explictly set, it'll be assumed
+     * SetIV is not required when \phpseclib\Crypt\Base::MODE_ECB is being used.  If not explicitly set, it'll be assumed
      * to be all zero's.
      *
+     * @see \phpseclib\Crypt\Base::setIV()
      * @access public
-     * @param String $iv
+     * @param string $iv
      */
     function setIV($iv)
     {
-        $this->encryptIV = $this->decryptIV = $this->iv = str_pad(substr($iv, 0, 8), 8, chr(0));
-        if ($this->mode == CRYPT_DES_MODE_3CBC) {
+        parent::setIV($iv);
+        if ($this->mode_3cbc) {
             $this->des[0]->setIV($iv);
             $this->des[1]->setIV($iv);
             $this->des[2]->setIV($iv);
         }
-        $this->changed = true;
     }
 
     /**
-     * Generate CTR XOR encryption key
+     * Sets the key length.
      *
-     * Encrypt the output of this and XOR it against the ciphertext / plaintext to get the
-     * plaintext / ciphertext in CTR mode.
+     * Valid key lengths are 64, 128 and 192
      *
-     * @see Crypt_DES::decrypt()
-     * @see Crypt_DES::encrypt()
+     * @see \phpseclib\Crypt\Base:setKeyLength()
      * @access public
-     * @param Integer $length
-     * @param String $iv
+     * @param int $length
      */
-    function _generate_xor($length, &$iv)
+    function setKeyLength($length)
     {
-        $xor = '';
-        $num_blocks = ($length + 7) >> 3;
-        for ($i = 0; $i < $num_blocks; $i++) {
-            $xor.= $iv;
-            for ($j = 4; $j <= 8; $j+=4) {
-                $temp = substr($iv, -$j, 4);
-                switch ($temp) {
-                    case "\xFF\xFF\xFF\xFF":
-                        $iv = substr_replace($iv, "\x00\x00\x00\x00", -$j, 4);
-                        break;
-                    case "\x7F\xFF\xFF\xFF":
-                        $iv = substr_replace($iv, "\x80\x00\x00\x00", -$j, 4);
-                        break 2;
-                    default:
-                        extract(unpack('Ncount', $temp));
-                        $iv = substr_replace($iv, pack('N', $count + 1), -$j, 4);
-                        break 2;
-                }
-            }
+        $length >>= 3;
+        switch (true) {
+            case $length <= 8:
+                $this->key_length = 8;
+                break;
+            case $length <= 16:
+                $this->key_length = 16;
+                break;
+            default:
+                $this->key_length = 24;
         }
 
-        return $xor;
+        parent::setKeyLength($length);
     }
 
     /**
-     * Encrypts a message.
+     * Sets the key.
+     *
+     * Keys can be of any length.  Triple DES, itself, can use 128-bit (eg. strlen($key) == 16) or
+     * 192-bit (eg. strlen($key) == 24) keys.  This function pads and truncates $key as appropriate.
+     *
+     * DES also requires that every eighth bit be a parity bit, however, we'll ignore that.
+     *
+     * If the key is not explicitly set, it'll be assumed to be all null bytes.
      *
      * @access public
-     * @param String $plaintext
+     * @see \phpseclib\Crypt\DES::setKey()
+     * @see \phpseclib\Crypt\Base::setKey()
+     * @param string $key
      */
-    function encrypt($plaintext)
+    function setKey($key)
     {
-        if ($this->mode != CRYPT_DES_MODE_CTR && $this->mode != 'ctr') {
-            $plaintext = $this->_pad($plaintext);
-        }
-
-        // if the key is smaller then 8, do what we'd normally do
-        if ($this->mode == CRYPT_DES_MODE_3CBC && strlen($this->key) > 8) {
-            $ciphertext = $this->des[2]->encrypt($this->des[1]->decrypt($this->des[0]->encrypt($plaintext)));
-
-            return $ciphertext;
+        $length = $this->explicit_key_length ? $this->key_length : strlen($key);
+        if ($length > 8) {
+            $key = str_pad(substr($key, 0, 24), 24, chr(0));
+            // if $key is between 64 and 128-bits, use the first 64-bits as the last, per this:
+            // http://php.net/function.mcrypt-encrypt#47973
+            $key = $length <= 16 ? substr_replace($key, substr($key, 0, 8), 16) : substr($key, 0, 24);
+        } else {
+            $key = str_pad($key, 8, chr(0));
         }
-
-        if ( CRYPT_DES_MODE == CRYPT_DES_MODE_MCRYPT ) {
-            if ($this->changed) {
-                if (!isset($this->enmcrypt)) {
-                    $this->enmcrypt = mcrypt_module_open(MCRYPT_3DES, '', $this->mode, '');
-                }
-                mcrypt_generic_init($this->enmcrypt, $this->key, $this->encryptIV);
-                $this->changed = false;
-            }
-
-            $ciphertext = mcrypt_generic($this->enmcrypt, $plaintext);
-
-            if (!$this->continuousBuffer) {
-                mcrypt_generic_init($this->enmcrypt, $this->key, $this->encryptIV);
-            }
-
-            return $ciphertext;
+        parent::setKey($key);
+
+        // And in case of self::MODE_3CBC:
+        // if key <= 64bits we not need the 3 $des to work,
+        // because we will then act as regular DES-CBC with just a <= 64bit key.
+        // So only if the key > 64bits (> 8 bytes) we will call setKey() for the 3 $des.
+        if ($this->mode_3cbc && $length > 8) {
+            $this->des[0]->setKey(substr($key,  0, 8));
+            $this->des[1]->setKey(substr($key,  8, 8));
+            $this->des[2]->setKey(substr($key, 16, 8));
         }
+    }
 
-        if (strlen($this->key) <= 8) {
-            $this->des[0]->mode = $this->mode;
-
-            return $this->des[0]->encrypt($plaintext);
-        }
+    /**
+     * Encrypts a message.
+     *
+     * @see \phpseclib\Crypt\Base::encrypt()
+     * @access public
+     * @param string $plaintext
+     * @return string $cipertext
+     */
+    function encrypt($plaintext)
+    {
+        // parent::en/decrypt() is able to do all the work for all modes and keylengths,
+        // except for: self::MODE_3CBC (inner chaining CBC) with a key > 64bits
 
-        // we pad with chr(0) since that's what mcrypt_generic does.  to quote from http://php.net/function.mcrypt-generic :
-        // "The data is padded with "\0" to make sure the length of the data is n * blocksize."
-        $plaintext = str_pad($plaintext, ceil(strlen($plaintext) / 8) * 8, chr(0));
-
-        $des = $this->des;
-
-        $ciphertext = '';
-        switch ($this->mode) {
-            case CRYPT_DES_MODE_ECB:
-                for ($i = 0; $i < strlen($plaintext); $i+=8) {
-                    $block = substr($plaintext, $i, 8);
-                    $block = $des[0]->_processBlock($block, CRYPT_DES_ENCRYPT);
-                    $block = $des[1]->_processBlock($block, CRYPT_DES_DECRYPT);
-                    $block = $des[2]->_processBlock($block, CRYPT_DES_ENCRYPT);
-                    $ciphertext.= $block;
-                }
-                break;
-            case CRYPT_DES_MODE_CBC:
-                $xor = $this->encryptIV;
-                for ($i = 0; $i < strlen($plaintext); $i+=8) {
-                    $block = substr($plaintext, $i, 8) ^ $xor;
-                    $block = $des[0]->_processBlock($block, CRYPT_DES_ENCRYPT);
-                    $block = $des[1]->_processBlock($block, CRYPT_DES_DECRYPT);
-                    $block = $des[2]->_processBlock($block, CRYPT_DES_ENCRYPT);
-                    $xor = $block;
-                    $ciphertext.= $block;
-                }
-                if ($this->continuousBuffer) {
-                    $this->encryptIV = $xor;
-                }
-                break;
-            case CRYPT_DES_MODE_CTR:
-                $xor = $this->encryptIV;
-                for ($i = 0; $i < strlen($plaintext); $i+=8) {
-                    $key = $this->_generate_xor(8, $xor);
-                    $key = $des[0]->_processBlock($key, CRYPT_DES_ENCRYPT);
-                    $key = $des[1]->_processBlock($key, CRYPT_DES_DECRYPT);
-                    $key = $des[2]->_processBlock($key, CRYPT_DES_ENCRYPT);
-                    $block = substr($plaintext, $i, 8);
-                    $ciphertext.= $block ^ $key;
-                }
-                if ($this->continuousBuffer) {
-                    $this->encryptIV = $xor;
-                }
+        // if the key is smaller then 8, do what we'd normally do
+        if ($this->mode_3cbc && strlen($this->key) > 8) {
+            return $this->des[2]->encrypt(
+                $this->des[1]->decrypt(
+                    $this->des[0]->encrypt(
+                        $this->_pad($plaintext)
+                    )
+                )
+            );
         }
 
-        return $ciphertext;
+        return parent::encrypt($plaintext);
     }
 
     /**
      * Decrypts a message.
      *
+     * @see \phpseclib\Crypt\Base::decrypt()
      * @access public
-     * @param String $ciphertext
+     * @param string $ciphertext
+     * @return string $plaintext
      */
     function decrypt($ciphertext)
     {
-        if ($this->mode == CRYPT_DES_MODE_3CBC && strlen($this->key) > 8) {
-            $plaintext = $this->des[0]->decrypt($this->des[1]->encrypt($this->des[2]->decrypt($ciphertext)));
-
-            return $this->_unpad($plaintext);
-        }
-
-        // we pad with chr(0) since that's what mcrypt_generic does.  to quote from http://php.net/function.mcrypt-generic :
-        // "The data is padded with "\0" to make sure the length of the data is n * blocksize."
-        $ciphertext = str_pad($ciphertext, (strlen($ciphertext) + 7) & 0xFFFFFFF8, chr(0));
-
-        if ( CRYPT_DES_MODE == CRYPT_DES_MODE_MCRYPT ) {
-            if ($this->changed) {
-                if (!isset($this->demcrypt)) {
-                    $this->demcrypt = mcrypt_module_open(MCRYPT_3DES, '', $this->mode, '');
-                }
-                mcrypt_generic_init($this->demcrypt, $this->key, $this->decryptIV);
-                $this->changed = false;
-            }
-
-            $plaintext = mdecrypt_generic($this->demcrypt, $ciphertext);
-
-            if (!$this->continuousBuffer) {
-                mcrypt_generic_init($this->demcrypt, $this->key, $this->decryptIV);
-            }
-
-            return $this->mode != 'ctr' ? $this->_unpad($plaintext) : $plaintext;
-        }
-
-        if (strlen($this->key) <= 8) {
-            $this->des[0]->mode = $this->mode;
-
-            return $this->_unpad($this->des[0]->decrypt($plaintext));
-        }
-
-        $des = $this->des;
-
-        $plaintext = '';
-        switch ($this->mode) {
-            case CRYPT_DES_MODE_ECB:
-                for ($i = 0; $i < strlen($ciphertext); $i+=8) {
-                    $block = substr($ciphertext, $i, 8);
-                    $block = $des[2]->_processBlock($block, CRYPT_DES_DECRYPT);
-                    $block = $des[1]->_processBlock($block, CRYPT_DES_ENCRYPT);
-                    $block = $des[0]->_processBlock($block, CRYPT_DES_DECRYPT);
-                    $plaintext.= $block;
-                }
-                break;
-            case CRYPT_DES_MODE_CBC:
-                $xor = $this->decryptIV;
-                for ($i = 0; $i < strlen($ciphertext); $i+=8) {
-                    $orig = $block = substr($ciphertext, $i, 8);
-                    $block = $des[2]->_processBlock($block, CRYPT_DES_DECRYPT);
-                    $block = $des[1]->_processBlock($block, CRYPT_DES_ENCRYPT);
-                    $block = $des[0]->_processBlock($block, CRYPT_DES_DECRYPT);
-                    $plaintext.= $block ^ $xor;
-                    $xor = $orig;
-                }
-                if ($this->continuousBuffer) {
-                    $this->decryptIV = $xor;
-                }
-                break;
-            case CRYPT_DES_MODE_CTR:
-                $xor = $this->decryptIV;
-                for ($i = 0; $i < strlen($ciphertext); $i+=8) {
-                    $key = $this->_generate_xor(8, $xor);
-                    $key = $des[0]->_processBlock($key, CRYPT_DES_ENCRYPT);
-                    $key = $des[1]->_processBlock($key, CRYPT_DES_DECRYPT);
-                    $key = $des[2]->_processBlock($key, CRYPT_DES_ENCRYPT);
-                    $block = substr($ciphertext, $i, 8);
-                    $plaintext.= $block ^ $key;
-                }
-                if ($this->continuousBuffer) {
-                    $this->decryptIV = $xor;
-                }
+        if ($this->mode_3cbc && strlen($this->key) > 8) {
+            return $this->_unpad(
+                $this->des[0]->decrypt(
+                    $this->des[1]->encrypt(
+                        $this->des[2]->decrypt(
+                            str_pad($ciphertext, (strlen($ciphertext) + 7) & 0xFFFFFFF8, "\0")
+                        )
+                    )
+                )
+            );
         }
 
-        return $this->mode != CRYPT_DES_MODE_CTR ? $this->_unpad($plaintext) : $plaintext;
+        return parent::decrypt($ciphertext);
     }
 
     /**
@@ -563,18 +365,19 @@ class Crypt_TripleDES {
      * outputs.  The reason is due to the fact that the initialization vector's change after every encryption /
      * decryption round when the continuous buffer is enabled.  When it's disabled, they remain constant.
      *
-     * Put another way, when the continuous buffer is enabled, the state of the Crypt_DES() object changes after each
+     * Put another way, when the continuous buffer is enabled, the state of the \phpseclib\Crypt\DES() object changes after each
      * encryption / decryption round, whereas otherwise, it'd remain constant.  For this reason, it's recommended that
      * continuous buffers not be used.  They do offer better security and are, in fact, sometimes required (SSH uses them),
      * however, they are also less intuitive and more likely to cause you problems.
      *
-     * @see Crypt_TripleDES::disableContinuousBuffer()
+     * @see \phpseclib\Crypt\Base::enableContinuousBuffer()
+     * @see self::disableContinuousBuffer()
      * @access public
      */
     function enableContinuousBuffer()
     {
-        $this->continuousBuffer = true;
-        if ($this->mode == CRYPT_DES_MODE_3CBC) {
+        parent::enableContinuousBuffer();
+        if ($this->mode_3cbc) {
             $this->des[0]->enableContinuousBuffer();
             $this->des[1]->enableContinuousBuffer();
             $this->des[2]->enableContinuousBuffer();
@@ -586,16 +389,14 @@ class Crypt_TripleDES {
      *
      * The default behavior.
      *
-     * @see Crypt_TripleDES::enableContinuousBuffer()
+     * @see \phpseclib\Crypt\Base::disableContinuousBuffer()
+     * @see self::enableContinuousBuffer()
      * @access public
      */
     function disableContinuousBuffer()
     {
-        $this->continuousBuffer = false;
-        $this->encryptIV = $this->iv;
-        $this->decryptIV = $this->iv;
-
-        if ($this->mode == CRYPT_DES_MODE_3CBC) {
+        parent::disableContinuousBuffer();
+        if ($this->mode_3cbc) {
             $this->des[0]->disableContinuousBuffer();
             $this->des[1]->disableContinuousBuffer();
             $this->des[2]->disableContinuousBuffer();
@@ -603,88 +404,57 @@ class Crypt_TripleDES {
     }
 
     /**
-     * Pad "packets".
-     *
-     * DES works by encrypting eight bytes at a time.  If you ever need to encrypt or decrypt something that's not
-     * a multiple of eight, it becomes necessary to pad the input so that it's length is a multiple of eight.
+     * Creates the key schedule
      *
-     * Padding is enabled by default.  Sometimes, however, it is undesirable to pad strings.  Such is the case in SSH1,
-     * where "packets" are padded with random bytes before being encrypted.  Unpad these packets and you risk stripping
-     * away characters that shouldn't be stripped away. (SSH knows how many bytes are added because the length is
-     * transmitted separately)
-     *
-     * @see Crypt_TripleDES::disablePadding()
-     * @access public
+     * @see \phpseclib\Crypt\DES::_setupKey()
+     * @see \phpseclib\Crypt\Base::_setupKey()
+     * @access private
      */
-    function enablePadding()
+    function _setupKey()
     {
-        $this->padding = true;
-    }
+        switch (true) {
+            // if $key <= 64bits we configure our internal pure-php cipher engine
+            // to act as regular [1]DES, not as 3DES. mcrypt.so::tripledes does the same.
+            case strlen($this->key) <= 8:
+                $this->des_rounds = 1;
+                break;
 
-    /**
-     * Do not pad packets.
-     *
-     * @see Crypt_TripleDES::enablePadding()
-     * @access public
-     */
-    function disablePadding()
-    {
-        $this->padding = false;
-    }
+            // otherwise, if $key > 64bits, we configure our engine to work as 3DES.
+            default:
+                $this->des_rounds = 3;
 
-    /**
-     * Pads a string
-     *
-     * Pads a string using the RSA PKCS padding standards so that its length is a multiple of the blocksize (8).
-     * 8 - (strlen($text) & 7) bytes are added, each of which is equal to chr(8 - (strlen($text) & 7)
-     *
-     * If padding is disabled and $text is not a multiple of the blocksize, the string will be padded regardless
-     * and padding will, hence forth, be enabled.
-     *
-     * @see Crypt_TripleDES::_unpad()
-     * @access private
-     */
-    function _pad($text)
-    {
-        $length = strlen($text);
-
-        if (!$this->padding) {
-            if (($length & 7) == 0) {
-                return $text;
-            } else {
-                user_error("The plaintext's length ($length) is not a multiple of the block size (8)", E_USER_NOTICE);
-                $this->padding = true;
-            }
-        }
+                // (only) if 3CBC is used we have, of course, to setup the $des[0-2] keys also separately.
+                if ($this->mode_3cbc) {
+                    $this->des[0]->_setupKey();
+                    $this->des[1]->_setupKey();
+                    $this->des[2]->_setupKey();
 
-        $pad = 8 - ($length & 7);
-        return str_pad($text, $length + $pad, chr($pad));
+                    // because $des[0-2] will, now, do all the work we can return here
+                    // not need unnecessary stress parent::_setupKey() with our, now unused, $key.
+                    return;
+                }
+        }
+        // setup our key
+        parent::_setupKey();
     }
 
     /**
-     * Unpads a string
+     * Sets the internal crypt engine
      *
-     * If padding is enabled and the reported padding length is invalid the encryption key will be assumed to be wrong
-     * and false will be returned.
-     *
-     * @see Crypt_TripleDES::_pad()
-     * @access private
+     * @see \phpseclib\Crypt\Base::__construct()
+     * @see \phpseclib\Crypt\Base::setPreferredEngine()
+     * @param int $engine
+     * @access public
+     * @return int
      */
-    function _unpad($text)
+    function setPreferredEngine($engine)
     {
-        if (!$this->padding) {
-            return $text;
+        if ($this->mode_3cbc) {
+            $this->des[0]->setPreferredEngine($engine);
+            $this->des[1]->setPreferredEngine($engine);
+            $this->des[2]->setPreferredEngine($engine);
         }
 
-        $length = ord($text[strlen($text) - 1]);
-
-        if (!$length || $length > 8) {
-            return false;
-        }
-
-        return substr($text, 0, -$length);
+        return parent::setPreferredEngine($engine);
     }
 }
-
-// vim: ts=4:sw=4:et:
-// vim6: fdl=1:
diff --git a/lib/phpseclib/Crypt/Twofish.php b/lib/phpseclib/Crypt/Twofish.php
new file mode 100644
index 0000000..70980a2
--- /dev/null
+++ b/lib/phpseclib/Crypt/Twofish.php
@@ -0,0 +1,816 @@
+<?php
+
+/**
+ * Pure-PHP implementation of Twofish.
+ *
+ * Uses mcrypt, if available, and an internal implementation, otherwise.
+ *
+ * PHP version 5
+ *
+ * Useful resources are as follows:
+ *
+ *  - {@link http://en.wikipedia.org/wiki/Twofish Wikipedia description of Twofish}
+ *
+ * Here's a short example of how to use this library:
+ * <code>
+ * <?php
+ *    include 'vendor/autoload.php';
+ *
+ *    $twofish = new \phpseclib\Crypt\Twofish();
+ *
+ *    $twofish->setKey('12345678901234567890123456789012');
+ *
+ *    $plaintext = str_repeat('a', 1024);
+ *
+ *    echo $twofish->decrypt($twofish->encrypt($plaintext));
+ * ?>
+ * </code>
+ *
+ * @category  Crypt
+ * @package   Twofish
+ * @author    Jim Wigginton <terrafrost@php.net>
+ * @author    Hans-Juergen Petrich <petrich@tronic-media.com>
+ * @copyright 2007 Jim Wigginton
+ * @license   http://www.opensource.org/licenses/mit-license.html  MIT License
+ * @link      http://phpseclib.sourceforge.net
+ */
+
+namespace phpseclib\Crypt;
+
+/**
+ * Pure-PHP implementation of Twofish.
+ *
+ * @package Twofish
+ * @author  Jim Wigginton <terrafrost@php.net>
+ * @author  Hans-Juergen Petrich <petrich@tronic-media.com>
+ * @access  public
+ */
+class Twofish extends Base
+{
+    /**
+     * The mcrypt specific name of the cipher
+     *
+     * @see \phpseclib\Crypt\Base::cipher_name_mcrypt
+     * @var string
+     * @access private
+     */
+    var $cipher_name_mcrypt = 'twofish';
+
+    /**
+     * Optimizing value while CFB-encrypting
+     *
+     * @see \phpseclib\Crypt\Base::cfb_init_len
+     * @var int
+     * @access private
+     */
+    var $cfb_init_len = 800;
+
+    /**
+     * Q-Table
+     *
+     * @var array
+     * @access private
+     */
+    var $q0 = array(
+        0xA9, 0x67, 0xB3, 0xE8, 0x04, 0xFD, 0xA3, 0x76,
+        0x9A, 0x92, 0x80, 0x78, 0xE4, 0xDD, 0xD1, 0x38,
+        0x0D, 0xC6, 0x35, 0x98, 0x18, 0xF7, 0xEC, 0x6C,
+        0x43, 0x75, 0x37, 0x26, 0xFA, 0x13, 0x94, 0x48,
+        0xF2, 0xD0, 0x8B, 0x30, 0x84, 0x54, 0xDF, 0x23,
+        0x19, 0x5B, 0x3D, 0x59, 0xF3, 0xAE, 0xA2, 0x82,
+        0x63, 0x01, 0x83, 0x2E, 0xD9, 0x51, 0x9B, 0x7C,
+        0xA6, 0xEB, 0xA5, 0xBE, 0x16, 0x0C, 0xE3, 0x61,
+        0xC0, 0x8C, 0x3A, 0xF5, 0x73, 0x2C, 0x25, 0x0B,
+        0xBB, 0x4E, 0x89, 0x6B, 0x53, 0x6A, 0xB4, 0xF1,
+        0xE1, 0xE6, 0xBD, 0x45, 0xE2, 0xF4, 0xB6, 0x66,
+        0xCC, 0x95, 0x03, 0x56, 0xD4, 0x1C, 0x1E, 0xD7,
+        0xFB, 0xC3, 0x8E, 0xB5, 0xE9, 0xCF, 0xBF, 0xBA,
+        0xEA, 0x77, 0x39, 0xAF, 0x33, 0xC9, 0x62, 0x71,
+        0x81, 0x79, 0x09, 0xAD, 0x24, 0xCD, 0xF9, 0xD8,
+        0xE5, 0xC5, 0xB9, 0x4D, 0x44, 0x08, 0x86, 0xE7,
+        0xA1, 0x1D, 0xAA, 0xED, 0x06, 0x70, 0xB2, 0xD2,
+        0x41, 0x7B, 0xA0, 0x11, 0x31, 0xC2, 0x27, 0x90,
+        0x20, 0xF6, 0x60, 0xFF, 0x96, 0x5C, 0xB1, 0xAB,
+        0x9E, 0x9C, 0x52, 0x1B, 0x5F, 0x93, 0x0A, 0xEF,
+        0x91, 0x85, 0x49, 0xEE, 0x2D, 0x4F, 0x8F, 0x3B,
+        0x47, 0x87, 0x6D, 0x46, 0xD6, 0x3E, 0x69, 0x64,
+        0x2A, 0xCE, 0xCB, 0x2F, 0xFC, 0x97, 0x05, 0x7A,
+        0xAC, 0x7F, 0xD5, 0x1A, 0x4B, 0x0E, 0xA7, 0x5A,
+        0x28, 0x14, 0x3F, 0x29, 0x88, 0x3C, 0x4C, 0x02,
+        0xB8, 0xDA, 0xB0, 0x17, 0x55, 0x1F, 0x8A, 0x7D,
+        0x57, 0xC7, 0x8D, 0x74, 0xB7, 0xC4, 0x9F, 0x72,
+        0x7E, 0x15, 0x22, 0x12, 0x58, 0x07, 0x99, 0x34,
+        0x6E, 0x50, 0xDE, 0x68, 0x65, 0xBC, 0xDB, 0xF8,
+        0xC8, 0xA8, 0x2B, 0x40, 0xDC, 0xFE, 0x32, 0xA4,
+        0xCA, 0x10, 0x21, 0xF0, 0xD3, 0x5D, 0x0F, 0x00,
+        0x6F, 0x9D, 0x36, 0x42, 0x4A, 0x5E, 0xC1, 0xE0
+    );
+
+    /**
+     * Q-Table
+     *
+     * @var array
+     * @access private
+     */
+    var $q1 = array(
+        0x75, 0xF3, 0xC6, 0xF4, 0xDB, 0x7B, 0xFB, 0xC8,
+        0x4A, 0xD3, 0xE6, 0x6B, 0x45, 0x7D, 0xE8, 0x4B,
+        0xD6, 0x32, 0xD8, 0xFD, 0x37, 0x71, 0xF1, 0xE1,
+        0x30, 0x0F, 0xF8, 0x1B, 0x87, 0xFA, 0x06, 0x3F,
+        0x5E, 0xBA, 0xAE, 0x5B, 0x8A, 0x00, 0xBC, 0x9D,
+        0x6D, 0xC1, 0xB1, 0x0E, 0x80, 0x5D, 0xD2, 0xD5,
+        0xA0, 0x84, 0x07, 0x14, 0xB5, 0x90, 0x2C, 0xA3,
+        0xB2, 0x73, 0x4C, 0x54, 0x92, 0x74, 0x36, 0x51,
+        0x38, 0xB0, 0xBD, 0x5A, 0xFC, 0x60, 0x62, 0x96,
+        0x6C, 0x42, 0xF7, 0x10, 0x7C, 0x28, 0x27, 0x8C,
+        0x13, 0x95, 0x9C, 0xC7, 0x24, 0x46, 0x3B, 0x70,
+        0xCA, 0xE3, 0x85, 0xCB, 0x11, 0xD0, 0x93, 0xB8,
+        0xA6, 0x83, 0x20, 0xFF, 0x9F, 0x77, 0xC3, 0xCC,
+        0x03, 0x6F, 0x08, 0xBF, 0x40, 0xE7, 0x2B, 0xE2,
+        0x79, 0x0C, 0xAA, 0x82, 0x41, 0x3A, 0xEA, 0xB9,
+        0xE4, 0x9A, 0xA4, 0x97, 0x7E, 0xDA, 0x7A, 0x17,
+        0x66, 0x94, 0xA1, 0x1D, 0x3D, 0xF0, 0xDE, 0xB3,
+        0x0B, 0x72, 0xA7, 0x1C, 0xEF, 0xD1, 0x53, 0x3E,
+        0x8F, 0x33, 0x26, 0x5F, 0xEC, 0x76, 0x2A, 0x49,
+        0x81, 0x88, 0xEE, 0x21, 0xC4, 0x1A, 0xEB, 0xD9,
+        0xC5, 0x39, 0x99, 0xCD, 0xAD, 0x31, 0x8B, 0x01,
+        0x18, 0x23, 0xDD, 0x1F, 0x4E, 0x2D, 0xF9, 0x48,
+        0x4F, 0xF2, 0x65, 0x8E, 0x78, 0x5C, 0x58, 0x19,
+        0x8D, 0xE5, 0x98, 0x57, 0x67, 0x7F, 0x05, 0x64,
+        0xAF, 0x63, 0xB6, 0xFE, 0xF5, 0xB7, 0x3C, 0xA5,
+        0xCE, 0xE9, 0x68, 0x44, 0xE0, 0x4D, 0x43, 0x69,
+        0x29, 0x2E, 0xAC, 0x15, 0x59, 0xA8, 0x0A, 0x9E,
+        0x6E, 0x47, 0xDF, 0x34, 0x35, 0x6A, 0xCF, 0xDC,
+        0x22, 0xC9, 0xC0, 0x9B, 0x89, 0xD4, 0xED, 0xAB,
+        0x12, 0xA2, 0x0D, 0x52, 0xBB, 0x02, 0x2F, 0xA9,
+        0xD7, 0x61, 0x1E, 0xB4, 0x50, 0x04, 0xF6, 0xC2,
+        0x16, 0x25, 0x86, 0x56, 0x55, 0x09, 0xBE, 0x91
+    );
+
+    /**
+     * M-Table
+     *
+     * @var array
+     * @access private
+     */
+    var $m0 = array(
+        0xBCBC3275, 0xECEC21F3, 0x202043C6, 0xB3B3C9F4, 0xDADA03DB, 0x02028B7B, 0xE2E22BFB, 0x9E9EFAC8,
+        0xC9C9EC4A, 0xD4D409D3, 0x18186BE6, 0x1E1E9F6B, 0x98980E45, 0xB2B2387D, 0xA6A6D2E8, 0x2626B74B,
+        0x3C3C57D6, 0x93938A32, 0x8282EED8, 0x525298FD, 0x7B7BD437, 0xBBBB3771, 0x5B5B97F1, 0x474783E1,
+        0x24243C30, 0x5151E20F, 0xBABAC6F8, 0x4A4AF31B, 0xBFBF4887, 0x0D0D70FA, 0xB0B0B306, 0x7575DE3F,
+        0xD2D2FD5E, 0x7D7D20BA, 0x666631AE, 0x3A3AA35B, 0x59591C8A, 0x00000000, 0xCDCD93BC, 0x1A1AE09D,
+        0xAEAE2C6D, 0x7F7FABC1, 0x2B2BC7B1, 0xBEBEB90E, 0xE0E0A080, 0x8A8A105D, 0x3B3B52D2, 0x6464BAD5,
+        0xD8D888A0, 0xE7E7A584, 0x5F5FE807, 0x1B1B1114, 0x2C2CC2B5, 0xFCFCB490, 0x3131272C, 0x808065A3,
+        0x73732AB2, 0x0C0C8173, 0x79795F4C, 0x6B6B4154, 0x4B4B0292, 0x53536974, 0x94948F36, 0x83831F51,
+        0x2A2A3638, 0xC4C49CB0, 0x2222C8BD, 0xD5D5F85A, 0xBDBDC3FC, 0x48487860, 0xFFFFCE62, 0x4C4C0796,
+        0x4141776C, 0xC7C7E642, 0xEBEB24F7, 0x1C1C1410, 0x5D5D637C, 0x36362228, 0x6767C027, 0xE9E9AF8C,
+        0x4444F913, 0x1414EA95, 0xF5F5BB9C, 0xCFCF18C7, 0x3F3F2D24, 0xC0C0E346, 0x7272DB3B, 0x54546C70,
+        0x29294CCA, 0xF0F035E3, 0x0808FE85, 0xC6C617CB, 0xF3F34F11, 0x8C8CE4D0, 0xA4A45993, 0xCACA96B8,
+        0x68683BA6, 0xB8B84D83, 0x38382820, 0xE5E52EFF, 0xADAD569F, 0x0B0B8477, 0xC8C81DC3, 0x9999FFCC,
+        0x5858ED03, 0x19199A6F, 0x0E0E0A08, 0x95957EBF, 0x70705040, 0xF7F730E7, 0x6E6ECF2B, 0x1F1F6EE2,
+        0xB5B53D79, 0x09090F0C, 0x616134AA, 0x57571682, 0x9F9F0B41, 0x9D9D803A, 0x111164EA, 0x2525CDB9,
+        0xAFAFDDE4, 0x4545089A, 0xDFDF8DA4, 0xA3A35C97, 0xEAEAD57E, 0x353558DA, 0xEDEDD07A, 0x4343FC17,
+        0xF8F8CB66, 0xFBFBB194, 0x3737D3A1, 0xFAFA401D, 0xC2C2683D, 0xB4B4CCF0, 0x32325DDE, 0x9C9C71B3,
+        0x5656E70B, 0xE3E3DA72, 0x878760A7, 0x15151B1C, 0xF9F93AEF, 0x6363BFD1, 0x3434A953, 0x9A9A853E,
+        0xB1B1428F, 0x7C7CD133, 0x88889B26, 0x3D3DA65F, 0xA1A1D7EC, 0xE4E4DF76, 0x8181942A, 0x91910149,
+        0x0F0FFB81, 0xEEEEAA88, 0x161661EE, 0xD7D77321, 0x9797F5C4, 0xA5A5A81A, 0xFEFE3FEB, 0x6D6DB5D9,
+        0x7878AEC5, 0xC5C56D39, 0x1D1DE599, 0x7676A4CD, 0x3E3EDCAD, 0xCBCB6731, 0xB6B6478B, 0xEFEF5B01,
+        0x12121E18, 0x6060C523, 0x6A6AB0DD, 0x4D4DF61F, 0xCECEE94E, 0xDEDE7C2D, 0x55559DF9, 0x7E7E5A48,
+        0x2121B24F, 0x03037AF2, 0xA0A02665, 0x5E5E198E, 0x5A5A6678, 0x65654B5C, 0x62624E58, 0xFDFD4519,
+        0x0606F48D, 0x404086E5, 0xF2F2BE98, 0x3333AC57, 0x17179067, 0x05058E7F, 0xE8E85E05, 0x4F4F7D64,
+        0x89896AAF, 0x10109563, 0x74742FB6, 0x0A0A75FE, 0x5C5C92F5, 0x9B9B74B7, 0x2D2D333C, 0x3030D6A5,
+        0x2E2E49CE, 0x494989E9, 0x46467268, 0x77775544, 0xA8A8D8E0, 0x9696044D, 0x2828BD43, 0xA9A92969,
+        0xD9D97929, 0x8686912E, 0xD1D187AC, 0xF4F44A15, 0x8D8D1559, 0xD6D682A8, 0xB9B9BC0A, 0x42420D9E,
+        0xF6F6C16E, 0x2F2FB847, 0xDDDD06DF, 0x23233934, 0xCCCC6235, 0xF1F1C46A, 0xC1C112CF, 0x8585EBDC,
+        0x8F8F9E22, 0x7171A1C9, 0x9090F0C0, 0xAAAA539B, 0x0101F189, 0x8B8BE1D4, 0x4E4E8CED, 0x8E8E6FAB,
+        0xABABA212, 0x6F6F3EA2, 0xE6E6540D, 0xDBDBF252, 0x92927BBB, 0xB7B7B602, 0x6969CA2F, 0x3939D9A9,
+        0xD3D30CD7, 0xA7A72361, 0xA2A2AD1E, 0xC3C399B4, 0x6C6C4450, 0x07070504, 0x04047FF6, 0x272746C2,
+        0xACACA716, 0xD0D07625, 0x50501386, 0xDCDCF756, 0x84841A55, 0xE1E15109, 0x7A7A25BE, 0x1313EF91
+    );
+
+    /**
+     * M-Table
+     *
+     * @var array
+     * @access private
+     */
+    var $m1 = array(
+        0xA9D93939, 0x67901717, 0xB3719C9C, 0xE8D2A6A6, 0x04050707, 0xFD985252, 0xA3658080, 0x76DFE4E4,
+        0x9A084545, 0x92024B4B, 0x80A0E0E0, 0x78665A5A, 0xE4DDAFAF, 0xDDB06A6A, 0xD1BF6363, 0x38362A2A,
+        0x0D54E6E6, 0xC6432020, 0x3562CCCC, 0x98BEF2F2, 0x181E1212, 0xF724EBEB, 0xECD7A1A1, 0x6C774141,
+        0x43BD2828, 0x7532BCBC, 0x37D47B7B, 0x269B8888, 0xFA700D0D, 0x13F94444, 0x94B1FBFB, 0x485A7E7E,
+        0xF27A0303, 0xD0E48C8C, 0x8B47B6B6, 0x303C2424, 0x84A5E7E7, 0x54416B6B, 0xDF06DDDD, 0x23C56060,
+        0x1945FDFD, 0x5BA33A3A, 0x3D68C2C2, 0x59158D8D, 0xF321ECEC, 0xAE316666, 0xA23E6F6F, 0x82165757,
+        0x63951010, 0x015BEFEF, 0x834DB8B8, 0x2E918686, 0xD9B56D6D, 0x511F8383, 0x9B53AAAA, 0x7C635D5D,
+        0xA63B6868, 0xEB3FFEFE, 0xA5D63030, 0xBE257A7A, 0x16A7ACAC, 0x0C0F0909, 0xE335F0F0, 0x6123A7A7,
+        0xC0F09090, 0x8CAFE9E9, 0x3A809D9D, 0xF5925C5C, 0x73810C0C, 0x2C273131, 0x2576D0D0, 0x0BE75656,
+        0xBB7B9292, 0x4EE9CECE, 0x89F10101, 0x6B9F1E1E, 0x53A93434, 0x6AC4F1F1, 0xB499C3C3, 0xF1975B5B,
+        0xE1834747, 0xE66B1818, 0xBDC82222, 0x450E9898, 0xE26E1F1F, 0xF4C9B3B3, 0xB62F7474, 0x66CBF8F8,
+        0xCCFF9999, 0x95EA1414, 0x03ED5858, 0x56F7DCDC, 0xD4E18B8B, 0x1C1B1515, 0x1EADA2A2, 0xD70CD3D3,
+        0xFB2BE2E2, 0xC31DC8C8, 0x8E195E5E, 0xB5C22C2C, 0xE9894949, 0xCF12C1C1, 0xBF7E9595, 0xBA207D7D,
+        0xEA641111, 0x77840B0B, 0x396DC5C5, 0xAF6A8989, 0x33D17C7C, 0xC9A17171, 0x62CEFFFF, 0x7137BBBB,
+        0x81FB0F0F, 0x793DB5B5, 0x0951E1E1, 0xADDC3E3E, 0x242D3F3F, 0xCDA47676, 0xF99D5555, 0xD8EE8282,
+        0xE5864040, 0xC5AE7878, 0xB9CD2525, 0x4D049696, 0x44557777, 0x080A0E0E, 0x86135050, 0xE730F7F7,
+        0xA1D33737, 0x1D40FAFA, 0xAA346161, 0xED8C4E4E, 0x06B3B0B0, 0x706C5454, 0xB22A7373, 0xD2523B3B,
+        0x410B9F9F, 0x7B8B0202, 0xA088D8D8, 0x114FF3F3, 0x3167CBCB, 0xC2462727, 0x27C06767, 0x90B4FCFC,
+        0x20283838, 0xF67F0404, 0x60784848, 0xFF2EE5E5, 0x96074C4C, 0x5C4B6565, 0xB1C72B2B, 0xAB6F8E8E,
+        0x9E0D4242, 0x9CBBF5F5, 0x52F2DBDB, 0x1BF34A4A, 0x5FA63D3D, 0x9359A4A4, 0x0ABCB9B9, 0xEF3AF9F9,
+        0x91EF1313, 0x85FE0808, 0x49019191, 0xEE611616, 0x2D7CDEDE, 0x4FB22121, 0x8F42B1B1, 0x3BDB7272,
+        0x47B82F2F, 0x8748BFBF, 0x6D2CAEAE, 0x46E3C0C0, 0xD6573C3C, 0x3E859A9A, 0x6929A9A9, 0x647D4F4F,
+        0x2A948181, 0xCE492E2E, 0xCB17C6C6, 0x2FCA6969, 0xFCC3BDBD, 0x975CA3A3, 0x055EE8E8, 0x7AD0EDED,
+        0xAC87D1D1, 0x7F8E0505, 0xD5BA6464, 0x1AA8A5A5, 0x4BB72626, 0x0EB9BEBE, 0xA7608787, 0x5AF8D5D5,
+        0x28223636, 0x14111B1B, 0x3FDE7575, 0x2979D9D9, 0x88AAEEEE, 0x3C332D2D, 0x4C5F7979, 0x02B6B7B7,
+        0xB896CACA, 0xDA583535, 0xB09CC4C4, 0x17FC4343, 0x551A8484, 0x1FF64D4D, 0x8A1C5959, 0x7D38B2B2,
+        0x57AC3333, 0xC718CFCF, 0x8DF40606, 0x74695353, 0xB7749B9B, 0xC4F59797, 0x9F56ADAD, 0x72DAE3E3,
+        0x7ED5EAEA, 0x154AF4F4, 0x229E8F8F, 0x12A2ABAB, 0x584E6262, 0x07E85F5F, 0x99E51D1D, 0x34392323,
+        0x6EC1F6F6, 0x50446C6C, 0xDE5D3232, 0x68724646, 0x6526A0A0, 0xBC93CDCD, 0xDB03DADA, 0xF8C6BABA,
+        0xC8FA9E9E, 0xA882D6D6, 0x2BCF6E6E, 0x40507070, 0xDCEB8585, 0xFE750A0A, 0x328A9393, 0xA48DDFDF,
+        0xCA4C2929, 0x10141C1C, 0x2173D7D7, 0xF0CCB4B4, 0xD309D4D4, 0x5D108A8A, 0x0FE25151, 0x00000000,
+        0x6F9A1919, 0x9DE01A1A, 0x368F9494, 0x42E6C7C7, 0x4AECC9C9, 0x5EFDD2D2, 0xC1AB7F7F, 0xE0D8A8A8
+    );
+
+    /**
+     * M-Table
+     *
+     * @var array
+     * @access private
+     */
+    var $m2 = array(
+        0xBC75BC32, 0xECF3EC21, 0x20C62043, 0xB3F4B3C9, 0xDADBDA03, 0x027B028B, 0xE2FBE22B, 0x9EC89EFA,
+        0xC94AC9EC, 0xD4D3D409, 0x18E6186B, 0x1E6B1E9F, 0x9845980E, 0xB27DB238, 0xA6E8A6D2, 0x264B26B7,
+        0x3CD63C57, 0x9332938A, 0x82D882EE, 0x52FD5298, 0x7B377BD4, 0xBB71BB37, 0x5BF15B97, 0x47E14783,
+        0x2430243C, 0x510F51E2, 0xBAF8BAC6, 0x4A1B4AF3, 0xBF87BF48, 0x0DFA0D70, 0xB006B0B3, 0x753F75DE,
+        0xD25ED2FD, 0x7DBA7D20, 0x66AE6631, 0x3A5B3AA3, 0x598A591C, 0x00000000, 0xCDBCCD93, 0x1A9D1AE0,
+        0xAE6DAE2C, 0x7FC17FAB, 0x2BB12BC7, 0xBE0EBEB9, 0xE080E0A0, 0x8A5D8A10, 0x3BD23B52, 0x64D564BA,
+        0xD8A0D888, 0xE784E7A5, 0x5F075FE8, 0x1B141B11, 0x2CB52CC2, 0xFC90FCB4, 0x312C3127, 0x80A38065,
+        0x73B2732A, 0x0C730C81, 0x794C795F, 0x6B546B41, 0x4B924B02, 0x53745369, 0x9436948F, 0x8351831F,
+        0x2A382A36, 0xC4B0C49C, 0x22BD22C8, 0xD55AD5F8, 0xBDFCBDC3, 0x48604878, 0xFF62FFCE, 0x4C964C07,
+        0x416C4177, 0xC742C7E6, 0xEBF7EB24, 0x1C101C14, 0x5D7C5D63, 0x36283622, 0x672767C0, 0xE98CE9AF,
+        0x441344F9, 0x149514EA, 0xF59CF5BB, 0xCFC7CF18, 0x3F243F2D, 0xC046C0E3, 0x723B72DB, 0x5470546C,
+        0x29CA294C, 0xF0E3F035, 0x088508FE, 0xC6CBC617, 0xF311F34F, 0x8CD08CE4, 0xA493A459, 0xCAB8CA96,
+        0x68A6683B, 0xB883B84D, 0x38203828, 0xE5FFE52E, 0xAD9FAD56, 0x0B770B84, 0xC8C3C81D, 0x99CC99FF,
+        0x580358ED, 0x196F199A, 0x0E080E0A, 0x95BF957E, 0x70407050, 0xF7E7F730, 0x6E2B6ECF, 0x1FE21F6E,
+        0xB579B53D, 0x090C090F, 0x61AA6134, 0x57825716, 0x9F419F0B, 0x9D3A9D80, 0x11EA1164, 0x25B925CD,
+        0xAFE4AFDD, 0x459A4508, 0xDFA4DF8D, 0xA397A35C, 0xEA7EEAD5, 0x35DA3558, 0xED7AEDD0, 0x431743FC,
+        0xF866F8CB, 0xFB94FBB1, 0x37A137D3, 0xFA1DFA40, 0xC23DC268, 0xB4F0B4CC, 0x32DE325D, 0x9CB39C71,
+        0x560B56E7, 0xE372E3DA, 0x87A78760, 0x151C151B, 0xF9EFF93A, 0x63D163BF, 0x345334A9, 0x9A3E9A85,
+        0xB18FB142, 0x7C337CD1, 0x8826889B, 0x3D5F3DA6, 0xA1ECA1D7, 0xE476E4DF, 0x812A8194, 0x91499101,
+        0x0F810FFB, 0xEE88EEAA, 0x16EE1661, 0xD721D773, 0x97C497F5, 0xA51AA5A8, 0xFEEBFE3F, 0x6DD96DB5,
+        0x78C578AE, 0xC539C56D, 0x1D991DE5, 0x76CD76A4, 0x3EAD3EDC, 0xCB31CB67, 0xB68BB647, 0xEF01EF5B,
+        0x1218121E, 0x602360C5, 0x6ADD6AB0, 0x4D1F4DF6, 0xCE4ECEE9, 0xDE2DDE7C, 0x55F9559D, 0x7E487E5A,
+        0x214F21B2, 0x03F2037A, 0xA065A026, 0x5E8E5E19, 0x5A785A66, 0x655C654B, 0x6258624E, 0xFD19FD45,
+        0x068D06F4, 0x40E54086, 0xF298F2BE, 0x335733AC, 0x17671790, 0x057F058E, 0xE805E85E, 0x4F644F7D,
+        0x89AF896A, 0x10631095, 0x74B6742F, 0x0AFE0A75, 0x5CF55C92, 0x9BB79B74, 0x2D3C2D33, 0x30A530D6,
+        0x2ECE2E49, 0x49E94989, 0x46684672, 0x77447755, 0xA8E0A8D8, 0x964D9604, 0x284328BD, 0xA969A929,
+        0xD929D979, 0x862E8691, 0xD1ACD187, 0xF415F44A, 0x8D598D15, 0xD6A8D682, 0xB90AB9BC, 0x429E420D,
+        0xF66EF6C1, 0x2F472FB8, 0xDDDFDD06, 0x23342339, 0xCC35CC62, 0xF16AF1C4, 0xC1CFC112, 0x85DC85EB,
+        0x8F228F9E, 0x71C971A1, 0x90C090F0, 0xAA9BAA53, 0x018901F1, 0x8BD48BE1, 0x4EED4E8C, 0x8EAB8E6F,
+        0xAB12ABA2, 0x6FA26F3E, 0xE60DE654, 0xDB52DBF2, 0x92BB927B, 0xB702B7B6, 0x692F69CA, 0x39A939D9,
+        0xD3D7D30C, 0xA761A723, 0xA21EA2AD, 0xC3B4C399, 0x6C506C44, 0x07040705, 0x04F6047F, 0x27C22746,
+        0xAC16ACA7, 0xD025D076, 0x50865013, 0xDC56DCF7, 0x8455841A, 0xE109E151, 0x7ABE7A25, 0x139113EF
+    );
+
+    /**
+     * M-Table
+     *
+     * @var array
+     * @access private
+     */
+    var $m3 = array(
+        0xD939A9D9, 0x90176790, 0x719CB371, 0xD2A6E8D2, 0x05070405, 0x9852FD98, 0x6580A365, 0xDFE476DF,
+        0x08459A08, 0x024B9202, 0xA0E080A0, 0x665A7866, 0xDDAFE4DD, 0xB06ADDB0, 0xBF63D1BF, 0x362A3836,
+        0x54E60D54, 0x4320C643, 0x62CC3562, 0xBEF298BE, 0x1E12181E, 0x24EBF724, 0xD7A1ECD7, 0x77416C77,
+        0xBD2843BD, 0x32BC7532, 0xD47B37D4, 0x9B88269B, 0x700DFA70, 0xF94413F9, 0xB1FB94B1, 0x5A7E485A,
+        0x7A03F27A, 0xE48CD0E4, 0x47B68B47, 0x3C24303C, 0xA5E784A5, 0x416B5441, 0x06DDDF06, 0xC56023C5,
+        0x45FD1945, 0xA33A5BA3, 0x68C23D68, 0x158D5915, 0x21ECF321, 0x3166AE31, 0x3E6FA23E, 0x16578216,
+        0x95106395, 0x5BEF015B, 0x4DB8834D, 0x91862E91, 0xB56DD9B5, 0x1F83511F, 0x53AA9B53, 0x635D7C63,
+        0x3B68A63B, 0x3FFEEB3F, 0xD630A5D6, 0x257ABE25, 0xA7AC16A7, 0x0F090C0F, 0x35F0E335, 0x23A76123,
+        0xF090C0F0, 0xAFE98CAF, 0x809D3A80, 0x925CF592, 0x810C7381, 0x27312C27, 0x76D02576, 0xE7560BE7,
+        0x7B92BB7B, 0xE9CE4EE9, 0xF10189F1, 0x9F1E6B9F, 0xA93453A9, 0xC4F16AC4, 0x99C3B499, 0x975BF197,
+        0x8347E183, 0x6B18E66B, 0xC822BDC8, 0x0E98450E, 0x6E1FE26E, 0xC9B3F4C9, 0x2F74B62F, 0xCBF866CB,
+        0xFF99CCFF, 0xEA1495EA, 0xED5803ED, 0xF7DC56F7, 0xE18BD4E1, 0x1B151C1B, 0xADA21EAD, 0x0CD3D70C,
+        0x2BE2FB2B, 0x1DC8C31D, 0x195E8E19, 0xC22CB5C2, 0x8949E989, 0x12C1CF12, 0x7E95BF7E, 0x207DBA20,
+        0x6411EA64, 0x840B7784, 0x6DC5396D, 0x6A89AF6A, 0xD17C33D1, 0xA171C9A1, 0xCEFF62CE, 0x37BB7137,
+        0xFB0F81FB, 0x3DB5793D, 0x51E10951, 0xDC3EADDC, 0x2D3F242D, 0xA476CDA4, 0x9D55F99D, 0xEE82D8EE,
+        0x8640E586, 0xAE78C5AE, 0xCD25B9CD, 0x04964D04, 0x55774455, 0x0A0E080A, 0x13508613, 0x30F7E730,
+        0xD337A1D3, 0x40FA1D40, 0x3461AA34, 0x8C4EED8C, 0xB3B006B3, 0x6C54706C, 0x2A73B22A, 0x523BD252,
+        0x0B9F410B, 0x8B027B8B, 0x88D8A088, 0x4FF3114F, 0x67CB3167, 0x4627C246, 0xC06727C0, 0xB4FC90B4,
+        0x28382028, 0x7F04F67F, 0x78486078, 0x2EE5FF2E, 0x074C9607, 0x4B655C4B, 0xC72BB1C7, 0x6F8EAB6F,
+        0x0D429E0D, 0xBBF59CBB, 0xF2DB52F2, 0xF34A1BF3, 0xA63D5FA6, 0x59A49359, 0xBCB90ABC, 0x3AF9EF3A,
+        0xEF1391EF, 0xFE0885FE, 0x01914901, 0x6116EE61, 0x7CDE2D7C, 0xB2214FB2, 0x42B18F42, 0xDB723BDB,
+        0xB82F47B8, 0x48BF8748, 0x2CAE6D2C, 0xE3C046E3, 0x573CD657, 0x859A3E85, 0x29A96929, 0x7D4F647D,
+        0x94812A94, 0x492ECE49, 0x17C6CB17, 0xCA692FCA, 0xC3BDFCC3, 0x5CA3975C, 0x5EE8055E, 0xD0ED7AD0,
+        0x87D1AC87, 0x8E057F8E, 0xBA64D5BA, 0xA8A51AA8, 0xB7264BB7, 0xB9BE0EB9, 0x6087A760, 0xF8D55AF8,
+        0x22362822, 0x111B1411, 0xDE753FDE, 0x79D92979, 0xAAEE88AA, 0x332D3C33, 0x5F794C5F, 0xB6B702B6,
+        0x96CAB896, 0x5835DA58, 0x9CC4B09C, 0xFC4317FC, 0x1A84551A, 0xF64D1FF6, 0x1C598A1C, 0x38B27D38,
+        0xAC3357AC, 0x18CFC718, 0xF4068DF4, 0x69537469, 0x749BB774, 0xF597C4F5, 0x56AD9F56, 0xDAE372DA,
+        0xD5EA7ED5, 0x4AF4154A, 0x9E8F229E, 0xA2AB12A2, 0x4E62584E, 0xE85F07E8, 0xE51D99E5, 0x39233439,
+        0xC1F66EC1, 0x446C5044, 0x5D32DE5D, 0x72466872, 0x26A06526, 0x93CDBC93, 0x03DADB03, 0xC6BAF8C6,
+        0xFA9EC8FA, 0x82D6A882, 0xCF6E2BCF, 0x50704050, 0xEB85DCEB, 0x750AFE75, 0x8A93328A, 0x8DDFA48D,
+        0x4C29CA4C, 0x141C1014, 0x73D72173, 0xCCB4F0CC, 0x09D4D309, 0x108A5D10, 0xE2510FE2, 0x00000000,
+        0x9A196F9A, 0xE01A9DE0, 0x8F94368F, 0xE6C742E6, 0xECC94AEC, 0xFDD25EFD, 0xAB7FC1AB, 0xD8A8E0D8
+    );
+
+    /**
+     * The Key Schedule Array
+     *
+     * @var array
+     * @access private
+     */
+    var $K = array();
+
+    /**
+     * The Key depended S-Table 0
+     *
+     * @var array
+     * @access private
+     */
+    var $S0 = array();
+
+    /**
+     * The Key depended S-Table 1
+     *
+     * @var array
+     * @access private
+     */
+    var $S1 = array();
+
+    /**
+     * The Key depended S-Table 2
+     *
+     * @var array
+     * @access private
+     */
+    var $S2 = array();
+
+    /**
+     * The Key depended S-Table 3
+     *
+     * @var array
+     * @access private
+     */
+    var $S3 = array();
+
+    /**
+     * Holds the last used key
+     *
+     * @var array
+     * @access private
+     */
+    var $kl;
+
+    /**
+     * The Key Length (in bytes)
+     *
+     * @see Crypt_Twofish::setKeyLength()
+     * @var int
+     * @access private
+     */
+    var $key_length = 16;
+
+    /**
+     * Sets the key length.
+     *
+     * Valid key lengths are 128, 192 or 256 bits
+     *
+     * @access public
+     * @param int $length
+     */
+    function setKeyLength($length)
+    {
+        switch (true) {
+            case $length <= 128:
+                $this->key_length = 16;
+                break;
+            case $length <= 192:
+                $this->key_length = 24;
+                break;
+            default:
+                $this->key_length = 32;
+        }
+
+        parent::setKeyLength($length);
+    }
+
+    /**
+     * Setup the key (expansion)
+     *
+     * @see \phpseclib\Crypt\Base::_setupKey()
+     * @access private
+     */
+    function _setupKey()
+    {
+        if (isset($this->kl['key']) && $this->key === $this->kl['key']) {
+            // already expanded
+            return;
+        }
+        $this->kl = array('key' => $this->key);
+
+        /* Key expanding and generating the key-depended s-boxes */
+        $le_longs = unpack('V*', $this->key);
+        $key = unpack('C*', $this->key);
+        $m0 = $this->m0;
+        $m1 = $this->m1;
+        $m2 = $this->m2;
+        $m3 = $this->m3;
+        $q0 = $this->q0;
+        $q1 = $this->q1;
+
+        $K = $S0 = $S1 = $S2 = $S3 = array();
+
+        switch (strlen($this->key)) {
+            case 16:
+                list($s7, $s6, $s5, $s4) = $this->_mdsrem($le_longs[1], $le_longs[2]);
+                list($s3, $s2, $s1, $s0) = $this->_mdsrem($le_longs[3], $le_longs[4]);
+                for ($i = 0, $j = 1; $i < 40; $i+= 2, $j+= 2) {
+                    $A = $m0[$q0[$q0[$i] ^ $key[ 9]] ^ $key[1]] ^
+                         $m1[$q0[$q1[$i] ^ $key[10]] ^ $key[2]] ^
+                         $m2[$q1[$q0[$i] ^ $key[11]] ^ $key[3]] ^
+                         $m3[$q1[$q1[$i] ^ $key[12]] ^ $key[4]];
+                    $B = $m0[$q0[$q0[$j] ^ $key[13]] ^ $key[5]] ^
+                         $m1[$q0[$q1[$j] ^ $key[14]] ^ $key[6]] ^
+                         $m2[$q1[$q0[$j] ^ $key[15]] ^ $key[7]] ^
+                         $m3[$q1[$q1[$j] ^ $key[16]] ^ $key[8]];
+                    $B = ($B << 8) | ($B >> 24 & 0xff);
+                    $A = $this->safe_intval($A + $B);
+                    $K[] = $A;
+                    $A = $this->safe_intval($A + $B);
+                    $K[] = ($A << 9 | $A >> 23 & 0x1ff);
+                }
+                for ($i = 0; $i < 256; ++$i) {
+                    $S0[$i] = $m0[$q0[$q0[$i] ^ $s4] ^ $s0];
+                    $S1[$i] = $m1[$q0[$q1[$i] ^ $s5] ^ $s1];
+                    $S2[$i] = $m2[$q1[$q0[$i] ^ $s6] ^ $s2];
+                    $S3[$i] = $m3[$q1[$q1[$i] ^ $s7] ^ $s3];
+                }
+                break;
+            case 24:
+                list($sb, $sa, $s9, $s8) = $this->_mdsrem($le_longs[1], $le_longs[2]);
+                list($s7, $s6, $s5, $s4) = $this->_mdsrem($le_longs[3], $le_longs[4]);
+                list($s3, $s2, $s1, $s0) = $this->_mdsrem($le_longs[5], $le_longs[6]);
+                for ($i = 0, $j = 1; $i < 40; $i+= 2, $j+= 2) {
+                    $A = $m0[$q0[$q0[$q1[$i] ^ $key[17]] ^ $key[ 9]] ^ $key[1]] ^
+                         $m1[$q0[$q1[$q1[$i] ^ $key[18]] ^ $key[10]] ^ $key[2]] ^
+                         $m2[$q1[$q0[$q0[$i] ^ $key[19]] ^ $key[11]] ^ $key[3]] ^
+                         $m3[$q1[$q1[$q0[$i] ^ $key[20]] ^ $key[12]] ^ $key[4]];
+                    $B = $m0[$q0[$q0[$q1[$j] ^ $key[21]] ^ $key[13]] ^ $key[5]] ^
+                         $m1[$q0[$q1[$q1[$j] ^ $key[22]] ^ $key[14]] ^ $key[6]] ^
+                         $m2[$q1[$q0[$q0[$j] ^ $key[23]] ^ $key[15]] ^ $key[7]] ^
+                         $m3[$q1[$q1[$q0[$j] ^ $key[24]] ^ $key[16]] ^ $key[8]];
+                    $B = ($B << 8) | ($B >> 24 & 0xff);
+                    $A = $this->safe_intval($A + $B);
+                    $K[] = $A;
+                    $A = $this->safe_intval($A + $B);
+                    $K[] = ($A << 9 | $A >> 23 & 0x1ff);
+                }
+                for ($i = 0; $i < 256; ++$i) {
+                    $S0[$i] = $m0[$q0[$q0[$q1[$i] ^ $s8] ^ $s4] ^ $s0];
+                    $S1[$i] = $m1[$q0[$q1[$q1[$i] ^ $s9] ^ $s5] ^ $s1];
+                    $S2[$i] = $m2[$q1[$q0[$q0[$i] ^ $sa] ^ $s6] ^ $s2];
+                    $S3[$i] = $m3[$q1[$q1[$q0[$i] ^ $sb] ^ $s7] ^ $s3];
+                }
+                break;
+            default: // 32
+                list($sf, $se, $sd, $sc) = $this->_mdsrem($le_longs[1], $le_longs[2]);
+                list($sb, $sa, $s9, $s8) = $this->_mdsrem($le_longs[3], $le_longs[4]);
+                list($s7, $s6, $s5, $s4) = $this->_mdsrem($le_longs[5], $le_longs[6]);
+                list($s3, $s2, $s1, $s0) = $this->_mdsrem($le_longs[7], $le_longs[8]);
+                for ($i = 0, $j = 1; $i < 40; $i+= 2, $j+= 2) {
+                    $A = $m0[$q0[$q0[$q1[$q1[$i] ^ $key[25]] ^ $key[17]] ^ $key[ 9]] ^ $key[1]] ^
+                         $m1[$q0[$q1[$q1[$q0[$i] ^ $key[26]] ^ $key[18]] ^ $key[10]] ^ $key[2]] ^
+                         $m2[$q1[$q0[$q0[$q0[$i] ^ $key[27]] ^ $key[19]] ^ $key[11]] ^ $key[3]] ^
+                         $m3[$q1[$q1[$q0[$q1[$i] ^ $key[28]] ^ $key[20]] ^ $key[12]] ^ $key[4]];
+                    $B = $m0[$q0[$q0[$q1[$q1[$j] ^ $key[29]] ^ $key[21]] ^ $key[13]] ^ $key[5]] ^
+                         $m1[$q0[$q1[$q1[$q0[$j] ^ $key[30]] ^ $key[22]] ^ $key[14]] ^ $key[6]] ^
+                         $m2[$q1[$q0[$q0[$q0[$j] ^ $key[31]] ^ $key[23]] ^ $key[15]] ^ $key[7]] ^
+                         $m3[$q1[$q1[$q0[$q1[$j] ^ $key[32]] ^ $key[24]] ^ $key[16]] ^ $key[8]];
+                    $B = ($B << 8) | ($B >> 24 & 0xff);
+                    $A = $this->safe_intval($A + $B);
+                    $K[] = $A;
+                    $A = $this->safe_intval($A + $B);
+                    $K[] = ($A << 9 | $A >> 23 & 0x1ff);
+                }
+                for ($i = 0; $i < 256; ++$i) {
+                    $S0[$i] = $m0[$q0[$q0[$q1[$q1[$i] ^ $sc] ^ $s8] ^ $s4] ^ $s0];
+                    $S1[$i] = $m1[$q0[$q1[$q1[$q0[$i] ^ $sd] ^ $s9] ^ $s5] ^ $s1];
+                    $S2[$i] = $m2[$q1[$q0[$q0[$q0[$i] ^ $se] ^ $sa] ^ $s6] ^ $s2];
+                    $S3[$i] = $m3[$q1[$q1[$q0[$q1[$i] ^ $sf] ^ $sb] ^ $s7] ^ $s3];
+                }
+        }
+
+        $this->K  = $K;
+        $this->S0 = $S0;
+        $this->S1 = $S1;
+        $this->S2 = $S2;
+        $this->S3 = $S3;
+    }
+
+    /**
+     * _mdsrem function using by the twofish cipher algorithm
+     *
+     * @access private
+     * @param string $A
+     * @param string $B
+     * @return array
+     */
+    function _mdsrem($A, $B)
+    {
+        // No gain by unrolling this loop.
+        for ($i = 0; $i < 8; ++$i) {
+            // Get most significant coefficient.
+            $t = 0xff & ($B >> 24);
+
+            // Shift the others up.
+            $B = ($B << 8) | (0xff & ($A >> 24));
+            $A<<= 8;
+
+            $u = $t << 1;
+
+            // Subtract the modular polynomial on overflow.
+            if ($t & 0x80) {
+                $u^= 0x14d;
+            }
+
+            // Remove t * (a * x^2 + 1).
+            $B ^= $t ^ ($u << 16);
+
+            // Form u = a*t + t/a = t*(a + 1/a).
+            $u^= 0x7fffffff & ($t >> 1);
+
+            // Add the modular polynomial on underflow.
+            if ($t & 0x01) {
+                $u^= 0xa6 ;
+            }
+
+            // Remove t * (a + 1/a) * (x^3 + x).
+            $B^= ($u << 24) | ($u << 8);
+        }
+
+        return array(
+            0xff & $B >> 24,
+            0xff & $B >> 16,
+            0xff & $B >>  8,
+            0xff & $B);
+    }
+
+    /**
+     * Encrypts a block
+     *
+     * @access private
+     * @param string $in
+     * @return string
+     */
+    function _encryptBlock($in)
+    {
+        $S0 = $this->S0;
+        $S1 = $this->S1;
+        $S2 = $this->S2;
+        $S3 = $this->S3;
+        $K  = $this->K;
+
+        $in = unpack("V4", $in);
+        $R0 = $K[0] ^ $in[1];
+        $R1 = $K[1] ^ $in[2];
+        $R2 = $K[2] ^ $in[3];
+        $R3 = $K[3] ^ $in[4];
+
+        $ki = 7;
+        while ($ki < 39) {
+            $t0 = $S0[ $R0        & 0xff] ^
+                  $S1[($R0 >>  8) & 0xff] ^
+                  $S2[($R0 >> 16) & 0xff] ^
+                  $S3[($R0 >> 24) & 0xff];
+            $t1 = $S0[($R1 >> 24) & 0xff] ^
+                  $S1[ $R1        & 0xff] ^
+                  $S2[($R1 >>  8) & 0xff] ^
+                  $S3[($R1 >> 16) & 0xff];
+            $R2^= $this->safe_intval($t0 + $t1 + $K[++$ki]);
+            $R2 = ($R2 >> 1 & 0x7fffffff) | ($R2 << 31);
+            $R3 = ((($R3 >> 31) & 1) | ($R3 << 1)) ^ $this->safe_intval($t0 + ($t1 << 1) + $K[++$ki]);
+
+            $t0 = $S0[ $R2        & 0xff] ^
+                  $S1[($R2 >>  8) & 0xff] ^
+                  $S2[($R2 >> 16) & 0xff] ^
+                  $S3[($R2 >> 24) & 0xff];
+            $t1 = $S0[($R3 >> 24) & 0xff] ^
+                  $S1[ $R3        & 0xff] ^
+                  $S2[($R3 >>  8) & 0xff] ^
+                  $S3[($R3 >> 16) & 0xff];
+            $R0^= $this->safe_intval($t0 + $t1 + $K[++$ki]);
+            $R0 = ($R0 >> 1 & 0x7fffffff) | ($R0 << 31);
+            $R1 = ((($R1 >> 31) & 1) | ($R1 << 1)) ^ $this->safe_intval($t0 + ($t1 << 1) + $K[++$ki]);
+        }
+
+        // @codingStandardsIgnoreStart
+        return pack("V4", $K[4] ^ $R2,
+                          $K[5] ^ $R3,
+                          $K[6] ^ $R0,
+                          $K[7] ^ $R1);
+        // @codingStandardsIgnoreEnd
+    }
+
+    /**
+     * Decrypts a block
+     *
+     * @access private
+     * @param string $in
+     * @return string
+     */
+    function _decryptBlock($in)
+    {
+        $S0 = $this->S0;
+        $S1 = $this->S1;
+        $S2 = $this->S2;
+        $S3 = $this->S3;
+        $K  = $this->K;
+
+        $in = unpack("V4", $in);
+        $R0 = $K[4] ^ $in[1];
+        $R1 = $K[5] ^ $in[2];
+        $R2 = $K[6] ^ $in[3];
+        $R3 = $K[7] ^ $in[4];
+
+        $ki = 40;
+        while ($ki > 8) {
+            $t0 = $S0[$R0       & 0xff] ^
+                  $S1[$R0 >>  8 & 0xff] ^
+                  $S2[$R0 >> 16 & 0xff] ^
+                  $S3[$R0 >> 24 & 0xff];
+            $t1 = $S0[$R1 >> 24 & 0xff] ^
+                  $S1[$R1       & 0xff] ^
+                  $S2[$R1 >>  8 & 0xff] ^
+                  $S3[$R1 >> 16 & 0xff];
+            $R3^= $this->safe_intval($t0 + ($t1 << 1) + $K[--$ki]);
+            $R3 = $R3 >> 1 & 0x7fffffff | $R3 << 31;
+            $R2 = ($R2 >> 31 & 0x1 | $R2 << 1) ^ $this->safe_intval($t0 + $t1 + $K[--$ki]);
+
+            $t0 = $S0[$R2       & 0xff] ^
+                  $S1[$R2 >>  8 & 0xff] ^
+                  $S2[$R2 >> 16 & 0xff] ^
+                  $S3[$R2 >> 24 & 0xff];
+            $t1 = $S0[$R3 >> 24 & 0xff] ^
+                  $S1[$R3       & 0xff] ^
+                  $S2[$R3 >>  8 & 0xff] ^
+                  $S3[$R3 >> 16 & 0xff];
+            $R1^= $this->safe_intval($t0 + ($t1 << 1) + $K[--$ki]);
+            $R1 = $R1 >> 1 & 0x7fffffff | $R1 << 31;
+            $R0 = ($R0 >> 31 & 0x1 | $R0 << 1) ^ $this->safe_intval($t0 + $t1 + $K[--$ki]);
+        }
+
+        // @codingStandardsIgnoreStart
+        return pack("V4", $K[0] ^ $R2,
+                          $K[1] ^ $R3,
+                          $K[2] ^ $R0,
+                          $K[3] ^ $R1);
+        // @codingStandardsIgnoreEnd
+    }
+
+    /**
+     * Setup the performance-optimized function for de/encrypt()
+     *
+     * @see \phpseclib\Crypt\Base::_setupInlineCrypt()
+     * @access private
+     */
+    function _setupInlineCrypt()
+    {
+        $lambda_functions =& self::_getLambdaFunctions();
+
+        // Max. 10 Ultra-Hi-optimized inline-crypt functions. After that, we'll (still) create very fast code, but not the ultimate fast one.
+        // (Currently, for Crypt_Twofish, one generated $lambda_function cost on php5.5@32bit ~140kb unfreeable mem and ~240kb on php5.5@64bit)
+        $gen_hi_opt_code = (bool)(count($lambda_functions) < 10);
+
+        // Generation of a unique hash for our generated code
+        $code_hash = "Crypt_Twofish, {$this->mode}";
+        if ($gen_hi_opt_code) {
+            $code_hash = str_pad($code_hash, 32) . $this->_hashInlineCryptFunction($this->key);
+        }
+
+        $safeint = $this->safe_intval_inline();
+
+        if (!isset($lambda_functions[$code_hash])) {
+            switch (true) {
+                case $gen_hi_opt_code:
+                    $K = $this->K;
+                    $init_crypt = '
+                        static $S0, $S1, $S2, $S3;
+                        if (!$S0) {
+                            for ($i = 0; $i < 256; ++$i) {
+                                $S0[] = (int)$self->S0[$i];
+                                $S1[] = (int)$self->S1[$i];
+                                $S2[] = (int)$self->S2[$i];
+                                $S3[] = (int)$self->S3[$i];
+                            }
+                        }
+                    ';
+                    break;
+                default:
+                    $K   = array();
+                    for ($i = 0; $i < 40; ++$i) {
+                        $K[] = '$K_' . $i;
+                    }
+                    $init_crypt = '
+                        $S0 = $self->S0;
+                        $S1 = $self->S1;
+                        $S2 = $self->S2;
+                        $S3 = $self->S3;
+                        list(' . implode(',', $K) . ') = $self->K;
+                    ';
+            }
+
+            // Generating encrypt code:
+            $encrypt_block = '
+                $in = unpack("V4", $in);
+                $R0 = '.$K[0].' ^ $in[1];
+                $R1 = '.$K[1].' ^ $in[2];
+                $R2 = '.$K[2].' ^ $in[3];
+                $R3 = '.$K[3].' ^ $in[4];
+            ';
+            for ($ki = 7, $i = 0; $i < 8; ++$i) {
+                $encrypt_block.= '
+                    $t0 = $S0[ $R0        & 0xff] ^
+                          $S1[($R0 >>  8) & 0xff] ^
+                          $S2[($R0 >> 16) & 0xff] ^
+                          $S3[($R0 >> 24) & 0xff];
+                    $t1 = $S0[($R1 >> 24) & 0xff] ^
+                          $S1[ $R1        & 0xff] ^
+                          $S2[($R1 >>  8) & 0xff] ^
+                          $S3[($R1 >> 16) & 0xff];
+                    $R2^= ' . sprintf($safeint, '$t0 + $t1 + ' . $K[++$ki]) . ';
+                    $R2 = ($R2 >> 1 & 0x7fffffff) | ($R2 << 31);
+                    $R3 = ((($R3 >> 31) & 1) | ($R3 << 1)) ^ ' . sprintf($safeint, '($t0 + ($t1 << 1) + ' . $K[++$ki] . ')') . ';
+
+                    $t0 = $S0[ $R2        & 0xff] ^
+                          $S1[($R2 >>  8) & 0xff] ^
+                          $S2[($R2 >> 16) & 0xff] ^
+                          $S3[($R2 >> 24) & 0xff];
+                    $t1 = $S0[($R3 >> 24) & 0xff] ^
+                          $S1[ $R3        & 0xff] ^
+                          $S2[($R3 >>  8) & 0xff] ^
+                          $S3[($R3 >> 16) & 0xff];
+                    $R0^= ' . sprintf($safeint, '($t0 + $t1 + ' . $K[++$ki] . ')') . ';
+                    $R0 = ($R0 >> 1 & 0x7fffffff) | ($R0 << 31);
+                    $R1 = ((($R1 >> 31) & 1) | ($R1 << 1)) ^ ' . sprintf($safeint, '($t0 + ($t1 << 1) + ' . $K[++$ki] . ')') . ';
+                ';
+            }
+            $encrypt_block.= '
+                $in = pack("V4", ' . $K[4] . ' ^ $R2,
+                                 ' . $K[5] . ' ^ $R3,
+                                 ' . $K[6] . ' ^ $R0,
+                                 ' . $K[7] . ' ^ $R1);
+            ';
+
+            // Generating decrypt code:
+            $decrypt_block = '
+                $in = unpack("V4", $in);
+                $R0 = '.$K[4].' ^ $in[1];
+                $R1 = '.$K[5].' ^ $in[2];
+                $R2 = '.$K[6].' ^ $in[3];
+                $R3 = '.$K[7].' ^ $in[4];
+            ';
+            for ($ki = 40, $i = 0; $i < 8; ++$i) {
+                $decrypt_block.= '
+                    $t0 = $S0[$R0       & 0xff] ^
+                          $S1[$R0 >>  8 & 0xff] ^
+                          $S2[$R0 >> 16 & 0xff] ^
+                          $S3[$R0 >> 24 & 0xff];
+                    $t1 = $S0[$R1 >> 24 & 0xff] ^
+                          $S1[$R1       & 0xff] ^
+                          $S2[$R1 >>  8 & 0xff] ^
+                          $S3[$R1 >> 16 & 0xff];
+                    $R3^= ' . sprintf($safeint, '$t0 + ($t1 << 1) + ' . $K[--$ki]) . ';
+                    $R3 = $R3 >> 1 & 0x7fffffff | $R3 << 31;
+                    $R2 = ($R2 >> 31 & 0x1 | $R2 << 1) ^ ' . sprintf($safeint, '($t0 + $t1 + '.$K[--$ki] . ')') . ';
+
+                    $t0 = $S0[$R2       & 0xff] ^
+                          $S1[$R2 >>  8 & 0xff] ^
+                          $S2[$R2 >> 16 & 0xff] ^
+                          $S3[$R2 >> 24 & 0xff];
+                    $t1 = $S0[$R3 >> 24 & 0xff] ^
+                          $S1[$R3       & 0xff] ^
+                          $S2[$R3 >>  8 & 0xff] ^
+                          $S3[$R3 >> 16 & 0xff];
+                    $R1^= ' . sprintf($safeint, '$t0 + ($t1 << 1) + ' . $K[--$ki]) . ';
+                    $R1 = $R1 >> 1 & 0x7fffffff | $R1 << 31;
+                    $R0 = ($R0 >> 31 & 0x1 | $R0 << 1) ^ ' . sprintf($safeint, '($t0 + $t1 + '.$K[--$ki] . ')') . ';
+                ';
+            }
+            $decrypt_block.= '
+                $in = pack("V4", ' . $K[0] . ' ^ $R2,
+                                 ' . $K[1] . ' ^ $R3,
+                                 ' . $K[2] . ' ^ $R0,
+                                 ' . $K[3] . ' ^ $R1);
+            ';
+
+            $lambda_functions[$code_hash] = $this->_createInlineCryptFunction(
+                array(
+                   'init_crypt'    => $init_crypt,
+                   'init_encrypt'  => '',
+                   'init_decrypt'  => '',
+                   'encrypt_block' => $encrypt_block,
+                   'decrypt_block' => $decrypt_block
+                )
+            );
+        }
+        $this->inline_crypt = $lambda_functions[$code_hash];
+    }
+}
diff --git a/lib/phpseclib/File/ANSI.php b/lib/phpseclib/File/ANSI.php
new file mode 100644
index 0000000..5ff1f2e
--- /dev/null
+++ b/lib/phpseclib/File/ANSI.php
@@ -0,0 +1,577 @@
+<?php
+
+/**
+ * Pure-PHP ANSI Decoder
+ *
+ * PHP version 5
+ *
+ * If you call read() in \phpseclib\Net\SSH2 you may get {@link http://en.wikipedia.org/wiki/ANSI_escape_code ANSI escape codes} back.
+ * They'd look like chr(0x1B) . '[00m' or whatever (0x1B = ESC).  They tell a
+ * {@link http://en.wikipedia.org/wiki/Terminal_emulator terminal emulator} how to format the characters, what
+ * color to display them in, etc. \phpseclib\File\ANSI is a {@link http://en.wikipedia.org/wiki/VT100 VT100} terminal emulator.
+ *
+ * @category  File
+ * @package   ANSI
+ * @author    Jim Wigginton <terrafrost@php.net>
+ * @copyright 2012 Jim Wigginton
+ * @license   http://www.opensource.org/licenses/mit-license.html  MIT License
+ * @link      http://phpseclib.sourceforge.net
+ */
+
+namespace phpseclib\File;
+
+/**
+ * Pure-PHP ANSI Decoder
+ *
+ * @package ANSI
+ * @author  Jim Wigginton <terrafrost@php.net>
+ * @access  public
+ */
+class ANSI
+{
+    /**
+     * Max Width
+     *
+     * @var int
+     * @access private
+     */
+    var $max_x;
+
+    /**
+     * Max Height
+     *
+     * @var int
+     * @access private
+     */
+    var $max_y;
+
+    /**
+     * Max History
+     *
+     * @var int
+     * @access private
+     */
+    var $max_history;
+
+    /**
+     * History
+     *
+     * @var array
+     * @access private
+     */
+    var $history;
+
+    /**
+     * History Attributes
+     *
+     * @var array
+     * @access private
+     */
+    var $history_attrs;
+
+    /**
+     * Current Column
+     *
+     * @var int
+     * @access private
+     */
+    var $x;
+
+    /**
+     * Current Row
+     *
+     * @var int
+     * @access private
+     */
+    var $y;
+
+    /**
+     * Old Column
+     *
+     * @var int
+     * @access private
+     */
+    var $old_x;
+
+    /**
+     * Old Row
+     *
+     * @var int
+     * @access private
+     */
+    var $old_y;
+
+    /**
+     * An empty attribute cell
+     *
+     * @var object
+     * @access private
+     */
+    var $base_attr_cell;
+
+    /**
+     * The current attribute cell
+     *
+     * @var object
+     * @access private
+     */
+    var $attr_cell;
+
+    /**
+     * An empty attribute row
+     *
+     * @var array
+     * @access private
+     */
+    var $attr_row;
+
+    /**
+     * The current screen text
+     *
+     * @var array
+     * @access private
+     */
+    var $screen;
+
+    /**
+     * The current screen attributes
+     *
+     * @var array
+     * @access private
+     */
+    var $attrs;
+
+    /**
+     * Current ANSI code
+     *
+     * @var string
+     * @access private
+     */
+    var $ansi;
+
+    /**
+     * Tokenization
+     *
+     * @var array
+     * @access private
+     */
+    var $tokenization;
+
+    /**
+     * Default Constructor.
+     *
+     * @return \phpseclib\File\ANSI
+     * @access public
+     */
+    function __construct()
+    {
+        $attr_cell = new \stdClass();
+        $attr_cell->bold = false;
+        $attr_cell->underline = false;
+        $attr_cell->blink = false;
+        $attr_cell->background = 'black';
+        $attr_cell->foreground = 'white';
+        $attr_cell->reverse = false;
+        $this->base_attr_cell = clone $attr_cell;
+        $this->attr_cell = clone $attr_cell;
+
+        $this->setHistory(200);
+        $this->setDimensions(80, 24);
+    }
+
+    /**
+     * Set terminal width and height
+     *
+     * Resets the screen as well
+     *
+     * @param int $x
+     * @param int $y
+     * @access public
+     */
+    function setDimensions($x, $y)
+    {
+        $this->max_x = $x - 1;
+        $this->max_y = $y - 1;
+        $this->x = $this->y = 0;
+        $this->history = $this->history_attrs = array();
+        $this->attr_row = array_fill(0, $this->max_x + 2, $this->base_attr_cell);
+        $this->screen = array_fill(0, $this->max_y + 1, '');
+        $this->attrs = array_fill(0, $this->max_y + 1, $this->attr_row);
+        $this->ansi = '';
+    }
+
+    /**
+     * Set the number of lines that should be logged past the terminal height
+     *
+     * @param int $x
+     * @param int $y
+     * @access public
+     */
+    function setHistory($history)
+    {
+        $this->max_history = $history;
+    }
+
+    /**
+     * Load a string
+     *
+     * @param string $source
+     * @access public
+     */
+    function loadString($source)
+    {
+        $this->setDimensions($this->max_x + 1, $this->max_y + 1);
+        $this->appendString($source);
+    }
+
+    /**
+     * Appdend a string
+     *
+     * @param string $source
+     * @access public
+     */
+    function appendString($source)
+    {
+        $this->tokenization = array('');
+        for ($i = 0; $i < strlen($source); $i++) {
+            if (strlen($this->ansi)) {
+                $this->ansi.= $source[$i];
+                $chr = ord($source[$i]);
+                // http://en.wikipedia.org/wiki/ANSI_escape_code#Sequence_elements
+                // single character CSI's not currently supported
+                switch (true) {
+                    case $this->ansi == "\x1B=":
+                        $this->ansi = '';
+                        continue 2;
+                    case strlen($this->ansi) == 2 && $chr >= 64 && $chr <= 95 && $chr != ord('['):
+                    case strlen($this->ansi) > 2 && $chr >= 64 && $chr <= 126:
+                        break;
+                    default:
+                        continue 2;
+                }
+                $this->tokenization[] = $this->ansi;
+                $this->tokenization[] = '';
+                // http://ascii-table.com/ansi-escape-sequences-vt-100.php
+                switch ($this->ansi) {
+                    case "\x1B[H": // Move cursor to upper left corner
+                        $this->old_x = $this->x;
+                        $this->old_y = $this->y;
+                        $this->x = $this->y = 0;
+                        break;
+                    case "\x1B[J": // Clear screen from cursor down
+                        $this->history = array_merge($this->history, array_slice(array_splice($this->screen, $this->y + 1), 0, $this->old_y));
+                        $this->screen = array_merge($this->screen, array_fill($this->y, $this->max_y, ''));
+
+                        $this->history_attrs = array_merge($this->history_attrs, array_slice(array_splice($this->attrs, $this->y + 1), 0, $this->old_y));
+                        $this->attrs = array_merge($this->attrs, array_fill($this->y, $this->max_y, $this->attr_row));
+
+                        if (count($this->history) == $this->max_history) {
+                            array_shift($this->history);
+                            array_shift($this->history_attrs);
+                        }
+                    case "\x1B[K": // Clear screen from cursor right
+                        $this->screen[$this->y] = substr($this->screen[$this->y], 0, $this->x);
+
+                        array_splice($this->attrs[$this->y], $this->x + 1, $this->max_x - $this->x, array_fill($this->x, $this->max_x - $this->x - 1, $this->base_attr_cell));
+                        break;
+                    case "\x1B[2K": // Clear entire line
+                        $this->screen[$this->y] = str_repeat(' ', $this->x);
+                        $this->attrs[$this->y] = $this->attr_row;
+                        break;
+                    case "\x1B[?1h": // set cursor key to application
+                    case "\x1B[?25h": // show the cursor
+                    case "\x1B(B": // set united states g0 character set
+                        break;
+                    case "\x1BE": // Move to next line
+                        $this->_newLine();
+                        $this->x = 0;
+                        break;
+                    default:
+                        switch (true) {
+                            case preg_match('#\x1B\[(\d+)B#', $this->ansi, $match): // Move cursor down n lines
+                                $this->old_y = $this->y;
+                                $this->y+= $match[1];
+                                break;
+                            case preg_match('#\x1B\[(\d+);(\d+)H#', $this->ansi, $match): // Move cursor to screen location v,h
+                                $this->old_x = $this->x;
+                                $this->old_y = $this->y;
+                                $this->x = $match[2] - 1;
+                                $this->y = $match[1] - 1;
+                                break;
+                            case preg_match('#\x1B\[(\d+)C#', $this->ansi, $match): // Move cursor right n lines
+                                $this->old_x = $this->x;
+                                $this->x+= $match[1];
+                                break;
+                            case preg_match('#\x1B\[(\d+)D#', $this->ansi, $match): // Move cursor left n lines
+                                $this->old_x = $this->x;
+                                $this->x-= $match[1];
+                                if ($this->x < 0) {
+                                    $this->x = 0;
+                                }
+                                break;
+                            case preg_match('#\x1B\[(\d+);(\d+)r#', $this->ansi, $match): // Set top and bottom lines of a window
+                                break;
+                            case preg_match('#\x1B\[(\d*(?:;\d*)*)m#', $this->ansi, $match): // character attributes
+                                $attr_cell = &$this->attr_cell;
+                                $mods = explode(';', $match[1]);
+                                foreach ($mods as $mod) {
+                                    switch ($mod) {
+                                        case 0: // Turn off character attributes
+                                            $attr_cell = clone $this->base_attr_cell;
+                                            break;
+                                        case 1: // Turn bold mode on
+                                            $attr_cell->bold = true;
+                                            break;
+                                        case 4: // Turn underline mode on
+                                            $attr_cell->underline = true;
+                                            break;
+                                        case 5: // Turn blinking mode on
+                                            $attr_cell->blink = true;
+                                            break;
+                                        case 7: // Turn reverse video on
+                                            $attr_cell->reverse = !$attr_cell->reverse;
+                                            $temp = $attr_cell->background;
+                                            $attr_cell->background = $attr_cell->foreground;
+                                            $attr_cell->foreground = $temp;
+                                            break;
+                                        default: // set colors
+                                            //$front = $attr_cell->reverse ? &$attr_cell->background : &$attr_cell->foreground;
+                                            $front = &$attr_cell->{ $attr_cell->reverse ? 'background' : 'foreground' };
+                                            //$back = $attr_cell->reverse ? &$attr_cell->foreground : &$attr_cell->background;
+                                            $back = &$attr_cell->{ $attr_cell->reverse ? 'foreground' : 'background' };
+                                            switch ($mod) {
+                                                // @codingStandardsIgnoreStart
+                                                case 30: $front = 'black'; break;
+                                                case 31: $front = 'red'; break;
+                                                case 32: $front = 'green'; break;
+                                                case 33: $front = 'yellow'; break;
+                                                case 34: $front = 'blue'; break;
+                                                case 35: $front = 'magenta'; break;
+                                                case 36: $front = 'cyan'; break;
+                                                case 37: $front = 'white'; break;
+
+                                                case 40: $back = 'black'; break;
+                                                case 41: $back = 'red'; break;
+                                                case 42: $back = 'green'; break;
+                                                case 43: $back = 'yellow'; break;
+                                                case 44: $back = 'blue'; break;
+                                                case 45: $back = 'magenta'; break;
+                                                case 46: $back = 'cyan'; break;
+                                                case 47: $back = 'white'; break;
+                                                // @codingStandardsIgnoreEnd
+
+                                                default:
+                                                    //user_error('Unsupported attribute: ' . $mod);
+                                                    $this->ansi = '';
+                                                    break 2;
+                                            }
+                                    }
+                                }
+                                break;
+                            default:
+                                //user_error("{$this->ansi} is unsupported\r\n");
+                        }
+                }
+                $this->ansi = '';
+                continue;
+            }
+
+            $this->tokenization[count($this->tokenization) - 1].= $source[$i];
+            switch ($source[$i]) {
+                case "\r":
+                    $this->x = 0;
+                    break;
+                case "\n":
+                    $this->_newLine();
+                    break;
+                case "\x08": // backspace
+                    if ($this->x) {
+                        $this->x--;
+                        $this->attrs[$this->y][$this->x] = clone $this->base_attr_cell;
+                        $this->screen[$this->y] = substr_replace(
+                            $this->screen[$this->y],
+                            $source[$i],
+                            $this->x,
+                            1
+                        );
+                    }
+                    break;
+                case "\x0F": // shift
+                    break;
+                case "\x1B": // start ANSI escape code
+                    $this->tokenization[count($this->tokenization) - 1] = substr($this->tokenization[count($this->tokenization) - 1], 0, -1);
+                    //if (!strlen($this->tokenization[count($this->tokenization) - 1])) {
+                    //    array_pop($this->tokenization);
+                    //}
+                    $this->ansi.= "\x1B";
+                    break;
+                default:
+                    $this->attrs[$this->y][$this->x] = clone $this->attr_cell;
+                    if ($this->x > strlen($this->screen[$this->y])) {
+                        $this->screen[$this->y] = str_repeat(' ', $this->x);
+                    }
+                    $this->screen[$this->y] = substr_replace(
+                        $this->screen[$this->y],
+                        $source[$i],
+                        $this->x,
+                        1
+                    );
+
+                    if ($this->x > $this->max_x) {
+                        $this->x = 0;
+                        $this->_newLine();
+                    } else {
+                        $this->x++;
+                    }
+            }
+        }
+    }
+
+    /**
+     * Add a new line
+     *
+     * Also update the $this->screen and $this->history buffers
+     *
+     * @access private
+     */
+    function _newLine()
+    {
+        //if ($this->y < $this->max_y) {
+        //    $this->y++;
+        //}
+
+        while ($this->y >= $this->max_y) {
+            $this->history = array_merge($this->history, array(array_shift($this->screen)));
+            $this->screen[] = '';
+
+            $this->history_attrs = array_merge($this->history_attrs, array(array_shift($this->attrs)));
+            $this->attrs[] = $this->attr_row;
+
+            if (count($this->history) >= $this->max_history) {
+                array_shift($this->history);
+                array_shift($this->history_attrs);
+            }
+
+            $this->y--;
+        }
+        $this->y++;
+    }
+
+    /**
+     * Returns the current coordinate without preformating
+     *
+     * @access private
+     * @return string
+     */
+    function _processCoordinate($last_attr, $cur_attr, $char)
+    {
+        $output = '';
+
+        if ($last_attr != $cur_attr) {
+            $close = $open = '';
+            if ($last_attr->foreground != $cur_attr->foreground) {
+                if ($cur_attr->foreground != 'white') {
+                    $open.= '<span style="color: ' . $cur_attr->foreground . '">';
+                }
+                if ($last_attr->foreground != 'white') {
+                    $close = '</span>' . $close;
+                }
+            }
+            if ($last_attr->background != $cur_attr->background) {
+                if ($cur_attr->background != 'black') {
+                    $open.= '<span style="background: ' . $cur_attr->background . '">';
+                }
+                if ($last_attr->background != 'black') {
+                    $close = '</span>' . $close;
+                }
+            }
+            if ($last_attr->bold != $cur_attr->bold) {
+                if ($cur_attr->bold) {
+                    $open.= '<b>';
+                } else {
+                    $close = '</b>' . $close;
+                }
+            }
+            if ($last_attr->underline != $cur_attr->underline) {
+                if ($cur_attr->underline) {
+                    $open.= '<u>';
+                } else {
+                    $close = '</u>' . $close;
+                }
+            }
+            if ($last_attr->blink != $cur_attr->blink) {
+                if ($cur_attr->blink) {
+                    $open.= '<blink>';
+                } else {
+                    $close = '</blink>' . $close;
+                }
+            }
+            $output.= $close . $open;
+        }
+
+        $output.= htmlspecialchars($char);
+
+        return $output;
+    }
+
+    /**
+     * Returns the current screen without preformating
+     *
+     * @access private
+     * @return string
+     */
+    function _getScreen()
+    {
+        $output = '';
+        $last_attr = $this->base_attr_cell;
+        for ($i = 0; $i <= $this->max_y; $i++) {
+            for ($j = 0; $j <= $this->max_x; $j++) {
+                $cur_attr = $this->attrs[$i][$j];
+                $output.= $this->_processCoordinate($last_attr, $cur_attr, isset($this->screen[$i][$j]) ? $this->screen[$i][$j] : '');
+                $last_attr = $this->attrs[$i][$j];
+            }
+            $output.= "\r\n";
+        }
+        $output = substr($output, 0, -2);
+        // close any remaining open tags
+        $output.= $this->_processCoordinate($last_attr, $this->base_attr_cell, '');
+        return rtrim($output);
+    }
+
+    /**
+     * Returns the current screen
+     *
+     * @access public
+     * @return string
+     */
+    function getScreen()
+    {
+        return '<pre width="' . ($this->max_x + 1) . '" style="color: white; background: black">' . $this->_getScreen() . '</pre>';
+    }
+
+    /**
+     * Returns the current screen and the x previous lines
+     *
+     * @access public
+     * @return string
+     */
+    function getHistory()
+    {
+        $scrollback = '';
+        $last_attr = $this->base_attr_cell;
+        for ($i = 0; $i < count($this->history); $i++) {
+            for ($j = 0; $j <= $this->max_x + 1; $j++) {
+                $cur_attr = $this->history_attrs[$i][$j];
+                $scrollback.= $this->_processCoordinate($last_attr, $cur_attr, isset($this->history[$i][$j]) ? $this->history[$i][$j] : '');
+                $last_attr = $this->history_attrs[$i][$j];
+            }
+            $scrollback.= "\r\n";
+        }
+        $base_attr_cell = $this->base_attr_cell;
+        $this->base_attr_cell = $last_attr;
+        $scrollback.= $this->_getScreen();
+        $this->base_attr_cell = $base_attr_cell;
+
+        return '<pre width="' . ($this->max_x + 1) . '" style="color: white; background: black">' . $scrollback . '</span></pre>';
+    }
+}
diff --git a/lib/phpseclib/File/ASN1.php b/lib/phpseclib/File/ASN1.php
new file mode 100644
index 0000000..76ff8e3
--- /dev/null
+++ b/lib/phpseclib/File/ASN1.php
@@ -0,0 +1,1325 @@
+<?php
+
+/**
+ * Pure-PHP ASN.1 Parser
+ *
+ * PHP version 5
+ *
+ * ASN.1 provides the semantics for data encoded using various schemes.  The most commonly
+ * utilized scheme is DER or the "Distinguished Encoding Rules".  PEM's are base64 encoded
+ * DER blobs.
+ *
+ * \phpseclib\File\ASN1 decodes and encodes DER formatted messages and places them in a semantic context.
+ *
+ * Uses the 1988 ASN.1 syntax.
+ *
+ * @category  File
+ * @package   ASN1
+ * @author    Jim Wigginton <terrafrost@php.net>
+ * @copyright 2012 Jim Wigginton
+ * @license   http://www.opensource.org/licenses/mit-license.html  MIT License
+ * @link      http://phpseclib.sourceforge.net
+ */
+
+namespace phpseclib\File;
+
+use phpseclib\File\ASN1\Element;
+use phpseclib\Math\BigInteger;
+use DateTime;
+use DateTimeZone;
+
+/**
+ * Pure-PHP ASN.1 Parser
+ *
+ * @package ASN1
+ * @author  Jim Wigginton <terrafrost@php.net>
+ * @access  public
+ */
+class ASN1
+{
+    /**#@+
+     * Tag Classes
+     *
+     * @access private
+     * @link http://www.itu.int/ITU-T/studygroups/com17/languages/X.690-0207.pdf#page=12
+     */
+    const CLASS_UNIVERSAL        = 0;
+    const CLASS_APPLICATION      = 1;
+    const CLASS_CONTEXT_SPECIFIC = 2;
+    const CLASS_PRIVATE          = 3;
+    /**#@-*/
+
+    /**#@+
+     * Tag Classes
+     *
+     * @access private
+     * @link http://www.obj-sys.com/asn1tutorial/node124.html
+    */
+    const TYPE_BOOLEAN           = 1;
+    const TYPE_INTEGER           = 2;
+    const TYPE_BIT_STRING        = 3;
+    const TYPE_OCTET_STRING      = 4;
+    const TYPE_NULL              = 5;
+    const TYPE_OBJECT_IDENTIFIER = 6;
+    //const TYPE_OBJECT_DESCRIPTOR = 7;
+    //const TYPE_INSTANCE_OF       = 8; // EXTERNAL
+    const TYPE_REAL              = 9;
+    const TYPE_ENUMERATED        = 10;
+    //const TYPE_EMBEDDED          = 11;
+    const TYPE_UTF8_STRING       = 12;
+    //const TYPE_RELATIVE_OID      = 13;
+    const TYPE_SEQUENCE          = 16; // SEQUENCE OF
+    const TYPE_SET               = 17; // SET OF
+    /**#@-*/
+    /**#@+
+     * More Tag Classes
+     *
+     * @access private
+     * @link http://www.obj-sys.com/asn1tutorial/node10.html
+    */
+    const TYPE_NUMERIC_STRING   = 18;
+    const TYPE_PRINTABLE_STRING = 19;
+    const TYPE_TELETEX_STRING   = 20; // T61String
+    const TYPE_VIDEOTEX_STRING  = 21;
+    const TYPE_IA5_STRING       = 22;
+    const TYPE_UTC_TIME         = 23;
+    const TYPE_GENERALIZED_TIME = 24;
+    const TYPE_GRAPHIC_STRING   = 25;
+    const TYPE_VISIBLE_STRING   = 26; // ISO646String
+    const TYPE_GENERAL_STRING   = 27;
+    const TYPE_UNIVERSAL_STRING = 28;
+    //const TYPE_CHARACTER_STRING = 29;
+    const TYPE_BMP_STRING       = 30;
+    /**#@-*/
+
+    /**#@+
+     * Tag Aliases
+     *
+     * These tags are kinda place holders for other tags.
+     *
+     * @access private
+    */
+    const TYPE_CHOICE = -1;
+    const TYPE_ANY    = -2;
+    /**#@-*/
+
+    /**
+     * ASN.1 object identifier
+     *
+     * @var array
+     * @access private
+     * @link http://en.wikipedia.org/wiki/Object_identifier
+     */
+    var $oids = array();
+
+    /**
+     * Default date format
+     *
+     * @var string
+     * @access private
+     * @link http://php.net/class.datetime
+     */
+    var $format = 'D, d M Y H:i:s O';
+
+    /**
+     * Default date format
+     *
+     * @var array
+     * @access private
+     * @see self::setTimeFormat()
+     * @see self::asn1map()
+     * @link http://php.net/class.datetime
+     */
+    var $encoded;
+
+    /**
+     * Filters
+     *
+     * If the mapping type is self::TYPE_ANY what do we actually encode it as?
+     *
+     * @var array
+     * @access private
+     * @see self::_encode_der()
+     */
+    var $filters;
+
+    /**
+     * Type mapping table for the ANY type.
+     *
+     * Structured or unknown types are mapped to a \phpseclib\File\ASN1\Element.
+     * Unambiguous types get the direct mapping (int/real/bool).
+     * Others are mapped as a choice, with an extra indexing level.
+     *
+     * @var array
+     * @access public
+     */
+    var $ANYmap = array(
+        self::TYPE_BOOLEAN              => true,
+        self::TYPE_INTEGER              => true,
+        self::TYPE_BIT_STRING           => 'bitString',
+        self::TYPE_OCTET_STRING         => 'octetString',
+        self::TYPE_NULL                 => 'null',
+        self::TYPE_OBJECT_IDENTIFIER    => 'objectIdentifier',
+        self::TYPE_REAL                 => true,
+        self::TYPE_ENUMERATED           => 'enumerated',
+        self::TYPE_UTF8_STRING          => 'utf8String',
+        self::TYPE_NUMERIC_STRING       => 'numericString',
+        self::TYPE_PRINTABLE_STRING     => 'printableString',
+        self::TYPE_TELETEX_STRING       => 'teletexString',
+        self::TYPE_VIDEOTEX_STRING      => 'videotexString',
+        self::TYPE_IA5_STRING           => 'ia5String',
+        self::TYPE_UTC_TIME             => 'utcTime',
+        self::TYPE_GENERALIZED_TIME     => 'generalTime',
+        self::TYPE_GRAPHIC_STRING       => 'graphicString',
+        self::TYPE_VISIBLE_STRING       => 'visibleString',
+        self::TYPE_GENERAL_STRING       => 'generalString',
+        self::TYPE_UNIVERSAL_STRING     => 'universalString',
+        //self::TYPE_CHARACTER_STRING     => 'characterString',
+        self::TYPE_BMP_STRING           => 'bmpString'
+    );
+
+    /**
+     * String type to character size mapping table.
+     *
+     * Non-convertable types are absent from this table.
+     * size == 0 indicates variable length encoding.
+     *
+     * @var array
+     * @access public
+     */
+    var $stringTypeSize = array(
+        self::TYPE_UTF8_STRING      => 0,
+        self::TYPE_BMP_STRING       => 2,
+        self::TYPE_UNIVERSAL_STRING => 4,
+        self::TYPE_PRINTABLE_STRING => 1,
+        self::TYPE_TELETEX_STRING   => 1,
+        self::TYPE_IA5_STRING       => 1,
+        self::TYPE_VISIBLE_STRING   => 1,
+    );
+
+    /**
+     * Parse BER-encoding
+     *
+     * Serves a similar purpose to openssl's asn1parse
+     *
+     * @param string $encoded
+     * @return array
+     * @access public
+     */
+    function decodeBER($encoded)
+    {
+        if ($encoded instanceof Element) {
+            $encoded = $encoded->element;
+        }
+
+        $this->encoded = $encoded;
+        // encapsulate in an array for BC with the old decodeBER
+        return array($this->_decode_ber($encoded));
+    }
+
+    /**
+     * Parse BER-encoding (Helper function)
+     *
+     * Sometimes we want to get the BER encoding of a particular tag.  $start lets us do that without having to reencode.
+     * $encoded is passed by reference for the recursive calls done for self::TYPE_BIT_STRING and
+     * self::TYPE_OCTET_STRING. In those cases, the indefinite length is used.
+     *
+     * @param string $encoded
+     * @param int $start
+     * @param int $encoded_pos
+     * @return array
+     * @access private
+     */
+    function _decode_ber($encoded, $start = 0, $encoded_pos = 0)
+    {
+        $current = array('start' => $start);
+
+        $type = ord($encoded[$encoded_pos++]);
+        $start++;
+
+        $constructed = ($type >> 5) & 1;
+
+        $tag = $type & 0x1F;
+        if ($tag == 0x1F) {
+            $tag = 0;
+            // process septets (since the eighth bit is ignored, it's not an octet)
+            do {
+                $loop = ord($encoded[0]) >> 7;
+                $tag <<= 7;
+                $tag |= ord($encoded[$encoded_pos++]) & 0x7F;
+                $start++;
+            } while ($loop);
+        }
+
+        // Length, as discussed in paragraph 8.1.3 of X.690-0207.pdf#page=13
+        $length = ord($encoded[$encoded_pos++]);
+        $start++;
+        if ($length == 0x80) { // indefinite length
+            // "[A sender shall] use the indefinite form (see 8.1.3.6) if the encoding is constructed and is not all
+            //  immediately available." -- paragraph 8.1.3.2.c
+            $length = strlen($encoded) - $encoded_pos;
+        } elseif ($length & 0x80) { // definite length, long form
+            // technically, the long form of the length can be represented by up to 126 octets (bytes), but we'll only
+            // support it up to four.
+            $length&= 0x7F;
+            $temp = substr($encoded, $encoded_pos, $length);
+            $encoded_pos += $length;
+            // tags of indefinte length don't really have a header length; this length includes the tag
+            $current+= array('headerlength' => $length + 2);
+            $start+= $length;
+            extract(unpack('Nlength', substr(str_pad($temp, 4, chr(0), STR_PAD_LEFT), -4)));
+        } else {
+            $current+= array('headerlength' => 2);
+        }
+
+        if ($length > (strlen($encoded) - $encoded_pos)) {
+            return false;
+        }
+
+        $content = substr($encoded, $encoded_pos, $length);
+        $content_pos = 0;
+
+        // at this point $length can be overwritten. it's only accurate for definite length things as is
+
+        /* Class is UNIVERSAL, APPLICATION, PRIVATE, or CONTEXT-SPECIFIC. The UNIVERSAL class is restricted to the ASN.1
+           built-in types. It defines an application-independent data type that must be distinguishable from all other
+           data types. The other three classes are user defined. The APPLICATION class distinguishes data types that
+           have a wide, scattered use within a particular presentation context. PRIVATE distinguishes data types within
+           a particular organization or country. CONTEXT-SPECIFIC distinguishes members of a sequence or set, the
+           alternatives of a CHOICE, or universally tagged set members. Only the class number appears in braces for this
+           data type; the term CONTEXT-SPECIFIC does not appear.
+
+             -- http://www.obj-sys.com/asn1tutorial/node12.html */
+        $class = ($type >> 6) & 3;
+        switch ($class) {
+            case self::CLASS_APPLICATION:
+            case self::CLASS_PRIVATE:
+            case self::CLASS_CONTEXT_SPECIFIC:
+                if (!$constructed) {
+                    return array(
+                        'type'     => $class,
+                        'constant' => $tag,
+                        'content'  => $content,
+                        'length'   => $length + $start - $current['start']
+                    );
+                }
+
+                $newcontent = array();
+                $remainingLength = $length;
+                while ($remainingLength > 0) {
+                    $temp = $this->_decode_ber($content, $start, $content_pos);
+                    $length = $temp['length'];
+                    // end-of-content octets - see paragraph 8.1.5
+                    if (substr($content, $content_pos + $length, 2) == "\0\0") {
+                        $length+= 2;
+                        $start+= $length;
+                        $newcontent[] = $temp;
+                        break;
+                    }
+                    $start+= $length;
+                    $remainingLength-= $length;
+                    $newcontent[] = $temp;
+                    $content_pos += $length;
+                }
+
+                return array(
+                    'type'     => $class,
+                    'constant' => $tag,
+                    // the array encapsulation is for BC with the old format
+                    'content'  => $newcontent,
+                    // the only time when $content['headerlength'] isn't defined is when the length is indefinite.
+                    // the absence of $content['headerlength'] is how we know if something is indefinite or not.
+                    // technically, it could be defined to be 2 and then another indicator could be used but whatever.
+                    'length'   => $start - $current['start']
+                ) + $current;
+        }
+
+        $current+= array('type' => $tag);
+
+        // decode UNIVERSAL tags
+        switch ($tag) {
+            case self::TYPE_BOOLEAN:
+                // "The contents octets shall consist of a single octet." -- paragraph 8.2.1
+                //if (strlen($content) != 1) {
+                //    return false;
+                //}
+                $current['content'] = (bool) ord($content[$content_pos]);
+                break;
+            case self::TYPE_INTEGER:
+            case self::TYPE_ENUMERATED:
+                $current['content'] = new BigInteger(substr($content, $content_pos), -256);
+                break;
+            case self::TYPE_REAL: // not currently supported
+                return false;
+            case self::TYPE_BIT_STRING:
+                // The initial octet shall encode, as an unsigned binary integer with bit 1 as the least significant bit,
+                // the number of unused bits in the final subsequent octet. The number shall be in the range zero to
+                // seven.
+                if (!$constructed) {
+                    $current['content'] = substr($content, $content_pos);
+                } else {
+                    $temp = $this->_decode_ber($content, $start, $content_pos);
+                    $length-= (strlen($content) - $content_pos);
+                    $last = count($temp) - 1;
+                    for ($i = 0; $i < $last; $i++) {
+                        // all subtags should be bit strings
+                        //if ($temp[$i]['type'] != self::TYPE_BIT_STRING) {
+                        //    return false;
+                        //}
+                        $current['content'].= substr($temp[$i]['content'], 1);
+                    }
+                    // all subtags should be bit strings
+                    //if ($temp[$last]['type'] != self::TYPE_BIT_STRING) {
+                    //    return false;
+                    //}
+                    $current['content'] = $temp[$last]['content'][0] . $current['content'] . substr($temp[$i]['content'], 1);
+                }
+                break;
+            case self::TYPE_OCTET_STRING:
+                if (!$constructed) {
+                    $current['content'] = substr($content, $content_pos);
+                } else {
+                    $current['content'] = '';
+                    $length = 0;
+                    while (substr($content, $content_pos, 2) != "\0\0") {
+                        $temp = $this->_decode_ber($content, $length + $start, $content_pos);
+                        $content_pos += $temp['length'];
+                        // all subtags should be octet strings
+                        //if ($temp['type'] != self::TYPE_OCTET_STRING) {
+                        //    return false;
+                        //}
+                        $current['content'].= $temp['content'];
+                        $length+= $temp['length'];
+                    }
+                    if (substr($content, $content_pos, 2) == "\0\0") {
+                        $length+= 2; // +2 for the EOC
+                    }
+                }
+                break;
+            case self::TYPE_NULL:
+                // "The contents octets shall not contain any octets." -- paragraph 8.8.2
+                //if (strlen($content)) {
+                //    return false;
+                //}
+                break;
+            case self::TYPE_SEQUENCE:
+            case self::TYPE_SET:
+                $offset = 0;
+                $current['content'] = array();
+                $content_len = strlen($content);
+                while ($content_pos < $content_len) {
+                    // if indefinite length construction was used and we have an end-of-content string next
+                    // see paragraphs 8.1.1.3, 8.1.3.2, 8.1.3.6, 8.1.5, and (for an example) 8.6.4.2
+                    if (!isset($current['headerlength']) && substr($content, $content_pos, 2) == "\0\0") {
+                        $length = $offset + 2; // +2 for the EOC
+                        break 2;
+                    }
+                    $temp = $this->_decode_ber($content, $start + $offset, $content_pos);
+                    $content_pos += $temp['length'];
+                    $current['content'][] = $temp;
+                    $offset+= $temp['length'];
+                }
+                break;
+            case self::TYPE_OBJECT_IDENTIFIER:
+                $temp = ord($content[$content_pos++]);
+                $current['content'] = sprintf('%d.%d', floor($temp / 40), $temp % 40);
+                $valuen = 0;
+                // process septets
+                $content_len = strlen($content);
+                while ($content_pos < $content_len) {
+                    $temp = ord($content[$content_pos++]);
+                    $valuen <<= 7;
+                    $valuen |= $temp & 0x7F;
+                    if (~$temp & 0x80) {
+                        $current['content'].= ".$valuen";
+                        $valuen = 0;
+                    }
+                }
+                // the eighth bit of the last byte should not be 1
+                //if ($temp >> 7) {
+                //    return false;
+                //}
+                break;
+            /* Each character string type shall be encoded as if it had been declared:
+               [UNIVERSAL x] IMPLICIT OCTET STRING
+
+                 -- X.690-0207.pdf#page=23 (paragraph 8.21.3)
+
+               Per that, we're not going to do any validation.  If there are any illegal characters in the string,
+               we don't really care */
+            case self::TYPE_NUMERIC_STRING:
+                // 0,1,2,3,4,5,6,7,8,9, and space
+            case self::TYPE_PRINTABLE_STRING:
+                // Upper and lower case letters, digits, space, apostrophe, left/right parenthesis, plus sign, comma,
+                // hyphen, full stop, solidus, colon, equal sign, question mark
+            case self::TYPE_TELETEX_STRING:
+                // The Teletex character set in CCITT's T61, space, and delete
+                // see http://en.wikipedia.org/wiki/Teletex#Character_sets
+            case self::TYPE_VIDEOTEX_STRING:
+                // The Videotex character set in CCITT's T.100 and T.101, space, and delete
+            case self::TYPE_VISIBLE_STRING:
+                // Printing character sets of international ASCII, and space
+            case self::TYPE_IA5_STRING:
+                // International Alphabet 5 (International ASCII)
+            case self::TYPE_GRAPHIC_STRING:
+                // All registered G sets, and space
+            case self::TYPE_GENERAL_STRING:
+                // All registered C and G sets, space and delete
+            case self::TYPE_UTF8_STRING:
+                // ????
+            case self::TYPE_BMP_STRING:
+                $current['content'] = substr($content, $content_pos);
+                break;
+            case self::TYPE_UTC_TIME:
+            case self::TYPE_GENERALIZED_TIME:
+                $current['content'] = $this->_decodeTime(substr($content, $content_pos), $tag);
+            default:
+        }
+
+        $start+= $length;
+
+        // ie. length is the length of the full TLV encoding - it's not just the length of the value
+        return $current + array('length' => $start - $current['start']);
+    }
+
+    /**
+     * ASN.1 Map
+     *
+     * Provides an ASN.1 semantic mapping ($mapping) from a parsed BER-encoding to a human readable format.
+     *
+     * "Special" mappings may be applied on a per tag-name basis via $special.
+     *
+     * @param array $decoded
+     * @param array $mapping
+     * @param array $special
+     * @return array
+     * @access public
+     */
+    function asn1map($decoded, $mapping, $special = array())
+    {
+        if (isset($mapping['explicit']) && is_array($decoded['content'])) {
+            $decoded = $decoded['content'][0];
+        }
+
+        switch (true) {
+            case $mapping['type'] == self::TYPE_ANY:
+                $intype = $decoded['type'];
+                if (isset($decoded['constant']) || !isset($this->ANYmap[$intype]) || (ord($this->encoded[$decoded['start']]) & 0x20)) {
+                    return new Element(substr($this->encoded, $decoded['start'], $decoded['length']));
+                }
+                $inmap = $this->ANYmap[$intype];
+                if (is_string($inmap)) {
+                    return array($inmap => $this->asn1map($decoded, array('type' => $intype) + $mapping, $special));
+                }
+                break;
+            case $mapping['type'] == self::TYPE_CHOICE:
+                foreach ($mapping['children'] as $key => $option) {
+                    switch (true) {
+                        case isset($option['constant']) && $option['constant'] == $decoded['constant']:
+                        case !isset($option['constant']) && $option['type'] == $decoded['type']:
+                            $value = $this->asn1map($decoded, $option, $special);
+                            break;
+                        case !isset($option['constant']) && $option['type'] == self::TYPE_CHOICE:
+                            $v = $this->asn1map($decoded, $option, $special);
+                            if (isset($v)) {
+                                $value = $v;
+                            }
+                    }
+                    if (isset($value)) {
+                        if (isset($special[$key])) {
+                            $value = call_user_func($special[$key], $value);
+                        }
+                        return array($key => $value);
+                    }
+                }
+                return null;
+            case isset($mapping['implicit']):
+            case isset($mapping['explicit']):
+            case $decoded['type'] == $mapping['type']:
+                break;
+            default:
+                // if $decoded['type'] and $mapping['type'] are both strings, but different types of strings,
+                // let it through
+                switch (true) {
+                    case $decoded['type'] < 18: // self::TYPE_NUMERIC_STRING == 18
+                    case $decoded['type'] > 30: // self::TYPE_BMP_STRING == 30
+                    case $mapping['type'] < 18:
+                    case $mapping['type'] > 30:
+                        return null;
+                }
+        }
+
+        if (isset($mapping['implicit'])) {
+            $decoded['type'] = $mapping['type'];
+        }
+
+        switch ($decoded['type']) {
+            case self::TYPE_SEQUENCE:
+                $map = array();
+
+                // ignore the min and max
+                if (isset($mapping['min']) && isset($mapping['max'])) {
+                    $child = $mapping['children'];
+                    foreach ($decoded['content'] as $content) {
+                        if (($map[] = $this->asn1map($content, $child, $special)) === null) {
+                            return null;
+                        }
+                    }
+
+                    return $map;
+                }
+
+                $n = count($decoded['content']);
+                $i = 0;
+
+                foreach ($mapping['children'] as $key => $child) {
+                    $maymatch = $i < $n; // Match only existing input.
+                    if ($maymatch) {
+                        $temp = $decoded['content'][$i];
+
+                        if ($child['type'] != self::TYPE_CHOICE) {
+                            // Get the mapping and input class & constant.
+                            $childClass = $tempClass = self::CLASS_UNIVERSAL;
+                            $constant = null;
+                            if (isset($temp['constant'])) {
+                                $tempClass = $temp['type'];
+                            }
+                            if (isset($child['class'])) {
+                                $childClass = $child['class'];
+                                $constant = $child['cast'];
+                            } elseif (isset($child['constant'])) {
+                                $childClass = self::CLASS_CONTEXT_SPECIFIC;
+                                $constant = $child['constant'];
+                            }
+
+                            if (isset($constant) && isset($temp['constant'])) {
+                                // Can only match if constants and class match.
+                                $maymatch = $constant == $temp['constant'] && $childClass == $tempClass;
+                            } else {
+                                // Can only match if no constant expected and type matches or is generic.
+                                $maymatch = !isset($child['constant']) && array_search($child['type'], array($temp['type'], self::TYPE_ANY, self::TYPE_CHOICE)) !== false;
+                            }
+                        }
+                    }
+
+                    if ($maymatch) {
+                        // Attempt submapping.
+                        $candidate = $this->asn1map($temp, $child, $special);
+                        $maymatch = $candidate !== null;
+                    }
+
+                    if ($maymatch) {
+                        // Got the match: use it.
+                        if (isset($special[$key])) {
+                            $candidate = call_user_func($special[$key], $candidate);
+                        }
+                        $map[$key] = $candidate;
+                        $i++;
+                    } elseif (isset($child['default'])) {
+                        $map[$key] = $child['default']; // Use default.
+                    } elseif (!isset($child['optional'])) {
+                        return null; // Syntax error.
+                    }
+                }
+
+                // Fail mapping if all input items have not been consumed.
+                return $i < $n ? null: $map;
+
+            // the main diff between sets and sequences is the encapsulation of the foreach in another for loop
+            case self::TYPE_SET:
+                $map = array();
+
+                // ignore the min and max
+                if (isset($mapping['min']) && isset($mapping['max'])) {
+                    $child = $mapping['children'];
+                    foreach ($decoded['content'] as $content) {
+                        if (($map[] = $this->asn1map($content, $child, $special)) === null) {
+                            return null;
+                        }
+                    }
+
+                    return $map;
+                }
+
+                for ($i = 0; $i < count($decoded['content']); $i++) {
+                    $temp = $decoded['content'][$i];
+                    $tempClass = self::CLASS_UNIVERSAL;
+                    if (isset($temp['constant'])) {
+                        $tempClass = $temp['type'];
+                    }
+
+                    foreach ($mapping['children'] as $key => $child) {
+                        if (isset($map[$key])) {
+                            continue;
+                        }
+                        $maymatch = true;
+                        if ($child['type'] != self::TYPE_CHOICE) {
+                            $childClass = self::CLASS_UNIVERSAL;
+                            $constant = null;
+                            if (isset($child['class'])) {
+                                $childClass = $child['class'];
+                                $constant = $child['cast'];
+                            } elseif (isset($child['constant'])) {
+                                $childClass = self::CLASS_CONTEXT_SPECIFIC;
+                                $constant = $child['constant'];
+                            }
+
+                            if (isset($constant) && isset($temp['constant'])) {
+                                // Can only match if constants and class match.
+                                $maymatch = $constant == $temp['constant'] && $childClass == $tempClass;
+                            } else {
+                                // Can only match if no constant expected and type matches or is generic.
+                                $maymatch = !isset($child['constant']) && array_search($child['type'], array($temp['type'], self::TYPE_ANY, self::TYPE_CHOICE)) !== false;
+                            }
+                        }
+
+                        if ($maymatch) {
+                            // Attempt submapping.
+                            $candidate = $this->asn1map($temp, $child, $special);
+                            $maymatch = $candidate !== null;
+                        }
+
+                        if (!$maymatch) {
+                            break;
+                        }
+
+                        // Got the match: use it.
+                        if (isset($special[$key])) {
+                            $candidate = call_user_func($special[$key], $candidate);
+                        }
+                        $map[$key] = $candidate;
+                        break;
+                    }
+                }
+
+                foreach ($mapping['children'] as $key => $child) {
+                    if (!isset($map[$key])) {
+                        if (isset($child['default'])) {
+                            $map[$key] = $child['default'];
+                        } elseif (!isset($child['optional'])) {
+                            return null;
+                        }
+                    }
+                }
+                return $map;
+            case self::TYPE_OBJECT_IDENTIFIER:
+                return isset($this->oids[$decoded['content']]) ? $this->oids[$decoded['content']] : $decoded['content'];
+            case self::TYPE_UTC_TIME:
+            case self::TYPE_GENERALIZED_TIME:
+                if (isset($mapping['implicit'])) {
+                    $decoded['content'] = $this->_decodeTime($decoded['content'], $decoded['type']);
+                }
+                return $decoded['content'] ? $decoded['content']->format($this->format) : false;
+            case self::TYPE_BIT_STRING:
+                if (isset($mapping['mapping'])) {
+                    $offset = ord($decoded['content'][0]);
+                    $size = (strlen($decoded['content']) - 1) * 8 - $offset;
+                    /*
+                       From X.680-0207.pdf#page=46 (21.7):
+
+                       "When a "NamedBitList" is used in defining a bitstring type ASN.1 encoding rules are free to add (or remove)
+                        arbitrarily any trailing 0 bits to (or from) values that are being encoded or decoded. Application designers should
+                        therefore ensure that different semantics are not associated with such values which differ only in the number of trailing
+                        0 bits."
+                    */
+                    $bits = count($mapping['mapping']) == $size ? array() : array_fill(0, count($mapping['mapping']) - $size, false);
+                    for ($i = strlen($decoded['content']) - 1; $i > 0; $i--) {
+                        $current = ord($decoded['content'][$i]);
+                        for ($j = $offset; $j < 8; $j++) {
+                            $bits[] = (bool) ($current & (1 << $j));
+                        }
+                        $offset = 0;
+                    }
+                    $values = array();
+                    $map = array_reverse($mapping['mapping']);
+                    foreach ($map as $i => $value) {
+                        if ($bits[$i]) {
+                            $values[] = $value;
+                        }
+                    }
+                    return $values;
+                }
+            case self::TYPE_OCTET_STRING:
+                return base64_encode($decoded['content']);
+            case self::TYPE_NULL:
+                return '';
+            case self::TYPE_BOOLEAN:
+                return $decoded['content'];
+            case self::TYPE_NUMERIC_STRING:
+            case self::TYPE_PRINTABLE_STRING:
+            case self::TYPE_TELETEX_STRING:
+            case self::TYPE_VIDEOTEX_STRING:
+            case self::TYPE_IA5_STRING:
+            case self::TYPE_GRAPHIC_STRING:
+            case self::TYPE_VISIBLE_STRING:
+            case self::TYPE_GENERAL_STRING:
+            case self::TYPE_UNIVERSAL_STRING:
+            case self::TYPE_UTF8_STRING:
+            case self::TYPE_BMP_STRING:
+                return $decoded['content'];
+            case self::TYPE_INTEGER:
+            case self::TYPE_ENUMERATED:
+                $temp = $decoded['content'];
+                if (isset($mapping['implicit'])) {
+                    $temp = new BigInteger($decoded['content'], -256);
+                }
+                if (isset($mapping['mapping'])) {
+                    $temp = (int) $temp->toString();
+                    return isset($mapping['mapping'][$temp]) ?
+                        $mapping['mapping'][$temp] :
+                        false;
+                }
+                return $temp;
+        }
+    }
+
+    /**
+     * ASN.1 Encode
+     *
+     * DER-encodes an ASN.1 semantic mapping ($mapping).  Some libraries would probably call this function
+     * an ASN.1 compiler.
+     *
+     * "Special" mappings can be applied via $special.
+     *
+     * @param string $source
+     * @param string $mapping
+     * @param int $idx
+     * @return string
+     * @access public
+     */
+    function encodeDER($source, $mapping, $special = array())
+    {
+        $this->location = array();
+        return $this->_encode_der($source, $mapping, null, $special);
+    }
+
+    /**
+     * ASN.1 Encode (Helper function)
+     *
+     * @param string $source
+     * @param string $mapping
+     * @param int $idx
+     * @return string
+     * @access private
+     */
+    function _encode_der($source, $mapping, $idx = null, $special = array())
+    {
+        if ($source instanceof Element) {
+            return $source->element;
+        }
+
+        // do not encode (implicitly optional) fields with value set to default
+        if (isset($mapping['default']) && $source === $mapping['default']) {
+            return '';
+        }
+
+        if (isset($idx)) {
+            if (isset($special[$idx])) {
+                $source = call_user_func($special[$idx], $source);
+            }
+            $this->location[] = $idx;
+        }
+
+        $tag = $mapping['type'];
+
+        switch ($tag) {
+            case self::TYPE_SET:    // Children order is not important, thus process in sequence.
+            case self::TYPE_SEQUENCE:
+                $tag|= 0x20; // set the constructed bit
+
+                // ignore the min and max
+                if (isset($mapping['min']) && isset($mapping['max'])) {
+                    $value = array();
+                    $child = $mapping['children'];
+
+                    foreach ($source as $content) {
+                        $temp = $this->_encode_der($content, $child, null, $special);
+                        if ($temp === false) {
+                            return false;
+                        }
+                        $value[]= $temp;
+                    }
+                    /* "The encodings of the component values of a set-of value shall appear in ascending order, the encodings being compared
+                        as octet strings with the shorter components being padded at their trailing end with 0-octets.
+                        NOTE - The padding octets are for comparison purposes only and do not appear in the encodings."
+
+                       -- sec 11.6 of http://www.itu.int/ITU-T/studygroups/com17/languages/X.690-0207.pdf  */
+                    if ($mapping['type'] == self::TYPE_SET) {
+                        sort($value);
+                    }
+                    $value = implode($value, '');
+                    break;
+                }
+
+                $value = '';
+                foreach ($mapping['children'] as $key => $child) {
+                    if (!array_key_exists($key, $source)) {
+                        if (!isset($child['optional'])) {
+                            return false;
+                        }
+                        continue;
+                    }
+
+                    $temp = $this->_encode_der($source[$key], $child, $key, $special);
+                    if ($temp === false) {
+                        return false;
+                    }
+
+                    // An empty child encoding means it has been optimized out.
+                    // Else we should have at least one tag byte.
+                    if ($temp === '') {
+                        continue;
+                    }
+
+                    // if isset($child['constant']) is true then isset($child['optional']) should be true as well
+                    if (isset($child['constant'])) {
+                        /*
+                           From X.680-0207.pdf#page=58 (30.6):
+
+                           "The tagging construction specifies explicit tagging if any of the following holds:
+                            ...
+                            c) the "Tag Type" alternative is used and the value of "TagDefault" for the module is IMPLICIT TAGS or
+                            AUTOMATIC TAGS, but the type defined by "Type" is an untagged choice type, an untagged open type, or
+                            an untagged "DummyReference" (see ITU-T Rec. X.683 | ISO/IEC 8824-4, 8.3)."
+                         */
+                        if (isset($child['explicit']) || $child['type'] == self::TYPE_CHOICE) {
+                            $subtag = chr((self::CLASS_CONTEXT_SPECIFIC << 6) | 0x20 | $child['constant']);
+                            $temp = $subtag . $this->_encodeLength(strlen($temp)) . $temp;
+                        } else {
+                            $subtag = chr((self::CLASS_CONTEXT_SPECIFIC << 6) | (ord($temp[0]) & 0x20) | $child['constant']);
+                            $temp = $subtag . substr($temp, 1);
+                        }
+                    }
+                    $value.= $temp;
+                }
+                break;
+            case self::TYPE_CHOICE:
+                $temp = false;
+
+                foreach ($mapping['children'] as $key => $child) {
+                    if (!isset($source[$key])) {
+                        continue;
+                    }
+
+                    $temp = $this->_encode_der($source[$key], $child, $key, $special);
+                    if ($temp === false) {
+                        return false;
+                    }
+
+                    // An empty child encoding means it has been optimized out.
+                    // Else we should have at least one tag byte.
+                    if ($temp === '') {
+                        continue;
+                    }
+
+                    $tag = ord($temp[0]);
+
+                    // if isset($child['constant']) is true then isset($child['optional']) should be true as well
+                    if (isset($child['constant'])) {
+                        if (isset($child['explicit']) || $child['type'] == self::TYPE_CHOICE) {
+                            $subtag = chr((self::CLASS_CONTEXT_SPECIFIC << 6) | 0x20 | $child['constant']);
+                            $temp = $subtag . $this->_encodeLength(strlen($temp)) . $temp;
+                        } else {
+                            $subtag = chr((self::CLASS_CONTEXT_SPECIFIC << 6) | (ord($temp[0]) & 0x20) | $child['constant']);
+                            $temp = $subtag . substr($temp, 1);
+                        }
+                    }
+                }
+
+                if (isset($idx)) {
+                    array_pop($this->location);
+                }
+
+                if ($temp && isset($mapping['cast'])) {
+                    $temp[0] = chr(($mapping['class'] << 6) | ($tag & 0x20) | $mapping['cast']);
+                }
+
+                return $temp;
+            case self::TYPE_INTEGER:
+            case self::TYPE_ENUMERATED:
+                if (!isset($mapping['mapping'])) {
+                    if (is_numeric($source)) {
+                        $source = new BigInteger($source);
+                    }
+                    $value = $source->toBytes(true);
+                } else {
+                    $value = array_search($source, $mapping['mapping']);
+                    if ($value === false) {
+                        return false;
+                    }
+                    $value = new BigInteger($value);
+                    $value = $value->toBytes(true);
+                }
+                if (!strlen($value)) {
+                    $value = chr(0);
+                }
+                break;
+            case self::TYPE_UTC_TIME:
+            case self::TYPE_GENERALIZED_TIME:
+                $format = $mapping['type'] == self::TYPE_UTC_TIME ? 'y' : 'Y';
+                $format.= 'mdHis';
+                $date = new DateTime($source, new DateTimeZone('GMT'));
+                $value = $date->format($format) . 'Z';
+                break;
+            case self::TYPE_BIT_STRING:
+                if (isset($mapping['mapping'])) {
+                    $bits = array_fill(0, count($mapping['mapping']), 0);
+                    $size = 0;
+                    for ($i = 0; $i < count($mapping['mapping']); $i++) {
+                        if (in_array($mapping['mapping'][$i], $source)) {
+                            $bits[$i] = 1;
+                            $size = $i;
+                        }
+                    }
+
+                    if (isset($mapping['min']) && $mapping['min'] >= 1 && $size < $mapping['min']) {
+                        $size = $mapping['min'] - 1;
+                    }
+
+                    $offset = 8 - (($size + 1) & 7);
+                    $offset = $offset !== 8 ? $offset : 0;
+
+                    $value = chr($offset);
+
+                    for ($i = $size + 1; $i < count($mapping['mapping']); $i++) {
+                        unset($bits[$i]);
+                    }
+
+                    $bits = implode('', array_pad($bits, $size + $offset + 1, 0));
+                    $bytes = explode(' ', rtrim(chunk_split($bits, 8, ' ')));
+                    foreach ($bytes as $byte) {
+                        $value.= chr(bindec($byte));
+                    }
+
+                    break;
+                }
+            case self::TYPE_OCTET_STRING:
+                /* The initial octet shall encode, as an unsigned binary integer with bit 1 as the least significant bit,
+                   the number of unused bits in the final subsequent octet. The number shall be in the range zero to seven.
+
+                   -- http://www.itu.int/ITU-T/studygroups/com17/languages/X.690-0207.pdf#page=16 */
+                $value = base64_decode($source);
+                break;
+            case self::TYPE_OBJECT_IDENTIFIER:
+                $oid = preg_match('#(?:\d+\.)+#', $source) ? $source : array_search($source, $this->oids);
+                if ($oid === false) {
+                    user_error('Invalid OID');
+                    return false;
+                }
+                $value = '';
+                $parts = explode('.', $oid);
+                $value = chr(40 * $parts[0] + $parts[1]);
+                for ($i = 2; $i < count($parts); $i++) {
+                    $temp = '';
+                    if (!$parts[$i]) {
+                        $temp = "\0";
+                    } else {
+                        while ($parts[$i]) {
+                            $temp = chr(0x80 | ($parts[$i] & 0x7F)) . $temp;
+                            $parts[$i] >>= 7;
+                        }
+                        $temp[strlen($temp) - 1] = $temp[strlen($temp) - 1] & chr(0x7F);
+                    }
+                    $value.= $temp;
+                }
+                break;
+            case self::TYPE_ANY:
+                $loc = $this->location;
+                if (isset($idx)) {
+                    array_pop($this->location);
+                }
+
+                switch (true) {
+                    case !isset($source):
+                        return $this->_encode_der(null, array('type' => self::TYPE_NULL) + $mapping, null, $special);
+                    case is_int($source):
+                    case $source instanceof BigInteger:
+                        return $this->_encode_der($source, array('type' => self::TYPE_INTEGER) + $mapping, null, $special);
+                    case is_float($source):
+                        return $this->_encode_der($source, array('type' => self::TYPE_REAL) + $mapping, null, $special);
+                    case is_bool($source):
+                        return $this->_encode_der($source, array('type' => self::TYPE_BOOLEAN) + $mapping, null, $special);
+                    case is_array($source) && count($source) == 1:
+                        $typename = implode('', array_keys($source));
+                        $outtype = array_search($typename, $this->ANYmap, true);
+                        if ($outtype !== false) {
+                            return $this->_encode_der($source[$typename], array('type' => $outtype) + $mapping, null, $special);
+                        }
+                }
+
+                $filters = $this->filters;
+                foreach ($loc as $part) {
+                    if (!isset($filters[$part])) {
+                        $filters = false;
+                        break;
+                    }
+                    $filters = $filters[$part];
+                }
+                if ($filters === false) {
+                    user_error('No filters defined for ' . implode('/', $loc));
+                    return false;
+                }
+                return $this->_encode_der($source, $filters + $mapping, null, $special);
+            case self::TYPE_NULL:
+                $value = '';
+                break;
+            case self::TYPE_NUMERIC_STRING:
+            case self::TYPE_TELETEX_STRING:
+            case self::TYPE_PRINTABLE_STRING:
+            case self::TYPE_UNIVERSAL_STRING:
+            case self::TYPE_UTF8_STRING:
+            case self::TYPE_BMP_STRING:
+            case self::TYPE_IA5_STRING:
+            case self::TYPE_VISIBLE_STRING:
+            case self::TYPE_VIDEOTEX_STRING:
+            case self::TYPE_GRAPHIC_STRING:
+            case self::TYPE_GENERAL_STRING:
+                $value = $source;
+                break;
+            case self::TYPE_BOOLEAN:
+                $value = $source ? "\xFF" : "\x00";
+                break;
+            default:
+                user_error('Mapping provides no type definition for ' . implode('/', $this->location));
+                return false;
+        }
+
+        if (isset($idx)) {
+            array_pop($this->location);
+        }
+
+        if (isset($mapping['cast'])) {
+            if (isset($mapping['explicit']) || $mapping['type'] == self::TYPE_CHOICE) {
+                $value = chr($tag) . $this->_encodeLength(strlen($value)) . $value;
+                $tag = ($mapping['class'] << 6) | 0x20 | $mapping['cast'];
+            } else {
+                $tag = ($mapping['class'] << 6) | (ord($temp[0]) & 0x20) | $mapping['cast'];
+            }
+        }
+
+        return chr($tag) . $this->_encodeLength(strlen($value)) . $value;
+    }
+
+    /**
+     * DER-encode the length
+     *
+     * DER supports lengths up to (2**8)**127, however, we'll only support lengths up to (2**8)**4.  See
+     * {@link http://itu.int/ITU-T/studygroups/com17/languages/X.690-0207.pdf#p=13 X.690 paragraph 8.1.3} for more information.
+     *
+     * @access private
+     * @param int $length
+     * @return string
+     */
+    function _encodeLength($length)
+    {
+        if ($length <= 0x7F) {
+            return chr($length);
+        }
+
+        $temp = ltrim(pack('N', $length), chr(0));
+        return pack('Ca*', 0x80 | strlen($temp), $temp);
+    }
+
+    /**
+     * BER-decode the time
+     *
+     * Called by _decode_ber() and in the case of implicit tags asn1map().
+     *
+     * @access private
+     * @param string $content
+     * @param int $tag
+     * @return string
+     */
+    function _decodeTime($content, $tag)
+    {
+        /* UTCTime:
+           http://tools.ietf.org/html/rfc5280#section-4.1.2.5.1
+           http://www.obj-sys.com/asn1tutorial/node15.html
+
+           GeneralizedTime:
+           http://tools.ietf.org/html/rfc5280#section-4.1.2.5.2
+           http://www.obj-sys.com/asn1tutorial/node14.html */
+
+        $format = 'YmdHis';
+
+        if ($tag == self::TYPE_UTC_TIME) {
+            // https://www.itu.int/ITU-T/studygroups/com17/languages/X.690-0207.pdf#page=28 says "the seconds
+            // element shall always be present" but none-the-less I've seen X509 certs where it isn't and if the
+            // browsers parse it phpseclib ought to too
+            if (preg_match('#^(\d{10})(Z|[+-]\d{4})$#', $content, $matches)) {
+                $content = $matches[1] . '00' . $matches[2];
+            }
+            $prefix = substr($content, 0, 2) >= 50 ? '19' : '20';
+            $content = $prefix . $content;
+        } elseif (strpos($content, '.') !== false) {
+            $format.= '.u';
+        }
+
+        if ($content[strlen($content) - 1] == 'Z') {
+            $content = substr($content, 0, -1) . '+0000';
+        }
+
+        if (strpos($content, '-') !== false || strpos($content, '+') !== false) {
+            $format.= 'O';
+        }
+
+        // error supression isn't necessary as of PHP 7.0:
+        // http://php.net/manual/en/migration70.other-changes.php
+        return @DateTime::createFromFormat($format, $content);
+    }
+
+    /**
+     * Set the time format
+     *
+     * Sets the time / date format for asn1map().
+     *
+     * @access public
+     * @param string $format
+     */
+    function setTimeFormat($format)
+    {
+        $this->format = $format;
+    }
+
+    /**
+     * Load OIDs
+     *
+     * Load the relevant OIDs for a particular ASN.1 semantic mapping.
+     *
+     * @access public
+     * @param array $oids
+     */
+    function loadOIDs($oids)
+    {
+        $this->oids = $oids;
+    }
+
+    /**
+     * Load filters
+     *
+     * See \phpseclib\File\X509, etc, for an example.
+     *
+     * @access public
+     * @param array $filters
+     */
+    function loadFilters($filters)
+    {
+        $this->filters = $filters;
+    }
+
+    /**
+     * String Shift
+     *
+     * Inspired by array_shift
+     *
+     * @param string $string
+     * @param int $index
+     * @return string
+     * @access private
+     */
+    function _string_shift(&$string, $index = 1)
+    {
+        $substr = substr($string, 0, $index);
+        $string = substr($string, $index);
+        return $substr;
+    }
+
+    /**
+     * String type conversion
+     *
+     * This is a lazy conversion, dealing only with character size.
+     * No real conversion table is used.
+     *
+     * @param string $in
+     * @param int $from
+     * @param int $to
+     * @return string
+     * @access public
+     */
+    function convert($in, $from = self::TYPE_UTF8_STRING, $to = self::TYPE_UTF8_STRING)
+    {
+        if (!isset($this->stringTypeSize[$from]) || !isset($this->stringTypeSize[$to])) {
+            return false;
+        }
+        $insize = $this->stringTypeSize[$from];
+        $outsize = $this->stringTypeSize[$to];
+        $inlength = strlen($in);
+        $out = '';
+
+        for ($i = 0; $i < $inlength;) {
+            if ($inlength - $i < $insize) {
+                return false;
+            }
+
+            // Get an input character as a 32-bit value.
+            $c = ord($in[$i++]);
+            switch (true) {
+                case $insize == 4:
+                    $c = ($c << 8) | ord($in[$i++]);
+                    $c = ($c << 8) | ord($in[$i++]);
+                case $insize == 2:
+                    $c = ($c << 8) | ord($in[$i++]);
+                case $insize == 1:
+                    break;
+                case ($c & 0x80) == 0x00:
+                    break;
+                case ($c & 0x40) == 0x00:
+                    return false;
+                default:
+                    $bit = 6;
+                    do {
+                        if ($bit > 25 || $i >= $inlength || (ord($in[$i]) & 0xC0) != 0x80) {
+                            return false;
+                        }
+                        $c = ($c << 6) | (ord($in[$i++]) & 0x3F);
+                        $bit += 5;
+                        $mask = 1 << $bit;
+                    } while ($c & $bit);
+                    $c &= $mask - 1;
+                    break;
+            }
+
+            // Convert and append the character to output string.
+            $v = '';
+            switch (true) {
+                case $outsize == 4:
+                    $v .= chr($c & 0xFF);
+                    $c >>= 8;
+                    $v .= chr($c & 0xFF);
+                    $c >>= 8;
+                case $outsize == 2:
+                    $v .= chr($c & 0xFF);
+                    $c >>= 8;
+                case $outsize == 1:
+                    $v .= chr($c & 0xFF);
+                    $c >>= 8;
+                    if ($c) {
+                        return false;
+                    }
+                    break;
+                case ($c & 0x80000000) != 0:
+                    return false;
+                case $c >= 0x04000000:
+                    $v .= chr(0x80 | ($c & 0x3F));
+                    $c = ($c >> 6) | 0x04000000;
+                case $c >= 0x00200000:
+                    $v .= chr(0x80 | ($c & 0x3F));
+                    $c = ($c >> 6) | 0x00200000;
+                case $c >= 0x00010000:
+                    $v .= chr(0x80 | ($c & 0x3F));
+                    $c = ($c >> 6) | 0x00010000;
+                case $c >= 0x00000800:
+                    $v .= chr(0x80 | ($c & 0x3F));
+                    $c = ($c >> 6) | 0x00000800;
+                case $c >= 0x00000080:
+                    $v .= chr(0x80 | ($c & 0x3F));
+                    $c = ($c >> 6) | 0x000000C0;
+                default:
+                    $v .= chr($c);
+                    break;
+            }
+            $out .= strrev($v);
+        }
+        return $out;
+    }
+}
diff --git a/lib/phpseclib/File/ASN1/Element.php b/lib/phpseclib/File/ASN1/Element.php
new file mode 100644
index 0000000..68246e2
--- /dev/null
+++ b/lib/phpseclib/File/ASN1/Element.php
@@ -0,0 +1,47 @@
+<?php
+/**
+ * Pure-PHP ASN.1 Parser
+ *
+ * PHP version 5
+ *
+ * @category  File
+ * @package   ASN1
+ * @author    Jim Wigginton <terrafrost@php.net>
+ * @copyright 2012 Jim Wigginton
+ * @license   http://www.opensource.org/licenses/mit-license.html  MIT License
+ * @link      http://phpseclib.sourceforge.net
+ */
+
+namespace phpseclib\File\ASN1;
+
+/**
+ * ASN.1 Element
+ *
+ * Bypass normal encoding rules in phpseclib\File\ASN1::encodeDER()
+ *
+ * @package ASN1
+ * @author  Jim Wigginton <terrafrost@php.net>
+ * @access  public
+ */
+class Element
+{
+    /**
+     * Raw element value
+     *
+     * @var string
+     * @access private
+     */
+    var $element;
+
+    /**
+     * Constructor
+     *
+     * @param string $encoded
+     * @return \phpseclib\File\ASN1\Element
+     * @access public
+     */
+    function __construct($encoded)
+    {
+        $this->element = $encoded;
+    }
+}
diff --git a/lib/phpseclib/File/X509.php b/lib/phpseclib/File/X509.php
new file mode 100644
index 0000000..f3ee813
--- /dev/null
+++ b/lib/phpseclib/File/X509.php
@@ -0,0 +1,5046 @@
+<?php
+
+/**
+ * Pure-PHP X.509 Parser
+ *
+ * PHP version 5
+ *
+ * Encode and decode X.509 certificates.
+ *
+ * The extensions are from {@link http://tools.ietf.org/html/rfc5280 RFC5280} and
+ * {@link http://web.archive.org/web/19961027104704/http://www3.netscape.com/eng/security/cert-exts.html Netscape Certificate Extensions}.
+ *
+ * Note that loading an X.509 certificate and resaving it may invalidate the signature.  The reason being that the signature is based on a
+ * portion of the certificate that contains optional parameters with default values.  ie. if the parameter isn't there the default value is
+ * used.  Problem is, if the parameter is there and it just so happens to have the default value there are two ways that that parameter can
+ * be encoded.  It can be encoded explicitly or left out all together.  This would effect the signature value and thus may invalidate the
+ * the certificate all together unless the certificate is re-signed.
+ *
+ * @category  File
+ * @package   X509
+ * @author    Jim Wigginton <terrafrost@php.net>
+ * @copyright 2012 Jim Wigginton
+ * @license   http://www.opensource.org/licenses/mit-license.html  MIT License
+ * @link      http://phpseclib.sourceforge.net
+ */
+
+namespace phpseclib\File;
+
+use phpseclib\Crypt\Hash;
+use phpseclib\Crypt\Random;
+use phpseclib\Crypt\RSA;
+use phpseclib\File\ASN1\Element;
+use phpseclib\Math\BigInteger;
+use DateTime;
+use DateTimeZone;
+
+/**
+ * Pure-PHP X.509 Parser
+ *
+ * @package X509
+ * @author  Jim Wigginton <terrafrost@php.net>
+ * @access  public
+ */
+class X509
+{
+    /**
+     * Flag to only accept signatures signed by certificate authorities
+     *
+     * Not really used anymore but retained all the same to suppress E_NOTICEs from old installs
+     *
+     * @access public
+     */
+    const VALIDATE_SIGNATURE_BY_CA = 1;
+
+    /**#@+
+     * @access public
+     * @see \phpseclib\File\X509::getDN()
+    */
+    /**
+     * Return internal array representation
+     */
+    const DN_ARRAY = 0;
+    /**
+     * Return string
+     */
+    const DN_STRING = 1;
+    /**
+     * Return ASN.1 name string
+     */
+    const DN_ASN1 = 2;
+    /**
+     * Return OpenSSL compatible array
+     */
+    const DN_OPENSSL = 3;
+    /**
+     * Return canonical ASN.1 RDNs string
+     */
+    const DN_CANON = 4;
+    /**
+     * Return name hash for file indexing
+     */
+    const DN_HASH = 5;
+    /**#@-*/
+
+    /**#@+
+     * @access public
+     * @see \phpseclib\File\X509::saveX509()
+     * @see \phpseclib\File\X509::saveCSR()
+     * @see \phpseclib\File\X509::saveCRL()
+    */
+    /**
+     * Save as PEM
+     *
+     * ie. a base64-encoded PEM with a header and a footer
+     */
+    const FORMAT_PEM = 0;
+    /**
+     * Save as DER
+     */
+    const FORMAT_DER = 1;
+    /**
+     * Save as a SPKAC
+     *
+     * Only works on CSRs. Not currently supported.
+     */
+    const FORMAT_SPKAC = 2;
+    /**
+     * Auto-detect the format
+     *
+     * Used only by the load*() functions
+     */
+    const FORMAT_AUTO_DETECT = 3;
+    /**#@-*/
+
+    /**
+     * Attribute value disposition.
+     * If disposition is >= 0, this is the index of the target value.
+     */
+    const ATTR_ALL = -1; // All attribute values (array).
+    const ATTR_APPEND = -2; // Add a value.
+    const ATTR_REPLACE = -3; // Clear first, then add a value.
+
+    /**
+     * ASN.1 syntax for X.509 certificates
+     *
+     * @var array
+     * @access private
+     */
+    var $Certificate;
+
+    /**#@+
+     * ASN.1 syntax for various extensions
+     *
+     * @access private
+     */
+    var $DirectoryString;
+    var $PKCS9String;
+    var $AttributeValue;
+    var $Extensions;
+    var $KeyUsage;
+    var $ExtKeyUsageSyntax;
+    var $BasicConstraints;
+    var $KeyIdentifier;
+    var $CRLDistributionPoints;
+    var $AuthorityKeyIdentifier;
+    var $CertificatePolicies;
+    var $AuthorityInfoAccessSyntax;
+    var $SubjectAltName;
+    var $SubjectDirectoryAttributes;
+    var $PrivateKeyUsagePeriod;
+    var $IssuerAltName;
+    var $PolicyMappings;
+    var $NameConstraints;
+
+    var $CPSuri;
+    var $UserNotice;
+
+    var $netscape_cert_type;
+    var $netscape_comment;
+    var $netscape_ca_policy_url;
+
+    var $Name;
+    var $RelativeDistinguishedName;
+    var $CRLNumber;
+    var $CRLReason;
+    var $IssuingDistributionPoint;
+    var $InvalidityDate;
+    var $CertificateIssuer;
+    var $HoldInstructionCode;
+    var $SignedPublicKeyAndChallenge;
+    /**#@-*/
+
+    /**#@+
+     * ASN.1 syntax for various DN attributes
+     *
+     * @access private
+     */
+    var $PostalAddress;
+    /**#@-*/
+
+    /**
+     * ASN.1 syntax for Certificate Signing Requests (RFC2986)
+     *
+     * @var array
+     * @access private
+     */
+    var $CertificationRequest;
+
+    /**
+     * ASN.1 syntax for Certificate Revocation Lists (RFC5280)
+     *
+     * @var array
+     * @access private
+     */
+    var $CertificateList;
+
+    /**
+     * Distinguished Name
+     *
+     * @var array
+     * @access private
+     */
+    var $dn;
+
+    /**
+     * Public key
+     *
+     * @var string
+     * @access private
+     */
+    var $publicKey;
+
+    /**
+     * Private key
+     *
+     * @var string
+     * @access private
+     */
+    var $privateKey;
+
+    /**
+     * Object identifiers for X.509 certificates
+     *
+     * @var array
+     * @access private
+     * @link http://en.wikipedia.org/wiki/Object_identifier
+     */
+    var $oids;
+
+    /**
+     * The certificate authorities
+     *
+     * @var array
+     * @access private
+     */
+    var $CAs;
+
+    /**
+     * The currently loaded certificate
+     *
+     * @var array
+     * @access private
+     */
+    var $currentCert;
+
+    /**
+     * The signature subject
+     *
+     * There's no guarantee \phpseclib\File\X509 is going to re-encode an X.509 cert in the same way it was originally
+     * encoded so we take save the portion of the original cert that the signature would have made for.
+     *
+     * @var string
+     * @access private
+     */
+    var $signatureSubject;
+
+    /**
+     * Certificate Start Date
+     *
+     * @var string
+     * @access private
+     */
+    var $startDate;
+
+    /**
+     * Certificate End Date
+     *
+     * @var string
+     * @access private
+     */
+    var $endDate;
+
+    /**
+     * Serial Number
+     *
+     * @var string
+     * @access private
+     */
+    var $serialNumber;
+
+    /**
+     * Key Identifier
+     *
+     * See {@link http://tools.ietf.org/html/rfc5280#section-4.2.1.1 RFC5280#section-4.2.1.1} and
+     * {@link http://tools.ietf.org/html/rfc5280#section-4.2.1.2 RFC5280#section-4.2.1.2}.
+     *
+     * @var string
+     * @access private
+     */
+    var $currentKeyIdentifier;
+
+    /**
+     * CA Flag
+     *
+     * @var bool
+     * @access private
+     */
+    var $caFlag = false;
+
+    /**
+     * SPKAC Challenge
+     *
+     * @var string
+     * @access private
+     */
+    var $challenge;
+
+    /**
+     * Recursion Limit
+     *
+     * @var int
+     * @access private
+     */
+    static $recur_limit = 5;
+
+    /**
+     * URL fetch flag
+     *
+     * @var bool
+     * @access private
+     */
+    static $disable_url_fetch = false;
+
+    /**
+     * Default Constructor.
+     *
+     * @return \phpseclib\File\X509
+     * @access public
+     */
+    function __construct()
+    {
+        // Explicitly Tagged Module, 1988 Syntax
+        // http://tools.ietf.org/html/rfc5280#appendix-A.1
+
+        $this->DirectoryString = array(
+            'type'     => ASN1::TYPE_CHOICE,
+            'children' => array(
+                'teletexString'   => array('type' => ASN1::TYPE_TELETEX_STRING),
+                'printableString' => array('type' => ASN1::TYPE_PRINTABLE_STRING),
+                'universalString' => array('type' => ASN1::TYPE_UNIVERSAL_STRING),
+                'utf8String'      => array('type' => ASN1::TYPE_UTF8_STRING),
+                'bmpString'       => array('type' => ASN1::TYPE_BMP_STRING)
+            )
+        );
+
+        $this->PKCS9String = array(
+            'type'     => ASN1::TYPE_CHOICE,
+            'children' => array(
+                'ia5String'       => array('type' => ASN1::TYPE_IA5_STRING),
+                'directoryString' => $this->DirectoryString
+            )
+        );
+
+        $this->AttributeValue = array('type' => ASN1::TYPE_ANY);
+
+        $AttributeType = array('type' => ASN1::TYPE_OBJECT_IDENTIFIER);
+
+        $AttributeTypeAndValue = array(
+            'type'     => ASN1::TYPE_SEQUENCE,
+            'children' => array(
+                'type' => $AttributeType,
+                'value'=> $this->AttributeValue
+            )
+        );
+
+        /*
+        In practice, RDNs containing multiple name-value pairs (called "multivalued RDNs") are rare,
+        but they can be useful at times when either there is no unique attribute in the entry or you
+        want to ensure that the entry's DN contains some useful identifying information.
+
+        - https://www.opends.org/wiki/page/DefinitionRelativeDistinguishedName
+        */
+        $this->RelativeDistinguishedName = array(
+            'type'     => ASN1::TYPE_SET,
+            'min'      => 1,
+            'max'      => -1,
+            'children' => $AttributeTypeAndValue
+        );
+
+        // http://tools.ietf.org/html/rfc5280#section-4.1.2.4
+        $RDNSequence = array(
+            'type'     => ASN1::TYPE_SEQUENCE,
+            // RDNSequence does not define a min or a max, which means it doesn't have one
+            'min'      => 0,
+            'max'      => -1,
+            'children' => $this->RelativeDistinguishedName
+        );
+
+        $this->Name = array(
+            'type'     => ASN1::TYPE_CHOICE,
+            'children' => array(
+                'rdnSequence' => $RDNSequence
+            )
+        );
+
+        // http://tools.ietf.org/html/rfc5280#section-4.1.1.2
+        $AlgorithmIdentifier = array(
+            'type'     => ASN1::TYPE_SEQUENCE,
+            'children' => array(
+                'algorithm'  => array('type' => ASN1::TYPE_OBJECT_IDENTIFIER),
+                'parameters' => array(
+                                    'type'     => ASN1::TYPE_ANY,
+                                    'optional' => true
+                                )
+            )
+        );
+
+        /*
+           A certificate using system MUST reject the certificate if it encounters
+           a critical extension it does not recognize; however, a non-critical
+           extension may be ignored if it is not recognized.
+
+           http://tools.ietf.org/html/rfc5280#section-4.2
+        */
+        $Extension = array(
+            'type'     => ASN1::TYPE_SEQUENCE,
+            'children' => array(
+                'extnId'   => array('type' => ASN1::TYPE_OBJECT_IDENTIFIER),
+                'critical' => array(
+                                  'type'     => ASN1::TYPE_BOOLEAN,
+                                  'optional' => true,
+                                  'default'  => false
+                              ),
+                'extnValue' => array('type' => ASN1::TYPE_OCTET_STRING)
+            )
+        );
+
+        $this->Extensions = array(
+            'type'     => ASN1::TYPE_SEQUENCE,
+            'min'      => 1,
+            // technically, it's MAX, but we'll assume anything < 0 is MAX
+            'max'      => -1,
+            // if 'children' isn't an array then 'min' and 'max' must be defined
+            'children' => $Extension
+        );
+
+        $SubjectPublicKeyInfo = array(
+            'type'     => ASN1::TYPE_SEQUENCE,
+            'children' => array(
+                'algorithm'        => $AlgorithmIdentifier,
+                'subjectPublicKey' => array('type' => ASN1::TYPE_BIT_STRING)
+            )
+        );
+
+        $UniqueIdentifier = array('type' => ASN1::TYPE_BIT_STRING);
+
+        $Time = array(
+            'type'     => ASN1::TYPE_CHOICE,
+            'children' => array(
+                'utcTime'     => array('type' => ASN1::TYPE_UTC_TIME),
+                'generalTime' => array('type' => ASN1::TYPE_GENERALIZED_TIME)
+            )
+        );
+
+        // http://tools.ietf.org/html/rfc5280#section-4.1.2.5
+        $Validity = array(
+            'type'     => ASN1::TYPE_SEQUENCE,
+            'children' => array(
+                'notBefore' => $Time,
+                'notAfter'  => $Time
+            )
+        );
+
+        $CertificateSerialNumber = array('type' => ASN1::TYPE_INTEGER);
+
+        $Version = array(
+            'type'    => ASN1::TYPE_INTEGER,
+            'mapping' => array('v1', 'v2', 'v3')
+        );
+
+        // assert($TBSCertificate['children']['signature'] == $Certificate['children']['signatureAlgorithm'])
+        $TBSCertificate = array(
+            'type'     => ASN1::TYPE_SEQUENCE,
+            'children' => array(
+                // technically, default implies optional, but we'll define it as being optional, none-the-less, just to
+                // reenforce that fact
+                'version'             => array(
+                                             'constant' => 0,
+                                             'optional' => true,
+                                             'explicit' => true,
+                                             'default'  => 'v1'
+                                         ) + $Version,
+                'serialNumber'         => $CertificateSerialNumber,
+                'signature'            => $AlgorithmIdentifier,
+                'issuer'               => $this->Name,
+                'validity'             => $Validity,
+                'subject'              => $this->Name,
+                'subjectPublicKeyInfo' => $SubjectPublicKeyInfo,
+                // implicit means that the T in the TLV structure is to be rewritten, regardless of the type
+                'issuerUniqueID'       => array(
+                                               'constant' => 1,
+                                               'optional' => true,
+                                               'implicit' => true
+                                           ) + $UniqueIdentifier,
+                'subjectUniqueID'       => array(
+                                               'constant' => 2,
+                                               'optional' => true,
+                                               'implicit' => true
+                                           ) + $UniqueIdentifier,
+                // <http://tools.ietf.org/html/rfc2459#page-74> doesn't use the EXPLICIT keyword but if
+                // it's not IMPLICIT, it's EXPLICIT
+                'extensions'            => array(
+                                               'constant' => 3,
+                                               'optional' => true,
+                                               'explicit' => true
+                                           ) + $this->Extensions
+            )
+        );
+
+        $this->Certificate = array(
+            'type'     => ASN1::TYPE_SEQUENCE,
+            'children' => array(
+                 'tbsCertificate'     => $TBSCertificate,
+                 'signatureAlgorithm' => $AlgorithmIdentifier,
+                 'signature'          => array('type' => ASN1::TYPE_BIT_STRING)
+            )
+        );
+
+        $this->KeyUsage = array(
+            'type'    => ASN1::TYPE_BIT_STRING,
+            'mapping' => array(
+                'digitalSignature',
+                'nonRepudiation',
+                'keyEncipherment',
+                'dataEncipherment',
+                'keyAgreement',
+                'keyCertSign',
+                'cRLSign',
+                'encipherOnly',
+                'decipherOnly'
+            )
+        );
+
+        $this->BasicConstraints = array(
+            'type'     => ASN1::TYPE_SEQUENCE,
+            'children' => array(
+                'cA'                => array(
+                                                 'type'     => ASN1::TYPE_BOOLEAN,
+                                                 'optional' => true,
+                                                 'default'  => false
+                                       ),
+                'pathLenConstraint' => array(
+                                                 'type' => ASN1::TYPE_INTEGER,
+                                                 'optional' => true
+                                       )
+            )
+        );
+
+        $this->KeyIdentifier = array('type' => ASN1::TYPE_OCTET_STRING);
+
+        $OrganizationalUnitNames = array(
+            'type'     => ASN1::TYPE_SEQUENCE,
+            'min'      => 1,
+            'max'      => 4, // ub-organizational-units
+            'children' => array('type' => ASN1::TYPE_PRINTABLE_STRING)
+        );
+
+        $PersonalName = array(
+            'type'     => ASN1::TYPE_SET,
+            'children' => array(
+                'surname'              => array(
+                                           'type' => ASN1::TYPE_PRINTABLE_STRING,
+                                           'constant' => 0,
+                                           'optional' => true,
+                                           'implicit' => true
+                                         ),
+                'given-name'           => array(
+                                           'type' => ASN1::TYPE_PRINTABLE_STRING,
+                                           'constant' => 1,
+                                           'optional' => true,
+                                           'implicit' => true
+                                         ),
+                'initials'             => array(
+                                           'type' => ASN1::TYPE_PRINTABLE_STRING,
+                                           'constant' => 2,
+                                           'optional' => true,
+                                           'implicit' => true
+                                         ),
+                'generation-qualifier' => array(
+                                           'type' => ASN1::TYPE_PRINTABLE_STRING,
+                                           'constant' => 3,
+                                           'optional' => true,
+                                           'implicit' => true
+                                         )
+            )
+        );
+
+        $NumericUserIdentifier = array('type' => ASN1::TYPE_NUMERIC_STRING);
+
+        $OrganizationName = array('type' => ASN1::TYPE_PRINTABLE_STRING);
+
+        $PrivateDomainName = array(
+            'type'     => ASN1::TYPE_CHOICE,
+            'children' => array(
+                'numeric'   => array('type' => ASN1::TYPE_NUMERIC_STRING),
+                'printable' => array('type' => ASN1::TYPE_PRINTABLE_STRING)
+            )
+        );
+
+        $TerminalIdentifier = array('type' => ASN1::TYPE_PRINTABLE_STRING);
+
+        $NetworkAddress = array('type' => ASN1::TYPE_NUMERIC_STRING);
+
+        $AdministrationDomainName = array(
+            'type'     => ASN1::TYPE_CHOICE,
+            // if class isn't present it's assumed to be \phpseclib\File\ASN1::CLASS_UNIVERSAL or
+            // (if constant is present) \phpseclib\File\ASN1::CLASS_CONTEXT_SPECIFIC
+            'class'    => ASN1::CLASS_APPLICATION,
+            'cast'     => 2,
+            'children' => array(
+                'numeric'   => array('type' => ASN1::TYPE_NUMERIC_STRING),
+                'printable' => array('type' => ASN1::TYPE_PRINTABLE_STRING)
+            )
+        );
+
+        $CountryName = array(
+            'type'     => ASN1::TYPE_CHOICE,
+            // if class isn't present it's assumed to be \phpseclib\File\ASN1::CLASS_UNIVERSAL or
+            // (if constant is present) \phpseclib\File\ASN1::CLASS_CONTEXT_SPECIFIC
+            'class'    => ASN1::CLASS_APPLICATION,
+            'cast'     => 1,
+            'children' => array(
+                'x121-dcc-code'        => array('type' => ASN1::TYPE_NUMERIC_STRING),
+                'iso-3166-alpha2-code' => array('type' => ASN1::TYPE_PRINTABLE_STRING)
+            )
+        );
+
+        $AnotherName = array(
+            'type'     => ASN1::TYPE_SEQUENCE,
+            'children' => array(
+                 'type-id' => array('type' => ASN1::TYPE_OBJECT_IDENTIFIER),
+                 'value'   => array(
+                                  'type' => ASN1::TYPE_ANY,
+                                  'constant' => 0,
+                                  'optional' => true,
+                                  'explicit' => true
+                              )
+            )
+        );
+
+        $ExtensionAttribute = array(
+            'type'     => ASN1::TYPE_SEQUENCE,
+            'children' => array(
+                 'extension-attribute-type'  => array(
+                                                    'type' => ASN1::TYPE_PRINTABLE_STRING,
+                                                    'constant' => 0,
+                                                    'optional' => true,
+                                                    'implicit' => true
+                                                ),
+                 'extension-attribute-value' => array(
+                                                    'type' => ASN1::TYPE_ANY,
+                                                    'constant' => 1,
+                                                    'optional' => true,
+                                                    'explicit' => true
+                                                )
+            )
+        );
+
+        $ExtensionAttributes = array(
+            'type'     => ASN1::TYPE_SET,
+            'min'      => 1,
+            'max'      => 256, // ub-extension-attributes
+            'children' => $ExtensionAttribute
+        );
+
+        $BuiltInDomainDefinedAttribute = array(
+            'type'     => ASN1::TYPE_SEQUENCE,
+            'children' => array(
+                 'type'  => array('type' => ASN1::TYPE_PRINTABLE_STRING),
+                 'value' => array('type' => ASN1::TYPE_PRINTABLE_STRING)
+            )
+        );
+
+        $BuiltInDomainDefinedAttributes = array(
+            'type'     => ASN1::TYPE_SEQUENCE,
+            'min'      => 1,
+            'max'      => 4, // ub-domain-defined-attributes
+            'children' => $BuiltInDomainDefinedAttribute
+        );
+
+        $BuiltInStandardAttributes =  array(
+            'type'     => ASN1::TYPE_SEQUENCE,
+            'children' => array(
+                'country-name'               => array('optional' => true) + $CountryName,
+                'administration-domain-name' => array('optional' => true) + $AdministrationDomainName,
+                'network-address'            => array(
+                                                 'constant' => 0,
+                                                 'optional' => true,
+                                                 'implicit' => true
+                                               ) + $NetworkAddress,
+                'terminal-identifier'        => array(
+                                                 'constant' => 1,
+                                                 'optional' => true,
+                                                 'implicit' => true
+                                               ) + $TerminalIdentifier,
+                'private-domain-name'        => array(
+                                                 'constant' => 2,
+                                                 'optional' => true,
+                                                 'explicit' => true
+                                               ) + $PrivateDomainName,
+                'organization-name'          => array(
+                                                 'constant' => 3,
+                                                 'optional' => true,
+                                                 'implicit' => true
+                                               ) + $OrganizationName,
+                'numeric-user-identifier'    => array(
+                                                 'constant' => 4,
+                                                 'optional' => true,
+                                                 'implicit' => true
+                                               ) + $NumericUserIdentifier,
+                'personal-name'              => array(
+                                                 'constant' => 5,
+                                                 'optional' => true,
+                                                 'implicit' => true
+                                               ) + $PersonalName,
+                'organizational-unit-names'  => array(
+                                                 'constant' => 6,
+                                                 'optional' => true,
+                                                 'implicit' => true
+                                               ) + $OrganizationalUnitNames
+            )
+        );
+
+        $ORAddress = array(
+            'type'     => ASN1::TYPE_SEQUENCE,
+            'children' => array(
+                 'built-in-standard-attributes'       => $BuiltInStandardAttributes,
+                 'built-in-domain-defined-attributes' => array('optional' => true) + $BuiltInDomainDefinedAttributes,
+                 'extension-attributes'               => array('optional' => true) + $ExtensionAttributes
+            )
+        );
+
+        $EDIPartyName = array(
+            'type'     => ASN1::TYPE_SEQUENCE,
+            'children' => array(
+                 'nameAssigner' => array(
+                                    'constant' => 0,
+                                    'optional' => true,
+                                    'implicit' => true
+                                ) + $this->DirectoryString,
+                 // partyName is technically required but \phpseclib\File\ASN1 doesn't currently support non-optional constants and
+                 // setting it to optional gets the job done in any event.
+                 'partyName'    => array(
+                                    'constant' => 1,
+                                    'optional' => true,
+                                    'implicit' => true
+                                ) + $this->DirectoryString
+            )
+        );
+
+        $GeneralName = array(
+            'type'     => ASN1::TYPE_CHOICE,
+            'children' => array(
+                'otherName'                 => array(
+                                                 'constant' => 0,
+                                                 'optional' => true,
+                                                 'implicit' => true
+                                               ) + $AnotherName,
+                'rfc822Name'                => array(
+                                                 'type' => ASN1::TYPE_IA5_STRING,
+                                                 'constant' => 1,
+                                                 'optional' => true,
+                                                 'implicit' => true
+                                               ),
+                'dNSName'                   => array(
+                                                 'type' => ASN1::TYPE_IA5_STRING,
+                                                 'constant' => 2,
+                                                 'optional' => true,
+                                                 'implicit' => true
+                                               ),
+                'x400Address'               => array(
+                                                 'constant' => 3,
+                                                 'optional' => true,
+                                                 'implicit' => true
+                                               ) + $ORAddress,
+                'directoryName'             => array(
+                                                 'constant' => 4,
+                                                 'optional' => true,
+                                                 'explicit' => true
+                                               ) + $this->Name,
+                'ediPartyName'              => array(
+                                                 'constant' => 5,
+                                                 'optional' => true,
+                                                 'implicit' => true
+                                               ) + $EDIPartyName,
+                'uniformResourceIdentifier' => array(
+                                                 'type' => ASN1::TYPE_IA5_STRING,
+                                                 'constant' => 6,
+                                                 'optional' => true,
+                                                 'implicit' => true
+                                               ),
+                'iPAddress'                 => array(
+                                                 'type' => ASN1::TYPE_OCTET_STRING,
+                                                 'constant' => 7,
+                                                 'optional' => true,
+                                                 'implicit' => true
+                                               ),
+                'registeredID'              => array(
+                                                 'type' => ASN1::TYPE_OBJECT_IDENTIFIER,
+                                                 'constant' => 8,
+                                                 'optional' => true,
+                                                 'implicit' => true
+                                               )
+            )
+        );
+
+        $GeneralNames = array(
+            'type'     => ASN1::TYPE_SEQUENCE,
+            'min'      => 1,
+            'max'      => -1,
+            'children' => $GeneralName
+        );
+
+        $this->IssuerAltName = $GeneralNames;
+
+        $ReasonFlags = array(
+            'type'    => ASN1::TYPE_BIT_STRING,
+            'mapping' => array(
+                'unused',
+                'keyCompromise',
+                'cACompromise',
+                'affiliationChanged',
+                'superseded',
+                'cessationOfOperation',
+                'certificateHold',
+                'privilegeWithdrawn',
+                'aACompromise'
+            )
+        );
+
+        $DistributionPointName = array(
+            'type'     => ASN1::TYPE_CHOICE,
+            'children' => array(
+                'fullName'                => array(
+                                                 'constant' => 0,
+                                                 'optional' => true,
+                                                 'implicit' => true
+                                       ) + $GeneralNames,
+                'nameRelativeToCRLIssuer' => array(
+                                                 'constant' => 1,
+                                                 'optional' => true,
+                                                 'implicit' => true
+                                       ) + $this->RelativeDistinguishedName
+            )
+        );
+
+        $DistributionPoint = array(
+            'type'     => ASN1::TYPE_SEQUENCE,
+            'children' => array(
+                'distributionPoint' => array(
+                                                 'constant' => 0,
+                                                 'optional' => true,
+                                                 'explicit' => true
+                                       ) + $DistributionPointName,
+                'reasons'           => array(
+                                                 'constant' => 1,
+                                                 'optional' => true,
+                                                 'implicit' => true
+                                       ) + $ReasonFlags,
+                'cRLIssuer'         => array(
+                                                 'constant' => 2,
+                                                 'optional' => true,
+                                                 'implicit' => true
+                                       ) + $GeneralNames
+            )
+        );
+
+        $this->CRLDistributionPoints = array(
+            'type'     => ASN1::TYPE_SEQUENCE,
+            'min'      => 1,
+            'max'      => -1,
+            'children' => $DistributionPoint
+        );
+
+        $this->AuthorityKeyIdentifier = array(
+            'type'     => ASN1::TYPE_SEQUENCE,
+            'children' => array(
+                'keyIdentifier'             => array(
+                                                 'constant' => 0,
+                                                 'optional' => true,
+                                                 'implicit' => true
+                                               ) + $this->KeyIdentifier,
+                'authorityCertIssuer'       => array(
+                                                 'constant' => 1,
+                                                 'optional' => true,
+                                                 'implicit' => true
+                                               ) + $GeneralNames,
+                'authorityCertSerialNumber' => array(
+                                                 'constant' => 2,
+                                                 'optional' => true,
+                                                 'implicit' => true
+                                               ) + $CertificateSerialNumber
+            )
+        );
+
+        $PolicyQualifierId = array('type' => ASN1::TYPE_OBJECT_IDENTIFIER);
+
+        $PolicyQualifierInfo = array(
+            'type'     => ASN1::TYPE_SEQUENCE,
+            'children' => array(
+                'policyQualifierId' => $PolicyQualifierId,
+                'qualifier'         => array('type' => ASN1::TYPE_ANY)
+            )
+        );
+
+        $CertPolicyId = array('type' => ASN1::TYPE_OBJECT_IDENTIFIER);
+
+        $PolicyInformation = array(
+            'type'     => ASN1::TYPE_SEQUENCE,
+            'children' => array(
+                'policyIdentifier' => $CertPolicyId,
+                'policyQualifiers' => array(
+                                          'type'     => ASN1::TYPE_SEQUENCE,
+                                          'min'      => 0,
+                                          'max'      => -1,
+                                          'optional' => true,
+                                          'children' => $PolicyQualifierInfo
+                                      )
+            )
+        );
+
+        $this->CertificatePolicies = array(
+            'type'     => ASN1::TYPE_SEQUENCE,
+            'min'      => 1,
+            'max'      => -1,
+            'children' => $PolicyInformation
+        );
+
+        $this->PolicyMappings = array(
+            'type'     => ASN1::TYPE_SEQUENCE,
+            'min'      => 1,
+            'max'      => -1,
+            'children' => array(
+                              'type'     => ASN1::TYPE_SEQUENCE,
+                              'children' => array(
+                                  'issuerDomainPolicy' => $CertPolicyId,
+                                  'subjectDomainPolicy' => $CertPolicyId
+                              )
+                       )
+        );
+
+        $KeyPurposeId = array('type' => ASN1::TYPE_OBJECT_IDENTIFIER);
+
+        $this->ExtKeyUsageSyntax = array(
+            'type'     => ASN1::TYPE_SEQUENCE,
+            'min'      => 1,
+            'max'      => -1,
+            'children' => $KeyPurposeId
+        );
+
+        $AccessDescription = array(
+            'type'     => ASN1::TYPE_SEQUENCE,
+            'children' => array(
+                'accessMethod'   => array('type' => ASN1::TYPE_OBJECT_IDENTIFIER),
+                'accessLocation' => $GeneralName
+            )
+        );
+
+        $this->AuthorityInfoAccessSyntax = array(
+            'type'     => ASN1::TYPE_SEQUENCE,
+            'min'      => 1,
+            'max'      => -1,
+            'children' => $AccessDescription
+        );
+
+        $this->SubjectAltName = $GeneralNames;
+
+        $this->PrivateKeyUsagePeriod = array(
+            'type'     => ASN1::TYPE_SEQUENCE,
+            'children' => array(
+                'notBefore' => array(
+                                                 'constant' => 0,
+                                                 'optional' => true,
+                                                 'implicit' => true,
+                                                 'type' => ASN1::TYPE_GENERALIZED_TIME),
+                'notAfter'  => array(
+                                                 'constant' => 1,
+                                                 'optional' => true,
+                                                 'implicit' => true,
+                                                 'type' => ASN1::TYPE_GENERALIZED_TIME)
+            )
+        );
+
+        $BaseDistance = array('type' => ASN1::TYPE_INTEGER);
+
+        $GeneralSubtree = array(
+            'type'     => ASN1::TYPE_SEQUENCE,
+            'children' => array(
+                'base'    => $GeneralName,
+                'minimum' => array(
+                                 'constant' => 0,
+                                 'optional' => true,
+                                 'implicit' => true,
+                                 'default' => new BigInteger(0)
+                             ) + $BaseDistance,
+                'maximum' => array(
+                                 'constant' => 1,
+                                 'optional' => true,
+                                 'implicit' => true,
+                             ) + $BaseDistance
+            )
+        );
+
+        $GeneralSubtrees = array(
+            'type'     => ASN1::TYPE_SEQUENCE,
+            'min'      => 1,
+            'max'      => -1,
+            'children' => $GeneralSubtree
+        );
+
+        $this->NameConstraints = array(
+            'type'     => ASN1::TYPE_SEQUENCE,
+            'children' => array(
+                'permittedSubtrees' => array(
+                                           'constant' => 0,
+                                           'optional' => true,
+                                           'implicit' => true
+                                       ) + $GeneralSubtrees,
+                'excludedSubtrees'  => array(
+                                           'constant' => 1,
+                                           'optional' => true,
+                                           'implicit' => true
+                                       ) + $GeneralSubtrees
+            )
+        );
+
+        $this->CPSuri = array('type' => ASN1::TYPE_IA5_STRING);
+
+        $DisplayText = array(
+            'type'     => ASN1::TYPE_CHOICE,
+            'children' => array(
+                'ia5String'     => array('type' => ASN1::TYPE_IA5_STRING),
+                'visibleString' => array('type' => ASN1::TYPE_VISIBLE_STRING),
+                'bmpString'     => array('type' => ASN1::TYPE_BMP_STRING),
+                'utf8String'    => array('type' => ASN1::TYPE_UTF8_STRING)
+            )
+        );
+
+        $NoticeReference = array(
+            'type'     => ASN1::TYPE_SEQUENCE,
+            'children' => array(
+                'organization'  => $DisplayText,
+                'noticeNumbers' => array(
+                                       'type'     => ASN1::TYPE_SEQUENCE,
+                                       'min'      => 1,
+                                       'max'      => 200,
+                                       'children' => array('type' => ASN1::TYPE_INTEGER)
+                                   )
+            )
+        );
+
+        $this->UserNotice = array(
+            'type'     => ASN1::TYPE_SEQUENCE,
+            'children' => array(
+                'noticeRef' => array(
+                                           'optional' => true,
+                                           'implicit' => true
+                                       ) + $NoticeReference,
+                'explicitText'  => array(
+                                           'optional' => true,
+                                           'implicit' => true
+                                       ) + $DisplayText
+            )
+        );
+
+        // mapping is from <http://www.mozilla.org/projects/security/pki/nss/tech-notes/tn3.html>
+        $this->netscape_cert_type = array(
+            'type'    => ASN1::TYPE_BIT_STRING,
+            'mapping' => array(
+                'SSLClient',
+                'SSLServer',
+                'Email',
+                'ObjectSigning',
+                'Reserved',
+                'SSLCA',
+                'EmailCA',
+                'ObjectSigningCA'
+            )
+        );
+
+        $this->netscape_comment = array('type' => ASN1::TYPE_IA5_STRING);
+        $this->netscape_ca_policy_url = array('type' => ASN1::TYPE_IA5_STRING);
+
+        // attribute is used in RFC2986 but we're using the RFC5280 definition
+
+        $Attribute = array(
+            'type'     => ASN1::TYPE_SEQUENCE,
+            'children' => array(
+                'type' => $AttributeType,
+                'value'=> array(
+                              'type'     => ASN1::TYPE_SET,
+                              'min'      => 1,
+                              'max'      => -1,
+                              'children' => $this->AttributeValue
+                          )
+            )
+        );
+
+        $this->SubjectDirectoryAttributes = array(
+            'type'     => ASN1::TYPE_SEQUENCE,
+            'min'      => 1,
+            'max'      => -1,
+            'children' => $Attribute
+        );
+
+        // adapted from <http://tools.ietf.org/html/rfc2986>
+
+        $Attributes = array(
+            'type'     => ASN1::TYPE_SET,
+            'min'      => 1,
+            'max'      => -1,
+            'children' => $Attribute
+        );
+
+        $CertificationRequestInfo = array(
+            'type'     => ASN1::TYPE_SEQUENCE,
+            'children' => array(
+                'version'       => array(
+                                       'type' => ASN1::TYPE_INTEGER,
+                                       'mapping' => array('v1')
+                                   ),
+                'subject'       => $this->Name,
+                'subjectPKInfo' => $SubjectPublicKeyInfo,
+                'attributes'    => array(
+                                       'constant' => 0,
+                                       'optional' => true,
+                                       'implicit' => true
+                                   ) + $Attributes,
+            )
+        );
+
+        $this->CertificationRequest = array(
+            'type'     => ASN1::TYPE_SEQUENCE,
+            'children' => array(
+                'certificationRequestInfo' => $CertificationRequestInfo,
+                'signatureAlgorithm'       => $AlgorithmIdentifier,
+                'signature'                => array('type' => ASN1::TYPE_BIT_STRING)
+            )
+        );
+
+        $RevokedCertificate = array(
+            'type'     => ASN1::TYPE_SEQUENCE,
+            'children' => array(
+                              'userCertificate'    => $CertificateSerialNumber,
+                              'revocationDate'     => $Time,
+                              'crlEntryExtensions' => array(
+                                                          'optional' => true
+                                                      ) + $this->Extensions
+                          )
+        );
+
+        $TBSCertList = array(
+            'type'     => ASN1::TYPE_SEQUENCE,
+            'children' => array(
+                'version'             => array(
+                                             'optional' => true,
+                                             'default'  => 'v1'
+                                         ) + $Version,
+                'signature'           => $AlgorithmIdentifier,
+                'issuer'              => $this->Name,
+                'thisUpdate'          => $Time,
+                'nextUpdate'          => array(
+                                             'optional' => true
+                                         ) + $Time,
+                'revokedCertificates' => array(
+                                             'type'     => ASN1::TYPE_SEQUENCE,
+                                             'optional' => true,
+                                             'min'      => 0,
+                                             'max'      => -1,
+                                             'children' => $RevokedCertificate
+                                         ),
+                'crlExtensions'       => array(
+                                             'constant' => 0,
+                                             'optional' => true,
+                                             'explicit' => true
+                                         ) + $this->Extensions
+            )
+        );
+
+        $this->CertificateList = array(
+            'type'     => ASN1::TYPE_SEQUENCE,
+            'children' => array(
+                'tbsCertList'        => $TBSCertList,
+                'signatureAlgorithm' => $AlgorithmIdentifier,
+                'signature'          => array('type' => ASN1::TYPE_BIT_STRING)
+            )
+        );
+
+        $this->CRLNumber = array('type' => ASN1::TYPE_INTEGER);
+
+        $this->CRLReason = array('type' => ASN1::TYPE_ENUMERATED,
+           'mapping' => array(
+                            'unspecified',
+                            'keyCompromise',
+                            'cACompromise',
+                            'affiliationChanged',
+                            'superseded',
+                            'cessationOfOperation',
+                            'certificateHold',
+                            // Value 7 is not used.
+                            8 => 'removeFromCRL',
+                            'privilegeWithdrawn',
+                            'aACompromise'
+            )
+        );
+
+        $this->IssuingDistributionPoint = array('type' => ASN1::TYPE_SEQUENCE,
+            'children' => array(
+                'distributionPoint'          => array(
+                                                    'constant' => 0,
+                                                    'optional' => true,
+                                                    'explicit' => true
+                                                ) + $DistributionPointName,
+                'onlyContainsUserCerts'      => array(
+                                                    'type'     => ASN1::TYPE_BOOLEAN,
+                                                    'constant' => 1,
+                                                    'optional' => true,
+                                                    'default'  => false,
+                                                    'implicit' => true
+                                                ),
+                'onlyContainsCACerts'        => array(
+                                                    'type'     => ASN1::TYPE_BOOLEAN,
+                                                    'constant' => 2,
+                                                    'optional' => true,
+                                                    'default'  => false,
+                                                    'implicit' => true
+                                                ),
+                'onlySomeReasons'           => array(
+                                                    'constant' => 3,
+                                                    'optional' => true,
+                                                    'implicit' => true
+                                                ) + $ReasonFlags,
+                'indirectCRL'               => array(
+                                                    'type'     => ASN1::TYPE_BOOLEAN,
+                                                    'constant' => 4,
+                                                    'optional' => true,
+                                                    'default'  => false,
+                                                    'implicit' => true
+                                                ),
+                'onlyContainsAttributeCerts' => array(
+                                                    'type'     => ASN1::TYPE_BOOLEAN,
+                                                    'constant' => 5,
+                                                    'optional' => true,
+                                                    'default'  => false,
+                                                    'implicit' => true
+                                                )
+                          )
+        );
+
+        $this->InvalidityDate = array('type' => ASN1::TYPE_GENERALIZED_TIME);
+
+        $this->CertificateIssuer = $GeneralNames;
+
+        $this->HoldInstructionCode = array('type' => ASN1::TYPE_OBJECT_IDENTIFIER);
+
+        $PublicKeyAndChallenge = array(
+            'type'     => ASN1::TYPE_SEQUENCE,
+            'children' => array(
+                'spki'      => $SubjectPublicKeyInfo,
+                'challenge' => array('type' => ASN1::TYPE_IA5_STRING)
+            )
+        );
+
+        $this->SignedPublicKeyAndChallenge = array(
+            'type'     => ASN1::TYPE_SEQUENCE,
+            'children' => array(
+                'publicKeyAndChallenge' => $PublicKeyAndChallenge,
+                'signatureAlgorithm'    => $AlgorithmIdentifier,
+                'signature'             => array('type' => ASN1::TYPE_BIT_STRING)
+            )
+        );
+
+        $this->PostalAddress = array(
+            'type'     => ASN1::TYPE_SEQUENCE,
+            'optional' => true,
+            'min'      => 1,
+            'max'      => -1,
+            'children' => $this->DirectoryString
+        );
+
+        // OIDs from RFC5280 and those RFCs mentioned in RFC5280#section-4.1.1.2
+        $this->oids = array(
+            '1.3.6.1.5.5.7' => 'id-pkix',
+            '1.3.6.1.5.5.7.1' => 'id-pe',
+            '1.3.6.1.5.5.7.2' => 'id-qt',
+            '1.3.6.1.5.5.7.3' => 'id-kp',
+            '1.3.6.1.5.5.7.48' => 'id-ad',
+            '1.3.6.1.5.5.7.2.1' => 'id-qt-cps',
+            '1.3.6.1.5.5.7.2.2' => 'id-qt-unotice',
+            '1.3.6.1.5.5.7.48.1' =>'id-ad-ocsp',
+            '1.3.6.1.5.5.7.48.2' => 'id-ad-caIssuers',
+            '1.3.6.1.5.5.7.48.3' => 'id-ad-timeStamping',
+            '1.3.6.1.5.5.7.48.5' => 'id-ad-caRepository',
+            '2.5.4' => 'id-at',
+            '2.5.4.41' => 'id-at-name',
+            '2.5.4.4' => 'id-at-surname',
+            '2.5.4.42' => 'id-at-givenName',
+            '2.5.4.43' => 'id-at-initials',
+            '2.5.4.44' => 'id-at-generationQualifier',
+            '2.5.4.3' => 'id-at-commonName',
+            '2.5.4.7' => 'id-at-localityName',
+            '2.5.4.8' => 'id-at-stateOrProvinceName',
+            '2.5.4.10' => 'id-at-organizationName',
+            '2.5.4.11' => 'id-at-organizationalUnitName',
+            '2.5.4.12' => 'id-at-title',
+            '2.5.4.13' => 'id-at-description',
+            '2.5.4.46' => 'id-at-dnQualifier',
+            '2.5.4.6' => 'id-at-countryName',
+            '2.5.4.5' => 'id-at-serialNumber',
+            '2.5.4.65' => 'id-at-pseudonym',
+            '2.5.4.17' => 'id-at-postalCode',
+            '2.5.4.9' => 'id-at-streetAddress',
+            '2.5.4.45' => 'id-at-uniqueIdentifier',
+            '2.5.4.72' => 'id-at-role',
+            '2.5.4.16' => 'id-at-postalAddress',
+
+            '0.9.2342.19200300.100.1.25' => 'id-domainComponent',
+            '1.2.840.113549.1.9' => 'pkcs-9',
+            '1.2.840.113549.1.9.1' => 'pkcs-9-at-emailAddress',
+            '2.5.29' => 'id-ce',
+            '2.5.29.35' => 'id-ce-authorityKeyIdentifier',
+            '2.5.29.14' => 'id-ce-subjectKeyIdentifier',
+            '2.5.29.15' => 'id-ce-keyUsage',
+            '2.5.29.16' => 'id-ce-privateKeyUsagePeriod',
+            '2.5.29.32' => 'id-ce-certificatePolicies',
+            '2.5.29.32.0' => 'anyPolicy',
+
+            '2.5.29.33' => 'id-ce-policyMappings',
+            '2.5.29.17' => 'id-ce-subjectAltName',
+            '2.5.29.18' => 'id-ce-issuerAltName',
+            '2.5.29.9' => 'id-ce-subjectDirectoryAttributes',
+            '2.5.29.19' => 'id-ce-basicConstraints',
+            '2.5.29.30' => 'id-ce-nameConstraints',
+            '2.5.29.36' => 'id-ce-policyConstraints',
+            '2.5.29.31' => 'id-ce-cRLDistributionPoints',
+            '2.5.29.37' => 'id-ce-extKeyUsage',
+            '2.5.29.37.0' => 'anyExtendedKeyUsage',
+            '1.3.6.1.5.5.7.3.1' => 'id-kp-serverAuth',
+            '1.3.6.1.5.5.7.3.2' => 'id-kp-clientAuth',
+            '1.3.6.1.5.5.7.3.3' => 'id-kp-codeSigning',
+            '1.3.6.1.5.5.7.3.4' => 'id-kp-emailProtection',
+            '1.3.6.1.5.5.7.3.8' => 'id-kp-timeStamping',
+            '1.3.6.1.5.5.7.3.9' => 'id-kp-OCSPSigning',
+            '2.5.29.54' => 'id-ce-inhibitAnyPolicy',
+            '2.5.29.46' => 'id-ce-freshestCRL',
+            '1.3.6.1.5.5.7.1.1' => 'id-pe-authorityInfoAccess',
+            '1.3.6.1.5.5.7.1.11' => 'id-pe-subjectInfoAccess',
+            '2.5.29.20' => 'id-ce-cRLNumber',
+            '2.5.29.28' => 'id-ce-issuingDistributionPoint',
+            '2.5.29.27' => 'id-ce-deltaCRLIndicator',
+            '2.5.29.21' => 'id-ce-cRLReasons',
+            '2.5.29.29' => 'id-ce-certificateIssuer',
+            '2.5.29.23' => 'id-ce-holdInstructionCode',
+            '1.2.840.10040.2' => 'holdInstruction',
+            '1.2.840.10040.2.1' => 'id-holdinstruction-none',
+            '1.2.840.10040.2.2' => 'id-holdinstruction-callissuer',
+            '1.2.840.10040.2.3' => 'id-holdinstruction-reject',
+            '2.5.29.24' => 'id-ce-invalidityDate',
+
+            '1.2.840.113549.2.2' => 'md2',
+            '1.2.840.113549.2.5' => 'md5',
+            '1.3.14.3.2.26' => 'id-sha1',
+            '1.2.840.10040.4.1' => 'id-dsa',
+            '1.2.840.10040.4.3' => 'id-dsa-with-sha1',
+            '1.2.840.113549.1.1' => 'pkcs-1',
+            '1.2.840.113549.1.1.1' => 'rsaEncryption',
+            '1.2.840.113549.1.1.2' => 'md2WithRSAEncryption',
+            '1.2.840.113549.1.1.4' => 'md5WithRSAEncryption',
+            '1.2.840.113549.1.1.5' => 'sha1WithRSAEncryption',
+            '1.2.840.10046.2.1' => 'dhpublicnumber',
+            '2.16.840.1.101.2.1.1.22' => 'id-keyExchangeAlgorithm',
+            '1.2.840.10045' => 'ansi-X9-62',
+            '1.2.840.10045.4' => 'id-ecSigType',
+            '1.2.840.10045.4.1' => 'ecdsa-with-SHA1',
+            '1.2.840.10045.1' => 'id-fieldType',
+            '1.2.840.10045.1.1' => 'prime-field',
+            '1.2.840.10045.1.2' => 'characteristic-two-field',
+            '1.2.840.10045.1.2.3' => 'id-characteristic-two-basis',
+            '1.2.840.10045.1.2.3.1' => 'gnBasis',
+            '1.2.840.10045.1.2.3.2' => 'tpBasis',
+            '1.2.840.10045.1.2.3.3' => 'ppBasis',
+            '1.2.840.10045.2' => 'id-publicKeyType',
+            '1.2.840.10045.2.1' => 'id-ecPublicKey',
+            '1.2.840.10045.3' => 'ellipticCurve',
+            '1.2.840.10045.3.0' => 'c-TwoCurve',
+            '1.2.840.10045.3.0.1' => 'c2pnb163v1',
+            '1.2.840.10045.3.0.2' => 'c2pnb163v2',
+            '1.2.840.10045.3.0.3' => 'c2pnb163v3',
+            '1.2.840.10045.3.0.4' => 'c2pnb176w1',
+            '1.2.840.10045.3.0.5' => 'c2pnb191v1',
+            '1.2.840.10045.3.0.6' => 'c2pnb191v2',
+            '1.2.840.10045.3.0.7' => 'c2pnb191v3',
+            '1.2.840.10045.3.0.8' => 'c2pnb191v4',
+            '1.2.840.10045.3.0.9' => 'c2pnb191v5',
+            '1.2.840.10045.3.0.10' => 'c2pnb208w1',
+            '1.2.840.10045.3.0.11' => 'c2pnb239v1',
+            '1.2.840.10045.3.0.12' => 'c2pnb239v2',
+            '1.2.840.10045.3.0.13' => 'c2pnb239v3',
+            '1.2.840.10045.3.0.14' => 'c2pnb239v4',
+            '1.2.840.10045.3.0.15' => 'c2pnb239v5',
+            '1.2.840.10045.3.0.16' => 'c2pnb272w1',
+            '1.2.840.10045.3.0.17' => 'c2pnb304w1',
+            '1.2.840.10045.3.0.18' => 'c2pnb359v1',
+            '1.2.840.10045.3.0.19' => 'c2pnb368w1',
+            '1.2.840.10045.3.0.20' => 'c2pnb431r1',
+            '1.2.840.10045.3.1' => 'primeCurve',
+            '1.2.840.10045.3.1.1' => 'prime192v1',
+            '1.2.840.10045.3.1.2' => 'prime192v2',
+            '1.2.840.10045.3.1.3' => 'prime192v3',
+            '1.2.840.10045.3.1.4' => 'prime239v1',
+            '1.2.840.10045.3.1.5' => 'prime239v2',
+            '1.2.840.10045.3.1.6' => 'prime239v3',
+            '1.2.840.10045.3.1.7' => 'prime256v1',
+            '1.2.840.113549.1.1.7' => 'id-RSAES-OAEP',
+            '1.2.840.113549.1.1.9' => 'id-pSpecified',
+            '1.2.840.113549.1.1.10' => 'id-RSASSA-PSS',
+            '1.2.840.113549.1.1.8' => 'id-mgf1',
+            '1.2.840.113549.1.1.14' => 'sha224WithRSAEncryption',
+            '1.2.840.113549.1.1.11' => 'sha256WithRSAEncryption',
+            '1.2.840.113549.1.1.12' => 'sha384WithRSAEncryption',
+            '1.2.840.113549.1.1.13' => 'sha512WithRSAEncryption',
+            '2.16.840.1.101.3.4.2.4' => 'id-sha224',
+            '2.16.840.1.101.3.4.2.1' => 'id-sha256',
+            '2.16.840.1.101.3.4.2.2' => 'id-sha384',
+            '2.16.840.1.101.3.4.2.3' => 'id-sha512',
+            '1.2.643.2.2.4' => 'id-GostR3411-94-with-GostR3410-94',
+            '1.2.643.2.2.3' => 'id-GostR3411-94-with-GostR3410-2001',
+            '1.2.643.2.2.20' => 'id-GostR3410-2001',
+            '1.2.643.2.2.19' => 'id-GostR3410-94',
+            // Netscape Object Identifiers from "Netscape Certificate Extensions"
+            '2.16.840.1.113730' => 'netscape',
+            '2.16.840.1.113730.1' => 'netscape-cert-extension',
+            '2.16.840.1.113730.1.1' => 'netscape-cert-type',
+            '2.16.840.1.113730.1.13' => 'netscape-comment',
+            '2.16.840.1.113730.1.8' => 'netscape-ca-policy-url',
+            // the following are X.509 extensions not supported by phpseclib
+            '1.3.6.1.5.5.7.1.12' => 'id-pe-logotype',
+            '1.2.840.113533.7.65.0' => 'entrustVersInfo',
+            '2.16.840.1.113733.1.6.9' => 'verisignPrivate',
+            // for Certificate Signing Requests
+            // see http://tools.ietf.org/html/rfc2985
+            '1.2.840.113549.1.9.2' => 'pkcs-9-at-unstructuredName', // PKCS #9 unstructured name
+            '1.2.840.113549.1.9.7' => 'pkcs-9-at-challengePassword', // Challenge password for certificate revocations
+            '1.2.840.113549.1.9.14' => 'pkcs-9-at-extensionRequest' // Certificate extension request
+        );
+    }
+
+    /**
+     * Load X.509 certificate
+     *
+     * Returns an associative array describing the X.509 cert or a false if the cert failed to load
+     *
+     * @param string $cert
+     * @param int $mode
+     * @access public
+     * @return mixed
+     */
+    function loadX509($cert, $mode = self::FORMAT_AUTO_DETECT)
+    {
+        if (is_array($cert) && isset($cert['tbsCertificate'])) {
+            unset($this->currentCert);
+            unset($this->currentKeyIdentifier);
+            $this->dn = $cert['tbsCertificate']['subject'];
+            if (!isset($this->dn)) {
+                return false;
+            }
+            $this->currentCert = $cert;
+
+            $currentKeyIdentifier = $this->getExtension('id-ce-subjectKeyIdentifier');
+            $this->currentKeyIdentifier = is_string($currentKeyIdentifier) ? $currentKeyIdentifier : null;
+
+            unset($this->signatureSubject);
+
+            return $cert;
+        }
+
+        $asn1 = new ASN1();
+
+        if ($mode != self::FORMAT_DER) {
+            $newcert = $this->_extractBER($cert);
+            if ($mode == self::FORMAT_PEM && $cert == $newcert) {
+                return false;
+            }
+            $cert = $newcert;
+        }
+
+        if ($cert === false) {
+            $this->currentCert = false;
+            return false;
+        }
+
+        $asn1->loadOIDs($this->oids);
+        $decoded = $asn1->decodeBER($cert);
+
+        if (!empty($decoded)) {
+            $x509 = $asn1->asn1map($decoded[0], $this->Certificate);
+        }
+        if (!isset($x509) || $x509 === false) {
+            $this->currentCert = false;
+            return false;
+        }
+
+        $this->signatureSubject = substr($cert, $decoded[0]['content'][0]['start'], $decoded[0]['content'][0]['length']);
+
+        if ($this->_isSubArrayValid($x509, 'tbsCertificate/extensions')) {
+            $this->_mapInExtensions($x509, 'tbsCertificate/extensions', $asn1);
+        }
+        $this->_mapInDNs($x509, 'tbsCertificate/issuer/rdnSequence', $asn1);
+        $this->_mapInDNs($x509, 'tbsCertificate/subject/rdnSequence', $asn1);
+
+        $key = &$x509['tbsCertificate']['subjectPublicKeyInfo']['subjectPublicKey'];
+        $key = $this->_reformatKey($x509['tbsCertificate']['subjectPublicKeyInfo']['algorithm']['algorithm'], $key);
+
+        $this->currentCert = $x509;
+        $this->dn = $x509['tbsCertificate']['subject'];
+
+        $currentKeyIdentifier = $this->getExtension('id-ce-subjectKeyIdentifier');
+        $this->currentKeyIdentifier = is_string($currentKeyIdentifier) ? $currentKeyIdentifier : null;
+
+        return $x509;
+    }
+
+    /**
+     * Save X.509 certificate
+     *
+     * @param array $cert
+     * @param int $format optional
+     * @access public
+     * @return string
+     */
+    function saveX509($cert, $format = self::FORMAT_PEM)
+    {
+        if (!is_array($cert) || !isset($cert['tbsCertificate'])) {
+            return false;
+        }
+
+        switch (true) {
+            // "case !$a: case !$b: break; default: whatever();" is the same thing as "if ($a && $b) whatever()"
+            case !($algorithm = $this->_subArray($cert, 'tbsCertificate/subjectPublicKeyInfo/algorithm/algorithm')):
+            case is_object($cert['tbsCertificate']['subjectPublicKeyInfo']['subjectPublicKey']):
+                break;
+            default:
+                switch ($algorithm) {
+                    case 'rsaEncryption':
+                        $cert['tbsCertificate']['subjectPublicKeyInfo']['subjectPublicKey']
+                            = base64_encode("\0" . base64_decode(preg_replace('#-.+-|[\r\n]#', '', $cert['tbsCertificate']['subjectPublicKeyInfo']['subjectPublicKey'])));
+                        /* "[For RSA keys] the parameters field MUST have ASN.1 type NULL for this algorithm identifier."
+                           -- https://tools.ietf.org/html/rfc3279#section-2.3.1
+
+                           given that and the fact that RSA keys appear ot be the only key type for which the parameters field can be blank,
+                           it seems like perhaps the ASN.1 description ought not say the parameters field is OPTIONAL, but whatever.
+                         */
+                        $cert['tbsCertificate']['subjectPublicKeyInfo']['algorithm']['parameters'] = null;
+                        // https://tools.ietf.org/html/rfc3279#section-2.2.1
+                        $cert['signatureAlgorithm']['parameters'] = null;
+                        $cert['tbsCertificate']['signature']['parameters'] = null;
+                }
+        }
+
+        $asn1 = new ASN1();
+        $asn1->loadOIDs($this->oids);
+
+        $filters = array();
+        $type_utf8_string = array('type' => ASN1::TYPE_UTF8_STRING);
+        $filters['tbsCertificate']['signature']['parameters'] = $type_utf8_string;
+        $filters['tbsCertificate']['signature']['issuer']['rdnSequence']['value'] = $type_utf8_string;
+        $filters['tbsCertificate']['issuer']['rdnSequence']['value'] = $type_utf8_string;
+        $filters['tbsCertificate']['subject']['rdnSequence']['value'] = $type_utf8_string;
+        $filters['tbsCertificate']['subjectPublicKeyInfo']['algorithm']['parameters'] = $type_utf8_string;
+        $filters['signatureAlgorithm']['parameters'] = $type_utf8_string;
+        $filters['authorityCertIssuer']['directoryName']['rdnSequence']['value'] = $type_utf8_string;
+        //$filters['policyQualifiers']['qualifier'] = $type_utf8_string;
+        $filters['distributionPoint']['fullName']['directoryName']['rdnSequence']['value'] = $type_utf8_string;
+        $filters['directoryName']['rdnSequence']['value'] = $type_utf8_string;
+
+        /* in the case of policyQualifiers/qualifier, the type has to be \phpseclib\File\ASN1::TYPE_IA5_STRING.
+           \phpseclib\File\ASN1::TYPE_PRINTABLE_STRING will cause OpenSSL's X.509 parser to spit out random
+           characters.
+         */
+        $filters['policyQualifiers']['qualifier']
+            = array('type' => ASN1::TYPE_IA5_STRING);
+
+        $asn1->loadFilters($filters);
+
+        $this->_mapOutExtensions($cert, 'tbsCertificate/extensions', $asn1);
+        $this->_mapOutDNs($cert, 'tbsCertificate/issuer/rdnSequence', $asn1);
+        $this->_mapOutDNs($cert, 'tbsCertificate/subject/rdnSequence', $asn1);
+
+        $cert = $asn1->encodeDER($cert, $this->Certificate);
+
+        switch ($format) {
+            case self::FORMAT_DER:
+                return $cert;
+            // case self::FORMAT_PEM:
+            default:
+                return "-----BEGIN CERTIFICATE-----\r\n" . chunk_split(base64_encode($cert), 64) . '-----END CERTIFICATE-----';
+        }
+    }
+
+    /**
+     * Map extension values from octet string to extension-specific internal
+     *   format.
+     *
+     * @param array ref $root
+     * @param string $path
+     * @param object $asn1
+     * @access private
+     */
+    function _mapInExtensions(&$root, $path, $asn1)
+    {
+        $extensions = &$this->_subArrayUnchecked($root, $path);
+
+        if ($extensions) {
+            for ($i = 0; $i < count($extensions); $i++) {
+                $id = $extensions[$i]['extnId'];
+                $value = &$extensions[$i]['extnValue'];
+                $value = base64_decode($value);
+                $decoded = $asn1->decodeBER($value);
+                /* [extnValue] contains the DER encoding of an ASN.1 value
+                   corresponding to the extension type identified by extnID */
+                $map = $this->_getMapping($id);
+                if (!is_bool($map)) {
+                    $mapped = $asn1->asn1map($decoded[0], $map, array('iPAddress' => array($this, '_decodeIP')));
+                    $value = $mapped === false ? $decoded[0] : $mapped;
+
+                    if ($id == 'id-ce-certificatePolicies') {
+                        for ($j = 0; $j < count($value); $j++) {
+                            if (!isset($value[$j]['policyQualifiers'])) {
+                                continue;
+                            }
+                            for ($k = 0; $k < count($value[$j]['policyQualifiers']); $k++) {
+                                $subid = $value[$j]['policyQualifiers'][$k]['policyQualifierId'];
+                                $map = $this->_getMapping($subid);
+                                $subvalue = &$value[$j]['policyQualifiers'][$k]['qualifier'];
+                                if ($map !== false) {
+                                    $decoded = $asn1->decodeBER($subvalue);
+                                    $mapped = $asn1->asn1map($decoded[0], $map);
+                                    $subvalue = $mapped === false ? $decoded[0] : $mapped;
+                                }
+                            }
+                        }
+                    }
+                } else {
+                    $value = base64_encode($value);
+                }
+            }
+        }
+    }
+
+    /**
+     * Map extension values from extension-specific internal format to
+     *   octet string.
+     *
+     * @param array ref $root
+     * @param string $path
+     * @param object $asn1
+     * @access private
+     */
+    function _mapOutExtensions(&$root, $path, $asn1)
+    {
+        $extensions = &$this->_subArray($root, $path);
+
+        if (is_array($extensions)) {
+            $size = count($extensions);
+            for ($i = 0; $i < $size; $i++) {
+                if ($extensions[$i] instanceof Element) {
+                    continue;
+                }
+
+                $id = $extensions[$i]['extnId'];
+                $value = &$extensions[$i]['extnValue'];
+
+                switch ($id) {
+                    case 'id-ce-certificatePolicies':
+                        for ($j = 0; $j < count($value); $j++) {
+                            if (!isset($value[$j]['policyQualifiers'])) {
+                                continue;
+                            }
+                            for ($k = 0; $k < count($value[$j]['policyQualifiers']); $k++) {
+                                $subid = $value[$j]['policyQualifiers'][$k]['policyQualifierId'];
+                                $map = $this->_getMapping($subid);
+                                $subvalue = &$value[$j]['policyQualifiers'][$k]['qualifier'];
+                                if ($map !== false) {
+                                    // by default \phpseclib\File\ASN1 will try to render qualifier as a \phpseclib\File\ASN1::TYPE_IA5_STRING since it's
+                                    // actual type is \phpseclib\File\ASN1::TYPE_ANY
+                                    $subvalue = new Element($asn1->encodeDER($subvalue, $map));
+                                }
+                            }
+                        }
+                        break;
+                    case 'id-ce-authorityKeyIdentifier': // use 00 as the serial number instead of an empty string
+                        if (isset($value['authorityCertSerialNumber'])) {
+                            if ($value['authorityCertSerialNumber']->toBytes() == '') {
+                                $temp = chr((ASN1::CLASS_CONTEXT_SPECIFIC << 6) | 2) . "\1\0";
+                                $value['authorityCertSerialNumber'] = new Element($temp);
+                            }
+                        }
+                }
+
+                /* [extnValue] contains the DER encoding of an ASN.1 value
+                   corresponding to the extension type identified by extnID */
+                $map = $this->_getMapping($id);
+                if (is_bool($map)) {
+                    if (!$map) {
+                        user_error($id . ' is not a currently supported extension');
+                        unset($extensions[$i]);
+                    }
+                } else {
+                    $temp = $asn1->encodeDER($value, $map, array('iPAddress' => array($this, '_encodeIP')));
+                    $value = base64_encode($temp);
+                }
+            }
+        }
+    }
+
+    /**
+     * Map attribute values from ANY type to attribute-specific internal
+     *   format.
+     *
+     * @param array ref $root
+     * @param string $path
+     * @param object $asn1
+     * @access private
+     */
+    function _mapInAttributes(&$root, $path, $asn1)
+    {
+        $attributes = &$this->_subArray($root, $path);
+
+        if (is_array($attributes)) {
+            for ($i = 0; $i < count($attributes); $i++) {
+                $id = $attributes[$i]['type'];
+                /* $value contains the DER encoding of an ASN.1 value
+                   corresponding to the attribute type identified by type */
+                $map = $this->_getMapping($id);
+                if (is_array($attributes[$i]['value'])) {
+                    $values = &$attributes[$i]['value'];
+                    for ($j = 0; $j < count($values); $j++) {
+                        $value = $asn1->encodeDER($values[$j], $this->AttributeValue);
+                        $decoded = $asn1->decodeBER($value);
+                        if (!is_bool($map)) {
+                            $mapped = $asn1->asn1map($decoded[0], $map);
+                            if ($mapped !== false) {
+                                $values[$j] = $mapped;
+                            }
+                            if ($id == 'pkcs-9-at-extensionRequest' && $this->_isSubArrayValid($values, $j)) {
+                                $this->_mapInExtensions($values, $j, $asn1);
+                            }
+                        } elseif ($map) {
+                            $values[$j] = base64_encode($value);
+                        }
+                    }
+                }
+            }
+        }
+    }
+
+    /**
+     * Map attribute values from attribute-specific internal format to
+     *   ANY type.
+     *
+     * @param array ref $root
+     * @param string $path
+     * @param object $asn1
+     * @access private
+     */
+    function _mapOutAttributes(&$root, $path, $asn1)
+    {
+        $attributes = &$this->_subArray($root, $path);
+
+        if (is_array($attributes)) {
+            $size = count($attributes);
+            for ($i = 0; $i < $size; $i++) {
+                /* [value] contains the DER encoding of an ASN.1 value
+                   corresponding to the attribute type identified by type */
+                $id = $attributes[$i]['type'];
+                $map = $this->_getMapping($id);
+                if ($map === false) {
+                    user_error($id . ' is not a currently supported attribute', E_USER_NOTICE);
+                    unset($attributes[$i]);
+                } elseif (is_array($attributes[$i]['value'])) {
+                    $values = &$attributes[$i]['value'];
+                    for ($j = 0; $j < count($values); $j++) {
+                        switch ($id) {
+                            case 'pkcs-9-at-extensionRequest':
+                                $this->_mapOutExtensions($values, $j, $asn1);
+                                break;
+                        }
+
+                        if (!is_bool($map)) {
+                            $temp = $asn1->encodeDER($values[$j], $map);
+                            $decoded = $asn1->decodeBER($temp);
+                            $values[$j] = $asn1->asn1map($decoded[0], $this->AttributeValue);
+                        }
+                    }
+                }
+            }
+        }
+    }
+
+    /**
+     * Map DN values from ANY type to DN-specific internal
+     *   format.
+     *
+     * @param array ref $root
+     * @param string $path
+     * @param object $asn1
+     * @access private
+     */
+    function _mapInDNs(&$root, $path, $asn1)
+    {
+        $dns = &$this->_subArray($root, $path);
+
+        if (is_array($dns)) {
+            for ($i = 0; $i < count($dns); $i++) {
+                for ($j = 0; $j < count($dns[$i]); $j++) {
+                    $type = $dns[$i][$j]['type'];
+                    $value = &$dns[$i][$j]['value'];
+                    if (is_object($value) && $value instanceof Element) {
+                        $map = $this->_getMapping($type);
+                        if (!is_bool($map)) {
+                            $decoded = $asn1->decodeBER($value);
+                            $value = $asn1->asn1map($decoded[0], $map);
+                        }
+                    }
+                }
+            }
+        }
+    }
+
+    /**
+     * Map DN values from DN-specific internal format to
+     *   ANY type.
+     *
+     * @param array ref $root
+     * @param string $path
+     * @param object $asn1
+     * @access private
+     */
+    function _mapOutDNs(&$root, $path, $asn1)
+    {
+        $dns = &$this->_subArray($root, $path);
+
+        if (is_array($dns)) {
+            $size = count($dns);
+            for ($i = 0; $i < $size; $i++) {
+                for ($j = 0; $j < count($dns[$i]); $j++) {
+                    $type = $dns[$i][$j]['type'];
+                    $value = &$dns[$i][$j]['value'];
+                    if (is_object($value) && $value instanceof Element) {
+                        continue;
+                    }
+
+                    $map = $this->_getMapping($type);
+                    if (!is_bool($map)) {
+                        $value = new Element($asn1->encodeDER($value, $map));
+                    }
+                }
+            }
+        }
+    }
+
+    /**
+     * Associate an extension ID to an extension mapping
+     *
+     * @param string $extnId
+     * @access private
+     * @return mixed
+     */
+    function _getMapping($extnId)
+    {
+        if (!is_string($extnId)) { // eg. if it's a \phpseclib\File\ASN1\Element object
+            return true;
+        }
+
+        switch ($extnId) {
+            case 'id-ce-keyUsage':
+                return $this->KeyUsage;
+            case 'id-ce-basicConstraints':
+                return $this->BasicConstraints;
+            case 'id-ce-subjectKeyIdentifier':
+                return $this->KeyIdentifier;
+            case 'id-ce-cRLDistributionPoints':
+                return $this->CRLDistributionPoints;
+            case 'id-ce-authorityKeyIdentifier':
+                return $this->AuthorityKeyIdentifier;
+            case 'id-ce-certificatePolicies':
+                return $this->CertificatePolicies;
+            case 'id-ce-extKeyUsage':
+                return $this->ExtKeyUsageSyntax;
+            case 'id-pe-authorityInfoAccess':
+                return $this->AuthorityInfoAccessSyntax;
+            case 'id-ce-subjectAltName':
+                return $this->SubjectAltName;
+            case 'id-ce-subjectDirectoryAttributes':
+                return $this->SubjectDirectoryAttributes;
+            case 'id-ce-privateKeyUsagePeriod':
+                return $this->PrivateKeyUsagePeriod;
+            case 'id-ce-issuerAltName':
+                return $this->IssuerAltName;
+            case 'id-ce-policyMappings':
+                return $this->PolicyMappings;
+            case 'id-ce-nameConstraints':
+                return $this->NameConstraints;
+
+            case 'netscape-cert-type':
+                return $this->netscape_cert_type;
+            case 'netscape-comment':
+                return $this->netscape_comment;
+            case 'netscape-ca-policy-url':
+                return $this->netscape_ca_policy_url;
+
+            // since id-qt-cps isn't a constructed type it will have already been decoded as a string by the time it gets
+            // back around to asn1map() and we don't want it decoded again.
+            //case 'id-qt-cps':
+            //    return $this->CPSuri;
+            case 'id-qt-unotice':
+                return $this->UserNotice;
+
+            // the following OIDs are unsupported but we don't want them to give notices when calling saveX509().
+            case 'id-pe-logotype': // http://www.ietf.org/rfc/rfc3709.txt
+            case 'entrustVersInfo':
+            // http://support.microsoft.com/kb/287547
+            case '1.3.6.1.4.1.311.20.2': // szOID_ENROLL_CERTTYPE_EXTENSION
+            case '1.3.6.1.4.1.311.21.1': // szOID_CERTSRV_CA_VERSION
+            // "SET Secure Electronic Transaction Specification"
+            // http://www.maithean.com/docs/set_bk3.pdf
+            case '2.23.42.7.0': // id-set-hashedRootKey
+            // "Certificate Transparency"
+            // https://tools.ietf.org/html/rfc6962
+            case '1.3.6.1.4.1.11129.2.4.2':
+                return true;
+
+            // CSR attributes
+            case 'pkcs-9-at-unstructuredName':
+                return $this->PKCS9String;
+            case 'pkcs-9-at-challengePassword':
+                return $this->DirectoryString;
+            case 'pkcs-9-at-extensionRequest':
+                return $this->Extensions;
+
+            // CRL extensions.
+            case 'id-ce-cRLNumber':
+                return $this->CRLNumber;
+            case 'id-ce-deltaCRLIndicator':
+                return $this->CRLNumber;
+            case 'id-ce-issuingDistributionPoint':
+                return $this->IssuingDistributionPoint;
+            case 'id-ce-freshestCRL':
+                return $this->CRLDistributionPoints;
+            case 'id-ce-cRLReasons':
+                return $this->CRLReason;
+            case 'id-ce-invalidityDate':
+                return $this->InvalidityDate;
+            case 'id-ce-certificateIssuer':
+                return $this->CertificateIssuer;
+            case 'id-ce-holdInstructionCode':
+                return $this->HoldInstructionCode;
+            case 'id-at-postalAddress':
+                return $this->PostalAddress;
+        }
+
+        return false;
+    }
+
+    /**
+     * Load an X.509 certificate as a certificate authority
+     *
+     * @param string $cert
+     * @access public
+     * @return bool
+     */
+    function loadCA($cert)
+    {
+        $olddn = $this->dn;
+        $oldcert = $this->currentCert;
+        $oldsigsubj = $this->signatureSubject;
+        $oldkeyid = $this->currentKeyIdentifier;
+
+        $cert = $this->loadX509($cert);
+        if (!$cert) {
+            $this->dn = $olddn;
+            $this->currentCert = $oldcert;
+            $this->signatureSubject = $oldsigsubj;
+            $this->currentKeyIdentifier = $oldkeyid;
+
+            return false;
+        }
+
+        /* From RFC5280 "PKIX Certificate and CRL Profile":
+
+           If the keyUsage extension is present, then the subject public key
+           MUST NOT be used to verify signatures on certificates or CRLs unless
+           the corresponding keyCertSign or cRLSign bit is set. */
+        //$keyUsage = $this->getExtension('id-ce-keyUsage');
+        //if ($keyUsage && !in_array('keyCertSign', $keyUsage)) {
+        //    return false;
+        //}
+
+        /* From RFC5280 "PKIX Certificate and CRL Profile":
+
+           The cA boolean indicates whether the certified public key may be used
+           to verify certificate signatures.  If the cA boolean is not asserted,
+           then the keyCertSign bit in the key usage extension MUST NOT be
+           asserted.  If the basic constraints extension is not present in a
+           version 3 certificate, or the extension is present but the cA boolean
+           is not asserted, then the certified public key MUST NOT be used to
+           verify certificate signatures. */
+        //$basicConstraints = $this->getExtension('id-ce-basicConstraints');
+        //if (!$basicConstraints || !$basicConstraints['cA']) {
+        //    return false;
+        //}
+
+        $this->CAs[] = $cert;
+
+        $this->dn = $olddn;
+        $this->currentCert = $oldcert;
+        $this->signatureSubject = $oldsigsubj;
+
+        return true;
+    }
+
+    /**
+     * Validate an X.509 certificate against a URL
+     *
+     * From RFC2818 "HTTP over TLS":
+     *
+     * Matching is performed using the matching rules specified by
+     * [RFC2459].  If more than one identity of a given type is present in
+     * the certificate (e.g., more than one dNSName name, a match in any one
+     * of the set is considered acceptable.) Names may contain the wildcard
+     * character * which is considered to match any single domain name
+     * component or component fragment. E.g., *.a.com matches foo.a.com but
+     * not bar.foo.a.com. f*.com matches foo.com but not bar.com.
+     *
+     * @param string $url
+     * @access public
+     * @return bool
+     */
+    function validateURL($url)
+    {
+        if (!is_array($this->currentCert) || !isset($this->currentCert['tbsCertificate'])) {
+            return false;
+        }
+
+        $components = parse_url($url);
+        if (!isset($components['host'])) {
+            return false;
+        }
+
+        if ($names = $this->getExtension('id-ce-subjectAltName')) {
+            foreach ($names as $name) {
+                foreach ($name as $key => $value) {
+                    $value = str_replace(array('.', '*'), array('\.', '[^.]*'), $value);
+                    switch ($key) {
+                        case 'dNSName':
+                            /* From RFC2818 "HTTP over TLS":
+
+                               If a subjectAltName extension of type dNSName is present, that MUST
+                               be used as the identity. Otherwise, the (most specific) Common Name
+                               field in the Subject field of the certificate MUST be used. Although
+                               the use of the Common Name is existing practice, it is deprecated and
+                               Certification Authorities are encouraged to use the dNSName instead. */
+                            if (preg_match('#^' . $value . '$#', $components['host'])) {
+                                return true;
+                            }
+                            break;
+                        case 'iPAddress':
+                            /* From RFC2818 "HTTP over TLS":
+
+                               In some cases, the URI is specified as an IP address rather than a
+                               hostname. In this case, the iPAddress subjectAltName must be present
+                               in the certificate and must exactly match the IP in the URI. */
+                            if (preg_match('#(?:\d{1-3}\.){4}#', $components['host'] . '.') && preg_match('#^' . $value . '$#', $components['host'])) {
+                                return true;
+                            }
+                    }
+                }
+            }
+            return false;
+        }
+
+        if ($value = $this->getDNProp('id-at-commonName')) {
+            $value = str_replace(array('.', '*'), array('\.', '[^.]*'), $value[0]);
+            return preg_match('#^' . $value . '$#', $components['host']);
+        }
+
+        return false;
+    }
+
+    /**
+     * Validate a date
+     *
+     * If $date isn't defined it is assumed to be the current date.
+     *
+     * @param int $date optional
+     * @access public
+     */
+    function validateDate($date = null)
+    {
+        if (!is_array($this->currentCert) || !isset($this->currentCert['tbsCertificate'])) {
+            return false;
+        }
+
+        if (!isset($date)) {
+            $date = new DateTime($date, new DateTimeZone(@date_default_timezone_get()));
+        }
+
+        $notBefore = $this->currentCert['tbsCertificate']['validity']['notBefore'];
+        $notBefore = isset($notBefore['generalTime']) ? $notBefore['generalTime'] : $notBefore['utcTime'];
+
+        $notAfter = $this->currentCert['tbsCertificate']['validity']['notAfter'];
+        $notAfter = isset($notAfter['generalTime']) ? $notAfter['generalTime'] : $notAfter['utcTime'];
+
+        switch (true) {
+            case $date < new DateTime($notBefore, new DateTimeZone(@date_default_timezone_get())):
+            case $date > new DateTime($notAfter, new DateTimeZone(@date_default_timezone_get())):
+                return false;
+        }
+
+        return true;
+    }
+
+    /**
+     * Fetches a URL
+     *
+     * @param string $url
+     * @access private
+     * @return bool|string
+     */
+    static function _fetchURL($url)
+    {
+        if (self::$disable_url_fetch) {
+            return false;
+        }
+
+        $parts = parse_url($url);
+        $data = '';
+        switch ($parts['scheme']) {
+            case 'http':
+                $fsock = @fsockopen($parts['host'], isset($parts['port']) ? $parts['port'] : 80);
+                if (!$fsock) {
+                    return false;
+                }
+                fputs($fsock, "GET $parts[path] HTTP/1.0\r\n");
+                fputs($fsock, "Host: $parts[host]\r\n\r\n");
+                $line = fgets($fsock, 1024);
+                if (strlen($line) < 3) {
+                    return false;
+                }
+                preg_match('#HTTP/1.\d (\d{3})#', $line, $temp);
+                if ($temp[1] != '200') {
+                    return false;
+                }
+
+                // skip the rest of the headers in the http response
+                while (!feof($fsock) && fgets($fsock, 1024) != "\r\n") {
+                }
+
+                while (!feof($fsock)) {
+                    $data.= fread($fsock, 1024);
+                }
+
+                break;
+            //case 'ftp':
+            //case 'ldap':
+            //default:
+        }
+
+        return $data;
+    }
+
+    /**
+     * Validates an intermediate cert as identified via authority info access extension
+     *
+     * See https://tools.ietf.org/html/rfc4325 for more info
+     *
+     * @param bool $caonly
+     * @param int $count
+     * @access private
+     * @return bool
+     */
+    function _testForIntermediate($caonly, $count)
+    {
+        $opts = $this->getExtension('id-pe-authorityInfoAccess');
+        if (!is_array($opts)) {
+            return false;
+        }
+        foreach ($opts as $opt) {
+            if ($opt['accessMethod'] == 'id-ad-caIssuers') {
+                // accessLocation is a GeneralName. GeneralName fields support stuff like email addresses, IP addresses, LDAP,
+                // etc, but we're only supporting URI's. URI's and LDAP are the only thing https://tools.ietf.org/html/rfc4325
+                // discusses
+                if (isset($opt['accessLocation']['uniformResourceIdentifier'])) {
+                    $url = $opt['accessLocation']['uniformResourceIdentifier'];
+                    break;
+                }
+            }
+        }
+
+        if (!isset($url)) {
+            return false;
+        }
+
+        $cert = static::_fetchURL($url);
+        if (!is_string($cert)) {
+            return false;
+        }
+
+        $parent = new static();
+        $parent->CAs = $this->CAs;
+        /*
+         "Conforming applications that support HTTP or FTP for accessing
+          certificates MUST be able to accept .cer files and SHOULD be able
+          to accept .p7c files." -- https://tools.ietf.org/html/rfc4325
+
+         A .p7c file is 'a "certs-only" CMS message as specified in RFC 2797"
+
+         These are currently unsupported
+        */
+        if (!is_array($parent->loadX509($cert))) {
+            return false;
+        }
+
+        if (!$parent->_validateSignatureCountable($caonly, ++$count)) {
+            return false;
+        }
+
+        $this->CAs[] = $parent->currentCert;
+        //$this->loadCA($cert);
+
+        return true;
+    }
+
+    /**
+     * Validate a signature
+     *
+     * Works on X.509 certs, CSR's and CRL's.
+     * Returns true if the signature is verified, false if it is not correct or null on error
+     *
+     * By default returns false for self-signed certs. Call validateSignature(false) to make this support
+     * self-signed.
+     *
+     * The behavior of this function is inspired by {@link http://php.net/openssl-verify openssl_verify}.
+     *
+     * @param bool $caonly optional
+     * @access public
+     * @return mixed
+     */
+    function validateSignature($caonly = true)
+    {
+        return $this->_validateSignatureCountable($caonly, 0);
+    }
+
+    /**
+     * Validate a signature
+     *
+     * Performs said validation whilst keeping track of how many times validation method is called
+     *
+     * @param bool $caonly
+     * @param int $count
+     * @access private
+     * @return mixed
+     */
+    function _validateSignatureCountable($caonly, $count)
+    {
+        if (!is_array($this->currentCert) || !isset($this->signatureSubject)) {
+            return null;
+        }
+
+        if ($count == self::$recur_limit) {
+            return false;
+        }
+
+        /* TODO:
+           "emailAddress attribute values are not case-sensitive (e.g., "subscriber@example.com" is the same as "SUBSCRIBER@EXAMPLE.COM")."
+            -- http://tools.ietf.org/html/rfc5280#section-4.1.2.6
+
+           implement pathLenConstraint in the id-ce-basicConstraints extension */
+
+        switch (true) {
+            case isset($this->currentCert['tbsCertificate']):
+                // self-signed cert
+                switch (true) {
+                    case !defined('FILE_X509_IGNORE_TYPE') && $this->currentCert['tbsCertificate']['issuer'] === $this->currentCert['tbsCertificate']['subject']:
+                    case defined('FILE_X509_IGNORE_TYPE') && $this->getIssuerDN(self::DN_STRING) === $this->getDN(self::DN_STRING):
+                        $authorityKey = $this->getExtension('id-ce-authorityKeyIdentifier');
+                        $subjectKeyID = $this->getExtension('id-ce-subjectKeyIdentifier');
+                        switch (true) {
+                            case !is_array($authorityKey):
+                            case !$subjectKeyID:
+                            case isset($authorityKey['keyIdentifier']) && $authorityKey['keyIdentifier'] === $subjectKeyID:
+                                $signingCert = $this->currentCert; // working cert
+                        }
+                }
+
+                if (!empty($this->CAs)) {
+                    for ($i = 0; $i < count($this->CAs); $i++) {
+                        // even if the cert is a self-signed one we still want to see if it's a CA;
+                        // if not, we'll conditionally return an error
+                        $ca = $this->CAs[$i];
+                        switch (true) {
+                            case !defined('FILE_X509_IGNORE_TYPE') && $this->currentCert['tbsCertificate']['issuer'] === $ca['tbsCertificate']['subject']:
+                            case defined('FILE_X509_IGNORE_TYPE') && $this->getDN(self::DN_STRING, $this->currentCert['tbsCertificate']['issuer']) === $this->getDN(self::DN_STRING, $ca['tbsCertificate']['subject']):
+                                $authorityKey = $this->getExtension('id-ce-authorityKeyIdentifier');
+                                $subjectKeyID = $this->getExtension('id-ce-subjectKeyIdentifier', $ca);
+                                switch (true) {
+                                    case !is_array($authorityKey):
+                                    case !$subjectKeyID:
+                                    case isset($authorityKey['keyIdentifier']) && $authorityKey['keyIdentifier'] === $subjectKeyID:
+                                        if (is_array($authorityKey) && isset($authorityKey['authorityCertSerialNumber']) && !$authorityKey['authorityCertSerialNumber']->equals($ca['tbsCertificate']['serialNumber'])) {
+                                            break 2; // serial mismatch - check other ca
+                                        }
+                                        $signingCert = $ca; // working cert
+                                        break 3;
+                                }
+                        }
+                    }
+                    if (count($this->CAs) == $i && $caonly) {
+                        return $this->_testForIntermediate($caonly, $count) && $this->validateSignature($caonly);
+                    }
+                } elseif (!isset($signingCert) || $caonly) {
+                    return $this->_testForIntermediate($caonly, $count) && $this->validateSignature($caonly);
+                }
+                return $this->_validateSignature(
+                    $signingCert['tbsCertificate']['subjectPublicKeyInfo']['algorithm']['algorithm'],
+                    $signingCert['tbsCertificate']['subjectPublicKeyInfo']['subjectPublicKey'],
+                    $this->currentCert['signatureAlgorithm']['algorithm'],
+                    substr(base64_decode($this->currentCert['signature']), 1),
+                    $this->signatureSubject
+                );
+            case isset($this->currentCert['certificationRequestInfo']):
+                return $this->_validateSignature(
+                    $this->currentCert['certificationRequestInfo']['subjectPKInfo']['algorithm']['algorithm'],
+                    $this->currentCert['certificationRequestInfo']['subjectPKInfo']['subjectPublicKey'],
+                    $this->currentCert['signatureAlgorithm']['algorithm'],
+                    substr(base64_decode($this->currentCert['signature']), 1),
+                    $this->signatureSubject
+                );
+            case isset($this->currentCert['publicKeyAndChallenge']):
+                return $this->_validateSignature(
+                    $this->currentCert['publicKeyAndChallenge']['spki']['algorithm']['algorithm'],
+                    $this->currentCert['publicKeyAndChallenge']['spki']['subjectPublicKey'],
+                    $this->currentCert['signatureAlgorithm']['algorithm'],
+                    substr(base64_decode($this->currentCert['signature']), 1),
+                    $this->signatureSubject
+                );
+            case isset($this->currentCert['tbsCertList']):
+                if (!empty($this->CAs)) {
+                    for ($i = 0; $i < count($this->CAs); $i++) {
+                        $ca = $this->CAs[$i];
+                        switch (true) {
+                            case !defined('FILE_X509_IGNORE_TYPE') && $this->currentCert['tbsCertList']['issuer'] === $ca['tbsCertificate']['subject']:
+                            case defined('FILE_X509_IGNORE_TYPE') && $this->getDN(self::DN_STRING, $this->currentCert['tbsCertList']['issuer']) === $this->getDN(self::DN_STRING, $ca['tbsCertificate']['subject']):
+                                $authorityKey = $this->getExtension('id-ce-authorityKeyIdentifier');
+                                $subjectKeyID = $this->getExtension('id-ce-subjectKeyIdentifier', $ca);
+                                switch (true) {
+                                    case !is_array($authorityKey):
+                                    case !$subjectKeyID:
+                                    case isset($authorityKey['keyIdentifier']) && $authorityKey['keyIdentifier'] === $subjectKeyID:
+                                        if (is_array($authorityKey) && isset($authorityKey['authorityCertSerialNumber']) && !$authorityKey['authorityCertSerialNumber']->equals($ca['tbsCertificate']['serialNumber'])) {
+                                            break 2; // serial mismatch - check other ca
+                                        }
+                                        $signingCert = $ca; // working cert
+                                        break 3;
+                                }
+                        }
+                    }
+                }
+                if (!isset($signingCert)) {
+                    return false;
+                }
+                return $this->_validateSignature(
+                    $signingCert['tbsCertificate']['subjectPublicKeyInfo']['algorithm']['algorithm'],
+                    $signingCert['tbsCertificate']['subjectPublicKeyInfo']['subjectPublicKey'],
+                    $this->currentCert['signatureAlgorithm']['algorithm'],
+                    substr(base64_decode($this->currentCert['signature']), 1),
+                    $this->signatureSubject
+                );
+            default:
+                return false;
+        }
+    }
+
+    /**
+     * Validates a signature
+     *
+     * Returns true if the signature is verified, false if it is not correct or null on error
+     *
+     * @param string $publicKeyAlgorithm
+     * @param string $publicKey
+     * @param string $signatureAlgorithm
+     * @param string $signature
+     * @param string $signatureSubject
+     * @access private
+     * @return int
+     */
+    function _validateSignature($publicKeyAlgorithm, $publicKey, $signatureAlgorithm, $signature, $signatureSubject)
+    {
+        switch ($publicKeyAlgorithm) {
+            case 'rsaEncryption':
+                $rsa = new RSA();
+                $rsa->loadKey($publicKey);
+
+                switch ($signatureAlgorithm) {
+                    case 'md2WithRSAEncryption':
+                    case 'md5WithRSAEncryption':
+                    case 'sha1WithRSAEncryption':
+                    case 'sha224WithRSAEncryption':
+                    case 'sha256WithRSAEncryption':
+                    case 'sha384WithRSAEncryption':
+                    case 'sha512WithRSAEncryption':
+                        $rsa->setHash(preg_replace('#WithRSAEncryption$#', '', $signatureAlgorithm));
+                        $rsa->setSignatureMode(RSA::SIGNATURE_PKCS1);
+                        if (!@$rsa->verify($signatureSubject, $signature)) {
+                            return false;
+                        }
+                        break;
+                    default:
+                        return null;
+                }
+                break;
+            default:
+                return null;
+        }
+
+        return true;
+    }
+
+    /**
+     * Sets the recursion limit
+     *
+     * When validating a signature it may be necessary to download intermediate certs from URI's.
+     * An intermediate cert that linked to itself would result in an infinite loop so to prevent
+     * that we set a recursion limit. A negative number means that there is no recursion limit.
+     *
+     * @param int $count
+     * @access public
+     */
+    static function setRecurLimit($count)
+    {
+        self::$recur_limit = $count;
+    }
+
+    /**
+     * Prevents URIs from being automatically retrieved
+     *
+     * @access public
+     */
+    static function disableURLFetch()
+    {
+        self::$disable_url_fetch = true;
+    }
+
+    /**
+     * Allows URIs to be automatically retrieved
+     *
+     * @access public
+     */
+    static function enableURLFetch()
+    {
+        self::$disable_url_fetch = false;
+    }
+
+    /**
+     * Reformat public keys
+     *
+     * Reformats a public key to a format supported by phpseclib (if applicable)
+     *
+     * @param string $algorithm
+     * @param string $key
+     * @access private
+     * @return string
+     */
+    function _reformatKey($algorithm, $key)
+    {
+        switch ($algorithm) {
+            case 'rsaEncryption':
+                return
+                    "-----BEGIN RSA PUBLIC KEY-----\r\n" .
+                    // subjectPublicKey is stored as a bit string in X.509 certs.  the first byte of a bit string represents how many bits
+                    // in the last byte should be ignored.  the following only supports non-zero stuff but as none of the X.509 certs Firefox
+                    // uses as a cert authority actually use a non-zero bit I think it's safe to assume that none do.
+                    chunk_split(base64_encode(substr(base64_decode($key), 1)), 64) .
+                    '-----END RSA PUBLIC KEY-----';
+            default:
+                return $key;
+        }
+    }
+
+    /**
+     * Decodes an IP address
+     *
+     * Takes in a base64 encoded "blob" and returns a human readable IP address
+     *
+     * @param string $ip
+     * @access private
+     * @return string
+     */
+    function _decodeIP($ip)
+    {
+        return inet_ntop(base64_decode($ip));
+    }
+
+    /**
+     * Encodes an IP address
+     *
+     * Takes a human readable IP address into a base64-encoded "blob"
+     *
+     * @param string $ip
+     * @access private
+     * @return string
+     */
+    function _encodeIP($ip)
+    {
+        return base64_encode(inet_pton($ip));
+    }
+
+    /**
+     * "Normalizes" a Distinguished Name property
+     *
+     * @param string $propName
+     * @access private
+     * @return mixed
+     */
+    function _translateDNProp($propName)
+    {
+        switch (strtolower($propName)) {
+            case 'id-at-countryname':
+            case 'countryname':
+            case 'c':
+                return 'id-at-countryName';
+            case 'id-at-organizationname':
+            case 'organizationname':
+            case 'o':
+                return 'id-at-organizationName';
+            case 'id-at-dnqualifier':
+            case 'dnqualifier':
+                return 'id-at-dnQualifier';
+            case 'id-at-commonname':
+            case 'commonname':
+            case 'cn':
+                return 'id-at-commonName';
+            case 'id-at-stateorprovincename':
+            case 'stateorprovincename':
+            case 'state':
+            case 'province':
+            case 'provincename':
+            case 'st':
+                return 'id-at-stateOrProvinceName';
+            case 'id-at-localityname':
+            case 'localityname':
+            case 'l':
+                return 'id-at-localityName';
+            case 'id-emailaddress':
+            case 'emailaddress':
+                return 'pkcs-9-at-emailAddress';
+            case 'id-at-serialnumber':
+            case 'serialnumber':
+                return 'id-at-serialNumber';
+            case 'id-at-postalcode':
+            case 'postalcode':
+                return 'id-at-postalCode';
+            case 'id-at-streetaddress':
+            case 'streetaddress':
+                return 'id-at-streetAddress';
+            case 'id-at-name':
+            case 'name':
+                return 'id-at-name';
+            case 'id-at-givenname':
+            case 'givenname':
+                return 'id-at-givenName';
+            case 'id-at-surname':
+            case 'surname':
+            case 'sn':
+                return 'id-at-surname';
+            case 'id-at-initials':
+            case 'initials':
+                return 'id-at-initials';
+            case 'id-at-generationqualifier':
+            case 'generationqualifier':
+                return 'id-at-generationQualifier';
+            case 'id-at-organizationalunitname':
+            case 'organizationalunitname':
+            case 'ou':
+                return 'id-at-organizationalUnitName';
+            case 'id-at-pseudonym':
+            case 'pseudonym':
+                return 'id-at-pseudonym';
+            case 'id-at-title':
+            case 'title':
+                return 'id-at-title';
+            case 'id-at-description':
+            case 'description':
+                return 'id-at-description';
+            case 'id-at-role':
+            case 'role':
+                return 'id-at-role';
+            case 'id-at-uniqueidentifier':
+            case 'uniqueidentifier':
+            case 'x500uniqueidentifier':
+                return 'id-at-uniqueIdentifier';
+            case 'postaladdress':
+            case 'id-at-postaladdress':
+                return 'id-at-postalAddress';
+            default:
+                return false;
+        }
+    }
+
+    /**
+     * Set a Distinguished Name property
+     *
+     * @param string $propName
+     * @param mixed $propValue
+     * @param string $type optional
+     * @access public
+     * @return bool
+     */
+    function setDNProp($propName, $propValue, $type = 'utf8String')
+    {
+        if (empty($this->dn)) {
+            $this->dn = array('rdnSequence' => array());
+        }
+
+        if (($propName = $this->_translateDNProp($propName)) === false) {
+            return false;
+        }
+
+        foreach ((array) $propValue as $v) {
+            if (!is_array($v) && isset($type)) {
+                $v = array($type => $v);
+            }
+            $this->dn['rdnSequence'][] = array(
+                array(
+                    'type' => $propName,
+                    'value'=> $v
+                )
+            );
+        }
+
+        return true;
+    }
+
+    /**
+     * Remove Distinguished Name properties
+     *
+     * @param string $propName
+     * @access public
+     */
+    function removeDNProp($propName)
+    {
+        if (empty($this->dn)) {
+            return;
+        }
+
+        if (($propName = $this->_translateDNProp($propName)) === false) {
+            return;
+        }
+
+        $dn = &$this->dn['rdnSequence'];
+        $size = count($dn);
+        for ($i = 0; $i < $size; $i++) {
+            if ($dn[$i][0]['type'] == $propName) {
+                unset($dn[$i]);
+            }
+        }
+
+        $dn = array_values($dn);
+        // fix for https://bugs.php.net/75433 affecting PHP 7.2
+        if (!isset($dn[0])) {
+            $dn = array_splice($dn, 0, 0);
+        }
+    }
+
+    /**
+     * Get Distinguished Name properties
+     *
+     * @param string $propName
+     * @param array $dn optional
+     * @param bool $withType optional
+     * @return mixed
+     * @access public
+     */
+    function getDNProp($propName, $dn = null, $withType = false)
+    {
+        if (!isset($dn)) {
+            $dn = $this->dn;
+        }
+
+        if (empty($dn)) {
+            return false;
+        }
+
+        if (($propName = $this->_translateDNProp($propName)) === false) {
+            return false;
+        }
+
+        $asn1 = new ASN1();
+        $asn1->loadOIDs($this->oids);
+        $filters = array();
+        $filters['value'] = array('type' => ASN1::TYPE_UTF8_STRING);
+        $asn1->loadFilters($filters);
+        $this->_mapOutDNs($dn, 'rdnSequence', $asn1);
+        $dn = $dn['rdnSequence'];
+        $result = array();
+        for ($i = 0; $i < count($dn); $i++) {
+            if ($dn[$i][0]['type'] == $propName) {
+                $v = $dn[$i][0]['value'];
+                if (!$withType) {
+                    if (is_array($v)) {
+                        foreach ($v as $type => $s) {
+                            $type = array_search($type, $asn1->ANYmap, true);
+                            if ($type !== false && isset($asn1->stringTypeSize[$type])) {
+                                $s = $asn1->convert($s, $type);
+                                if ($s !== false) {
+                                    $v = $s;
+                                    break;
+                                }
+                            }
+                        }
+                        if (is_array($v)) {
+                            $v = array_pop($v); // Always strip data type.
+                        }
+                    } elseif (is_object($v) && $v instanceof Element) {
+                        $map = $this->_getMapping($propName);
+                        if (!is_bool($map)) {
+                            $decoded = $asn1->decodeBER($v);
+                            $v = $asn1->asn1map($decoded[0], $map);
+                        }
+                    }
+                }
+                $result[] = $v;
+            }
+        }
+
+        return $result;
+    }
+
+    /**
+     * Set a Distinguished Name
+     *
+     * @param mixed $dn
+     * @param bool $merge optional
+     * @param string $type optional
+     * @access public
+     * @return bool
+     */
+    function setDN($dn, $merge = false, $type = 'utf8String')
+    {
+        if (!$merge) {
+            $this->dn = null;
+        }
+
+        if (is_array($dn)) {
+            if (isset($dn['rdnSequence'])) {
+                $this->dn = $dn; // No merge here.
+                return true;
+            }
+
+            // handles stuff generated by openssl_x509_parse()
+            foreach ($dn as $prop => $value) {
+                if (!$this->setDNProp($prop, $value, $type)) {
+                    return false;
+                }
+            }
+            return true;
+        }
+
+        // handles everything else
+        $results = preg_split('#((?:^|, *|/)(?:C=|O=|OU=|CN=|L=|ST=|SN=|postalCode=|streetAddress=|emailAddress=|serialNumber=|organizationalUnitName=|title=|description=|role=|x500UniqueIdentifier=|postalAddress=))#', $dn, -1, PREG_SPLIT_DELIM_CAPTURE);
+        for ($i = 1; $i < count($results); $i+=2) {
+            $prop = trim($results[$i], ', =/');
+            $value = $results[$i + 1];
+            if (!$this->setDNProp($prop, $value, $type)) {
+                return false;
+            }
+        }
+
+        return true;
+    }
+
+    /**
+     * Get the Distinguished Name for a certificates subject
+     *
+     * @param mixed $format optional
+     * @param array $dn optional
+     * @access public
+     * @return bool
+     */
+    function getDN($format = self::DN_ARRAY, $dn = null)
+    {
+        if (!isset($dn)) {
+            $dn = isset($this->currentCert['tbsCertList']) ? $this->currentCert['tbsCertList']['issuer'] : $this->dn;
+        }
+
+        switch ((int) $format) {
+            case self::DN_ARRAY:
+                return $dn;
+            case self::DN_ASN1:
+                $asn1 = new ASN1();
+                $asn1->loadOIDs($this->oids);
+                $filters = array();
+                $filters['rdnSequence']['value'] = array('type' => ASN1::TYPE_UTF8_STRING);
+                $asn1->loadFilters($filters);
+                $this->_mapOutDNs($dn, 'rdnSequence', $asn1);
+                return $asn1->encodeDER($dn, $this->Name);
+            case self::DN_CANON:
+                //  No SEQUENCE around RDNs and all string values normalized as
+                // trimmed lowercase UTF-8 with all spacing as one blank.
+                // constructed RDNs will not be canonicalized
+                $asn1 = new ASN1();
+                $asn1->loadOIDs($this->oids);
+                $filters = array();
+                $filters['value'] = array('type' => ASN1::TYPE_UTF8_STRING);
+                $asn1->loadFilters($filters);
+                $result = '';
+                $this->_mapOutDNs($dn, 'rdnSequence', $asn1);
+                foreach ($dn['rdnSequence'] as $rdn) {
+                    foreach ($rdn as $i => $attr) {
+                        $attr = &$rdn[$i];
+                        if (is_array($attr['value'])) {
+                            foreach ($attr['value'] as $type => $v) {
+                                $type = array_search($type, $asn1->ANYmap, true);
+                                if ($type !== false && isset($asn1->stringTypeSize[$type])) {
+                                    $v = $asn1->convert($v, $type);
+                                    if ($v !== false) {
+                                        $v = preg_replace('/\s+/', ' ', $v);
+                                        $attr['value'] = strtolower(trim($v));
+                                        break;
+                                    }
+                                }
+                            }
+                        }
+                    }
+                    $result .= $asn1->encodeDER($rdn, $this->RelativeDistinguishedName);
+                }
+                return $result;
+            case self::DN_HASH:
+                $dn = $this->getDN(self::DN_CANON, $dn);
+                $hash = new Hash('sha1');
+                $hash = $hash->hash($dn);
+                extract(unpack('Vhash', $hash));
+                return strtolower(bin2hex(pack('N', $hash)));
+        }
+
+        // Default is to return a string.
+        $start = true;
+        $output = '';
+
+        $result = array();
+        $asn1 = new ASN1();
+        $asn1->loadOIDs($this->oids);
+        $filters = array();
+        $filters['rdnSequence']['value'] = array('type' => ASN1::TYPE_UTF8_STRING);
+        $asn1->loadFilters($filters);
+        $this->_mapOutDNs($dn, 'rdnSequence', $asn1);
+
+        foreach ($dn['rdnSequence'] as $field) {
+            $prop = $field[0]['type'];
+            $value = $field[0]['value'];
+
+            $delim = ', ';
+            switch ($prop) {
+                case 'id-at-countryName':
+                    $desc = 'C';
+                    break;
+                case 'id-at-stateOrProvinceName':
+                    $desc = 'ST';
+                    break;
+                case 'id-at-organizationName':
+                    $desc = 'O';
+                    break;
+                case 'id-at-organizationalUnitName':
+                    $desc = 'OU';
+                    break;
+                case 'id-at-commonName':
+                    $desc = 'CN';
+                    break;
+                case 'id-at-localityName':
+                    $desc = 'L';
+                    break;
+                case 'id-at-surname':
+                    $desc = 'SN';
+                    break;
+                case 'id-at-uniqueIdentifier':
+                    $delim = '/';
+                    $desc = 'x500UniqueIdentifier';
+                    break;
+                case 'id-at-postalAddress':
+                    $delim = '/';
+                    $desc = 'postalAddress';
+                    break;
+                default:
+                    $delim = '/';
+                    $desc = preg_replace('#.+-([^-]+)$#', '$1', $prop);
+            }
+
+            if (!$start) {
+                $output.= $delim;
+            }
+            if (is_array($value)) {
+                foreach ($value as $type => $v) {
+                    $type = array_search($type, $asn1->ANYmap, true);
+                    if ($type !== false && isset($asn1->stringTypeSize[$type])) {
+                        $v = $asn1->convert($v, $type);
+                        if ($v !== false) {
+                            $value = $v;
+                            break;
+                        }
+                    }
+                }
+                if (is_array($value)) {
+                    $value = array_pop($value); // Always strip data type.
+                }
+            } elseif (is_object($value) && $value instanceof Element) {
+                $callback = function ($x) {
+                    return "\x" . bin2hex($x[0]);
+                };
+                $value = strtoupper(preg_replace_callback('#[^\x20-\x7E]#', $callback, $value->element));
+            }
+            $output.= $desc . '=' . $value;
+            $result[$desc] = isset($result[$desc]) ?
+                array_merge((array) $dn[$prop], array($value)) :
+                $value;
+            $start = false;
+        }
+
+        return $format == self::DN_OPENSSL ? $result : $output;
+    }
+
+    /**
+     * Get the Distinguished Name for a certificate/crl issuer
+     *
+     * @param int $format optional
+     * @access public
+     * @return mixed
+     */
+    function getIssuerDN($format = self::DN_ARRAY)
+    {
+        switch (true) {
+            case !isset($this->currentCert) || !is_array($this->currentCert):
+                break;
+            case isset($this->currentCert['tbsCertificate']):
+                return $this->getDN($format, $this->currentCert['tbsCertificate']['issuer']);
+            case isset($this->currentCert['tbsCertList']):
+                return $this->getDN($format, $this->currentCert['tbsCertList']['issuer']);
+        }
+
+        return false;
+    }
+
+    /**
+     * Get the Distinguished Name for a certificate/csr subject
+     * Alias of getDN()
+     *
+     * @param int $format optional
+     * @access public
+     * @return mixed
+     */
+    function getSubjectDN($format = self::DN_ARRAY)
+    {
+        switch (true) {
+            case !empty($this->dn):
+                return $this->getDN($format);
+            case !isset($this->currentCert) || !is_array($this->currentCert):
+                break;
+            case isset($this->currentCert['tbsCertificate']):
+                return $this->getDN($format, $this->currentCert['tbsCertificate']['subject']);
+            case isset($this->currentCert['certificationRequestInfo']):
+                return $this->getDN($format, $this->currentCert['certificationRequestInfo']['subject']);
+        }
+
+        return false;
+    }
+
+    /**
+     * Get an individual Distinguished Name property for a certificate/crl issuer
+     *
+     * @param string $propName
+     * @param bool $withType optional
+     * @access public
+     * @return mixed
+     */
+    function getIssuerDNProp($propName, $withType = false)
+    {
+        switch (true) {
+            case !isset($this->currentCert) || !is_array($this->currentCert):
+                break;
+            case isset($this->currentCert['tbsCertificate']):
+                return $this->getDNProp($propName, $this->currentCert['tbsCertificate']['issuer'], $withType);
+            case isset($this->currentCert['tbsCertList']):
+                return $this->getDNProp($propName, $this->currentCert['tbsCertList']['issuer'], $withType);
+        }
+
+        return false;
+    }
+
+    /**
+     * Get an individual Distinguished Name property for a certificate/csr subject
+     *
+     * @param string $propName
+     * @param bool $withType optional
+     * @access public
+     * @return mixed
+     */
+    function getSubjectDNProp($propName, $withType = false)
+    {
+        switch (true) {
+            case !empty($this->dn):
+                return $this->getDNProp($propName, null, $withType);
+            case !isset($this->currentCert) || !is_array($this->currentCert):
+                break;
+            case isset($this->currentCert['tbsCertificate']):
+                return $this->getDNProp($propName, $this->currentCert['tbsCertificate']['subject'], $withType);
+            case isset($this->currentCert['certificationRequestInfo']):
+                return $this->getDNProp($propName, $this->currentCert['certificationRequestInfo']['subject'], $withType);
+        }
+
+        return false;
+    }
+
+    /**
+     * Get the certificate chain for the current cert
+     *
+     * @access public
+     * @return mixed
+     */
+    function getChain()
+    {
+        $chain = array($this->currentCert);
+
+        if (!is_array($this->currentCert) || !isset($this->currentCert['tbsCertificate'])) {
+            return false;
+        }
+        if (empty($this->CAs)) {
+            return $chain;
+        }
+        while (true) {
+            $currentCert = $chain[count($chain) - 1];
+            for ($i = 0; $i < count($this->CAs); $i++) {
+                $ca = $this->CAs[$i];
+                if ($currentCert['tbsCertificate']['issuer'] === $ca['tbsCertificate']['subject']) {
+                    $authorityKey = $this->getExtension('id-ce-authorityKeyIdentifier', $currentCert);
+                    $subjectKeyID = $this->getExtension('id-ce-subjectKeyIdentifier', $ca);
+                    switch (true) {
+                        case !is_array($authorityKey):
+                        case is_array($authorityKey) && isset($authorityKey['keyIdentifier']) && $authorityKey['keyIdentifier'] === $subjectKeyID:
+                            if ($currentCert === $ca) {
+                                break 3;
+                            }
+                            $chain[] = $ca;
+                            break 2;
+                    }
+                }
+            }
+            if ($i == count($this->CAs)) {
+                break;
+            }
+        }
+        foreach ($chain as $key => $value) {
+            $chain[$key] = new X509();
+            $chain[$key]->loadX509($value);
+        }
+        return $chain;
+    }
+
+    /**
+     * Set public key
+     *
+     * Key needs to be a \phpseclib\Crypt\RSA object
+     *
+     * @param object $key
+     * @access public
+     * @return bool
+     */
+    function setPublicKey($key)
+    {
+        $key->setPublicKey();
+        $this->publicKey = $key;
+    }
+
+    /**
+     * Set private key
+     *
+     * Key needs to be a \phpseclib\Crypt\RSA object
+     *
+     * @param object $key
+     * @access public
+     */
+    function setPrivateKey($key)
+    {
+        $this->privateKey = $key;
+    }
+
+    /**
+     * Set challenge
+     *
+     * Used for SPKAC CSR's
+     *
+     * @param string $challenge
+     * @access public
+     */
+    function setChallenge($challenge)
+    {
+        $this->challenge = $challenge;
+    }
+
+    /**
+     * Gets the public key
+     *
+     * Returns a \phpseclib\Crypt\RSA object or a false.
+     *
+     * @access public
+     * @return mixed
+     */
+    function getPublicKey()
+    {
+        if (isset($this->publicKey)) {
+            return $this->publicKey;
+        }
+
+        if (isset($this->currentCert) && is_array($this->currentCert)) {
+            foreach (array('tbsCertificate/subjectPublicKeyInfo', 'certificationRequestInfo/subjectPKInfo') as $path) {
+                $keyinfo = $this->_subArray($this->currentCert, $path);
+                if (!empty($keyinfo)) {
+                    break;
+                }
+            }
+        }
+        if (empty($keyinfo)) {
+            return false;
+        }
+
+        $key = $keyinfo['subjectPublicKey'];
+
+        switch ($keyinfo['algorithm']['algorithm']) {
+            case 'rsaEncryption':
+                $publicKey = new RSA();
+                $publicKey->loadKey($key);
+                $publicKey->setPublicKey();
+                break;
+            default:
+                return false;
+        }
+
+        return $publicKey;
+    }
+
+    /**
+     * Load a Certificate Signing Request
+     *
+     * @param string $csr
+     * @access public
+     * @return mixed
+     */
+    function loadCSR($csr, $mode = self::FORMAT_AUTO_DETECT)
+    {
+        if (is_array($csr) && isset($csr['certificationRequestInfo'])) {
+            unset($this->currentCert);
+            unset($this->currentKeyIdentifier);
+            unset($this->signatureSubject);
+            $this->dn = $csr['certificationRequestInfo']['subject'];
+            if (!isset($this->dn)) {
+                return false;
+            }
+
+            $this->currentCert = $csr;
+            return $csr;
+        }
+
+        // see http://tools.ietf.org/html/rfc2986
+
+        $asn1 = new ASN1();
+
+        if ($mode != self::FORMAT_DER) {
+            $newcsr = $this->_extractBER($csr);
+            if ($mode == self::FORMAT_PEM && $csr == $newcsr) {
+                return false;
+            }
+            $csr = $newcsr;
+        }
+        $orig = $csr;
+
+        if ($csr === false) {
+            $this->currentCert = false;
+            return false;
+        }
+
+        $asn1->loadOIDs($this->oids);
+        $decoded = $asn1->decodeBER($csr);
+
+        if (empty($decoded)) {
+            $this->currentCert = false;
+            return false;
+        }
+
+        $csr = $asn1->asn1map($decoded[0], $this->CertificationRequest);
+        if (!isset($csr) || $csr === false) {
+            $this->currentCert = false;
+            return false;
+        }
+
+        $this->_mapInAttributes($csr, 'certificationRequestInfo/attributes', $asn1);
+        $this->_mapInDNs($csr, 'certificationRequestInfo/subject/rdnSequence', $asn1);
+
+        $this->dn = $csr['certificationRequestInfo']['subject'];
+
+        $this->signatureSubject = substr($orig, $decoded[0]['content'][0]['start'], $decoded[0]['content'][0]['length']);
+
+        $algorithm = &$csr['certificationRequestInfo']['subjectPKInfo']['algorithm']['algorithm'];
+        $key = &$csr['certificationRequestInfo']['subjectPKInfo']['subjectPublicKey'];
+        $key = $this->_reformatKey($algorithm, $key);
+
+        switch ($algorithm) {
+            case 'rsaEncryption':
+                $this->publicKey = new RSA();
+                $this->publicKey->loadKey($key);
+                $this->publicKey->setPublicKey();
+                break;
+            default:
+                $this->publicKey = null;
+        }
+
+        $this->currentKeyIdentifier = null;
+        $this->currentCert = $csr;
+
+        return $csr;
+    }
+
+    /**
+     * Save CSR request
+     *
+     * @param array $csr
+     * @param int $format optional
+     * @access public
+     * @return string
+     */
+    function saveCSR($csr, $format = self::FORMAT_PEM)
+    {
+        if (!is_array($csr) || !isset($csr['certificationRequestInfo'])) {
+            return false;
+        }
+
+        switch (true) {
+            case !($algorithm = $this->_subArray($csr, 'certificationRequestInfo/subjectPKInfo/algorithm/algorithm')):
+            case is_object($csr['certificationRequestInfo']['subjectPKInfo']['subjectPublicKey']):
+                break;
+            default:
+                switch ($algorithm) {
+                    case 'rsaEncryption':
+                        $csr['certificationRequestInfo']['subjectPKInfo']['subjectPublicKey']
+                            = base64_encode("\0" . base64_decode(preg_replace('#-.+-|[\r\n]#', '', $csr['certificationRequestInfo']['subjectPKInfo']['subjectPublicKey'])));
+                        $csr['certificationRequestInfo']['subjectPKInfo']['algorithm']['parameters'] = null;
+                        $csr['signatureAlgorithm']['parameters'] = null;
+                        $csr['certificationRequestInfo']['signature']['parameters'] = null;
+                }
+        }
+
+        $asn1 = new ASN1();
+
+        $asn1->loadOIDs($this->oids);
+
+        $filters = array();
+        $filters['certificationRequestInfo']['subject']['rdnSequence']['value']
+            = array('type' => ASN1::TYPE_UTF8_STRING);
+
+        $asn1->loadFilters($filters);
+
+        $this->_mapOutDNs($csr, 'certificationRequestInfo/subject/rdnSequence', $asn1);
+        $this->_mapOutAttributes($csr, 'certificationRequestInfo/attributes', $asn1);
+        $csr = $asn1->encodeDER($csr, $this->CertificationRequest);
+
+        switch ($format) {
+            case self::FORMAT_DER:
+                return $csr;
+            // case self::FORMAT_PEM:
+            default:
+                return "-----BEGIN CERTIFICATE REQUEST-----\r\n" . chunk_split(base64_encode($csr), 64) . '-----END CERTIFICATE REQUEST-----';
+        }
+    }
+
+    /**
+     * Load a SPKAC CSR
+     *
+     * SPKAC's are produced by the HTML5 keygen element:
+     *
+     * https://developer.mozilla.org/en-US/docs/HTML/Element/keygen
+     *
+     * @param string $csr
+     * @access public
+     * @return mixed
+     */
+    function loadSPKAC($spkac)
+    {
+        if (is_array($spkac) && isset($spkac['publicKeyAndChallenge'])) {
+            unset($this->currentCert);
+            unset($this->currentKeyIdentifier);
+            unset($this->signatureSubject);
+            $this->currentCert = $spkac;
+            return $spkac;
+        }
+
+        // see http://www.w3.org/html/wg/drafts/html/master/forms.html#signedpublickeyandchallenge
+
+        $asn1 = new ASN1();
+
+        // OpenSSL produces SPKAC's that are preceded by the string SPKAC=
+        $temp = preg_replace('#(?:SPKAC=)|[ \r\n\\\]#', '', $spkac);
+        $temp = preg_match('#^[a-zA-Z\d/+]*={0,2}$#', $temp) ? base64_decode($temp) : false;
+        if ($temp != false) {
+            $spkac = $temp;
+        }
+        $orig = $spkac;
+
+        if ($spkac === false) {
+            $this->currentCert = false;
+            return false;
+        }
+
+        $asn1->loadOIDs($this->oids);
+        $decoded = $asn1->decodeBER($spkac);
+
+        if (empty($decoded)) {
+            $this->currentCert = false;
+            return false;
+        }
+
+        $spkac = $asn1->asn1map($decoded[0], $this->SignedPublicKeyAndChallenge);
+
+        if (!isset($spkac) || $spkac === false) {
+            $this->currentCert = false;
+            return false;
+        }
+
+        $this->signatureSubject = substr($orig, $decoded[0]['content'][0]['start'], $decoded[0]['content'][0]['length']);
+
+        $algorithm = &$spkac['publicKeyAndChallenge']['spki']['algorithm']['algorithm'];
+        $key = &$spkac['publicKeyAndChallenge']['spki']['subjectPublicKey'];
+        $key = $this->_reformatKey($algorithm, $key);
+
+        switch ($algorithm) {
+            case 'rsaEncryption':
+                $this->publicKey = new RSA();
+                $this->publicKey->loadKey($key);
+                $this->publicKey->setPublicKey();
+                break;
+            default:
+                $this->publicKey = null;
+        }
+
+        $this->currentKeyIdentifier = null;
+        $this->currentCert = $spkac;
+
+        return $spkac;
+    }
+
+    /**
+     * Save a SPKAC CSR request
+     *
+     * @param array $csr
+     * @param int $format optional
+     * @access public
+     * @return string
+     */
+    function saveSPKAC($spkac, $format = self::FORMAT_PEM)
+    {
+        if (!is_array($spkac) || !isset($spkac['publicKeyAndChallenge'])) {
+            return false;
+        }
+
+        $algorithm = $this->_subArray($spkac, 'publicKeyAndChallenge/spki/algorithm/algorithm');
+        switch (true) {
+            case !$algorithm:
+            case is_object($spkac['publicKeyAndChallenge']['spki']['subjectPublicKey']):
+                break;
+            default:
+                switch ($algorithm) {
+                    case 'rsaEncryption':
+                        $spkac['publicKeyAndChallenge']['spki']['subjectPublicKey']
+                            = base64_encode("\0" . base64_decode(preg_replace('#-.+-|[\r\n]#', '', $spkac['publicKeyAndChallenge']['spki']['subjectPublicKey'])));
+                }
+        }
+
+        $asn1 = new ASN1();
+
+        $asn1->loadOIDs($this->oids);
+        $spkac = $asn1->encodeDER($spkac, $this->SignedPublicKeyAndChallenge);
+
+        switch ($format) {
+            case self::FORMAT_DER:
+                return $spkac;
+            // case self::FORMAT_PEM:
+            default:
+                // OpenSSL's implementation of SPKAC requires the SPKAC be preceded by SPKAC= and since there are pretty much
+                // no other SPKAC decoders phpseclib will use that same format
+                return 'SPKAC=' . base64_encode($spkac);
+        }
+    }
+
+    /**
+     * Load a Certificate Revocation List
+     *
+     * @param string $crl
+     * @access public
+     * @return mixed
+     */
+    function loadCRL($crl, $mode = self::FORMAT_AUTO_DETECT)
+    {
+        if (is_array($crl) && isset($crl['tbsCertList'])) {
+            $this->currentCert = $crl;
+            unset($this->signatureSubject);
+            return $crl;
+        }
+
+        $asn1 = new ASN1();
+
+        if ($mode != self::FORMAT_DER) {
+            $newcrl = $this->_extractBER($crl);
+            if ($mode == self::FORMAT_PEM && $crl == $newcrl) {
+                return false;
+            }
+            $crl = $newcrl;
+        }
+        $orig = $crl;
+
+        if ($crl === false) {
+            $this->currentCert = false;
+            return false;
+        }
+
+        $asn1->loadOIDs($this->oids);
+        $decoded = $asn1->decodeBER($crl);
+
+        if (empty($decoded)) {
+            $this->currentCert = false;
+            return false;
+        }
+
+        $crl = $asn1->asn1map($decoded[0], $this->CertificateList);
+        if (!isset($crl) || $crl === false) {
+            $this->currentCert = false;
+            return false;
+        }
+
+        $this->signatureSubject = substr($orig, $decoded[0]['content'][0]['start'], $decoded[0]['content'][0]['length']);
+
+        $this->_mapInDNs($crl, 'tbsCertList/issuer/rdnSequence', $asn1);
+        if ($this->_isSubArrayValid($crl, 'tbsCertList/crlExtensions')) {
+            $this->_mapInExtensions($crl, 'tbsCertList/crlExtensions', $asn1);
+        }
+        if ($this->_isSubArrayValid($crl, 'tbsCertList/revokedCertificates')) {
+            $rclist_ref = &$this->_subArrayUnchecked($crl, 'tbsCertList/revokedCertificates');
+            if ($rclist_ref) {
+                $rclist = $crl['tbsCertList']['revokedCertificates'];
+                foreach ($rclist as $i => $extension) {
+                    if ($this->_isSubArrayValid($rclist, "$i/crlEntryExtensions", $asn1)) {
+                        $this->_mapInExtensions($rclist_ref, "$i/crlEntryExtensions", $asn1);
+                    }
+                }
+            }
+        }
+
+        $this->currentKeyIdentifier = null;
+        $this->currentCert = $crl;
+
+        return $crl;
+    }
+
+    /**
+     * Save Certificate Revocation List.
+     *
+     * @param array $crl
+     * @param int $format optional
+     * @access public
+     * @return string
+     */
+    function saveCRL($crl, $format = self::FORMAT_PEM)
+    {
+        if (!is_array($crl) || !isset($crl['tbsCertList'])) {
+            return false;
+        }
+
+        $asn1 = new ASN1();
+
+        $asn1->loadOIDs($this->oids);
+
+        $filters = array();
+        $filters['tbsCertList']['issuer']['rdnSequence']['value']
+            = array('type' => ASN1::TYPE_UTF8_STRING);
+        $filters['tbsCertList']['signature']['parameters']
+            = array('type' => ASN1::TYPE_UTF8_STRING);
+        $filters['signatureAlgorithm']['parameters']
+            = array('type' => ASN1::TYPE_UTF8_STRING);
+
+        if (empty($crl['tbsCertList']['signature']['parameters'])) {
+            $filters['tbsCertList']['signature']['parameters']
+                = array('type' => ASN1::TYPE_NULL);
+        }
+
+        if (empty($crl['signatureAlgorithm']['parameters'])) {
+            $filters['signatureAlgorithm']['parameters']
+                = array('type' => ASN1::TYPE_NULL);
+        }
+
+        $asn1->loadFilters($filters);
+
+        $this->_mapOutDNs($crl, 'tbsCertList/issuer/rdnSequence', $asn1);
+        $this->_mapOutExtensions($crl, 'tbsCertList/crlExtensions', $asn1);
+        $rclist = &$this->_subArray($crl, 'tbsCertList/revokedCertificates');
+        if (is_array($rclist)) {
+            foreach ($rclist as $i => $extension) {
+                $this->_mapOutExtensions($rclist, "$i/crlEntryExtensions", $asn1);
+            }
+        }
+
+        $crl = $asn1->encodeDER($crl, $this->CertificateList);
+
+        switch ($format) {
+            case self::FORMAT_DER:
+                return $crl;
+            // case self::FORMAT_PEM:
+            default:
+                return "-----BEGIN X509 CRL-----\r\n" . chunk_split(base64_encode($crl), 64) . '-----END X509 CRL-----';
+        }
+    }
+
+    /**
+     * Helper function to build a time field according to RFC 3280 section
+     *  - 4.1.2.5 Validity
+     *  - 5.1.2.4 This Update
+     *  - 5.1.2.5 Next Update
+     *  - 5.1.2.6 Revoked Certificates
+     * by choosing utcTime iff year of date given is before 2050 and generalTime else.
+     *
+     * @param string $date in format date('D, d M Y H:i:s O')
+     * @access private
+     * @return array
+     */
+    function _timeField($date)
+    {
+        if ($date instanceof Element) {
+            return $date;
+        }
+        $dateObj = new DateTime($date, new DateTimeZone('GMT'));
+        $year = $dateObj->format('Y'); // the same way ASN1.php parses this
+        if ($year < 2050) {
+            return array('utcTime' => $date);
+        } else {
+            return array('generalTime' => $date);
+        }
+    }
+
+    /**
+     * Sign an X.509 certificate
+     *
+     * $issuer's private key needs to be loaded.
+     * $subject can be either an existing X.509 cert (if you want to resign it),
+     * a CSR or something with the DN and public key explicitly set.
+     *
+     * @param \phpseclib\File\X509 $issuer
+     * @param \phpseclib\File\X509 $subject
+     * @param string $signatureAlgorithm optional
+     * @access public
+     * @return mixed
+     */
+    function sign($issuer, $subject, $signatureAlgorithm = 'sha1WithRSAEncryption')
+    {
+        if (!is_object($issuer->privateKey) || empty($issuer->dn)) {
+            return false;
+        }
+
+        if (isset($subject->publicKey) && !($subjectPublicKey = $subject->_formatSubjectPublicKey())) {
+            return false;
+        }
+
+        $currentCert = isset($this->currentCert) ? $this->currentCert : null;
+        $signatureSubject = isset($this->signatureSubject) ? $this->signatureSubject: null;
+
+        if (isset($subject->currentCert) && is_array($subject->currentCert) && isset($subject->currentCert['tbsCertificate'])) {
+            $this->currentCert = $subject->currentCert;
+            $this->currentCert['tbsCertificate']['signature']['algorithm'] = $signatureAlgorithm;
+            $this->currentCert['signatureAlgorithm']['algorithm'] = $signatureAlgorithm;
+
+            if (!empty($this->startDate)) {
+                $this->currentCert['tbsCertificate']['validity']['notBefore'] = $this->_timeField($this->startDate);
+            }
+            if (!empty($this->endDate)) {
+                $this->currentCert['tbsCertificate']['validity']['notAfter'] = $this->_timeField($this->endDate);
+            }
+            if (!empty($this->serialNumber)) {
+                $this->currentCert['tbsCertificate']['serialNumber'] = $this->serialNumber;
+            }
+            if (!empty($subject->dn)) {
+                $this->currentCert['tbsCertificate']['subject'] = $subject->dn;
+            }
+            if (!empty($subject->publicKey)) {
+                $this->currentCert['tbsCertificate']['subjectPublicKeyInfo'] = $subjectPublicKey;
+            }
+            $this->removeExtension('id-ce-authorityKeyIdentifier');
+            if (isset($subject->domains)) {
+                $this->removeExtension('id-ce-subjectAltName');
+            }
+        } elseif (isset($subject->currentCert) && is_array($subject->currentCert) && isset($subject->currentCert['tbsCertList'])) {
+            return false;
+        } else {
+            if (!isset($subject->publicKey)) {
+                return false;
+            }
+
+            $startDate = new DateTime('now', new DateTimeZone(@date_default_timezone_get()));
+            $startDate = !empty($this->startDate) ? $this->startDate : $startDate->format('D, d M Y H:i:s O');
+
+            $endDate = new DateTime('+1 year', new DateTimeZone(@date_default_timezone_get()));
+            $endDate = !empty($this->endDate) ? $this->endDate : $endDate->format('D, d M Y H:i:s O');
+
+            /* "The serial number MUST be a positive integer"
+               "Conforming CAs MUST NOT use serialNumber values longer than 20 octets."
+                -- https://tools.ietf.org/html/rfc5280#section-4.1.2.2
+
+               for the integer to be positive the leading bit needs to be 0 hence the
+               application of a bitmap
+            */
+            $serialNumber = !empty($this->serialNumber) ?
+                $this->serialNumber :
+                new BigInteger(Random::string(20) & ("\x7F" . str_repeat("\xFF", 19)), 256);
+
+            $this->currentCert = array(
+                'tbsCertificate' =>
+                    array(
+                        'version' => 'v3',
+                        'serialNumber' => $serialNumber, // $this->setSerialNumber()
+                        'signature' => array('algorithm' => $signatureAlgorithm),
+                        'issuer' => false, // this is going to be overwritten later
+                        'validity' => array(
+                            'notBefore' => $this->_timeField($startDate), // $this->setStartDate()
+                            'notAfter' => $this->_timeField($endDate)   // $this->setEndDate()
+                        ),
+                        'subject' => $subject->dn,
+                        'subjectPublicKeyInfo' => $subjectPublicKey
+                    ),
+                    'signatureAlgorithm' => array('algorithm' => $signatureAlgorithm),
+                    'signature'          => false // this is going to be overwritten later
+            );
+
+            // Copy extensions from CSR.
+            $csrexts = $subject->getAttribute('pkcs-9-at-extensionRequest', 0);
+
+            if (!empty($csrexts)) {
+                $this->currentCert['tbsCertificate']['extensions'] = $csrexts;
+            }
+        }
+
+        $this->currentCert['tbsCertificate']['issuer'] = $issuer->dn;
+
+        if (isset($issuer->currentKeyIdentifier)) {
+            $this->setExtension('id-ce-authorityKeyIdentifier', array(
+                    //'authorityCertIssuer' => array(
+                    //    array(
+                    //        'directoryName' => $issuer->dn
+                    //    )
+                    //),
+                    'keyIdentifier' => $issuer->currentKeyIdentifier
+                ));
+            //$extensions = &$this->currentCert['tbsCertificate']['extensions'];
+            //if (isset($issuer->serialNumber)) {
+            //    $extensions[count($extensions) - 1]['authorityCertSerialNumber'] = $issuer->serialNumber;
+            //}
+            //unset($extensions);
+        }
+
+        if (isset($subject->currentKeyIdentifier)) {
+            $this->setExtension('id-ce-subjectKeyIdentifier', $subject->currentKeyIdentifier);
+        }
+
+        $altName = array();
+
+        if (isset($subject->domains) && count($subject->domains)) {
+            $altName = array_map(array('\phpseclib\File\X509', '_dnsName'), $subject->domains);
+        }
+
+        if (isset($subject->ipAddresses) && count($subject->ipAddresses)) {
+            // should an IP address appear as the CN if no domain name is specified? idk
+            //$ips = count($subject->domains) ? $subject->ipAddresses : array_slice($subject->ipAddresses, 1);
+            $ipAddresses = array();
+            foreach ($subject->ipAddresses as $ipAddress) {
+                $encoded = $subject->_ipAddress($ipAddress);
+                if ($encoded !== false) {
+                    $ipAddresses[] = $encoded;
+                }
+            }
+            if (count($ipAddresses)) {
+                $altName = array_merge($altName, $ipAddresses);
+            }
+        }
+
+        if (!empty($altName)) {
+            $this->setExtension('id-ce-subjectAltName', $altName);
+        }
+
+        if ($this->caFlag) {
+            $keyUsage = $this->getExtension('id-ce-keyUsage');
+            if (!$keyUsage) {
+                $keyUsage = array();
+            }
+
+            $this->setExtension(
+                'id-ce-keyUsage',
+                array_values(array_unique(array_merge($keyUsage, array('cRLSign', 'keyCertSign'))))
+            );
+
+            $basicConstraints = $this->getExtension('id-ce-basicConstraints');
+            if (!$basicConstraints) {
+                $basicConstraints = array();
+            }
+
+            $this->setExtension(
+                'id-ce-basicConstraints',
+                array_unique(array_merge(array('cA' => true), $basicConstraints)),
+                true
+            );
+
+            if (!isset($subject->currentKeyIdentifier)) {
+                $this->setExtension('id-ce-subjectKeyIdentifier', base64_encode($this->computeKeyIdentifier($this->currentCert)), false, false);
+            }
+        }
+
+        // resync $this->signatureSubject
+        // save $tbsCertificate in case there are any \phpseclib\File\ASN1\Element objects in it
+        $tbsCertificate = $this->currentCert['tbsCertificate'];
+        $this->loadX509($this->saveX509($this->currentCert));
+
+        $result = $this->_sign($issuer->privateKey, $signatureAlgorithm);
+        $result['tbsCertificate'] = $tbsCertificate;
+
+        $this->currentCert = $currentCert;
+        $this->signatureSubject = $signatureSubject;
+
+        return $result;
+    }
+
+    /**
+     * Sign a CSR
+     *
+     * @access public
+     * @return mixed
+     */
+    function signCSR($signatureAlgorithm = 'sha1WithRSAEncryption')
+    {
+        if (!is_object($this->privateKey) || empty($this->dn)) {
+            return false;
+        }
+
+        $origPublicKey = $this->publicKey;
+        $class = get_class($this->privateKey);
+        $this->publicKey = new $class();
+        $this->publicKey->loadKey($this->privateKey->getPublicKey());
+        $this->publicKey->setPublicKey();
+        if (!($publicKey = $this->_formatSubjectPublicKey())) {
+            return false;
+        }
+        $this->publicKey = $origPublicKey;
+
+        $currentCert = isset($this->currentCert) ? $this->currentCert : null;
+        $signatureSubject = isset($this->signatureSubject) ? $this->signatureSubject: null;
+
+        if (isset($this->currentCert) && is_array($this->currentCert) && isset($this->currentCert['certificationRequestInfo'])) {
+            $this->currentCert['signatureAlgorithm']['algorithm'] = $signatureAlgorithm;
+            if (!empty($this->dn)) {
+                $this->currentCert['certificationRequestInfo']['subject'] = $this->dn;
+            }
+            $this->currentCert['certificationRequestInfo']['subjectPKInfo'] = $publicKey;
+        } else {
+            $this->currentCert = array(
+                'certificationRequestInfo' =>
+                    array(
+                        'version' => 'v1',
+                        'subject' => $this->dn,
+                        'subjectPKInfo' => $publicKey
+                    ),
+                    'signatureAlgorithm' => array('algorithm' => $signatureAlgorithm),
+                    'signature'          => false // this is going to be overwritten later
+            );
+        }
+
+        // resync $this->signatureSubject
+        // save $certificationRequestInfo in case there are any \phpseclib\File\ASN1\Element objects in it
+        $certificationRequestInfo = $this->currentCert['certificationRequestInfo'];
+        $this->loadCSR($this->saveCSR($this->currentCert));
+
+        $result = $this->_sign($this->privateKey, $signatureAlgorithm);
+        $result['certificationRequestInfo'] = $certificationRequestInfo;
+
+        $this->currentCert = $currentCert;
+        $this->signatureSubject = $signatureSubject;
+
+        return $result;
+    }
+
+    /**
+     * Sign a SPKAC
+     *
+     * @access public
+     * @return mixed
+     */
+    function signSPKAC($signatureAlgorithm = 'sha1WithRSAEncryption')
+    {
+        if (!is_object($this->privateKey)) {
+            return false;
+        }
+
+        $origPublicKey = $this->publicKey;
+        $class = get_class($this->privateKey);
+        $this->publicKey = new $class();
+        $this->publicKey->loadKey($this->privateKey->getPublicKey());
+        $this->publicKey->setPublicKey();
+        $publicKey = $this->_formatSubjectPublicKey();
+        if (!$publicKey) {
+            return false;
+        }
+        $this->publicKey = $origPublicKey;
+
+        $currentCert = isset($this->currentCert) ? $this->currentCert : null;
+        $signatureSubject = isset($this->signatureSubject) ? $this->signatureSubject: null;
+
+        // re-signing a SPKAC seems silly but since everything else supports re-signing why not?
+        if (isset($this->currentCert) && is_array($this->currentCert) && isset($this->currentCert['publicKeyAndChallenge'])) {
+            $this->currentCert['signatureAlgorithm']['algorithm'] = $signatureAlgorithm;
+            $this->currentCert['publicKeyAndChallenge']['spki'] = $publicKey;
+            if (!empty($this->challenge)) {
+                // the bitwise AND ensures that the output is a valid IA5String
+                $this->currentCert['publicKeyAndChallenge']['challenge'] = $this->challenge & str_repeat("\x7F", strlen($this->challenge));
+            }
+        } else {
+            $this->currentCert = array(
+                'publicKeyAndChallenge' =>
+                    array(
+                        'spki' => $publicKey,
+                        // quoting <https://developer.mozilla.org/en-US/docs/Web/HTML/Element/keygen>,
+                        // "A challenge string that is submitted along with the public key. Defaults to an empty string if not specified."
+                        // both Firefox and OpenSSL ("openssl spkac -key private.key") behave this way
+                        // we could alternatively do this instead if we ignored the specs:
+                        // Random::string(8) & str_repeat("\x7F", 8)
+                        'challenge' => !empty($this->challenge) ? $this->challenge : ''
+                    ),
+                    'signatureAlgorithm' => array('algorithm' => $signatureAlgorithm),
+                    'signature'          => false // this is going to be overwritten later
+            );
+        }
+
+        // resync $this->signatureSubject
+        // save $publicKeyAndChallenge in case there are any \phpseclib\File\ASN1\Element objects in it
+        $publicKeyAndChallenge = $this->currentCert['publicKeyAndChallenge'];
+        $this->loadSPKAC($this->saveSPKAC($this->currentCert));
+
+        $result = $this->_sign($this->privateKey, $signatureAlgorithm);
+        $result['publicKeyAndChallenge'] = $publicKeyAndChallenge;
+
+        $this->currentCert = $currentCert;
+        $this->signatureSubject = $signatureSubject;
+
+        return $result;
+    }
+
+    /**
+     * Sign a CRL
+     *
+     * $issuer's private key needs to be loaded.
+     *
+     * @param \phpseclib\File\X509 $issuer
+     * @param \phpseclib\File\X509 $crl
+     * @param string $signatureAlgorithm optional
+     * @access public
+     * @return mixed
+     */
+    function signCRL($issuer, $crl, $signatureAlgorithm = 'sha1WithRSAEncryption')
+    {
+        if (!is_object($issuer->privateKey) || empty($issuer->dn)) {
+            return false;
+        }
+
+        $currentCert = isset($this->currentCert) ? $this->currentCert : null;
+        $signatureSubject = isset($this->signatureSubject) ? $this->signatureSubject : null;
+
+        $thisUpdate = new DateTime('now', new DateTimeZone(@date_default_timezone_get()));
+        $thisUpdate = !empty($this->startDate) ? $this->startDate : $thisUpdate->format('D, d M Y H:i:s O');
+
+        if (isset($crl->currentCert) && is_array($crl->currentCert) && isset($crl->currentCert['tbsCertList'])) {
+            $this->currentCert = $crl->currentCert;
+            $this->currentCert['tbsCertList']['signature']['algorithm'] = $signatureAlgorithm;
+            $this->currentCert['signatureAlgorithm']['algorithm'] = $signatureAlgorithm;
+        } else {
+            $this->currentCert = array(
+                'tbsCertList' =>
+                    array(
+                        'version' => 'v2',
+                        'signature' => array('algorithm' => $signatureAlgorithm),
+                        'issuer' => false, // this is going to be overwritten later
+                        'thisUpdate' => $this->_timeField($thisUpdate) // $this->setStartDate()
+                    ),
+                    'signatureAlgorithm' => array('algorithm' => $signatureAlgorithm),
+                    'signature'          => false // this is going to be overwritten later
+            );
+        }
+
+        $tbsCertList = &$this->currentCert['tbsCertList'];
+        $tbsCertList['issuer'] = $issuer->dn;
+        $tbsCertList['thisUpdate'] = $this->_timeField($thisUpdate);
+
+        if (!empty($this->endDate)) {
+            $tbsCertList['nextUpdate'] = $this->_timeField($this->endDate); // $this->setEndDate()
+        } else {
+            unset($tbsCertList['nextUpdate']);
+        }
+
+        if (!empty($this->serialNumber)) {
+            $crlNumber = $this->serialNumber;
+        } else {
+            $crlNumber = $this->getExtension('id-ce-cRLNumber');
+            // "The CRL number is a non-critical CRL extension that conveys a
+            //  monotonically increasing sequence number for a given CRL scope and
+            //  CRL issuer.  This extension allows users to easily determine when a
+            //  particular CRL supersedes another CRL."
+            // -- https://tools.ietf.org/html/rfc5280#section-5.2.3
+            $crlNumber = $crlNumber !== false ? $crlNumber->add(new BigInteger(1)) : null;
+        }
+
+        $this->removeExtension('id-ce-authorityKeyIdentifier');
+        $this->removeExtension('id-ce-issuerAltName');
+
+        // Be sure version >= v2 if some extension found.
+        $version = isset($tbsCertList['version']) ? $tbsCertList['version'] : 0;
+        if (!$version) {
+            if (!empty($tbsCertList['crlExtensions'])) {
+                $version = 1; // v2.
+            } elseif (!empty($tbsCertList['revokedCertificates'])) {
+                foreach ($tbsCertList['revokedCertificates'] as $cert) {
+                    if (!empty($cert['crlEntryExtensions'])) {
+                        $version = 1; // v2.
+                    }
+                }
+            }
+
+            if ($version) {
+                $tbsCertList['version'] = $version;
+            }
+        }
+
+        // Store additional extensions.
+        if (!empty($tbsCertList['version'])) { // At least v2.
+            if (!empty($crlNumber)) {
+                $this->setExtension('id-ce-cRLNumber', $crlNumber);
+            }
+
+            if (isset($issuer->currentKeyIdentifier)) {
+                $this->setExtension('id-ce-authorityKeyIdentifier', array(
+                        //'authorityCertIssuer' => array(
+                        //    array(
+                        //        'directoryName' => $issuer->dn
+                        //    )
+                        //),
+                        'keyIdentifier' => $issuer->currentKeyIdentifier
+                    ));
+                //$extensions = &$tbsCertList['crlExtensions'];
+                //if (isset($issuer->serialNumber)) {
+                //    $extensions[count($extensions) - 1]['authorityCertSerialNumber'] = $issuer->serialNumber;
+                //}
+                //unset($extensions);
+            }
+
+            $issuerAltName = $this->getExtension('id-ce-subjectAltName', $issuer->currentCert);
+
+            if ($issuerAltName !== false) {
+                $this->setExtension('id-ce-issuerAltName', $issuerAltName);
+            }
+        }
+
+        if (empty($tbsCertList['revokedCertificates'])) {
+            unset($tbsCertList['revokedCertificates']);
+        }
+
+        unset($tbsCertList);
+
+        // resync $this->signatureSubject
+        // save $tbsCertList in case there are any \phpseclib\File\ASN1\Element objects in it
+        $tbsCertList = $this->currentCert['tbsCertList'];
+        $this->loadCRL($this->saveCRL($this->currentCert));
+
+        $result = $this->_sign($issuer->privateKey, $signatureAlgorithm);
+        $result['tbsCertList'] = $tbsCertList;
+
+        $this->currentCert = $currentCert;
+        $this->signatureSubject = $signatureSubject;
+
+        return $result;
+    }
+
+    /**
+     * X.509 certificate signing helper function.
+     *
+     * @param object $key
+     * @param \phpseclib\File\X509 $subject
+     * @param string $signatureAlgorithm
+     * @access public
+     * @return mixed
+     */
+    function _sign($key, $signatureAlgorithm)
+    {
+        if ($key instanceof RSA) {
+            switch ($signatureAlgorithm) {
+                case 'md2WithRSAEncryption':
+                case 'md5WithRSAEncryption':
+                case 'sha1WithRSAEncryption':
+                case 'sha224WithRSAEncryption':
+                case 'sha256WithRSAEncryption':
+                case 'sha384WithRSAEncryption':
+                case 'sha512WithRSAEncryption':
+                    $key->setHash(preg_replace('#WithRSAEncryption$#', '', $signatureAlgorithm));
+                    $key->setSignatureMode(RSA::SIGNATURE_PKCS1);
+
+                    $this->currentCert['signature'] = base64_encode("\0" . $key->sign($this->signatureSubject));
+                    return $this->currentCert;
+            }
+        }
+
+        return false;
+    }
+
+    /**
+     * Set certificate start date
+     *
+     * @param string $date
+     * @access public
+     */
+    function setStartDate($date)
+    {
+        if (!is_object($date) || !is_a($date, 'DateTime')) {
+            $date = new DateTime($date, new DateTimeZone(@date_default_timezone_get()));
+        }
+
+        $this->startDate = $date->format('D, d M Y H:i:s O');
+    }
+
+    /**
+     * Set certificate end date
+     *
+     * @param string $date
+     * @access public
+     */
+    function setEndDate($date)
+    {
+        /*
+          To indicate that a certificate has no well-defined expiration date,
+          the notAfter SHOULD be assigned the GeneralizedTime value of
+          99991231235959Z.
+
+          -- http://tools.ietf.org/html/rfc5280#section-4.1.2.5
+        */
+        if (strtolower($date) == 'lifetime') {
+            $temp = '99991231235959Z';
+            $asn1 = new ASN1();
+            $temp = chr(ASN1::TYPE_GENERALIZED_TIME) . $asn1->_encodeLength(strlen($temp)) . $temp;
+            $this->endDate = new Element($temp);
+        } else {
+            if (!is_object($date) || !is_a($date, 'DateTime')) {
+                $date = new DateTime($date, new DateTimeZone(@date_default_timezone_get()));
+            }
+
+            $this->endDate = $date->format('D, d M Y H:i:s O');
+        }
+    }
+
+    /**
+     * Set Serial Number
+     *
+     * @param string $serial
+     * @param $base optional
+     * @access public
+     */
+    function setSerialNumber($serial, $base = -256)
+    {
+        $this->serialNumber = new BigInteger($serial, $base);
+    }
+
+    /**
+     * Turns the certificate into a certificate authority
+     *
+     * @access public
+     */
+    function makeCA()
+    {
+        $this->caFlag = true;
+    }
+
+    /**
+     * Check for validity of subarray
+     *
+     * This is intended for use in conjunction with _subArrayUnchecked(),
+     * implementing the checks included in _subArray() but without copying
+     * a potentially large array by passing its reference by-value to is_array().
+     *
+     * @param array $root
+     * @param string $path
+     * @return boolean
+     * @access private
+     */
+    function _isSubArrayValid($root, $path)
+    {
+        if (!is_array($root)) {
+            return false;
+        }
+
+        foreach (explode('/', $path) as $i) {
+            if (!is_array($root)) {
+                return false;
+            }
+
+            if (!isset($root[$i])) {
+                return true;
+            }
+
+            $root = $root[$i];
+        }
+
+        return true;
+    }
+
+    /**
+     * Get a reference to a subarray
+     *
+     * This variant of _subArray() does no is_array() checking,
+     * so $root should be checked with _isSubArrayValid() first.
+     *
+     * This is here for performance reasons:
+     * Passing a reference (i.e. $root) by-value (i.e. to is_array())
+     * creates a copy. If $root is an especially large array, this is expensive.
+     *
+     * @param array $root
+     * @param string $path  absolute path with / as component separator
+     * @param bool $create optional
+     * @access private
+     * @return array|false
+     */
+    function &_subArrayUnchecked(&$root, $path, $create = false)
+    {
+        $false = false;
+
+        foreach (explode('/', $path) as $i) {
+            if (!isset($root[$i])) {
+                if (!$create) {
+                    return $false;
+                }
+
+                $root[$i] = array();
+            }
+
+            $root = &$root[$i];
+        }
+
+        return $root;
+    }
+
+    /**
+     * Get a reference to a subarray
+     *
+     * @param array $root
+     * @param string $path  absolute path with / as component separator
+     * @param bool $create optional
+     * @access private
+     * @return array|false
+     */
+    function &_subArray(&$root, $path, $create = false)
+    {
+        $false = false;
+
+        if (!is_array($root)) {
+            return $false;
+        }
+
+        foreach (explode('/', $path) as $i) {
+            if (!is_array($root)) {
+                return $false;
+            }
+
+            if (!isset($root[$i])) {
+                if (!$create) {
+                    return $false;
+                }
+
+                $root[$i] = array();
+            }
+
+            $root = &$root[$i];
+        }
+
+        return $root;
+    }
+
+    /**
+     * Get a reference to an extension subarray
+     *
+     * @param array $root
+     * @param string $path optional absolute path with / as component separator
+     * @param bool $create optional
+     * @access private
+     * @return array|false
+     */
+    function &_extensions(&$root, $path = null, $create = false)
+    {
+        if (!isset($root)) {
+            $root = $this->currentCert;
+        }
+
+        switch (true) {
+            case !empty($path):
+            case !is_array($root):
+                break;
+            case isset($root['tbsCertificate']):
+                $path = 'tbsCertificate/extensions';
+                break;
+            case isset($root['tbsCertList']):
+                $path = 'tbsCertList/crlExtensions';
+                break;
+            case isset($root['certificationRequestInfo']):
+                $pth = 'certificationRequestInfo/attributes';
+                $attributes = &$this->_subArray($root, $pth, $create);
+
+                if (is_array($attributes)) {
+                    foreach ($attributes as $key => $value) {
+                        if ($value['type'] == 'pkcs-9-at-extensionRequest') {
+                            $path = "$pth/$key/value/0";
+                            break 2;
+                        }
+                    }
+                    if ($create) {
+                        $key = count($attributes);
+                        $attributes[] = array('type' => 'pkcs-9-at-extensionRequest', 'value' => array());
+                        $path = "$pth/$key/value/0";
+                    }
+                }
+                break;
+        }
+
+        $extensions = &$this->_subArray($root, $path, $create);
+
+        if (!is_array($extensions)) {
+            $false = false;
+            return $false;
+        }
+
+        return $extensions;
+    }
+
+    /**
+     * Remove an Extension
+     *
+     * @param string $id
+     * @param string $path optional
+     * @access private
+     * @return bool
+     */
+    function _removeExtension($id, $path = null)
+    {
+        $extensions = &$this->_extensions($this->currentCert, $path);
+
+        if (!is_array($extensions)) {
+            return false;
+        }
+
+        $result = false;
+        foreach ($extensions as $key => $value) {
+            if ($value['extnId'] == $id) {
+                unset($extensions[$key]);
+                $result = true;
+            }
+        }
+
+        $extensions = array_values($extensions);
+        // fix for https://bugs.php.net/75433 affecting PHP 7.2
+        if (!isset($extensions[0])) {
+            $extensions = array_splice($extensions, 0, 0);
+        }
+        return $result;
+    }
+
+    /**
+     * Get an Extension
+     *
+     * Returns the extension if it exists and false if not
+     *
+     * @param string $id
+     * @param array $cert optional
+     * @param string $path optional
+     * @access private
+     * @return mixed
+     */
+    function _getExtension($id, $cert = null, $path = null)
+    {
+        $extensions = $this->_extensions($cert, $path);
+
+        if (!is_array($extensions)) {
+            return false;
+        }
+
+        foreach ($extensions as $key => $value) {
+            if ($value['extnId'] == $id) {
+                return $value['extnValue'];
+            }
+        }
+
+        return false;
+    }
+
+    /**
+     * Returns a list of all extensions in use
+     *
+     * @param array $cert optional
+     * @param string $path optional
+     * @access private
+     * @return array
+     */
+    function _getExtensions($cert = null, $path = null)
+    {
+        $exts = $this->_extensions($cert, $path);
+        $extensions = array();
+
+        if (is_array($exts)) {
+            foreach ($exts as $extension) {
+                $extensions[] = $extension['extnId'];
+            }
+        }
+
+        return $extensions;
+    }
+
+    /**
+     * Set an Extension
+     *
+     * @param string $id
+     * @param mixed $value
+     * @param bool $critical optional
+     * @param bool $replace optional
+     * @param string $path optional
+     * @access private
+     * @return bool
+     */
+    function _setExtension($id, $value, $critical = false, $replace = true, $path = null)
+    {
+        $extensions = &$this->_extensions($this->currentCert, $path, true);
+
+        if (!is_array($extensions)) {
+            return false;
+        }
+
+        $newext = array('extnId'  => $id, 'critical' => $critical, 'extnValue' => $value);
+
+        foreach ($extensions as $key => $value) {
+            if ($value['extnId'] == $id) {
+                if (!$replace) {
+                    return false;
+                }
+
+                $extensions[$key] = $newext;
+                return true;
+            }
+        }
+
+        $extensions[] = $newext;
+        return true;
+    }
+
+    /**
+     * Remove a certificate, CSR or CRL Extension
+     *
+     * @param string $id
+     * @access public
+     * @return bool
+     */
+    function removeExtension($id)
+    {
+        return $this->_removeExtension($id);
+    }
+
+    /**
+     * Get a certificate, CSR or CRL Extension
+     *
+     * Returns the extension if it exists and false if not
+     *
+     * @param string $id
+     * @param array $cert optional
+     * @access public
+     * @return mixed
+     */
+    function getExtension($id, $cert = null)
+    {
+        return $this->_getExtension($id, $cert);
+    }
+
+    /**
+     * Returns a list of all extensions in use in certificate, CSR or CRL
+     *
+     * @param array $cert optional
+     * @access public
+     * @return array
+     */
+    function getExtensions($cert = null)
+    {
+        return $this->_getExtensions($cert);
+    }
+
+    /**
+     * Set a certificate, CSR or CRL Extension
+     *
+     * @param string $id
+     * @param mixed $value
+     * @param bool $critical optional
+     * @param bool $replace optional
+     * @access public
+     * @return bool
+     */
+    function setExtension($id, $value, $critical = false, $replace = true)
+    {
+        return $this->_setExtension($id, $value, $critical, $replace);
+    }
+
+    /**
+     * Remove a CSR attribute.
+     *
+     * @param string $id
+     * @param int $disposition optional
+     * @access public
+     * @return bool
+     */
+    function removeAttribute($id, $disposition = self::ATTR_ALL)
+    {
+        $attributes = &$this->_subArray($this->currentCert, 'certificationRequestInfo/attributes');
+
+        if (!is_array($attributes)) {
+            return false;
+        }
+
+        $result = false;
+        foreach ($attributes as $key => $attribute) {
+            if ($attribute['type'] == $id) {
+                $n = count($attribute['value']);
+                switch (true) {
+                    case $disposition == self::ATTR_APPEND:
+                    case $disposition == self::ATTR_REPLACE:
+                        return false;
+                    case $disposition >= $n:
+                        $disposition -= $n;
+                        break;
+                    case $disposition == self::ATTR_ALL:
+                    case $n == 1:
+                        unset($attributes[$key]);
+                        $result = true;
+                        break;
+                    default:
+                        unset($attributes[$key]['value'][$disposition]);
+                        $attributes[$key]['value'] = array_values($attributes[$key]['value']);
+                        $result = true;
+                        break;
+                }
+                if ($result && $disposition != self::ATTR_ALL) {
+                    break;
+                }
+            }
+        }
+
+        $attributes = array_values($attributes);
+        return $result;
+    }
+
+    /**
+     * Get a CSR attribute
+     *
+     * Returns the attribute if it exists and false if not
+     *
+     * @param string $id
+     * @param int $disposition optional
+     * @param array $csr optional
+     * @access public
+     * @return mixed
+     */
+    function getAttribute($id, $disposition = self::ATTR_ALL, $csr = null)
+    {
+        if (empty($csr)) {
+            $csr = $this->currentCert;
+        }
+
+        $attributes = $this->_subArray($csr, 'certificationRequestInfo/attributes');
+
+        if (!is_array($attributes)) {
+            return false;
+        }
+
+        foreach ($attributes as $key => $attribute) {
+            if ($attribute['type'] == $id) {
+                $n = count($attribute['value']);
+                switch (true) {
+                    case $disposition == self::ATTR_APPEND:
+                    case $disposition == self::ATTR_REPLACE:
+                        return false;
+                    case $disposition == self::ATTR_ALL:
+                        return $attribute['value'];
+                    case $disposition >= $n:
+                        $disposition -= $n;
+                        break;
+                    default:
+                        return $attribute['value'][$disposition];
+                }
+            }
+        }
+
+        return false;
+    }
+
+    /**
+     * Returns a list of all CSR attributes in use
+     *
+     * @param array $csr optional
+     * @access public
+     * @return array
+     */
+    function getAttributes($csr = null)
+    {
+        if (empty($csr)) {
+            $csr = $this->currentCert;
+        }
+
+        $attributes = $this->_subArray($csr, 'certificationRequestInfo/attributes');
+        $attrs = array();
+
+        if (is_array($attributes)) {
+            foreach ($attributes as $attribute) {
+                $attrs[] = $attribute['type'];
+            }
+        }
+
+        return $attrs;
+    }
+
+    /**
+     * Set a CSR attribute
+     *
+     * @param string $id
+     * @param mixed $value
+     * @param bool $disposition optional
+     * @access public
+     * @return bool
+     */
+    function setAttribute($id, $value, $disposition = self::ATTR_ALL)
+    {
+        $attributes = &$this->_subArray($this->currentCert, 'certificationRequestInfo/attributes', true);
+
+        if (!is_array($attributes)) {
+            return false;
+        }
+
+        switch ($disposition) {
+            case self::ATTR_REPLACE:
+                $disposition = self::ATTR_APPEND;
+            case self::ATTR_ALL:
+                $this->removeAttribute($id);
+                break;
+        }
+
+        foreach ($attributes as $key => $attribute) {
+            if ($attribute['type'] == $id) {
+                $n = count($attribute['value']);
+                switch (true) {
+                    case $disposition == self::ATTR_APPEND:
+                        $last = $key;
+                        break;
+                    case $disposition >= $n:
+                        $disposition -= $n;
+                        break;
+                    default:
+                        $attributes[$key]['value'][$disposition] = $value;
+                        return true;
+                }
+            }
+        }
+
+        switch (true) {
+            case $disposition >= 0:
+                return false;
+            case isset($last):
+                $attributes[$last]['value'][] = $value;
+                break;
+            default:
+                $attributes[] = array('type' => $id, 'value' => $disposition == self::ATTR_ALL ? $value: array($value));
+                break;
+        }
+
+        return true;
+    }
+
+    /**
+     * Sets the subject key identifier
+     *
+     * This is used by the id-ce-authorityKeyIdentifier and the id-ce-subjectKeyIdentifier extensions.
+     *
+     * @param string $value
+     * @access public
+     */
+    function setKeyIdentifier($value)
+    {
+        if (empty($value)) {
+            unset($this->currentKeyIdentifier);
+        } else {
+            $this->currentKeyIdentifier = base64_encode($value);
+        }
+    }
+
+    /**
+     * Compute a public key identifier.
+     *
+     * Although key identifiers may be set to any unique value, this function
+     * computes key identifiers from public key according to the two
+     * recommended methods (4.2.1.2 RFC 3280).
+     * Highly polymorphic: try to accept all possible forms of key:
+     * - Key object
+     * - \phpseclib\File\X509 object with public or private key defined
+     * - Certificate or CSR array
+     * - \phpseclib\File\ASN1\Element object
+     * - PEM or DER string
+     *
+     * @param mixed $key optional
+     * @param int $method optional
+     * @access public
+     * @return string binary key identifier
+     */
+    function computeKeyIdentifier($key = null, $method = 1)
+    {
+        if (is_null($key)) {
+            $key = $this;
+        }
+
+        switch (true) {
+            case is_string($key):
+                break;
+            case is_array($key) && isset($key['tbsCertificate']['subjectPublicKeyInfo']['subjectPublicKey']):
+                return $this->computeKeyIdentifier($key['tbsCertificate']['subjectPublicKeyInfo']['subjectPublicKey'], $method);
+            case is_array($key) && isset($key['certificationRequestInfo']['subjectPKInfo']['subjectPublicKey']):
+                return $this->computeKeyIdentifier($key['certificationRequestInfo']['subjectPKInfo']['subjectPublicKey'], $method);
+            case !is_object($key):
+                return false;
+            case $key instanceof Element:
+                // Assume the element is a bitstring-packed key.
+                $asn1 = new ASN1();
+                $decoded = $asn1->decodeBER($key->element);
+                if (empty($decoded)) {
+                    return false;
+                }
+                $raw = $asn1->asn1map($decoded[0], array('type' => ASN1::TYPE_BIT_STRING));
+                if (empty($raw)) {
+                    return false;
+                }
+                $raw = base64_decode($raw);
+                // If the key is private, compute identifier from its corresponding public key.
+                $key = new RSA();
+                if (!$key->loadKey($raw)) {
+                    return false;   // Not an unencrypted RSA key.
+                }
+                if ($key->getPrivateKey() !== false) {  // If private.
+                    return $this->computeKeyIdentifier($key, $method);
+                }
+                $key = $raw;    // Is a public key.
+                break;
+            case $key instanceof X509:
+                if (isset($key->publicKey)) {
+                    return $this->computeKeyIdentifier($key->publicKey, $method);
+                }
+                if (isset($key->privateKey)) {
+                    return $this->computeKeyIdentifier($key->privateKey, $method);
+                }
+                if (isset($key->currentCert['tbsCertificate']) || isset($key->currentCert['certificationRequestInfo'])) {
+                    return $this->computeKeyIdentifier($key->currentCert, $method);
+                }
+                return false;
+            default: // Should be a key object (i.e.: \phpseclib\Crypt\RSA).
+                $key = $key->getPublicKey(RSA::PUBLIC_FORMAT_PKCS1);
+                break;
+        }
+
+        // If in PEM format, convert to binary.
+        $key = $this->_extractBER($key);
+
+        // Now we have the key string: compute its sha-1 sum.
+        $hash = new Hash('sha1');
+        $hash = $hash->hash($key);
+
+        if ($method == 2) {
+            $hash = substr($hash, -8);
+            $hash[0] = chr((ord($hash[0]) & 0x0F) | 0x40);
+        }
+
+        return $hash;
+    }
+
+    /**
+     * Format a public key as appropriate
+     *
+     * @access private
+     * @return array
+     */
+    function _formatSubjectPublicKey()
+    {
+        if ($this->publicKey instanceof RSA) {
+            // the following two return statements do the same thing. i dunno.. i just prefer the later for some reason.
+            // the former is a good example of how to do fuzzing on the public key
+            //return new Element(base64_decode(preg_replace('#-.+-|[\r\n]#', '', $this->publicKey->getPublicKey())));
+            return array(
+                'algorithm' => array('algorithm' => 'rsaEncryption'),
+                'subjectPublicKey' => $this->publicKey->getPublicKey(RSA::PUBLIC_FORMAT_PKCS1)
+            );
+        }
+
+        return false;
+    }
+
+    /**
+     * Set the domain name's which the cert is to be valid for
+     *
+     * @access public
+     * @return array
+     */
+    function setDomain()
+    {
+        $this->domains = func_get_args();
+        $this->removeDNProp('id-at-commonName');
+        $this->setDNProp('id-at-commonName', $this->domains[0]);
+    }
+
+    /**
+     * Set the IP Addresses's which the cert is to be valid for
+     *
+     * @access public
+     * @param string $ipAddress optional
+     */
+    function setIPAddress()
+    {
+        $this->ipAddresses = func_get_args();
+        /*
+        if (!isset($this->domains)) {
+            $this->removeDNProp('id-at-commonName');
+            $this->setDNProp('id-at-commonName', $this->ipAddresses[0]);
+        }
+        */
+    }
+
+    /**
+     * Helper function to build domain array
+     *
+     * @access private
+     * @param string $domain
+     * @return array
+     */
+    function _dnsName($domain)
+    {
+        return array('dNSName' => $domain);
+    }
+
+    /**
+     * Helper function to build IP Address array
+     *
+     * (IPv6 is not currently supported)
+     *
+     * @access private
+     * @param string $address
+     * @return array
+     */
+    function _iPAddress($address)
+    {
+        return array('iPAddress' => $address);
+    }
+
+    /**
+     * Get the index of a revoked certificate.
+     *
+     * @param array $rclist
+     * @param string $serial
+     * @param bool $create optional
+     * @access private
+     * @return int|false
+     */
+    function _revokedCertificate(&$rclist, $serial, $create = false)
+    {
+        $serial = new BigInteger($serial);
+
+        foreach ($rclist as $i => $rc) {
+            if (!($serial->compare($rc['userCertificate']))) {
+                return $i;
+            }
+        }
+
+        if (!$create) {
+            return false;
+        }
+
+        $i = count($rclist);
+        $revocationDate = new DateTime('now', new DateTimeZone(@date_default_timezone_get()));
+        $rclist[] = array('userCertificate' => $serial,
+                          'revocationDate'  => $this->_timeField($revocationDate->format('D, d M Y H:i:s O')));
+        return $i;
+    }
+
+    /**
+     * Revoke a certificate.
+     *
+     * @param string $serial
+     * @param string $date optional
+     * @access public
+     * @return bool
+     */
+    function revoke($serial, $date = null)
+    {
+        if (isset($this->currentCert['tbsCertList'])) {
+            if (is_array($rclist = &$this->_subArray($this->currentCert, 'tbsCertList/revokedCertificates', true))) {
+                if ($this->_revokedCertificate($rclist, $serial) === false) { // If not yet revoked
+                    if (($i = $this->_revokedCertificate($rclist, $serial, true)) !== false) {
+                        if (!empty($date)) {
+                            $rclist[$i]['revocationDate'] = $this->_timeField($date);
+                        }
+
+                        return true;
+                    }
+                }
+            }
+        }
+
+        return false;
+    }
+
+    /**
+     * Unrevoke a certificate.
+     *
+     * @param string $serial
+     * @access public
+     * @return bool
+     */
+    function unrevoke($serial)
+    {
+        if (is_array($rclist = &$this->_subArray($this->currentCert, 'tbsCertList/revokedCertificates'))) {
+            if (($i = $this->_revokedCertificate($rclist, $serial)) !== false) {
+                unset($rclist[$i]);
+                $rclist = array_values($rclist);
+                return true;
+            }
+        }
+
+        return false;
+    }
+
+    /**
+     * Get a revoked certificate.
+     *
+     * @param string $serial
+     * @access public
+     * @return mixed
+     */
+    function getRevoked($serial)
+    {
+        if (is_array($rclist = $this->_subArray($this->currentCert, 'tbsCertList/revokedCertificates'))) {
+            if (($i = $this->_revokedCertificate($rclist, $serial)) !== false) {
+                return $rclist[$i];
+            }
+        }
+
+        return false;
+    }
+
+    /**
+     * List revoked certificates
+     *
+     * @param array $crl optional
+     * @access public
+     * @return array
+     */
+    function listRevoked($crl = null)
+    {
+        if (!isset($crl)) {
+            $crl = $this->currentCert;
+        }
+
+        if (!isset($crl['tbsCertList'])) {
+            return false;
+        }
+
+        $result = array();
+
+        if (is_array($rclist = $this->_subArray($crl, 'tbsCertList/revokedCertificates'))) {
+            foreach ($rclist as $rc) {
+                $result[] = $rc['userCertificate']->toString();
+            }
+        }
+
+        return $result;
+    }
+
+    /**
+     * Remove a Revoked Certificate Extension
+     *
+     * @param string $serial
+     * @param string $id
+     * @access public
+     * @return bool
+     */
+    function removeRevokedCertificateExtension($serial, $id)
+    {
+        if (is_array($rclist = &$this->_subArray($this->currentCert, 'tbsCertList/revokedCertificates'))) {
+            if (($i = $this->_revokedCertificate($rclist, $serial)) !== false) {
+                return $this->_removeExtension($id, "tbsCertList/revokedCertificates/$i/crlEntryExtensions");
+            }
+        }
+
+        return false;
+    }
+
+    /**
+     * Get a Revoked Certificate Extension
+     *
+     * Returns the extension if it exists and false if not
+     *
+     * @param string $serial
+     * @param string $id
+     * @param array $crl optional
+     * @access public
+     * @return mixed
+     */
+    function getRevokedCertificateExtension($serial, $id, $crl = null)
+    {
+        if (!isset($crl)) {
+            $crl = $this->currentCert;
+        }
+
+        if (is_array($rclist = $this->_subArray($crl, 'tbsCertList/revokedCertificates'))) {
+            if (($i = $this->_revokedCertificate($rclist, $serial)) !== false) {
+                return $this->_getExtension($id, $crl,  "tbsCertList/revokedCertificates/$i/crlEntryExtensions");
+            }
+        }
+
+        return false;
+    }
+
+    /**
+     * Returns a list of all extensions in use for a given revoked certificate
+     *
+     * @param string $serial
+     * @param array $crl optional
+     * @access public
+     * @return array
+     */
+    function getRevokedCertificateExtensions($serial, $crl = null)
+    {
+        if (!isset($crl)) {
+            $crl = $this->currentCert;
+        }
+
+        if (is_array($rclist = $this->_subArray($crl, 'tbsCertList/revokedCertificates'))) {
+            if (($i = $this->_revokedCertificate($rclist, $serial)) !== false) {
+                return $this->_getExtensions($crl, "tbsCertList/revokedCertificates/$i/crlEntryExtensions");
+            }
+        }
+
+        return false;
+    }
+
+    /**
+     * Set a Revoked Certificate Extension
+     *
+     * @param string $serial
+     * @param string $id
+     * @param mixed $value
+     * @param bool $critical optional
+     * @param bool $replace optional
+     * @access public
+     * @return bool
+     */
+    function setRevokedCertificateExtension($serial, $id, $value, $critical = false, $replace = true)
+    {
+        if (isset($this->currentCert['tbsCertList'])) {
+            if (is_array($rclist = &$this->_subArray($this->currentCert, 'tbsCertList/revokedCertificates', true))) {
+                if (($i = $this->_revokedCertificate($rclist, $serial, true)) !== false) {
+                    return $this->_setExtension($id, $value, $critical, $replace, "tbsCertList/revokedCertificates/$i/crlEntryExtensions");
+                }
+            }
+        }
+
+        return false;
+    }
+
+    /**
+     * Extract raw BER from Base64 encoding
+     *
+     * @access private
+     * @param string $str
+     * @return string
+     */
+    function _extractBER($str)
+    {
+        /* X.509 certs are assumed to be base64 encoded but sometimes they'll have additional things in them
+         * above and beyond the ceritificate.
+         * ie. some may have the following preceding the -----BEGIN CERTIFICATE----- line:
+         *
+         * Bag Attributes
+         *     localKeyID: 01 00 00 00
+         * subject=/O=organization/OU=org unit/CN=common name
+         * issuer=/O=organization/CN=common name
+         */
+        $temp = preg_replace('#.*?^-+[^-]+-+[\r\n ]*$#ms', '', $str, 1);
+        // remove the -----BEGIN CERTIFICATE----- and -----END CERTIFICATE----- stuff
+        $temp = preg_replace('#-+[^-]+-+#', '', $temp);
+        // remove new lines
+        $temp = str_replace(array("\r", "\n", ' '), '', $temp);
+        $temp = preg_match('#^[a-zA-Z\d/+]*={0,2}$#', $temp) ? base64_decode($temp) : false;
+        return $temp != false ? $temp : $str;
+    }
+
+    /**
+     * Returns the OID corresponding to a name
+     *
+     * What's returned in the associative array returned by loadX509() (or load*()) is either a name or an OID if
+     * no OID to name mapping is available. The problem with this is that what may be an unmapped OID in one version
+     * of phpseclib may not be unmapped in the next version, so apps that are looking at this OID may not be able
+     * to work from version to version.
+     *
+     * This method will return the OID if a name is passed to it and if no mapping is avialable it'll assume that
+     * what's being passed to it already is an OID and return that instead. A few examples.
+     *
+     * getOID('2.16.840.1.101.3.4.2.1') == '2.16.840.1.101.3.4.2.1'
+     * getOID('id-sha256') == '2.16.840.1.101.3.4.2.1'
+     * getOID('zzz') == 'zzz'
+     *
+     * @access public
+     * @return string
+     */
+    function getOID($name)
+    {
+        static $reverseMap;
+        if (!isset($reverseMap)) {
+            $reverseMap = array_flip($this->oids);
+        }
+        return isset($reverseMap[$name]) ? $reverseMap[$name] : $name;
+    }
+}
diff --git a/lib/phpseclib/Math/BigInteger.php b/lib/phpseclib/Math/BigInteger.php
index 92b50b8..d82d123 100644
--- a/lib/phpseclib/Math/BigInteger.php
+++ b/lib/phpseclib/Math/BigInteger.php
@@ -1,5 +1,4 @@
 <?php
-/* vim: set expandtab tabstop=4 shiftwidth=4 softtabstop=4: */
 
 /**
  * Pure-PHP arbitrary precision integer arithmetic library.
@@ -7,12 +6,12 @@
  * Supports base-2, base-10, base-16, and base-256 numbers.  Uses the GMP or BCMath extensions, if available,
  * and an internal implementation, otherwise.
  *
- * PHP versions 4 and 5
+ * PHP version 5
  *
- * {@internal (all DocBlock comments regarding implementation - such as the one that follows - refer to the 
- * {@link MATH_BIGINTEGER_MODE_INTERNAL MATH_BIGINTEGER_MODE_INTERNAL} mode)
+ * {@internal (all DocBlock comments regarding implementation - such as the one that follows - refer to the
+ * {@link self::MODE_INTERNAL self::MODE_INTERNAL} mode)
  *
- * Math_BigInteger uses base-2**26 to perform operations such as multiplication and division and
+ * BigInteger uses base-2**26 to perform operations such as multiplication and division and
  * base-2**52 (ie. two base 2**26 digits) to perform addition and subtraction.  Because the largest possible
  * value when multiplying two base-2**26 numbers together is a base-2**52 number, double precision floating
  * point numbers - numbers that should be supported on most hardware and whose significand is 53 bits - are
@@ -20,12 +19,8 @@
  * which only supports integers.  Although this fact will slow this library down, the fact that such a high
  * base is being used should more than compensate.
  *
- * When PHP version 6 is officially released, we'll be able to use 64-bit integers.  This should, once again,
- * allow bitwise operators, and will increase the maximum possible base to 2**31 (or 2**62 for addition /
- * subtraction).
- *
  * Numbers are stored in {@link http://en.wikipedia.org/wiki/Endianness little endian} format.  ie.
- * (new Math_BigInteger(pow(2, 26)))->value = array(0, 1)
+ * (new \phpseclib\Math\BigInteger(pow(2, 26)))->value = array(0, 1)
  *
  * Useful resources are as follows:
  *
@@ -36,10 +31,8 @@
  * Here's an example of how to use this library:
  * <code>
  * <?php
- *    include('Math/BigInteger.php');
- *
- *    $a = new Math_BigInteger(2);
- *    $b = new Math_BigInteger(3);
+ *    $a = new \phpseclib\Math\BigInteger(2);
+ *    $b = new \phpseclib\Math\BigInteger(3);
  *
  *    $c = $a->add($b);
  *
@@ -47,175 +40,169 @@
  * ?>
  * </code>
  *
- * LICENSE: This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA  02111-1307  USA
- *
- * @category   Math
- * @package    Math_BigInteger
- * @author     Jim Wigginton <terrafrost@php.net>
- * @copyright  MMVI Jim Wigginton
- * @license    http://www.gnu.org/licenses/lgpl.txt
- * @version    $Id: BigInteger.php,v 1.33 2010/03/22 22:32:03 terrafrost Exp $
- * @link       http://pear.php.net/package/Math_BigInteger
+ * @category  Math
+ * @package   BigInteger
+ * @author    Jim Wigginton <terrafrost@php.net>
+ * @copyright 2006 Jim Wigginton
+ * @license   http://www.opensource.org/licenses/mit-license.html  MIT License
+ * @link      http://pear.php.net/package/Math_BigInteger
  */
 
-/**#@+
- * Reduction constants
- *
- * @access private
- * @see Math_BigInteger::_reduce()
- */
-/**
- * @see Math_BigInteger::_montgomery()
- * @see Math_BigInteger::_prepMontgomery()
- */
-define('MATH_BIGINTEGER_MONTGOMERY', 0);
-/**
- * @see Math_BigInteger::_barrett()
- */
-define('MATH_BIGINTEGER_BARRETT', 1);
-/**
- * @see Math_BigInteger::_mod2()
- */
-define('MATH_BIGINTEGER_POWEROF2', 2);
-/**
- * @see Math_BigInteger::_remainder()
- */
-define('MATH_BIGINTEGER_CLASSIC', 3);
-/**
- * @see Math_BigInteger::__clone()
- */
-define('MATH_BIGINTEGER_NONE', 4);
-/**#@-*/
+namespace phpseclib\Math;
 
-/**#@+
- * Array constants
- *
- * Rather than create a thousands and thousands of new Math_BigInteger objects in repeated function calls to add() and
- * multiply() or whatever, we'll just work directly on arrays, taking them in as parameters and returning them.
- *
- * @access private
- */
-/**
- * $result[MATH_BIGINTEGER_VALUE] contains the value.
- */
-define('MATH_BIGINTEGER_VALUE', 0);
-/**
- * $result[MATH_BIGINTEGER_SIGN] contains the sign.
- */
-define('MATH_BIGINTEGER_SIGN', 1);
-/**#@-*/
-
-/**#@+
- * @access private
- * @see Math_BigInteger::_montgomery()
- * @see Math_BigInteger::_barrett()
- */
-/**
- * Cache constants
- *
- * $cache[MATH_BIGINTEGER_VARIABLE] tells us whether or not the cached data is still valid.
- */
-define('MATH_BIGINTEGER_VARIABLE', 0);
-/**
- * $cache[MATH_BIGINTEGER_DATA] contains the cached data.
- */
-define('MATH_BIGINTEGER_DATA', 1);
-/**#@-*/
-
-/**#@+
- * Mode constants.
- *
- * @access private
- * @see Math_BigInteger::Math_BigInteger()
- */
-/**
- * To use the pure-PHP implementation
- */
-define('MATH_BIGINTEGER_MODE_INTERNAL', 1);
-/**
- * To use the BCMath library
- *
- * (if enabled; otherwise, the internal implementation will be used)
- */
-define('MATH_BIGINTEGER_MODE_BCMATH', 2);
-/**
- * To use the GMP library
- *
- * (if present; otherwise, either the BCMath or the internal implementation will be used)
- */
-define('MATH_BIGINTEGER_MODE_GMP', 3);
-/**#@-*/
-
-/**
- * The largest digit that may be used in addition / subtraction
- *
- * (we do pow(2, 52) instead of using 4503599627370496, directly, because some PHP installations
- *  will truncate 4503599627370496)
- *
- * @access private
- */
-define('MATH_BIGINTEGER_MAX_DIGIT52', pow(2, 52));
-
-/**
- * Karatsuba Cutoff
- *
- * At what point do we switch between Karatsuba multiplication and schoolbook long multiplication?
- *
- * @access private
- */
-define('MATH_BIGINTEGER_KARATSUBA_CUTOFF', 25);
+use phpseclib\Crypt\Random;
 
 /**
  * Pure-PHP arbitrary precision integer arithmetic library. Supports base-2, base-10, base-16, and base-256
  * numbers.
  *
+ * @package BigInteger
  * @author  Jim Wigginton <terrafrost@php.net>
- * @version 1.0.0RC4
  * @access  public
- * @package Math_BigInteger
  */
-class Math_BigInteger {
+class BigInteger
+{
+    /**#@+
+     * Reduction constants
+     *
+     * @access private
+     * @see BigInteger::_reduce()
+     */
     /**
-     * Holds the BigInteger's value.
+     * @see BigInteger::_montgomery()
+     * @see BigInteger::_prepMontgomery()
+     */
+    const MONTGOMERY = 0;
+    /**
+     * @see BigInteger::_barrett()
+     */
+    const BARRETT = 1;
+    /**
+     * @see BigInteger::_mod2()
+     */
+    const POWEROF2 = 2;
+    /**
+     * @see BigInteger::_remainder()
+     */
+    const CLASSIC = 3;
+    /**
+     * @see BigInteger::__clone()
+     */
+    const NONE = 4;
+    /**#@-*/
+
+    /**#@+
+     * Array constants
+     *
+     * Rather than create a thousands and thousands of new BigInteger objects in repeated function calls to add() and
+     * multiply() or whatever, we'll just work directly on arrays, taking them in as parameters and returning them.
      *
-     * @var Array
      * @access private
+    */
+    /**
+     * $result[self::VALUE] contains the value.
      */
-    var $value;
+    const VALUE = 0;
+    /**
+     * $result[self::SIGN] contains the sign.
+     */
+    const SIGN = 1;
+    /**#@-*/
 
+    /**#@+
+     * @access private
+     * @see BigInteger::_montgomery()
+     * @see BigInteger::_barrett()
+    */
     /**
-     * Holds the BigInteger's magnitude.
+     * Cache constants
+     *
+     * $cache[self::VARIABLE] tells us whether or not the cached data is still valid.
+     */
+    const VARIABLE = 0;
+    /**
+     * $cache[self::DATA] contains the cached data.
+     */
+    const DATA = 1;
+    /**#@-*/
+
+    /**#@+
+     * Mode constants.
      *
-     * @var Boolean
      * @access private
+     * @see BigInteger::__construct()
+    */
+    /**
+     * To use the pure-PHP implementation
      */
-    var $is_negative = false;
+    const MODE_INTERNAL = 1;
+    /**
+     * To use the BCMath library
+     *
+     * (if enabled; otherwise, the internal implementation will be used)
+     */
+    const MODE_BCMATH = 2;
+    /**
+     * To use the GMP library
+     *
+     * (if present; otherwise, either the BCMath or the internal implementation will be used)
+     */
+    const MODE_GMP = 3;
+    /**#@-*/
+
+    /**
+     * Karatsuba Cutoff
+     *
+     * At what point do we switch between Karatsuba multiplication and schoolbook long multiplication?
+     *
+     * @access private
+     */
+    const KARATSUBA_CUTOFF = 25;
+
+    /**#@+
+     * Static properties used by the pure-PHP implementation.
+     *
+     * @see __construct()
+     */
+    protected static $base;
+    protected static $baseFull;
+    protected static $maxDigit;
+    protected static $msb;
+
+    /**
+     * $max10 in greatest $max10Len satisfying
+     * $max10 = 10**$max10Len <= 2**$base.
+     */
+    protected static $max10;
+
+    /**
+     * $max10Len in greatest $max10Len satisfying
+     * $max10 = 10**$max10Len <= 2**$base.
+     */
+    protected static $max10Len;
+    protected static $maxDigit2;
+    /**#@-*/
+
+    /**
+     * Holds the BigInteger's value.
+     *
+     * @var array
+     * @access private
+     */
+    var $value;
 
     /**
-     * Random number generator function
+     * Holds the BigInteger's magnitude.
      *
-     * @see setRandomGenerator()
+     * @var bool
      * @access private
      */
-    var $generator = 'mt_rand';
+    var $is_negative = false;
 
     /**
      * Precision
      *
-     * @see setPrecision()
+     * @see self::setPrecision()
      * @access private
      */
     var $precision = -1;
@@ -223,27 +210,27 @@ class Math_BigInteger {
     /**
      * Precision Bitmask
      *
-     * @see setPrecision()
+     * @see self::setPrecision()
      * @access private
      */
     var $bitmask = false;
 
     /**
-     * Mode independant value used for serialization.
+     * Mode independent value used for serialization.
      *
-     * If the bcmath or gmp extensions are installed $this->value will be a non-serializable resource, hence the need for 
+     * If the bcmath or gmp extensions are installed $this->value will be a non-serializable resource, hence the need for
      * a variable that'll be serializable regardless of whether or not extensions are being used.  Unlike $this->value,
      * however, $this->hex is only calculated when $this->__sleep() is called.
      *
-     * @see __sleep()
-     * @see __wakeup()
-     * @var String
+     * @see self::__sleep()
+     * @see self::__wakeup()
+     * @var string
      * @access private
      */
     var $hex;
 
     /**
-     * Converts base-2, base-10, base-16, and binary strings (eg. base-256) to BigIntegers.
+     * Converts base-2, base-10, base-16, and binary strings (base-256) to BigIntegers.
      *
      * If the second parameter - $base - is negative, then it will be assumed that the number's are encoded using
      * two's compliment.  The sole exception to this is -10, which is treated the same as 10 is.
@@ -251,50 +238,120 @@ class Math_BigInteger {
      * Here's an example:
      * <code>
      * <?php
-     *    include('Math/BigInteger.php');
-     *
-     *    $a = new Math_BigInteger('0x32', 16); // 50 in base-16
+     *    $a = new \phpseclib\Math\BigInteger('0x32', 16); // 50 in base-16
      *
      *    echo $a->toString(); // outputs 50
      * ?>
      * </code>
      *
-     * @param optional $x base-10 number or base-$base number if $base set.
-     * @param optional integer $base
-     * @return Math_BigInteger
+     * @param $x base-10 number or base-$base number if $base set.
+     * @param int $base
+     * @return \phpseclib\Math\BigInteger
      * @access public
      */
-    function Math_BigInteger($x = 0, $base = 10)
+    function __construct($x = 0, $base = 10)
     {
-        if ( !defined('MATH_BIGINTEGER_MODE') ) {
+        if (!defined('MATH_BIGINTEGER_MODE')) {
             switch (true) {
                 case extension_loaded('gmp'):
-                    define('MATH_BIGINTEGER_MODE', MATH_BIGINTEGER_MODE_GMP);
+                    define('MATH_BIGINTEGER_MODE', self::MODE_GMP);
                     break;
                 case extension_loaded('bcmath'):
-                    define('MATH_BIGINTEGER_MODE', MATH_BIGINTEGER_MODE_BCMATH);
+                    define('MATH_BIGINTEGER_MODE', self::MODE_BCMATH);
+                    break;
+                default:
+                    define('MATH_BIGINTEGER_MODE', self::MODE_INTERNAL);
+            }
+        }
+
+        if (extension_loaded('openssl') && !defined('MATH_BIGINTEGER_OPENSSL_DISABLE') && !defined('MATH_BIGINTEGER_OPENSSL_ENABLED')) {
+            // some versions of XAMPP have mismatched versions of OpenSSL which causes it not to work
+            $versions = array();
+
+            // avoid generating errors (even with suppression) when phpinfo() is disabled (common in production systems)
+            if (strpos(ini_get('disable_functions'), 'phpinfo') === false) {
+                ob_start();
+                @phpinfo();
+                $content = ob_get_contents();
+                ob_end_clean();
+
+                preg_match_all('#OpenSSL (Header|Library) Version(.*)#im', $content, $matches);
+
+                if (!empty($matches[1])) {
+                    for ($i = 0; $i < count($matches[1]); $i++) {
+                        $fullVersion = trim(str_replace('=>', '', strip_tags($matches[2][$i])));
+
+                        // Remove letter part in OpenSSL version
+                        if (!preg_match('/(\d+\.\d+\.\d+)/i', $fullVersion, $m)) {
+                            $versions[$matches[1][$i]] = $fullVersion;
+                        } else {
+                            $versions[$matches[1][$i]] = $m[0];
+                        }
+                    }
+                }
+            }
+
+            // it doesn't appear that OpenSSL versions were reported upon until PHP 5.3+
+            switch (true) {
+                case !isset($versions['Header']):
+                case !isset($versions['Library']):
+                case $versions['Header'] == $versions['Library']:
+                case version_compare($versions['Header'], '1.0.0') >= 0 && version_compare($versions['Library'], '1.0.0') >= 0:
+                    define('MATH_BIGINTEGER_OPENSSL_ENABLED', true);
                     break;
                 default:
-                    define('MATH_BIGINTEGER_MODE', MATH_BIGINTEGER_MODE_INTERNAL);
+                    define('MATH_BIGINTEGER_OPENSSL_DISABLE', true);
             }
         }
 
-        switch ( MATH_BIGINTEGER_MODE ) {
-            case MATH_BIGINTEGER_MODE_GMP:
-                if (is_resource($x) && get_resource_type($x) == 'GMP integer') {
-                    $this->value = $x;
-                    return;
+        if (!defined('PHP_INT_SIZE')) {
+            define('PHP_INT_SIZE', 4);
+        }
+
+        if (empty(self::$base) && MATH_BIGINTEGER_MODE == self::MODE_INTERNAL) {
+            switch (PHP_INT_SIZE) {
+                case 8: // use 64-bit integers if int size is 8 bytes
+                    self::$base      = 31;
+                    self::$baseFull  = 0x80000000;
+                    self::$maxDigit  = 0x7FFFFFFF;
+                    self::$msb       = 0x40000000;
+                    self::$max10     = 1000000000;
+                    self::$max10Len  = 9;
+                    self::$maxDigit2 = pow(2, 62);
+                    break;
+                //case 4: // use 64-bit floats if int size is 4 bytes
+                default:
+                    self::$base      = 26;
+                    self::$baseFull  = 0x4000000;
+                    self::$maxDigit  = 0x3FFFFFF;
+                    self::$msb       = 0x2000000;
+                    self::$max10     = 10000000;
+                    self::$max10Len  = 7;
+                    self::$maxDigit2 = pow(2, 52); // pow() prevents truncation
+            }
+        }
+
+        switch (MATH_BIGINTEGER_MODE) {
+            case self::MODE_GMP:
+                switch (true) {
+                    case is_resource($x) && get_resource_type($x) == 'GMP integer':
+                    // PHP 5.6 switched GMP from using resources to objects
+                    case $x instanceof \GMP:
+                        $this->value = $x;
+                        return;
                 }
                 $this->value = gmp_init(0);
                 break;
-            case MATH_BIGINTEGER_MODE_BCMATH:
+            case self::MODE_BCMATH:
                 $this->value = '0';
                 break;
             default:
                 $this->value = array();
         }
 
-        if (empty($x)) {
+        // '0' counts as empty() but when the base is 256 '0' is equal to ord('0') or 48
+        // '0' is the only value like this per http://php.net/empty
+        if (empty($x) && (abs($base) != 256 || $x !== '0')) {
             return;
         }
 
@@ -304,13 +361,17 @@ class Math_BigInteger {
                     $x = ~$x;
                     $this->is_negative = true;
                 }
-            case  256:
-                switch ( MATH_BIGINTEGER_MODE ) {
-                    case MATH_BIGINTEGER_MODE_GMP:
-                        $sign = $this->is_negative ? '-' : '';
-                        $this->value = gmp_init($sign . '0x' . bin2hex($x));
+            case 256:
+                switch (MATH_BIGINTEGER_MODE) {
+                    case self::MODE_GMP:
+                        $this->value = function_exists('gmp_import') ?
+                            gmp_import($x) :
+                            gmp_init('0x' . bin2hex($x));
+                        if ($this->is_negative) {
+                            $this->value = gmp_neg($this->value);
+                        }
                         break;
-                    case MATH_BIGINTEGER_MODE_BCMATH:
+                    case self::MODE_BCMATH:
                         // round $len to the nearest 4 (thanks, DavidMJ!)
                         $len = (strlen($x) + 3) & 0xFFFFFFFC;
 
@@ -329,19 +390,19 @@ class Math_BigInteger {
                     // converts a base-2**8 (big endian / msb) number to base-2**26 (little endian / lsb)
                     default:
                         while (strlen($x)) {
-                            $this->value[] = $this->_bytes2int($this->_base256_rshift($x, 26));
+                            $this->value[] = $this->_bytes2int($this->_base256_rshift($x, self::$base));
                         }
                 }
 
                 if ($this->is_negative) {
-                    if (MATH_BIGINTEGER_MODE != MATH_BIGINTEGER_MODE_INTERNAL) {
+                    if (MATH_BIGINTEGER_MODE != self::MODE_INTERNAL) {
                         $this->is_negative = false;
                     }
-                    $temp = $this->add(new Math_BigInteger('-1'));
+                    $temp = $this->add(new static('-1'));
                     $this->value = $temp->value;
                 }
                 break;
-            case  16:
+            case 16:
             case -16:
                 if ($base > 0 && $x[0] == '-') {
                     $this->is_negative = true;
@@ -356,66 +417,67 @@ class Math_BigInteger {
                     $x = bin2hex(~pack('H*', $x));
                 }
 
-                switch ( MATH_BIGINTEGER_MODE ) {
-                    case MATH_BIGINTEGER_MODE_GMP:
+                switch (MATH_BIGINTEGER_MODE) {
+                    case self::MODE_GMP:
                         $temp = $this->is_negative ? '-0x' . $x : '0x' . $x;
                         $this->value = gmp_init($temp);
                         $this->is_negative = false;
                         break;
-                    case MATH_BIGINTEGER_MODE_BCMATH:
-                        $x = ( strlen($x) & 1 ) ? '0' . $x : $x;
-                        $temp = new Math_BigInteger(pack('H*', $x), 256);
+                    case self::MODE_BCMATH:
+                        $x = (strlen($x) & 1) ? '0' . $x : $x;
+                        $temp = new static(pack('H*', $x), 256);
                         $this->value = $this->is_negative ? '-' . $temp->value : $temp->value;
                         $this->is_negative = false;
                         break;
                     default:
-                        $x = ( strlen($x) & 1 ) ? '0' . $x : $x;
-                        $temp = new Math_BigInteger(pack('H*', $x), 256);
+                        $x = (strlen($x) & 1) ? '0' . $x : $x;
+                        $temp = new static(pack('H*', $x), 256);
                         $this->value = $temp->value;
                 }
 
                 if ($is_negative) {
-                    $temp = $this->add(new Math_BigInteger('-1'));
+                    $temp = $this->add(new static('-1'));
                     $this->value = $temp->value;
                 }
                 break;
-            case  10:
+            case 10:
             case -10:
-                $x = preg_replace('#^(-?[0-9]*).*#', '$1', $x);
+                // (?<!^)(?:-).*: find any -'s that aren't at the beginning and then any characters that follow that
+                // (?<=^|-)0*: find any 0's that are preceded by the start of the string or by a - (ie. octals)
+                // [^-0-9].*: find any non-numeric characters and then any characters that follow that
+                $x = preg_replace('#(?<!^)(?:-).*|(?<=^|-)0*|[^-0-9].*#', '', $x);
 
-                switch ( MATH_BIGINTEGER_MODE ) {
-                    case MATH_BIGINTEGER_MODE_GMP:
+                switch (MATH_BIGINTEGER_MODE) {
+                    case self::MODE_GMP:
                         $this->value = gmp_init($x);
                         break;
-                    case MATH_BIGINTEGER_MODE_BCMATH:
+                    case self::MODE_BCMATH:
                         // explicitly casting $x to a string is necessary, here, since doing $x[0] on -1 yields different
                         // results then doing it on '-1' does (modInverse does $x[0])
-                        $this->value = (string) $x;
+                        $this->value = $x === '-' ? '0' : (string) $x;
                         break;
                     default:
-                        $temp = new Math_BigInteger();
+                        $temp = new static();
 
-                        // array(10000000) is 10**7 in base-2**26.  10**7 is the closest to 2**26 we can get without passing it.
-                        $multiplier = new Math_BigInteger();
-                        $multiplier->value = array(10000000);
+                        $multiplier = new static();
+                        $multiplier->value = array(self::$max10);
 
                         if ($x[0] == '-') {
                             $this->is_negative = true;
                             $x = substr($x, 1);
                         }
 
-                        $x = str_pad($x, strlen($x) + (6 * strlen($x)) % 7, 0, STR_PAD_LEFT);
-
+                        $x = str_pad($x, strlen($x) + ((self::$max10Len - 1) * strlen($x)) % self::$max10Len, 0, STR_PAD_LEFT);
                         while (strlen($x)) {
                             $temp = $temp->multiply($multiplier);
-                            $temp = $temp->add(new Math_BigInteger($this->_int2bytes(substr($x, 0, 7)), 256));
-                            $x = substr($x, 7);
+                            $temp = $temp->add(new static($this->_int2bytes(substr($x, 0, self::$max10Len)), 256));
+                            $x = substr($x, self::$max10Len);
                         }
 
                         $this->value = $temp->value;
                 }
                 break;
-            case  2: // base-2 support originally implemented by Lluis Pamies - thanks!
+            case 2: // base-2 support originally implemented by Lluis Pamies - thanks!
             case -2:
                 if ($base > 0 && $x[0] == '-') {
                     $this->is_negative = true;
@@ -436,7 +498,7 @@ class Math_BigInteger {
                     $str = '-' . $str;
                 }
 
-                $temp = new Math_BigInteger($str, 8 * $base); // ie. either -16 or +16
+                $temp = new static($str, 8 * $base); // ie. either -16 or +16
                 $this->value = $temp->value;
                 $this->is_negative = $temp->is_negative;
 
@@ -455,31 +517,29 @@ class Math_BigInteger {
      * Here's an example:
      * <code>
      * <?php
-     *    include('Math/BigInteger.php');
-     *
-     *    $a = new Math_BigInteger('65');
+     *    $a = new \phpseclib\Math\BigInteger('65');
      *
      *    echo $a->toBytes(); // outputs chr(65)
      * ?>
      * </code>
      *
-     * @param Boolean $twos_compliment
-     * @return String
+     * @param bool $twos_compliment
+     * @return string
      * @access public
      * @internal Converts a base-2**26 number to base-2**8
      */
     function toBytes($twos_compliment = false)
     {
         if ($twos_compliment) {
-            $comparison = $this->compare(new Math_BigInteger());
+            $comparison = $this->compare(new static());
             if ($comparison == 0) {
                 return $this->precision > 0 ? str_repeat(chr(0), ($this->precision + 1) >> 3) : '';
             }
 
-            $temp = $comparison < 0 ? $this->add(new Math_BigInteger(1)) : $this->copy();
+            $temp = $comparison < 0 ? $this->add(new static(1)) : $this->copy();
             $bytes = $temp->toBytes();
 
-            if (empty($bytes)) { // eg. if the number we're trying to convert is -1
+            if (!strlen($bytes)) { // eg. if the number we're trying to convert is -1
                 $bytes = chr(0);
             }
 
@@ -490,20 +550,24 @@ class Math_BigInteger {
             return $comparison < 0 ? ~$bytes : $bytes;
         }
 
-        switch ( MATH_BIGINTEGER_MODE ) {
-            case MATH_BIGINTEGER_MODE_GMP:
+        switch (MATH_BIGINTEGER_MODE) {
+            case self::MODE_GMP:
                 if (gmp_cmp($this->value, gmp_init(0)) == 0) {
                     return $this->precision > 0 ? str_repeat(chr(0), ($this->precision + 1) >> 3) : '';
                 }
 
-                $temp = gmp_strval(gmp_abs($this->value), 16);
-                $temp = ( strlen($temp) & 1 ) ? '0' . $temp : $temp;
-                $temp = pack('H*', $temp);
+                if (function_exists('gmp_export')) {
+                    $temp = gmp_export($this->value);
+                } else {
+                    $temp = gmp_strval(gmp_abs($this->value), 16);
+                    $temp = (strlen($temp) & 1) ? '0' . $temp : $temp;
+                    $temp = pack('H*', $temp);
+                }
 
                 return $this->precision > 0 ?
                     substr(str_pad($temp, $this->precision >> 3, chr(0), STR_PAD_LEFT), -($this->precision >> 3)) :
                     ltrim($temp, chr(0));
-            case MATH_BIGINTEGER_MODE_BCMATH:
+            case self::MODE_BCMATH:
                 if ($this->value === '0') {
                     return $this->precision > 0 ? str_repeat(chr(0), ($this->precision + 1) >> 3) : '';
                 }
@@ -534,7 +598,7 @@ class Math_BigInteger {
         $temp = $this->copy();
 
         for ($i = count($temp->value) - 2; $i >= 0; --$i) {
-            $temp->_base256_lshift($result, 26);
+            $temp->_base256_lshift($result, self::$base);
             $result = $result | str_pad($temp->_int2bytes($temp->value[$i]), strlen($result), chr(0), STR_PAD_LEFT);
         }
 
@@ -552,16 +616,14 @@ class Math_BigInteger {
      * Here's an example:
      * <code>
      * <?php
-     *    include('Math/BigInteger.php');
-     *
-     *    $a = new Math_BigInteger('65');
+     *    $a = new \phpseclib\Math\BigInteger('65');
      *
      *    echo $a->toHex(); // outputs '41'
      * ?>
      * </code>
      *
-     * @param Boolean $twos_compliment
-     * @return String
+     * @param bool $twos_compliment
+     * @return string
      * @access public
      * @internal Converts a base-2**26 number to base-2**8
      */
@@ -579,16 +641,14 @@ class Math_BigInteger {
      * Here's an example:
      * <code>
      * <?php
-     *    include('Math/BigInteger.php');
-     *
-     *    $a = new Math_BigInteger('65');
+     *    $a = new \phpseclib\Math\BigInteger('65');
      *
      *    echo $a->toBits(); // outputs '1000001'
      * ?>
      * </code>
      *
-     * @param Boolean $twos_compliment
-     * @return String
+     * @param bool $twos_compliment
+     * @return string
      * @access public
      * @internal Converts a base-2**26 number to base-2**2
      */
@@ -596,10 +656,19 @@ class Math_BigInteger {
     {
         $hex = $this->toHex($twos_compliment);
         $bits = '';
-        for ($i = 0; $i < strlen($hex); $i+=8) {
-            $bits.= str_pad(decbin(hexdec(substr($hex, $i, 8))), 32, '0', STR_PAD_LEFT);
+        for ($i = strlen($hex) - 8, $start = strlen($hex) & 7; $i >= $start; $i-=8) {
+            $bits = str_pad(decbin(hexdec(substr($hex, $i, 8))), 32, '0', STR_PAD_LEFT) . $bits;
         }
-        return $this->precision > 0 ? substr($bits, -$this->precision) : ltrim($bits, '0');
+        if ($start) { // hexdec('') == 0
+            $bits = str_pad(decbin(hexdec(substr($hex, 0, $start))), 8, '0', STR_PAD_LEFT) . $bits;
+        }
+        $result = $this->precision > 0 ? substr($bits, -$this->precision) : ltrim($bits, '0');
+
+        if ($twos_compliment && $this->compare(new static()) > 0 && $this->precision <= 0) {
+            return '0' . $result;
+        }
+
+        return $result;
     }
 
     /**
@@ -608,24 +677,22 @@ class Math_BigInteger {
      * Here's an example:
      * <code>
      * <?php
-     *    include('Math/BigInteger.php');
-     *
-     *    $a = new Math_BigInteger('50');
+     *    $a = new \phpseclib\Math\BigInteger('50');
      *
      *    echo $a->toString(); // outputs 50
      * ?>
      * </code>
      *
-     * @return String
+     * @return string
      * @access public
      * @internal Converts a base-2**26 number to base-10**7 (which is pretty much base-10)
      */
     function toString()
     {
-        switch ( MATH_BIGINTEGER_MODE ) {
-            case MATH_BIGINTEGER_MODE_GMP:
+        switch (MATH_BIGINTEGER_MODE) {
+            case self::MODE_GMP:
                 return gmp_strval($this->value);
-            case MATH_BIGINTEGER_MODE_BCMATH:
+            case self::MODE_BCMATH:
                 if ($this->value === '0') {
                     return '0';
                 }
@@ -640,12 +707,12 @@ class Math_BigInteger {
         $temp = $this->copy();
         $temp->is_negative = false;
 
-        $divisor = new Math_BigInteger();
-        $divisor->value = array(10000000); // eg. 10**7
+        $divisor = new static();
+        $divisor->value = array(self::$max10);
         $result = '';
         while (count($temp->value)) {
             list($temp, $mod) = $temp->divide($divisor);
-            $result = str_pad(isset($mod->value[0]) ? $mod->value[0] : '', 7, '0', STR_PAD_LEFT) . $result;
+            $result = str_pad(isset($mod->value[0]) ? $mod->value[0] : '', self::$max10Len, '0', STR_PAD_LEFT) . $result;
         }
         $result = ltrim($result, '0');
         if (empty($result)) {
@@ -668,15 +735,14 @@ class Math_BigInteger {
      * {@link http://php.net/language.oop5.basic#51624}
      *
      * @access public
-     * @see __clone()
-     * @return Math_BigInteger
+     * @see self::__clone()
+     * @return \phpseclib\Math\BigInteger
      */
     function copy()
     {
-        $temp = new Math_BigInteger();
+        $temp = new static();
         $temp->value = $this->value;
         $temp->is_negative = $this->is_negative;
-        $temp->generator = $this->generator;
         $temp->precision = $this->precision;
         $temp->bitmask = $this->bitmask;
         return $temp;
@@ -699,14 +765,14 @@ class Math_BigInteger {
     /**
      * __clone() magic method
      *
-     * Although you can call Math_BigInteger::__toString() directly in PHP5, you cannot call Math_BigInteger::__clone()
-     * directly in PHP5.  You can in PHP4 since it's not a magic method, but in PHP5, you have to call it by using the PHP5
-     * only syntax of $y = clone $x.  As such, if you're trying to write an application that works on both PHP4 and PHP5,
-     * call Math_BigInteger::copy(), instead.
+     * Although you can call BigInteger::__toString() directly in PHP5, you cannot call BigInteger::__clone() directly
+     * in PHP5.  You can in PHP4 since it's not a magic method, but in PHP5, you have to call it by using the PHP5
+     * only syntax of $y = clone $x.  As such, if you're trying to write an application that works on both PHP4 and
+     * PHP5, call BigInteger::copy(), instead.
      *
      * @access public
-     * @see copy()
-     * @return Math_BigInteger
+     * @see self::copy()
+     * @return \phpseclib\Math\BigInteger
      */
     function __clone()
     {
@@ -716,39 +782,34 @@ class Math_BigInteger {
     /**
      *  __sleep() magic method
      *
-     * Will be called, automatically, when serialize() is called on a Math_BigInteger object.
+     * Will be called, automatically, when serialize() is called on a BigInteger object.
      *
-     * @see __wakeup()
+     * @see self::__wakeup()
      * @access public
      */
     function __sleep()
     {
         $this->hex = $this->toHex(true);
         $vars = array('hex');
-        if ($this->generator != 'mt_rand') {
-            $vars[] = 'generator';
-        }
         if ($this->precision > 0) {
             $vars[] = 'precision';
         }
         return $vars;
-        
     }
 
     /**
      *  __wakeup() magic method
      *
-     * Will be called, automatically, when unserialize() is called on a Math_BigInteger object.
+     * Will be called, automatically, when unserialize() is called on a BigInteger object.
      *
-     * @see __sleep()
+     * @see self::__sleep()
      * @access public
      */
     function __wakeup()
     {
-        $temp = new Math_BigInteger($this->hex, -16);
+        $temp = new static($this->hex, -16);
         $this->value = $temp->value;
         $this->is_negative = $temp->is_negative;
-        $this->setRandomGenerator($this->generator);
         if ($this->precision > 0) {
             // recalculate $this->bitmask
             $this->setPrecision($this->precision);
@@ -756,15 +817,46 @@ class Math_BigInteger {
     }
 
     /**
+     *  __debugInfo() magic method
+     *
+     * Will be called, automatically, when print_r() or var_dump() are called
+     *
+     * @access public
+     */
+    function __debugInfo()
+    {
+        $opts = array();
+        switch (MATH_BIGINTEGER_MODE) {
+            case self::MODE_GMP:
+                $engine = 'gmp';
+                break;
+            case self::MODE_BCMATH:
+                $engine = 'bcmath';
+                break;
+            case self::MODE_INTERNAL:
+                $engine = 'internal';
+                $opts[] = PHP_INT_SIZE == 8 ? '64-bit' : '32-bit';
+        }
+        if (MATH_BIGINTEGER_MODE != self::MODE_GMP && defined('MATH_BIGINTEGER_OPENSSL_ENABLED')) {
+            $opts[] = 'OpenSSL';
+        }
+        if (!empty($opts)) {
+            $engine.= ' (' . implode($opts, ', ') . ')';
+        }
+        return array(
+            'value' => '0x' . $this->toHex(true),
+            'engine' => $engine
+        );
+    }
+
+    /**
      * Adds two BigIntegers.
      *
      * Here's an example:
      * <code>
      * <?php
-     *    include('Math/BigInteger.php');
-     *
-     *    $a = new Math_BigInteger('10');
-     *    $b = new Math_BigInteger('20');
+     *    $a = new \phpseclib\Math\BigInteger('10');
+     *    $b = new \phpseclib\Math\BigInteger('20');
      *
      *    $c = $a->add($b);
      *
@@ -772,21 +864,21 @@ class Math_BigInteger {
      * ?>
      * </code>
      *
-     * @param Math_BigInteger $y
-     * @return Math_BigInteger
+     * @param \phpseclib\Math\BigInteger $y
+     * @return \phpseclib\Math\BigInteger
      * @access public
      * @internal Performs base-2**52 addition
      */
     function add($y)
     {
-        switch ( MATH_BIGINTEGER_MODE ) {
-            case MATH_BIGINTEGER_MODE_GMP:
-                $temp = new Math_BigInteger();
+        switch (MATH_BIGINTEGER_MODE) {
+            case self::MODE_GMP:
+                $temp = new static();
                 $temp->value = gmp_add($this->value, $y->value);
 
                 return $this->_normalize($temp);
-            case MATH_BIGINTEGER_MODE_BCMATH:
-                $temp = new Math_BigInteger();
+            case self::MODE_BCMATH:
+                $temp = new static();
                 $temp->value = bcadd($this->value, $y->value, 0);
 
                 return $this->_normalize($temp);
@@ -794,9 +886,9 @@ class Math_BigInteger {
 
         $temp = $this->_add($this->value, $this->is_negative, $y->value, $y->is_negative);
 
-        $result = new Math_BigInteger();
-        $result->value = $temp[MATH_BIGINTEGER_VALUE];
-        $result->is_negative = $temp[MATH_BIGINTEGER_SIGN];
+        $result = new static();
+        $result->value = $temp[self::VALUE];
+        $result->is_negative = $temp[self::SIGN];
 
         return $this->_normalize($result);
     }
@@ -804,11 +896,11 @@ class Math_BigInteger {
     /**
      * Performs addition.
      *
-     * @param Array $x_value
-     * @param Boolean $x_negative
-     * @param Array $y_value
-     * @param Boolean $y_negative
-     * @return Array
+     * @param array $x_value
+     * @param bool $x_negative
+     * @param array $y_value
+     * @param bool $y_negative
+     * @return array
      * @access private
      */
     function _add($x_value, $x_negative, $y_value, $y_negative)
@@ -818,27 +910,27 @@ class Math_BigInteger {
 
         if ($x_size == 0) {
             return array(
-                MATH_BIGINTEGER_VALUE => $y_value,
-                MATH_BIGINTEGER_SIGN => $y_negative
+                self::VALUE => $y_value,
+                self::SIGN => $y_negative
             );
-        } else if ($y_size == 0) {
+        } elseif ($y_size == 0) {
             return array(
-                MATH_BIGINTEGER_VALUE => $x_value,
-                MATH_BIGINTEGER_SIGN => $x_negative
+                self::VALUE => $x_value,
+                self::SIGN => $x_negative
             );
         }
 
         // subtract, if appropriate
-        if ( $x_negative != $y_negative ) {
-            if ( $x_value == $y_value ) {
+        if ($x_negative != $y_negative) {
+            if ($x_value == $y_value) {
                 return array(
-                    MATH_BIGINTEGER_VALUE => array(),
-                    MATH_BIGINTEGER_SIGN => false
+                    self::VALUE => array(),
+                    self::SIGN => false
                 );
             }
 
             $temp = $this->_subtract($x_value, false, $y_value, false);
-            $temp[MATH_BIGINTEGER_SIGN] = $this->_compare($x_value, false, $y_value, false) > 0 ?
+            $temp[self::SIGN] = $this->_compare($x_value, false, $y_value, false) > 0 ?
                                           $x_negative : $y_negative;
 
             return $temp;
@@ -852,37 +944,37 @@ class Math_BigInteger {
             $value = $x_value;
         }
 
-        $value[] = 0; // just in case the carry adds an extra digit
+        $value[count($value)] = 0; // just in case the carry adds an extra digit
 
         $carry = 0;
         for ($i = 0, $j = 1; $j < $size; $i+=2, $j+=2) {
-            $sum = $x_value[$j] * 0x4000000 + $x_value[$i] + $y_value[$j] * 0x4000000 + $y_value[$i] + $carry;
-            $carry = $sum >= MATH_BIGINTEGER_MAX_DIGIT52; // eg. floor($sum / 2**52); only possible values (in any base) are 0 and 1
-            $sum = $carry ? $sum - MATH_BIGINTEGER_MAX_DIGIT52 : $sum;
+            $sum = $x_value[$j] * self::$baseFull + $x_value[$i] + $y_value[$j] * self::$baseFull + $y_value[$i] + $carry;
+            $carry = $sum >= self::$maxDigit2; // eg. floor($sum / 2**52); only possible values (in any base) are 0 and 1
+            $sum = $carry ? $sum - self::$maxDigit2 : $sum;
 
-            $temp = (int) ($sum / 0x4000000);
+            $temp = self::$base === 26 ? intval($sum / 0x4000000) : ($sum >> 31);
 
-            $value[$i] = (int) ($sum - 0x4000000 * $temp); // eg. a faster alternative to fmod($sum, 0x4000000)
+            $value[$i] = (int) ($sum - self::$baseFull * $temp); // eg. a faster alternative to fmod($sum, 0x4000000)
             $value[$j] = $temp;
         }
 
         if ($j == $size) { // ie. if $y_size is odd
             $sum = $x_value[$i] + $y_value[$i] + $carry;
-            $carry = $sum >= 0x4000000;
-            $value[$i] = $carry ? $sum - 0x4000000 : $sum;
+            $carry = $sum >= self::$baseFull;
+            $value[$i] = $carry ? $sum - self::$baseFull : $sum;
             ++$i; // ie. let $i = $j since we've just done $value[$i]
         }
 
         if ($carry) {
-            for (; $value[$i] == 0x3FFFFFF; ++$i) {
+            for (; $value[$i] == self::$maxDigit; ++$i) {
                 $value[$i] = 0;
             }
             ++$value[$i];
         }
 
         return array(
-            MATH_BIGINTEGER_VALUE => $this->_trim($value),
-            MATH_BIGINTEGER_SIGN => $x_negative
+            self::VALUE => $this->_trim($value),
+            self::SIGN => $x_negative
         );
     }
 
@@ -892,10 +984,8 @@ class Math_BigInteger {
      * Here's an example:
      * <code>
      * <?php
-     *    include('Math/BigInteger.php');
-     *
-     *    $a = new Math_BigInteger('10');
-     *    $b = new Math_BigInteger('20');
+     *    $a = new \phpseclib\Math\BigInteger('10');
+     *    $b = new \phpseclib\Math\BigInteger('20');
      *
      *    $c = $a->subtract($b);
      *
@@ -903,21 +993,21 @@ class Math_BigInteger {
      * ?>
      * </code>
      *
-     * @param Math_BigInteger $y
-     * @return Math_BigInteger
+     * @param \phpseclib\Math\BigInteger $y
+     * @return \phpseclib\Math\BigInteger
      * @access public
      * @internal Performs base-2**52 subtraction
      */
     function subtract($y)
     {
-        switch ( MATH_BIGINTEGER_MODE ) {
-            case MATH_BIGINTEGER_MODE_GMP:
-                $temp = new Math_BigInteger();
+        switch (MATH_BIGINTEGER_MODE) {
+            case self::MODE_GMP:
+                $temp = new static();
                 $temp->value = gmp_sub($this->value, $y->value);
 
                 return $this->_normalize($temp);
-            case MATH_BIGINTEGER_MODE_BCMATH:
-                $temp = new Math_BigInteger();
+            case self::MODE_BCMATH:
+                $temp = new static();
                 $temp->value = bcsub($this->value, $y->value, 0);
 
                 return $this->_normalize($temp);
@@ -925,9 +1015,9 @@ class Math_BigInteger {
 
         $temp = $this->_subtract($this->value, $this->is_negative, $y->value, $y->is_negative);
 
-        $result = new Math_BigInteger();
-        $result->value = $temp[MATH_BIGINTEGER_VALUE];
-        $result->is_negative = $temp[MATH_BIGINTEGER_SIGN];
+        $result = new static();
+        $result->value = $temp[self::VALUE];
+        $result->is_negative = $temp[self::SIGN];
 
         return $this->_normalize($result);
     }
@@ -935,11 +1025,11 @@ class Math_BigInteger {
     /**
      * Performs subtraction.
      *
-     * @param Array $x_value
-     * @param Boolean $x_negative
-     * @param Array $y_value
-     * @param Boolean $y_negative
-     * @return Array
+     * @param array $x_value
+     * @param bool $x_negative
+     * @param array $y_value
+     * @param bool $y_negative
+     * @return array
      * @access private
      */
     function _subtract($x_value, $x_negative, $y_value, $y_negative)
@@ -949,35 +1039,35 @@ class Math_BigInteger {
 
         if ($x_size == 0) {
             return array(
-                MATH_BIGINTEGER_VALUE => $y_value,
-                MATH_BIGINTEGER_SIGN => !$y_negative
+                self::VALUE => $y_value,
+                self::SIGN => !$y_negative
             );
-        } else if ($y_size == 0) {
+        } elseif ($y_size == 0) {
             return array(
-                MATH_BIGINTEGER_VALUE => $x_value,
-                MATH_BIGINTEGER_SIGN => $x_negative
+                self::VALUE => $x_value,
+                self::SIGN => $x_negative
             );
         }
 
         // add, if appropriate (ie. -$x - +$y or +$x - -$y)
-        if ( $x_negative != $y_negative ) {
+        if ($x_negative != $y_negative) {
             $temp = $this->_add($x_value, false, $y_value, false);
-            $temp[MATH_BIGINTEGER_SIGN] = $x_negative;
+            $temp[self::SIGN] = $x_negative;
 
             return $temp;
         }
 
         $diff = $this->_compare($x_value, $x_negative, $y_value, $y_negative);
 
-        if ( !$diff ) {
+        if (!$diff) {
             return array(
-                MATH_BIGINTEGER_VALUE => array(),
-                MATH_BIGINTEGER_SIGN => false
+                self::VALUE => array(),
+                self::SIGN => false
             );
         }
 
         // switch $x and $y around, if appropriate.
-        if ( (!$x_negative && $diff < 0) || ($x_negative && $diff > 0) ) {
+        if ((!$x_negative && $diff < 0) || ($x_negative && $diff > 0)) {
             $temp = $x_value;
             $x_value = $y_value;
             $y_value = $temp;
@@ -992,33 +1082,33 @@ class Math_BigInteger {
 
         $carry = 0;
         for ($i = 0, $j = 1; $j < $y_size; $i+=2, $j+=2) {
-            $sum = $x_value[$j] * 0x4000000 + $x_value[$i] - $y_value[$j] * 0x4000000 - $y_value[$i] - $carry;
+            $sum = $x_value[$j] * self::$baseFull + $x_value[$i] - $y_value[$j] * self::$baseFull - $y_value[$i] - $carry;
             $carry = $sum < 0; // eg. floor($sum / 2**52); only possible values (in any base) are 0 and 1
-            $sum = $carry ? $sum + MATH_BIGINTEGER_MAX_DIGIT52 : $sum;
+            $sum = $carry ? $sum + self::$maxDigit2 : $sum;
 
-            $temp = (int) ($sum / 0x4000000);
+            $temp = self::$base === 26 ? intval($sum / 0x4000000) : ($sum >> 31);
 
-            $x_value[$i] = (int) ($sum - 0x4000000 * $temp);
+            $x_value[$i] = (int) ($sum - self::$baseFull * $temp);
             $x_value[$j] = $temp;
         }
 
         if ($j == $y_size) { // ie. if $y_size is odd
             $sum = $x_value[$i] - $y_value[$i] - $carry;
             $carry = $sum < 0;
-            $x_value[$i] = $carry ? $sum + 0x4000000 : $sum;
+            $x_value[$i] = $carry ? $sum + self::$baseFull : $sum;
             ++$i;
         }
 
         if ($carry) {
             for (; !$x_value[$i]; ++$i) {
-                $x_value[$i] = 0x3FFFFFF;
+                $x_value[$i] = self::$maxDigit;
             }
             --$x_value[$i];
         }
 
         return array(
-            MATH_BIGINTEGER_VALUE => $this->_trim($x_value),
-            MATH_BIGINTEGER_SIGN => $x_negative
+            self::VALUE => $this->_trim($x_value),
+            self::SIGN => $x_negative
         );
     }
 
@@ -1028,10 +1118,8 @@ class Math_BigInteger {
      * Here's an example:
      * <code>
      * <?php
-     *    include('Math/BigInteger.php');
-     *
-     *    $a = new Math_BigInteger('10');
-     *    $b = new Math_BigInteger('20');
+     *    $a = new \phpseclib\Math\BigInteger('10');
+     *    $b = new \phpseclib\Math\BigInteger('20');
      *
      *    $c = $a->multiply($b);
      *
@@ -1039,20 +1127,20 @@ class Math_BigInteger {
      * ?>
      * </code>
      *
-     * @param Math_BigInteger $x
-     * @return Math_BigInteger
+     * @param \phpseclib\Math\BigInteger $x
+     * @return \phpseclib\Math\BigInteger
      * @access public
      */
     function multiply($x)
     {
-        switch ( MATH_BIGINTEGER_MODE ) {
-            case MATH_BIGINTEGER_MODE_GMP:
-                $temp = new Math_BigInteger();
+        switch (MATH_BIGINTEGER_MODE) {
+            case self::MODE_GMP:
+                $temp = new static();
                 $temp->value = gmp_mul($this->value, $x->value);
 
                 return $this->_normalize($temp);
-            case MATH_BIGINTEGER_MODE_BCMATH:
-                $temp = new Math_BigInteger();
+            case self::MODE_BCMATH:
+                $temp = new static();
                 $temp->value = bcmul($this->value, $x->value, 0);
 
                 return $this->_normalize($temp);
@@ -1060,9 +1148,9 @@ class Math_BigInteger {
 
         $temp = $this->_multiply($this->value, $this->is_negative, $x->value, $x->is_negative);
 
-        $product = new Math_BigInteger();
-        $product->value = $temp[MATH_BIGINTEGER_VALUE];
-        $product->is_negative = $temp[MATH_BIGINTEGER_SIGN];
+        $product = new static();
+        $product->value = $temp[self::VALUE];
+        $product->is_negative = $temp[self::SIGN];
 
         return $this->_normalize($product);
     }
@@ -1070,37 +1158,37 @@ class Math_BigInteger {
     /**
      * Performs multiplication.
      *
-     * @param Array $x_value
-     * @param Boolean $x_negative
-     * @param Array $y_value
-     * @param Boolean $y_negative
-     * @return Array
+     * @param array $x_value
+     * @param bool $x_negative
+     * @param array $y_value
+     * @param bool $y_negative
+     * @return array
      * @access private
      */
     function _multiply($x_value, $x_negative, $y_value, $y_negative)
     {
         //if ( $x_value == $y_value ) {
         //    return array(
-        //        MATH_BIGINTEGER_VALUE => $this->_square($x_value),
-        //        MATH_BIGINTEGER_SIGN => $x_sign != $y_value
+        //        self::VALUE => $this->_square($x_value),
+        //        self::SIGN => $x_sign != $y_value
         //    );
         //}
 
         $x_length = count($x_value);
         $y_length = count($y_value);
 
-        if ( !$x_length || !$y_length ) { // a 0 is being multiplied
+        if (!$x_length || !$y_length) { // a 0 is being multiplied
             return array(
-                MATH_BIGINTEGER_VALUE => array(),
-                MATH_BIGINTEGER_SIGN => false
+                self::VALUE => array(),
+                self::SIGN => false
             );
         }
 
         return array(
-            MATH_BIGINTEGER_VALUE => min($x_length, $y_length) < 2 * MATH_BIGINTEGER_KARATSUBA_CUTOFF ?
+            self::VALUE => min($x_length, $y_length) < 2 * self::KARATSUBA_CUTOFF ?
                 $this->_trim($this->_regularMultiply($x_value, $y_value)) :
                 $this->_trim($this->_karatsuba($x_value, $y_value)),
-            MATH_BIGINTEGER_SIGN => $x_negative != $y_negative
+            self::SIGN => $x_negative != $y_negative
         );
     }
 
@@ -1109,9 +1197,9 @@ class Math_BigInteger {
      *
      * Modeled after 'multiply' in MutableBigInteger.java.
      *
-     * @param Array $x_value
-     * @param Array $y_value
-     * @return Array
+     * @param array $x_value
+     * @param array $y_value
+     * @return array
      * @access private
      */
     function _regularMultiply($x_value, $y_value)
@@ -1119,11 +1207,11 @@ class Math_BigInteger {
         $x_length = count($x_value);
         $y_length = count($y_value);
 
-        if ( !$x_length || !$y_length ) { // a 0 is being multiplied
+        if (!$x_length || !$y_length) { // a 0 is being multiplied
             return array();
         }
 
-        if ( $x_length < $y_length ) {
+        if ($x_length < $y_length) {
             $temp = $x_value;
             $x_value = $y_value;
             $y_value = $temp;
@@ -1144,8 +1232,8 @@ class Math_BigInteger {
 
         for ($j = 0; $j < $x_length; ++$j) { // ie. $i = 0
             $temp = $x_value[$j] * $y_value[0] + $carry; // $product_value[$k] == 0
-            $carry = (int) ($temp / 0x4000000);
-            $product_value[$j] = (int) ($temp - 0x4000000 * $carry);
+            $carry = self::$base === 26 ? intval($temp / 0x4000000) : ($temp >> 31);
+            $product_value[$j] = (int) ($temp - self::$baseFull * $carry);
         }
 
         $product_value[$j] = $carry;
@@ -1157,8 +1245,8 @@ class Math_BigInteger {
 
             for ($j = 0, $k = $i; $j < $x_length; ++$j, ++$k) {
                 $temp = $product_value[$k] + $x_value[$j] * $y_value[$i] + $carry;
-                $carry = (int) ($temp / 0x4000000);
-                $product_value[$k] = (int) ($temp - 0x4000000 * $carry);
+                $carry = self::$base === 26 ? intval($temp / 0x4000000) : ($temp >> 31);
+                $product_value[$k] = (int) ($temp - self::$baseFull * $carry);
             }
 
             $product_value[$k] = $carry;
@@ -1173,16 +1261,16 @@ class Math_BigInteger {
      * See {@link http://en.wikipedia.org/wiki/Karatsuba_algorithm Karatsuba algorithm} and
      * {@link http://math.libtomcrypt.com/files/tommath.pdf#page=120 MPM 5.2.3}.
      *
-     * @param Array $x_value
-     * @param Array $y_value
-     * @return Array
+     * @param array $x_value
+     * @param array $y_value
+     * @return array
      * @access private
      */
     function _karatsuba($x_value, $y_value)
     {
         $m = min(count($x_value) >> 1, count($y_value) >> 1);
 
-        if ($m < MATH_BIGINTEGER_KARATSUBA_CUTOFF) {
+        if ($m < self::KARATSUBA_CUTOFF) {
             return $this->_regularMultiply($x_value, $y_value);
         }
 
@@ -1196,29 +1284,29 @@ class Math_BigInteger {
 
         $z1 = $this->_add($x1, false, $x0, false);
         $temp = $this->_add($y1, false, $y0, false);
-        $z1 = $this->_karatsuba($z1[MATH_BIGINTEGER_VALUE], $temp[MATH_BIGINTEGER_VALUE]);
+        $z1 = $this->_karatsuba($z1[self::VALUE], $temp[self::VALUE]);
         $temp = $this->_add($z2, false, $z0, false);
-        $z1 = $this->_subtract($z1, false, $temp[MATH_BIGINTEGER_VALUE], false);
+        $z1 = $this->_subtract($z1, false, $temp[self::VALUE], false);
 
         $z2 = array_merge(array_fill(0, 2 * $m, 0), $z2);
-        $z1[MATH_BIGINTEGER_VALUE] = array_merge(array_fill(0, $m, 0), $z1[MATH_BIGINTEGER_VALUE]);
+        $z1[self::VALUE] = array_merge(array_fill(0, $m, 0), $z1[self::VALUE]);
 
-        $xy = $this->_add($z2, false, $z1[MATH_BIGINTEGER_VALUE], $z1[MATH_BIGINTEGER_SIGN]);
-        $xy = $this->_add($xy[MATH_BIGINTEGER_VALUE], $xy[MATH_BIGINTEGER_SIGN], $z0, false);
+        $xy = $this->_add($z2, false, $z1[self::VALUE], $z1[self::SIGN]);
+        $xy = $this->_add($xy[self::VALUE], $xy[self::SIGN], $z0, false);
 
-        return $xy[MATH_BIGINTEGER_VALUE];
+        return $xy[self::VALUE];
     }
 
     /**
      * Performs squaring
      *
-     * @param Array $x
-     * @return Array
+     * @param array $x
+     * @return array
      * @access private
      */
     function _square($x = false)
     {
-        return count($x) < 2 * MATH_BIGINTEGER_KARATSUBA_CUTOFF ?
+        return count($x) < 2 * self::KARATSUBA_CUTOFF ?
             $this->_trim($this->_baseSquare($x)) :
             $this->_trim($this->_karatsubaSquare($x));
     }
@@ -1230,13 +1318,13 @@ class Math_BigInteger {
      * {@link http://www.cacr.math.uwaterloo.ca/hac/about/chap14.pdf#page=7 HAC 14.2.4} /
      * {@link http://math.libtomcrypt.com/files/tommath.pdf#page=141 MPM 5.3} for more information.
      *
-     * @param Array $value
-     * @return Array
+     * @param array $value
+     * @return array
      * @access private
      */
     function _baseSquare($value)
     {
-        if ( empty($value) ) {
+        if (empty($value)) {
             return array();
         }
         $square_value = $this->_array_repeat(0, 2 * count($value));
@@ -1245,14 +1333,14 @@ class Math_BigInteger {
             $i2 = $i << 1;
 
             $temp = $square_value[$i2] + $value[$i] * $value[$i];
-            $carry = (int) ($temp / 0x4000000);
-            $square_value[$i2] = (int) ($temp - 0x4000000 * $carry);
+            $carry = self::$base === 26 ? intval($temp / 0x4000000) : ($temp >> 31);
+            $square_value[$i2] = (int) ($temp - self::$baseFull * $carry);
 
             // note how we start from $i+1 instead of 0 as we do in multiplication.
             for ($j = $i + 1, $k = $i2 + 1; $j <= $max_index; ++$j, ++$k) {
                 $temp = $square_value[$k] + 2 * $value[$j] * $value[$i] + $carry;
-                $carry = (int) ($temp / 0x4000000);
-                $square_value[$k] = (int) ($temp - 0x4000000 * $carry);
+                $carry = self::$base === 26 ? intval($temp / 0x4000000) : ($temp >> 31);
+                $square_value[$k] = (int) ($temp - self::$baseFull * $carry);
             }
 
             // the following line can yield values larger 2**15.  at this point, PHP should switch
@@ -1269,15 +1357,15 @@ class Math_BigInteger {
      * See {@link http://en.wikipedia.org/wiki/Karatsuba_algorithm Karatsuba algorithm} and
      * {@link http://math.libtomcrypt.com/files/tommath.pdf#page=151 MPM 5.3.4}.
      *
-     * @param Array $value
-     * @return Array
+     * @param array $value
+     * @return array
      * @access private
      */
     function _karatsubaSquare($value)
     {
         $m = count($value) >> 1;
 
-        if ($m < MATH_BIGINTEGER_KARATSUBA_CUTOFF) {
+        if ($m < self::KARATSUBA_CUTOFF) {
             return $this->_baseSquare($value);
         }
 
@@ -1288,17 +1376,17 @@ class Math_BigInteger {
         $z0 = $this->_karatsubaSquare($x0);
 
         $z1 = $this->_add($x1, false, $x0, false);
-        $z1 = $this->_karatsubaSquare($z1[MATH_BIGINTEGER_VALUE]);
+        $z1 = $this->_karatsubaSquare($z1[self::VALUE]);
         $temp = $this->_add($z2, false, $z0, false);
-        $z1 = $this->_subtract($z1, false, $temp[MATH_BIGINTEGER_VALUE], false);
+        $z1 = $this->_subtract($z1, false, $temp[self::VALUE], false);
 
         $z2 = array_merge(array_fill(0, 2 * $m, 0), $z2);
-        $z1[MATH_BIGINTEGER_VALUE] = array_merge(array_fill(0, $m, 0), $z1[MATH_BIGINTEGER_VALUE]);
+        $z1[self::VALUE] = array_merge(array_fill(0, $m, 0), $z1[self::VALUE]);
 
-        $xx = $this->_add($z2, false, $z1[MATH_BIGINTEGER_VALUE], $z1[MATH_BIGINTEGER_SIGN]);
-        $xx = $this->_add($xx[MATH_BIGINTEGER_VALUE], $xx[MATH_BIGINTEGER_SIGN], $z0, false);
+        $xx = $this->_add($z2, false, $z1[self::VALUE], $z1[self::SIGN]);
+        $xx = $this->_add($xx[self::VALUE], $xx[self::SIGN], $z0, false);
 
-        return $xx[MATH_BIGINTEGER_VALUE];
+        return $xx[self::VALUE];
     }
 
     /**
@@ -1312,10 +1400,8 @@ class Math_BigInteger {
      * Here's an example:
      * <code>
      * <?php
-     *    include('Math/BigInteger.php');
-     *
-     *    $a = new Math_BigInteger('10');
-     *    $b = new Math_BigInteger('20');
+     *    $a = new \phpseclib\Math\BigInteger('10');
+     *    $b = new \phpseclib\Math\BigInteger('20');
      *
      *    list($quotient, $remainder) = $a->divide($b);
      *
@@ -1325,17 +1411,17 @@ class Math_BigInteger {
      * ?>
      * </code>
      *
-     * @param Math_BigInteger $y
-     * @return Array
+     * @param \phpseclib\Math\BigInteger $y
+     * @return array
      * @access public
      * @internal This function is based off of {@link http://www.cacr.math.uwaterloo.ca/hac/about/chap14.pdf#page=9 HAC 14.20}.
      */
     function divide($y)
     {
-        switch ( MATH_BIGINTEGER_MODE ) {
-            case MATH_BIGINTEGER_MODE_GMP:
-                $quotient = new Math_BigInteger();
-                $remainder = new Math_BigInteger();
+        switch (MATH_BIGINTEGER_MODE) {
+            case self::MODE_GMP:
+                $quotient = new static();
+                $remainder = new static();
 
                 list($quotient->value, $remainder->value) = gmp_div_qr($this->value, $y->value);
 
@@ -1344,9 +1430,9 @@ class Math_BigInteger {
                 }
 
                 return array($this->_normalize($quotient), $this->_normalize($remainder));
-            case MATH_BIGINTEGER_MODE_BCMATH:
-                $quotient = new Math_BigInteger();
-                $remainder = new Math_BigInteger();
+            case self::MODE_BCMATH:
+                $quotient = new static();
+                $remainder = new static();
 
                 $quotient->value = bcdiv($this->value, $y->value, 0);
                 $remainder->value = bcmod($this->value, $y->value);
@@ -1360,8 +1446,8 @@ class Math_BigInteger {
 
         if (count($y->value) == 1) {
             list($q, $r) = $this->_divide_digit($this->value, $y->value[0]);
-            $quotient = new Math_BigInteger();
-            $remainder = new Math_BigInteger();
+            $quotient = new static();
+            $remainder = new static();
             $quotient->value = $q;
             $remainder->value = array($r);
             $quotient->is_negative = $this->is_negative != $y->is_negative;
@@ -1369,8 +1455,8 @@ class Math_BigInteger {
         }
 
         static $zero;
-        if ( !isset($zero) ) {
-            $zero = new Math_BigInteger();
+        if (!isset($zero)) {
+            $zero = new static();
         }
 
         $x = $this->copy();
@@ -1383,24 +1469,24 @@ class Math_BigInteger {
 
         $diff = $x->compare($y);
 
-        if ( !$diff ) {
-            $temp = new Math_BigInteger();
+        if (!$diff) {
+            $temp = new static();
             $temp->value = array(1);
             $temp->is_negative = $x_sign != $y_sign;
-            return array($this->_normalize($temp), $this->_normalize(new Math_BigInteger()));
+            return array($this->_normalize($temp), $this->_normalize(new static()));
         }
 
-        if ( $diff < 0 ) {
+        if ($diff < 0) {
             // if $x is negative, "add" $y.
-            if ( $x_sign ) {
+            if ($x_sign) {
                 $x = $y->subtract($x);
             }
-            return array($this->_normalize(new Math_BigInteger()), $this->_normalize($x));
+            return array($this->_normalize(new static()), $this->_normalize($x));
         }
 
         // normalize $x and $y as described in HAC 14.23 / 14.24
         $msb = $y->value[count($y->value) - 1];
-        for ($shift = 0; !($msb & 0x2000000); ++$shift) {
+        for ($shift = 0; !($msb & self::$msb); ++$shift) {
             $msb <<= 1;
         }
         $x->_lshift($shift);
@@ -1410,15 +1496,15 @@ class Math_BigInteger {
         $x_max = count($x->value) - 1;
         $y_max = count($y->value) - 1;
 
-        $quotient = new Math_BigInteger();
+        $quotient = new static();
         $quotient_value = &$quotient->value;
         $quotient_value = $this->_array_repeat(0, $x_max - $y_max + 1);
 
         static $temp, $lhs, $rhs;
         if (!isset($temp)) {
-            $temp = new Math_BigInteger();
-            $lhs =  new Math_BigInteger();
-            $rhs =  new Math_BigInteger();
+            $temp = new static();
+            $lhs =  new static();
+            $rhs =  new static();
         }
         $temp_value = &$temp->value;
         $rhs_value =  &$rhs->value;
@@ -1426,7 +1512,7 @@ class Math_BigInteger {
         // $temp = $y << ($x_max - $y_max-1) in base 2**26
         $temp_value = array_merge($this->_array_repeat(0, $x_max - $y_max), $y_value);
 
-        while ( $x->compare($temp) >= 0 ) {
+        while ($x->compare($temp) >= 0) {
             // calculate the "common residue"
             ++$quotient_value[$x_max - $y_max];
             $x = $x->subtract($temp);
@@ -1442,16 +1528,15 @@ class Math_BigInteger {
             );
             $y_window = array(
                 $y_value[$y_max],
-                ( $y_max > 0 ) ? $y_value[$y_max - 1] : 0
+                ($y_max > 0) ? $y_value[$y_max - 1] : 0
             );
 
             $q_index = $i - $y_max - 1;
             if ($x_window[0] == $y_window[0]) {
-                $quotient_value[$q_index] = 0x3FFFFFF;
+                $quotient_value[$q_index] = self::$maxDigit;
             } else {
-                $quotient_value[$q_index] = (int) (
-                    ($x_window[0] * 0x4000000 + $x_window[1])
-                    /
+                $quotient_value[$q_index] = $this->_safe_divide(
+                    $x_window[0] * self::$baseFull + $x_window[1],
                     $y_window[0]
                 );
             }
@@ -1463,7 +1548,7 @@ class Math_BigInteger {
 
             $rhs_value = array($x_window[2], $x_window[1], $x_window[0]);
 
-            while ( $lhs->compare($rhs) > 0 ) {
+            while ($lhs->compare($rhs) > 0) {
                 --$quotient_value[$q_index];
 
                 $lhs->value = array($quotient_value[$q_index]);
@@ -1494,7 +1579,7 @@ class Math_BigInteger {
         $quotient->is_negative = $x_sign != $y_sign;
 
         // calculate the "common residue", if appropriate
-        if ( $x_sign ) {
+        if ($x_sign) {
             $y->_rshift($shift);
             $x = $y->subtract($x);
         }
@@ -1507,9 +1592,9 @@ class Math_BigInteger {
      *
      * abc / x = a00 / x + b0 / x + c / x
      *
-     * @param Array $dividend
-     * @param Array $divisor
-     * @return Array
+     * @param array $dividend
+     * @param array $divisor
+     * @return array
      * @access private
      */
     function _divide_digit($dividend, $divisor)
@@ -1518,8 +1603,8 @@ class Math_BigInteger {
         $result = array();
 
         for ($i = count($dividend) - 1; $i >= 0; --$i) {
-            $temp = 0x4000000 * $carry + $dividend[$i];
-            $result[$i] = (int) ($temp / $divisor);
+            $temp = self::$baseFull * $carry + $dividend[$i];
+            $result[$i] = $this->_safe_divide($temp, $divisor);
             $carry = (int) ($temp - $divisor * $result[$i]);
         }
 
@@ -1532,11 +1617,9 @@ class Math_BigInteger {
      * Here's an example:
      * <code>
      * <?php
-     *    include('Math/BigInteger.php');
-     *
-     *    $a = new Math_BigInteger('10');
-     *    $b = new Math_BigInteger('20');
-     *    $c = new Math_BigInteger('30');
+     *    $a = new \phpseclib\Math\BigInteger('10');
+     *    $b = new \phpseclib\Math\BigInteger('20');
+     *    $c = new \phpseclib\Math\BigInteger('30');
      *
      *    $c = $a->modPow($b, $c);
      *
@@ -1544,9 +1627,9 @@ class Math_BigInteger {
      * ?>
      * </code>
      *
-     * @param Math_BigInteger $e
-     * @param Math_BigInteger $n
-     * @return Math_BigInteger
+     * @param \phpseclib\Math\BigInteger $e
+     * @param \phpseclib\Math\BigInteger $n
+     * @return \phpseclib\Math\BigInteger
      * @access public
      * @internal The most naive approach to modular exponentiation has very unreasonable requirements, and
      *    and although the approach involving repeated squaring does vastly better, it, too, is impractical
@@ -1572,7 +1655,7 @@ class Math_BigInteger {
     {
         $n = $this->bitmask !== false && $this->bitmask->compare($n) < 0 ? $this->bitmask : $n->abs();
 
-        if ($e->compare(new Math_BigInteger()) < 0) {
+        if ($e->compare(new static()) < 0) {
             $e = $e->abs();
 
             $temp = $this->modInverse($n);
@@ -1583,48 +1666,100 @@ class Math_BigInteger {
             return $this->_normalize($temp->modPow($e, $n));
         }
 
-        switch ( MATH_BIGINTEGER_MODE ) {
-            case MATH_BIGINTEGER_MODE_GMP:
-                $temp = new Math_BigInteger();
-                $temp->value = gmp_powm($this->value, $e->value, $n->value);
+        if (MATH_BIGINTEGER_MODE == self::MODE_GMP) {
+            $temp = new static();
+            $temp->value = gmp_powm($this->value, $e->value, $n->value);
 
-                return $this->_normalize($temp);
-            case MATH_BIGINTEGER_MODE_BCMATH:
-                $temp = new Math_BigInteger();
-                $temp->value = bcpowmod($this->value, $e->value, $n->value, 0);
+            return $this->_normalize($temp);
+        }
 
-                return $this->_normalize($temp);
+        if ($this->compare(new static()) < 0 || $this->compare($n) > 0) {
+            list(, $temp) = $this->divide($n);
+            return $temp->modPow($e, $n);
+        }
+
+        if (defined('MATH_BIGINTEGER_OPENSSL_ENABLED')) {
+            $components = array(
+                'modulus' => $n->toBytes(true),
+                'publicExponent' => $e->toBytes(true)
+            );
+
+            $components = array(
+                'modulus' => pack('Ca*a*', 2, $this->_encodeASN1Length(strlen($components['modulus'])), $components['modulus']),
+                'publicExponent' => pack('Ca*a*', 2, $this->_encodeASN1Length(strlen($components['publicExponent'])), $components['publicExponent'])
+            );
+
+            $RSAPublicKey = pack(
+                'Ca*a*a*',
+                48,
+                $this->_encodeASN1Length(strlen($components['modulus']) + strlen($components['publicExponent'])),
+                $components['modulus'],
+                $components['publicExponent']
+            );
+
+            $rsaOID = pack('H*', '300d06092a864886f70d0101010500'); // hex version of MA0GCSqGSIb3DQEBAQUA
+            $RSAPublicKey = chr(0) . $RSAPublicKey;
+            $RSAPublicKey = chr(3) . $this->_encodeASN1Length(strlen($RSAPublicKey)) . $RSAPublicKey;
+
+            $encapsulated = pack(
+                'Ca*a*',
+                48,
+                $this->_encodeASN1Length(strlen($rsaOID . $RSAPublicKey)),
+                $rsaOID . $RSAPublicKey
+            );
+
+            $RSAPublicKey = "-----BEGIN PUBLIC KEY-----\r\n" .
+                             chunk_split(base64_encode($encapsulated)) .
+                             '-----END PUBLIC KEY-----';
+
+            $plaintext = str_pad($this->toBytes(), strlen($n->toBytes(true)) - 1, "\0", STR_PAD_LEFT);
+
+            if (openssl_public_encrypt($plaintext, $result, $RSAPublicKey, OPENSSL_NO_PADDING)) {
+                return new static($result, 256);
+            }
+        }
+
+        if (MATH_BIGINTEGER_MODE == self::MODE_BCMATH) {
+            $temp = new static();
+            $temp->value = bcpowmod($this->value, $e->value, $n->value, 0);
+
+            return $this->_normalize($temp);
         }
 
-        if ( empty($e->value) ) {
-            $temp = new Math_BigInteger();
+        if (empty($e->value)) {
+            $temp = new static();
             $temp->value = array(1);
             return $this->_normalize($temp);
         }
 
-        if ( $e->value == array(1) ) {
+        if ($e->value == array(1)) {
             list(, $temp) = $this->divide($n);
             return $this->_normalize($temp);
         }
 
-        if ( $e->value == array(2) ) {
-            $temp = new Math_BigInteger();
+        if ($e->value == array(2)) {
+            $temp = new static();
             $temp->value = $this->_square($this->value);
             list(, $temp) = $temp->divide($n);
             return $this->_normalize($temp);
         }
 
-        return $this->_normalize($this->_slidingWindow($e, $n, MATH_BIGINTEGER_BARRETT));
+        return $this->_normalize($this->_slidingWindow($e, $n, self::BARRETT));
+
+        // the following code, although not callable, can be run independently of the above code
+        // although the above code performed better in my benchmarks the following could might
+        // perform better under different circumstances. in lieu of deleting it it's just been
+        // made uncallable
 
         // is the modulo odd?
-        if ( $n->value[0] & 1 ) {
-            return $this->_normalize($this->_slidingWindow($e, $n, MATH_BIGINTEGER_MONTGOMERY));
+        if ($n->value[0] & 1) {
+            return $this->_normalize($this->_slidingWindow($e, $n, self::MONTGOMERY));
         }
         // if it's not, it's even
 
         // find the lowest set bit (eg. the max pow of 2 that divides $n)
         for ($i = 0; $i < count($n->value); ++$i) {
-            if ( $n->value[$i] ) {
+            if ($n->value[$i]) {
                 $temp = decbin($n->value[$i]);
                 $j = strlen($temp) - strrpos($temp, '1') - 1;
                 $j+= 26 * $i;
@@ -1635,12 +1770,12 @@ class Math_BigInteger {
 
         $mod1 = $n->copy();
         $mod1->_rshift($j);
-        $mod2 = new Math_BigInteger();
+        $mod2 = new static();
         $mod2->value = array(1);
         $mod2->_lshift($j);
 
-        $part1 = ( $mod1->value != array(1) ) ? $this->_slidingWindow($e, $mod1, MATH_BIGINTEGER_MONTGOMERY) : new Math_BigInteger();
-        $part2 = $this->_slidingWindow($e, $mod2, MATH_BIGINTEGER_POWEROF2);
+        $part1 = ($mod1->value != array(1)) ? $this->_slidingWindow($e, $mod1, self::MONTGOMERY) : new static();
+        $part2 = $this->_slidingWindow($e, $mod2, self::POWEROF2);
 
         $y1 = $mod2->modInverse($mod1);
         $y2 = $mod1->modInverse($mod2);
@@ -1660,11 +1795,11 @@ class Math_BigInteger {
     /**
      * Performs modular exponentiation.
      *
-     * Alias for Math_BigInteger::modPow()
+     * Alias for modPow().
      *
-     * @param Math_BigInteger $e
-     * @param Math_BigInteger $n
-     * @return Math_BigInteger
+     * @param \phpseclib\Math\BigInteger $e
+     * @param \phpseclib\Math\BigInteger $n
+     * @return \phpseclib\Math\BigInteger
      * @access public
      */
     function powMod($e, $n)
@@ -1680,10 +1815,10 @@ class Math_BigInteger {
      * however, this function performs a modular reduction after every multiplication and squaring operation.
      * As such, this function has the same preconditions that the reductions being used do.
      *
-     * @param Math_BigInteger $e
-     * @param Math_BigInteger $n
-     * @param Integer $mode
-     * @return Math_BigInteger
+     * @param \phpseclib\Math\BigInteger $e
+     * @param \phpseclib\Math\BigInteger $n
+     * @param int $mode
+     * @return \phpseclib\Math\BigInteger
      * @access private
      */
     function _slidingWindow($e, $n, $mode)
@@ -1695,14 +1830,15 @@ class Math_BigInteger {
         $e_length = count($e_value) - 1;
         $e_bits = decbin($e_value[$e_length]);
         for ($i = $e_length - 1; $i >= 0; --$i) {
-            $e_bits.= str_pad(decbin($e_value[$i]), 26, '0', STR_PAD_LEFT);
+            $e_bits.= str_pad(decbin($e_value[$i]), self::$base, '0', STR_PAD_LEFT);
         }
 
         $e_length = strlen($e_bits);
 
         // calculate the appropriate window size.
         // $window_size == 3 if $window_ranges is between 25 and 81, for example.
-        for ($i = 0, $window_size = 1; $e_length > $window_ranges[$i] && $i < count($window_ranges); ++$window_size, ++$i);
+        for ($i = 0, $window_size = 1; $i < count($window_ranges) && $e_length > $window_ranges[$i]; ++$window_size, ++$i) {
+        }
 
         $n_value = $n->value;
 
@@ -1722,28 +1858,29 @@ class Math_BigInteger {
         $result = array(1);
         $result = $this->_prepareReduce($result, $n_value, $mode);
 
-        for ($i = 0; $i < $e_length; ) {
-            if ( !$e_bits[$i] ) {
+        for ($i = 0; $i < $e_length;) {
+            if (!$e_bits[$i]) {
                 $result = $this->_squareReduce($result, $n_value, $mode);
                 ++$i;
             } else {
                 for ($j = $window_size - 1; $j > 0; --$j) {
-                    if ( !empty($e_bits[$i + $j]) ) {
+                    if (!empty($e_bits[$i + $j])) {
                         break;
                     }
                 }
 
-                for ($k = 0; $k <= $j; ++$k) {// eg. the length of substr($e_bits, $i, $j+1)
+                // eg. the length of substr($e_bits, $i, $j + 1)
+                for ($k = 0; $k <= $j; ++$k) {
                     $result = $this->_squareReduce($result, $n_value, $mode);
                 }
 
                 $result = $this->_multiplyReduce($result, $powers[bindec(substr($e_bits, $i, $j + 1))], $n_value, $mode);
 
-                $i+=$j + 1;
+                $i += $j + 1;
             }
         }
 
-        $temp = new Math_BigInteger();
+        $temp = new static();
         $temp->value = $this->_reduce($result, $n_value, $mode);
 
         return $temp;
@@ -1754,34 +1891,34 @@ class Math_BigInteger {
      *
      * For most $modes this will return the remainder.
      *
-     * @see _slidingWindow()
+     * @see self::_slidingWindow()
      * @access private
-     * @param Array $x
-     * @param Array $n
-     * @param Integer $mode
-     * @return Array
+     * @param array $x
+     * @param array $n
+     * @param int $mode
+     * @return array
      */
     function _reduce($x, $n, $mode)
     {
         switch ($mode) {
-            case MATH_BIGINTEGER_MONTGOMERY:
+            case self::MONTGOMERY:
                 return $this->_montgomery($x, $n);
-            case MATH_BIGINTEGER_BARRETT:
+            case self::BARRETT:
                 return $this->_barrett($x, $n);
-            case MATH_BIGINTEGER_POWEROF2:
-                $lhs = new Math_BigInteger();
+            case self::POWEROF2:
+                $lhs = new static();
                 $lhs->value = $x;
-                $rhs = new Math_BigInteger();
+                $rhs = new static();
                 $rhs->value = $n;
                 return $x->_mod2($n);
-            case MATH_BIGINTEGER_CLASSIC:
-                $lhs = new Math_BigInteger();
+            case self::CLASSIC:
+                $lhs = new static();
                 $lhs->value = $x;
-                $rhs = new Math_BigInteger();
+                $rhs = new static();
                 $rhs->value = $n;
                 list(, $temp) = $lhs->divide($rhs);
                 return $temp->value;
-            case MATH_BIGINTEGER_NONE:
+            case self::NONE:
                 return $x;
             default:
                 // an invalid $mode was provided
@@ -1791,16 +1928,16 @@ class Math_BigInteger {
     /**
      * Modular reduction preperation
      *
-     * @see _slidingWindow()
+     * @see self::_slidingWindow()
      * @access private
-     * @param Array $x
-     * @param Array $n
-     * @param Integer $mode
-     * @return Array
+     * @param array $x
+     * @param array $n
+     * @param int $mode
+     * @return array
      */
     function _prepareReduce($x, $n, $mode)
     {
-        if ($mode == MATH_BIGINTEGER_MONTGOMERY) {
+        if ($mode == self::MONTGOMERY) {
             return $this->_prepMontgomery($x, $n);
         }
         return $this->_reduce($x, $n, $mode);
@@ -1809,36 +1946,36 @@ class Math_BigInteger {
     /**
      * Modular multiply
      *
-     * @see _slidingWindow()
+     * @see self::_slidingWindow()
      * @access private
-     * @param Array $x
-     * @param Array $y
-     * @param Array $n
-     * @param Integer $mode
-     * @return Array
+     * @param array $x
+     * @param array $y
+     * @param array $n
+     * @param int $mode
+     * @return array
      */
     function _multiplyReduce($x, $y, $n, $mode)
     {
-        if ($mode == MATH_BIGINTEGER_MONTGOMERY) {
+        if ($mode == self::MONTGOMERY) {
             return $this->_montgomeryMultiply($x, $y, $n);
         }
         $temp = $this->_multiply($x, false, $y, false);
-        return $this->_reduce($temp[MATH_BIGINTEGER_VALUE], $n, $mode);
+        return $this->_reduce($temp[self::VALUE], $n, $mode);
     }
 
     /**
      * Modular square
      *
-     * @see _slidingWindow()
+     * @see self::_slidingWindow()
      * @access private
-     * @param Array $x
-     * @param Array $n
-     * @param Integer $mode
-     * @return Array
+     * @param array $x
+     * @param array $n
+     * @param int $mode
+     * @return array
      */
     function _squareReduce($x, $n, $mode)
     {
-        if ($mode == MATH_BIGINTEGER_MONTGOMERY) {
+        if ($mode == self::MONTGOMERY) {
             return $this->_montgomeryMultiply($x, $x, $n);
         }
         return $this->_reduce($this->_square($x), $n, $mode);
@@ -1850,14 +1987,14 @@ class Math_BigInteger {
      * Calculates $x%$n, where $n = 2**$e, for some $e.  Since this is basically the same as doing $x & ($n-1),
      * we'll just use this function as a wrapper for doing that.
      *
-     * @see _slidingWindow()
+     * @see self::_slidingWindow()
      * @access private
-     * @param Math_BigInteger
-     * @return Math_BigInteger
+     * @param \phpseclib\Math\BigInteger
+     * @return \phpseclib\Math\BigInteger
      */
     function _mod2($n)
     {
-        $temp = new Math_BigInteger();
+        $temp = new static();
         $temp->value = array(1);
         return $this->bitwise_and($n->subtract($temp));
     }
@@ -1880,25 +2017,25 @@ class Math_BigInteger {
      * (x >> 1) + (x >> 1) != x / 2 + x / 2.  If x is even, they're the same, but if x is odd, they're not.  See the in-line
      * comments for details.
      *
-     * @see _slidingWindow()
+     * @see self::_slidingWindow()
      * @access private
-     * @param Array $n
-     * @param Array $m
-     * @return Array
+     * @param array $n
+     * @param array $m
+     * @return array
      */
     function _barrett($n, $m)
     {
         static $cache = array(
-            MATH_BIGINTEGER_VARIABLE => array(),
-            MATH_BIGINTEGER_DATA => array()
+            self::VARIABLE => array(),
+            self::DATA => array()
         );
 
         $m_length = count($m);
 
         // if ($this->_compare($n, $this->_square($m)) >= 0) {
         if (count($n) > 2 * $m_length) {
-            $lhs = new Math_BigInteger();
-            $rhs = new Math_BigInteger();
+            $lhs = new static();
+            $rhs = new static();
             $lhs->value = $n;
             $rhs->value = $m;
             list(, $temp) = $lhs->divide($rhs);
@@ -1912,27 +2049,27 @@ class Math_BigInteger {
 
         // n = 2 * m.length
 
-        if ( ($key = array_search($m, $cache[MATH_BIGINTEGER_VARIABLE])) === false ) {
-            $key = count($cache[MATH_BIGINTEGER_VARIABLE]);
-            $cache[MATH_BIGINTEGER_VARIABLE][] = $m;
+        if (($key = array_search($m, $cache[self::VARIABLE])) === false) {
+            $key = count($cache[self::VARIABLE]);
+            $cache[self::VARIABLE][] = $m;
 
-            $lhs = new Math_BigInteger();
+            $lhs = new static();
             $lhs_value = &$lhs->value;
             $lhs_value = $this->_array_repeat(0, $m_length + ($m_length >> 1));
             $lhs_value[] = 1;
-            $rhs = new Math_BigInteger();
+            $rhs = new static();
             $rhs->value = $m;
 
             list($u, $m1) = $lhs->divide($rhs);
             $u = $u->value;
             $m1 = $m1->value;
 
-            $cache[MATH_BIGINTEGER_DATA][] = array(
+            $cache[self::DATA][] = array(
                 'u' => $u, // m.length >> 1 (technically (m.length >> 1) + 1)
                 'm1'=> $m1 // m.length
             );
         } else {
-            extract($cache[MATH_BIGINTEGER_DATA][$key]);
+            extract($cache[self::DATA][$key]);
         }
 
         $cutoff = $m_length + ($m_length >> 1);
@@ -1940,20 +2077,20 @@ class Math_BigInteger {
         $msd = array_slice($n, $cutoff);    // m.length >> 1
         $lsd = $this->_trim($lsd);
         $temp = $this->_multiply($msd, false, $m1, false);
-        $n = $this->_add($lsd, false, $temp[MATH_BIGINTEGER_VALUE], false); // m.length + (m.length >> 1) + 1
+        $n = $this->_add($lsd, false, $temp[self::VALUE], false); // m.length + (m.length >> 1) + 1
 
         if ($m_length & 1) {
-            return $this->_regularBarrett($n[MATH_BIGINTEGER_VALUE], $m);
+            return $this->_regularBarrett($n[self::VALUE], $m);
         }
 
         // (m.length + (m.length >> 1) + 1) - (m.length - 1) == (m.length >> 1) + 2
-        $temp = array_slice($n[MATH_BIGINTEGER_VALUE], $m_length - 1);
+        $temp = array_slice($n[self::VALUE], $m_length - 1);
         // if even: ((m.length >> 1) + 2) + (m.length >> 1) == m.length + 2
         // if odd:  ((m.length >> 1) + 2) + (m.length >> 1) == (m.length - 1) + 2 == m.length + 1
         $temp = $this->_multiply($temp, false, $u, false);
         // if even: (m.length + 2) - ((m.length >> 1) + 1) = m.length - (m.length >> 1) + 1
         // if odd:  (m.length + 1) - ((m.length >> 1) + 1) = m.length - (m.length >> 1)
-        $temp = array_slice($temp[MATH_BIGINTEGER_VALUE], ($m_length >> 1) + 1);
+        $temp = array_slice($temp[self::VALUE], ($m_length >> 1) + 1);
         // if even: (m.length - (m.length >> 1) + 1) + m.length = 2 * m.length - (m.length >> 1) + 1
         // if odd:  (m.length - (m.length >> 1)) + m.length     = 2 * m.length - (m.length >> 1)
         $temp = $this->_multiply($temp, false, $m, false);
@@ -1962,64 +2099,64 @@ class Math_BigInteger {
         // number from a m.length + (m.length >> 1) + 1 digit number.  ie. there'd be an extra digit and the while loop
         // following this comment would loop a lot (hence our calling _regularBarrett() in that situation).
 
-        $result = $this->_subtract($n[MATH_BIGINTEGER_VALUE], false, $temp[MATH_BIGINTEGER_VALUE], false);
+        $result = $this->_subtract($n[self::VALUE], false, $temp[self::VALUE], false);
 
-        while ($this->_compare($result[MATH_BIGINTEGER_VALUE], $result[MATH_BIGINTEGER_SIGN], $m, false) >= 0) {
-            $result = $this->_subtract($result[MATH_BIGINTEGER_VALUE], $result[MATH_BIGINTEGER_SIGN], $m, false);
+        while ($this->_compare($result[self::VALUE], $result[self::SIGN], $m, false) >= 0) {
+            $result = $this->_subtract($result[self::VALUE], $result[self::SIGN], $m, false);
         }
 
-        return $result[MATH_BIGINTEGER_VALUE];
+        return $result[self::VALUE];
     }
 
     /**
      * (Regular) Barrett Modular Reduction
      *
-     * For numbers with more than four digits Math_BigInteger::_barrett() is faster.  The difference between that and this
+     * For numbers with more than four digits BigInteger::_barrett() is faster.  The difference between that and this
      * is that this function does not fold the denominator into a smaller form.
      *
-     * @see _slidingWindow()
+     * @see self::_slidingWindow()
      * @access private
-     * @param Array $x
-     * @param Array $n
-     * @return Array
+     * @param array $x
+     * @param array $n
+     * @return array
      */
     function _regularBarrett($x, $n)
     {
         static $cache = array(
-            MATH_BIGINTEGER_VARIABLE => array(),
-            MATH_BIGINTEGER_DATA => array()
+            self::VARIABLE => array(),
+            self::DATA => array()
         );
 
         $n_length = count($n);
 
         if (count($x) > 2 * $n_length) {
-            $lhs = new Math_BigInteger();
-            $rhs = new Math_BigInteger();
+            $lhs = new static();
+            $rhs = new static();
             $lhs->value = $x;
             $rhs->value = $n;
             list(, $temp) = $lhs->divide($rhs);
             return $temp->value;
         }
 
-        if ( ($key = array_search($n, $cache[MATH_BIGINTEGER_VARIABLE])) === false ) {
-            $key = count($cache[MATH_BIGINTEGER_VARIABLE]);
-            $cache[MATH_BIGINTEGER_VARIABLE][] = $n;
-            $lhs = new Math_BigInteger();
+        if (($key = array_search($n, $cache[self::VARIABLE])) === false) {
+            $key = count($cache[self::VARIABLE]);
+            $cache[self::VARIABLE][] = $n;
+            $lhs = new static();
             $lhs_value = &$lhs->value;
             $lhs_value = $this->_array_repeat(0, 2 * $n_length);
             $lhs_value[] = 1;
-            $rhs = new Math_BigInteger();
+            $rhs = new static();
             $rhs->value = $n;
             list($temp, ) = $lhs->divide($rhs); // m.length
-            $cache[MATH_BIGINTEGER_DATA][] = $temp->value;
+            $cache[self::DATA][] = $temp->value;
         }
 
         // 2 * m.length - (m.length - 1) = m.length + 1
         $temp = array_slice($x, $n_length - 1);
         // (m.length + 1) + m.length = 2 * m.length + 1
-        $temp = $this->_multiply($temp, false, $cache[MATH_BIGINTEGER_DATA][$key], false);
+        $temp = $this->_multiply($temp, false, $cache[self::DATA][$key], false);
         // (2 * m.length + 1) - (m.length - 1) = m.length + 2
-        $temp = array_slice($temp[MATH_BIGINTEGER_VALUE], $n_length + 1);
+        $temp = array_slice($temp[self::VALUE], $n_length + 1);
 
         // m.length + 1
         $result = array_slice($x, 0, $n_length + 1);
@@ -2027,20 +2164,20 @@ class Math_BigInteger {
         $temp = $this->_multiplyLower($temp, false, $n, false, $n_length + 1);
         // $temp == array_slice($temp->_multiply($temp, false, $n, false)->value, 0, $n_length + 1)
 
-        if ($this->_compare($result, false, $temp[MATH_BIGINTEGER_VALUE], $temp[MATH_BIGINTEGER_SIGN]) < 0) {
+        if ($this->_compare($result, false, $temp[self::VALUE], $temp[self::SIGN]) < 0) {
             $corrector_value = $this->_array_repeat(0, $n_length + 1);
-            $corrector_value[] = 1;
-            $result = $this->_add($result, false, $corrector, false);
-            $result = $result[MATH_BIGINTEGER_VALUE];
+            $corrector_value[count($corrector_value)] = 1;
+            $result = $this->_add($result, false, $corrector_value, false);
+            $result = $result[self::VALUE];
         }
 
         // at this point, we're subtracting a number with m.length + 1 digits from another number with m.length + 1 digits
-        $result = $this->_subtract($result, false, $temp[MATH_BIGINTEGER_VALUE], $temp[MATH_BIGINTEGER_SIGN]);
-        while ($this->_compare($result[MATH_BIGINTEGER_VALUE], $result[MATH_BIGINTEGER_SIGN], $n, false) > 0) {
-            $result = $this->_subtract($result[MATH_BIGINTEGER_VALUE], $result[MATH_BIGINTEGER_SIGN], $n, false);
+        $result = $this->_subtract($result, false, $temp[self::VALUE], $temp[self::SIGN]);
+        while ($this->_compare($result[self::VALUE], $result[self::SIGN], $n, false) > 0) {
+            $result = $this->_subtract($result[self::VALUE], $result[self::SIGN], $n, false);
         }
 
-        return $result[MATH_BIGINTEGER_VALUE];
+        return $result[self::VALUE];
     }
 
     /**
@@ -2048,12 +2185,13 @@ class Math_BigInteger {
      *
      * If you're going to be doing array_slice($product->value, 0, $stop), some cycles can be saved.
      *
-     * @see _regularBarrett()
-     * @param Array $x_value
-     * @param Boolean $x_negative
-     * @param Array $y_value
-     * @param Boolean $y_negative
-     * @return Array
+     * @see self::_regularBarrett()
+     * @param array $x_value
+     * @param bool $x_negative
+     * @param array $y_value
+     * @param bool $y_negative
+     * @param int $stop
+     * @return array
      * @access private
      */
     function _multiplyLower($x_value, $x_negative, $y_value, $y_negative, $stop)
@@ -2061,14 +2199,14 @@ class Math_BigInteger {
         $x_length = count($x_value);
         $y_length = count($y_value);
 
-        if ( !$x_length || !$y_length ) { // a 0 is being multiplied
+        if (!$x_length || !$y_length) { // a 0 is being multiplied
             return array(
-                MATH_BIGINTEGER_VALUE => array(),
-                MATH_BIGINTEGER_SIGN => false
+                self::VALUE => array(),
+                self::SIGN => false
             );
         }
 
-        if ( $x_length < $y_length ) {
+        if ($x_length < $y_length) {
             $temp = $x_value;
             $x_value = $y_value;
             $y_value = $temp;
@@ -2089,8 +2227,8 @@ class Math_BigInteger {
 
         for ($j = 0; $j < $x_length; ++$j) { // ie. $i = 0, $k = $i
             $temp = $x_value[$j] * $y_value[0] + $carry; // $product_value[$k] == 0
-            $carry = (int) ($temp / 0x4000000);
-            $product_value[$j] = (int) ($temp - 0x4000000 * $carry);
+            $carry = self::$base === 26 ? intval($temp / 0x4000000) : ($temp >> 31);
+            $product_value[$j] = (int) ($temp - self::$baseFull * $carry);
         }
 
         if ($j < $stop) {
@@ -2105,8 +2243,8 @@ class Math_BigInteger {
 
             for ($j = 0, $k = $i; $j < $x_length && $k < $stop; ++$j, ++$k) {
                 $temp = $product_value[$k] + $x_value[$j] * $y_value[$i] + $carry;
-                $carry = (int) ($temp / 0x4000000);
-                $product_value[$k] = (int) ($temp - 0x4000000 * $carry);
+                $carry = self::$base === 26 ? intval($temp / 0x4000000) : ($temp >> 31);
+                $product_value[$k] = (int) ($temp - self::$baseFull * $carry);
             }
 
             if ($k < $stop) {
@@ -2115,8 +2253,8 @@ class Math_BigInteger {
         }
 
         return array(
-            MATH_BIGINTEGER_VALUE => $this->_trim($product_value),
-            MATH_BIGINTEGER_SIGN => $x_negative != $y_negative
+            self::VALUE => $this->_trim($product_value),
+            self::SIGN => $x_negative != $y_negative
         );
     }
 
@@ -2128,112 +2266,117 @@ class Math_BigInteger {
      * improved upon (basically, by using the comba method).  gcd($n, 2) must be equal to one for this function
      * to work correctly.
      *
-     * @see _prepMontgomery()
-     * @see _slidingWindow()
+     * @see self::_prepMontgomery()
+     * @see self::_slidingWindow()
      * @access private
-     * @param Array $x
-     * @param Array $n
-     * @return Array
+     * @param array $x
+     * @param array $n
+     * @return array
      */
     function _montgomery($x, $n)
     {
         static $cache = array(
-            MATH_BIGINTEGER_VARIABLE => array(),
-            MATH_BIGINTEGER_DATA => array()
+            self::VARIABLE => array(),
+            self::DATA => array()
         );
 
-        if ( ($key = array_search($n, $cache[MATH_BIGINTEGER_VARIABLE])) === false ) {
-            $key = count($cache[MATH_BIGINTEGER_VARIABLE]);
-            $cache[MATH_BIGINTEGER_VARIABLE][] = $x;
-            $cache[MATH_BIGINTEGER_DATA][] = $this->_modInverse67108864($n);
+        if (($key = array_search($n, $cache[self::VARIABLE])) === false) {
+            $key = count($cache[self::VARIABLE]);
+            $cache[self::VARIABLE][] = $x;
+            $cache[self::DATA][] = $this->_modInverse67108864($n);
         }
 
         $k = count($n);
 
-        $result = array(MATH_BIGINTEGER_VALUE => $x);
+        $result = array(self::VALUE => $x);
 
         for ($i = 0; $i < $k; ++$i) {
-            $temp = $result[MATH_BIGINTEGER_VALUE][$i] * $cache[MATH_BIGINTEGER_DATA][$key];
-            $temp = (int) ($temp - 0x4000000 * ((int) ($temp / 0x4000000)));
+            $temp = $result[self::VALUE][$i] * $cache[self::DATA][$key];
+            $temp = $temp - self::$baseFull * (self::$base === 26 ? intval($temp / 0x4000000) : ($temp >> 31));
             $temp = $this->_regularMultiply(array($temp), $n);
             $temp = array_merge($this->_array_repeat(0, $i), $temp);
-            $result = $this->_add($result[MATH_BIGINTEGER_VALUE], false, $temp, false);
+            $result = $this->_add($result[self::VALUE], false, $temp, false);
         }
 
-        $result[MATH_BIGINTEGER_VALUE] = array_slice($result[MATH_BIGINTEGER_VALUE], $k);
+        $result[self::VALUE] = array_slice($result[self::VALUE], $k);
 
         if ($this->_compare($result, false, $n, false) >= 0) {
-            $result = $this->_subtract($result[MATH_BIGINTEGER_VALUE], false, $n, false);
+            $result = $this->_subtract($result[self::VALUE], false, $n, false);
         }
 
-        return $result[MATH_BIGINTEGER_VALUE];
+        return $result[self::VALUE];
     }
 
     /**
      * Montgomery Multiply
      *
-     * Interleaves the montgomery reduction and long multiplication algorithms together as described in 
+     * Interleaves the montgomery reduction and long multiplication algorithms together as described in
      * {@link http://www.cacr.math.uwaterloo.ca/hac/about/chap14.pdf#page=13 HAC 14.36}
      *
-     * @see _prepMontgomery()
-     * @see _montgomery()
+     * @see self::_prepMontgomery()
+     * @see self::_montgomery()
      * @access private
-     * @param Array $x
-     * @param Array $y
-     * @param Array $m
-     * @return Array
+     * @param array $x
+     * @param array $y
+     * @param array $m
+     * @return array
      */
     function _montgomeryMultiply($x, $y, $m)
     {
         $temp = $this->_multiply($x, false, $y, false);
-        return $this->_montgomery($temp[MATH_BIGINTEGER_VALUE], $m);
+        return $this->_montgomery($temp[self::VALUE], $m);
+
+        // the following code, although not callable, can be run independently of the above code
+        // although the above code performed better in my benchmarks the following could might
+        // perform better under different circumstances. in lieu of deleting it it's just been
+        // made uncallable
 
         static $cache = array(
-            MATH_BIGINTEGER_VARIABLE => array(),
-            MATH_BIGINTEGER_DATA => array()
+            self::VARIABLE => array(),
+            self::DATA => array()
         );
 
-        if ( ($key = array_search($m, $cache[MATH_BIGINTEGER_VARIABLE])) === false ) {
-            $key = count($cache[MATH_BIGINTEGER_VARIABLE]);
-            $cache[MATH_BIGINTEGER_VARIABLE][] = $m;
-            $cache[MATH_BIGINTEGER_DATA][] = $this->_modInverse67108864($m);
+        if (($key = array_search($m, $cache[self::VARIABLE])) === false) {
+            $key = count($cache[self::VARIABLE]);
+            $cache[self::VARIABLE][] = $m;
+            $cache[self::DATA][] = $this->_modInverse67108864($m);
         }
 
         $n = max(count($x), count($y), count($m));
         $x = array_pad($x, $n, 0);
         $y = array_pad($y, $n, 0);
         $m = array_pad($m, $n, 0);
-        $a = array(MATH_BIGINTEGER_VALUE => $this->_array_repeat(0, $n + 1));
+        $a = array(self::VALUE => $this->_array_repeat(0, $n + 1));
         for ($i = 0; $i < $n; ++$i) {
-            $temp = $a[MATH_BIGINTEGER_VALUE][0] + $x[$i] * $y[0];
-            $temp = (int) ($temp - 0x4000000 * ((int) ($temp / 0x4000000)));
-            $temp = $temp * $cache[MATH_BIGINTEGER_DATA][$key];
-            $temp = (int) ($temp - 0x4000000 * ((int) ($temp / 0x4000000)));
+            $temp = $a[self::VALUE][0] + $x[$i] * $y[0];
+            $temp = $temp - self::$baseFull * (self::$base === 26 ? intval($temp / 0x4000000) : ($temp >> 31));
+            $temp = $temp * $cache[self::DATA][$key];
+            $temp = $temp - self::$baseFull * (self::$base === 26 ? intval($temp / 0x4000000) : ($temp >> 31));
             $temp = $this->_add($this->_regularMultiply(array($x[$i]), $y), false, $this->_regularMultiply(array($temp), $m), false);
-            $a = $this->_add($a[MATH_BIGINTEGER_VALUE], false, $temp[MATH_BIGINTEGER_VALUE], false);
-            $a[MATH_BIGINTEGER_VALUE] = array_slice($a[MATH_BIGINTEGER_VALUE], 1);
+            $a = $this->_add($a[self::VALUE], false, $temp[self::VALUE], false);
+            $a[self::VALUE] = array_slice($a[self::VALUE], 1);
         }
-        if ($this->_compare($a[MATH_BIGINTEGER_VALUE], false, $m, false) >= 0) {
-            $a = $this->_subtract($a[MATH_BIGINTEGER_VALUE], false, $m, false);
+        if ($this->_compare($a[self::VALUE], false, $m, false) >= 0) {
+            $a = $this->_subtract($a[self::VALUE], false, $m, false);
         }
-        return $a[MATH_BIGINTEGER_VALUE];
+        return $a[self::VALUE];
     }
 
     /**
      * Prepare a number for use in Montgomery Modular Reductions
      *
-     * @see _montgomery()
-     * @see _slidingWindow()
+     * @see self::_montgomery()
+     * @see self::_slidingWindow()
      * @access private
-     * @param Array $x
-     * @param Array $n
-     * @return Array
+     * @param array $x
+     * @param array $n
+     * @return array
      */
     function _prepMontgomery($x, $n)
     {
-        $lhs = new Math_BigInteger();
+        $lhs = new static();
         $lhs->value = array_merge($this->_array_repeat(0, count($n)), $x);
-        $rhs = new Math_BigInteger();
+        $rhs = new static();
         $rhs->value = $n;
 
         list(, $temp) = $lhs->divide($rhs);
@@ -2252,7 +2395,7 @@ class Math_BigInteger {
      * {@link http://groups.google.com/group/sci.crypt/msg/7a137205c1be7d85}
      *
      * As for why we do all the bitmasking...  strange things can happen when converting from floats to ints. For
-     * instance, on some computers, var_dump((int) -4294967297) yields int(-1) and on others, it yields 
+     * instance, on some computers, var_dump((int) -4294967297) yields int(-1) and on others, it yields
      * int(-2147483648).  To avoid problems stemming from this, we use bitmasks to guarantee that ints aren't
      * auto-converted to floats.  The outermost bitmask is present because without it, there's no guarantee that
      * the "residue" returned would be the so-called "common residue".  We use fmod, in the last step, because the
@@ -2261,20 +2404,20 @@ class Math_BigInteger {
      *
      * Thanks to Pedro Gimeno Fortea for input!
      *
-     * @see _montgomery()
+     * @see self::_montgomery()
      * @access private
-     * @param Array $x
-     * @return Integer
+     * @param array $x
+     * @return int
      */
-    function _modInverse67108864($x) // 2**26 == 67108864
+    function _modInverse67108864($x) // 2**26 == 67,108,864
     {
         $x = -$x[0];
         $result = $x & 0x3; // x**-1 mod 2**2
         $result = ($result * (2 - $x * $result)) & 0xF; // x**-1 mod 2**4
         $result = ($result * (2 - ($x & 0xFF) * $result))  & 0xFF; // x**-1 mod 2**8
         $result = ($result * ((2 - ($x & 0xFFFF) * $result) & 0xFFFF)) & 0xFFFF; // x**-1 mod 2**16
-        $result = fmod($result * (2 - fmod($x * $result, 0x4000000)), 0x4000000); // x**-1 mod 2**26
-        return $result & 0x3FFFFFF;
+        $result = fmod($result * (2 - fmod($x * $result, self::$baseFull)), self::$baseFull); // x**-1 mod 2**26
+        return $result & self::$maxDigit;
     }
 
     /**
@@ -2285,10 +2428,8 @@ class Math_BigInteger {
      * Here's an example:
      * <code>
      * <?php
-     *    include('Math/BigInteger.php');
-     *
-     *    $a = new Math_BigInteger(30);
-     *    $b = new Math_BigInteger(17);
+     *    $a = new \phpseclib\Math\BigInteger(30);
+     *    $b = new \phpseclib\Math\BigInteger(17);
      *
      *    $c = $a->modInverse($b);
      *    echo $c->toString(); // outputs 4
@@ -2301,34 +2442,34 @@ class Math_BigInteger {
      * ?>
      * </code>
      *
-     * @param Math_BigInteger $n
-     * @return mixed false, if no modular inverse exists, Math_BigInteger, otherwise.
+     * @param \phpseclib\Math\BigInteger $n
+     * @return \phpseclib\Math\BigInteger|false
      * @access public
      * @internal See {@link http://www.cacr.math.uwaterloo.ca/hac/about/chap14.pdf#page=21 HAC 14.64} for more information.
      */
     function modInverse($n)
     {
-        switch ( MATH_BIGINTEGER_MODE ) {
-            case MATH_BIGINTEGER_MODE_GMP:
-                $temp = new Math_BigInteger();
+        switch (MATH_BIGINTEGER_MODE) {
+            case self::MODE_GMP:
+                $temp = new static();
                 $temp->value = gmp_invert($this->value, $n->value);
 
-                return ( $temp->value === false ) ? false : $this->_normalize($temp);
+                return ($temp->value === false) ? false : $this->_normalize($temp);
         }
 
         static $zero, $one;
         if (!isset($zero)) {
-            $zero = new Math_BigInteger();
-            $one = new Math_BigInteger(1);
+            $zero = new static();
+            $one = new static(1);
         }
 
-        // $x mod $n == $x mod -$n.
+        // $x mod -$n == $x mod $n.
         $n = $n->abs();
 
         if ($this->compare($zero) < 0) {
             $temp = $this->abs();
             $temp = $temp->modInverse($n);
-            return $negated === false ? false : $this->_normalize($n->subtract($temp));
+            return $this->_normalize($n->subtract($temp));
         }
 
         extract($this->extendedGCD($n));
@@ -2343,20 +2484,18 @@ class Math_BigInteger {
     }
 
     /**
-     * Calculates the greatest common divisor and B�zout's identity.
+     * Calculates the greatest common divisor and Bezout's identity.
      *
-     * Say you have 693 and 609.  The GCD is 21.  B�zout's identity states that there exist integers x and y such that
+     * Say you have 693 and 609.  The GCD is 21.  Bezout's identity states that there exist integers x and y such that
      * 693*x + 609*y == 21.  In point of fact, there are actually an infinite number of x and y combinations and which
-     * combination is returned is dependant upon which mode is in use.  See
-     * {@link http://en.wikipedia.org/wiki/B%C3%A9zout%27s_identity B�zout's identity - Wikipedia} for more information.
+     * combination is returned is dependent upon which mode is in use.  See
+     * {@link http://en.wikipedia.org/wiki/B%C3%A9zout%27s_identity Bezout's identity - Wikipedia} for more information.
      *
      * Here's an example:
      * <code>
      * <?php
-     *    include('Math/BigInteger.php');
-     *
-     *    $a = new Math_BigInteger(693);
-     *    $b = new Math_BigInteger(609);
+     *    $a = new \phpseclib\Math\BigInteger(693);
+     *    $b = new \phpseclib\Math\BigInteger(609);
      *
      *    extract($a->extendedGCD($b));
      *
@@ -2365,8 +2504,8 @@ class Math_BigInteger {
      * ?>
      * </code>
      *
-     * @param Math_BigInteger $n
-     * @return Math_BigInteger
+     * @param \phpseclib\Math\BigInteger $n
+     * @return \phpseclib\Math\BigInteger
      * @access public
      * @internal Calculates the GCD using the binary xGCD algorithim described in
      *    {@link http://www.cacr.math.uwaterloo.ca/hac/about/chap14.pdf#page=19 HAC 14.61}.  As the text above 14.61 notes,
@@ -2374,16 +2513,16 @@ class Math_BigInteger {
      */
     function extendedGCD($n)
     {
-        switch ( MATH_BIGINTEGER_MODE ) {
-            case MATH_BIGINTEGER_MODE_GMP:
+        switch (MATH_BIGINTEGER_MODE) {
+            case self::MODE_GMP:
                 extract(gmp_gcdext($this->value, $n->value));
 
                 return array(
-                    'gcd' => $this->_normalize(new Math_BigInteger($g)),
-                    'x'   => $this->_normalize(new Math_BigInteger($s)),
-                    'y'   => $this->_normalize(new Math_BigInteger($t))
+                    'gcd' => $this->_normalize(new static($g)),
+                    'x'   => $this->_normalize(new static($s)),
+                    'y'   => $this->_normalize(new static($t))
                 );
-            case MATH_BIGINTEGER_MODE_BCMATH:
+            case self::MODE_BCMATH:
                 // it might be faster to use the binary xGCD algorithim here, as well, but (1) that algorithim works
                 // best when the base is a power of 2 and (2) i don't think it'd make much difference, anyway.  as is,
                 // the basic extended euclidean algorithim is what we're using.
@@ -2413,18 +2552,18 @@ class Math_BigInteger {
                 }
 
                 return array(
-                    'gcd' => $this->_normalize(new Math_BigInteger($u)),
-                    'x'   => $this->_normalize(new Math_BigInteger($a)),
-                    'y'   => $this->_normalize(new Math_BigInteger($b))
+                    'gcd' => $this->_normalize(new static($u)),
+                    'x'   => $this->_normalize(new static($a)),
+                    'y'   => $this->_normalize(new static($b))
                 );
         }
 
         $y = $n->copy();
         $x = $this->copy();
-        $g = new Math_BigInteger();
+        $g = new static();
         $g->value = array(1);
 
-        while ( !(($x->value[0] & 1)|| ($y->value[0] & 1)) ) {
+        while (!(($x->value[0] & 1)|| ($y->value[0] & 1))) {
             $x->_rshift(1);
             $y->_rshift(1);
             $g->_lshift(1);
@@ -2433,18 +2572,18 @@ class Math_BigInteger {
         $u = $x->copy();
         $v = $y->copy();
 
-        $a = new Math_BigInteger();
-        $b = new Math_BigInteger();
-        $c = new Math_BigInteger();
-        $d = new Math_BigInteger();
+        $a = new static();
+        $b = new static();
+        $c = new static();
+        $d = new static();
 
         $a->value = $d->value = $g->value = array(1);
         $b->value = $c->value = array();
 
-        while ( !empty($u->value) ) {
-            while ( !($u->value[0] & 1) ) {
+        while (!empty($u->value)) {
+            while (!($u->value[0] & 1)) {
                 $u->_rshift(1);
-                if ( (!empty($a->value) && ($a->value[0] & 1)) || (!empty($b->value) && ($b->value[0] & 1)) ) {
+                if ((!empty($a->value) && ($a->value[0] & 1)) || (!empty($b->value) && ($b->value[0] & 1))) {
                     $a = $a->add($y);
                     $b = $b->subtract($x);
                 }
@@ -2452,9 +2591,9 @@ class Math_BigInteger {
                 $b->_rshift(1);
             }
 
-            while ( !($v->value[0] & 1) ) {
+            while (!($v->value[0] & 1)) {
                 $v->_rshift(1);
-                if ( (!empty($d->value) && ($d->value[0] & 1)) || (!empty($c->value) && ($c->value[0] & 1)) ) {
+                if ((!empty($d->value) && ($d->value[0] & 1)) || (!empty($c->value) && ($c->value[0] & 1))) {
                     $c = $c->add($y);
                     $d = $d->subtract($x);
                 }
@@ -2488,10 +2627,8 @@ class Math_BigInteger {
      * Here's an example:
      * <code>
      * <?php
-     *    include('Math/BigInteger.php');
-     *
-     *    $a = new Math_BigInteger(693);
-     *    $b = new Math_BigInteger(609);
+     *    $a = new \phpseclib\Math\BigInteger(693);
+     *    $b = new \phpseclib\Math\BigInteger(609);
      *
      *    $gcd = a->extendedGCD($b);
      *
@@ -2499,8 +2636,8 @@ class Math_BigInteger {
      * ?>
      * </code>
      *
-     * @param Math_BigInteger $n
-     * @return Math_BigInteger
+     * @param \phpseclib\Math\BigInteger $n
+     * @return \phpseclib\Math\BigInteger
      * @access public
      */
     function gcd($n)
@@ -2512,18 +2649,18 @@ class Math_BigInteger {
     /**
      * Absolute value.
      *
-     * @return Math_BigInteger
+     * @return \phpseclib\Math\BigInteger
      * @access public
      */
     function abs()
     {
-        $temp = new Math_BigInteger();
+        $temp = new static();
 
-        switch ( MATH_BIGINTEGER_MODE ) {
-            case MATH_BIGINTEGER_MODE_GMP:
+        switch (MATH_BIGINTEGER_MODE) {
+            case self::MODE_GMP:
                 $temp->value = gmp_abs($this->value);
                 break;
-            case MATH_BIGINTEGER_MODE_BCMATH:
+            case self::MODE_BCMATH:
                 $temp->value = (bccomp($this->value, '0', 0) < 0) ? substr($this->value, 1) : $this->value;
                 break;
             default:
@@ -2545,18 +2682,18 @@ class Math_BigInteger {
      *
      * Note how the same comparison operator is used.  If you want to test for equality, use $x->equals($y).
      *
-     * @param Math_BigInteger $x
-     * @return Integer < 0 if $this is less than $x; > 0 if $this is greater than $x, and 0 if they are equal.
+     * @param \phpseclib\Math\BigInteger $y
+     * @return int < 0 if $this is less than $y; > 0 if $this is greater than $y, and 0 if they are equal.
      * @access public
-     * @see equals()
+     * @see self::equals()
      * @internal Could return $this->subtract($x), but that's not as fast as what we do do.
      */
     function compare($y)
     {
-        switch ( MATH_BIGINTEGER_MODE ) {
-            case MATH_BIGINTEGER_MODE_GMP:
+        switch (MATH_BIGINTEGER_MODE) {
+            case self::MODE_GMP:
                 return gmp_cmp($this->value, $y->value);
-            case MATH_BIGINTEGER_MODE_BCMATH:
+            case self::MODE_BCMATH:
                 return bccomp($this->value, $y->value, 0);
         }
 
@@ -2566,24 +2703,24 @@ class Math_BigInteger {
     /**
      * Compares two numbers.
      *
-     * @param Array $x_value
-     * @param Boolean $x_negative
-     * @param Array $y_value
-     * @param Boolean $y_negative
-     * @return Integer
-     * @see compare()
+     * @param array $x_value
+     * @param bool $x_negative
+     * @param array $y_value
+     * @param bool $y_negative
+     * @return int
+     * @see self::compare()
      * @access private
      */
     function _compare($x_value, $x_negative, $y_value, $y_negative)
     {
-        if ( $x_negative != $y_negative ) {
-            return ( !$x_negative && $y_negative ) ? 1 : -1;
+        if ($x_negative != $y_negative) {
+            return (!$x_negative && $y_negative) ? 1 : -1;
         }
 
         $result = $x_negative ? -1 : 1;
 
-        if ( count($x_value) != count($y_value) ) {
-            return ( count($x_value) > count($y_value) ) ? $result : -$result;
+        if (count($x_value) != count($y_value)) {
+            return (count($x_value) > count($y_value)) ? $result : -$result;
         }
         $size = max(count($x_value), count($y_value));
 
@@ -2592,7 +2729,7 @@ class Math_BigInteger {
 
         for ($i = count($x_value) - 1; $i >= 0; --$i) {
             if ($x_value[$i] != $y_value[$i]) {
-                return ( $x_value[$i] > $y_value[$i] ) ? $result : -$result;
+                return ($x_value[$i] > $y_value[$i]) ? $result : -$result;
             }
         }
 
@@ -2602,17 +2739,17 @@ class Math_BigInteger {
     /**
      * Tests the equality of two numbers.
      *
-     * If you need to see if one number is greater than or less than another number, use Math_BigInteger::compare()
+     * If you need to see if one number is greater than or less than another number, use BigInteger::compare()
      *
-     * @param Math_BigInteger $x
-     * @return Boolean
+     * @param \phpseclib\Math\BigInteger $x
+     * @return bool
      * @access public
-     * @see compare()
+     * @see self::compare()
      */
     function equals($x)
     {
-        switch ( MATH_BIGINTEGER_MODE ) {
-            case MATH_BIGINTEGER_MODE_GMP:
+        switch (MATH_BIGINTEGER_MODE) {
+            case self::MODE_GMP:
                 return gmp_cmp($this->value, $x->value) == 0;
             default:
                 return $this->value === $x->value && $this->is_negative == $x->is_negative;
@@ -2625,17 +2762,16 @@ class Math_BigInteger {
      * Some bitwise operations give different results depending on the precision being used.  Examples include left
      * shift, not, and rotates.
      *
-     * @param Math_BigInteger $x
+     * @param int $bits
      * @access public
-     * @return Math_BigInteger
      */
     function setPrecision($bits)
     {
         $this->precision = $bits;
-        if ( MATH_BIGINTEGER_MODE != MATH_BIGINTEGER_MODE_BCMATH ) {
-            $this->bitmask = new Math_BigInteger(chr((1 << ($bits & 0x7)) - 1) . str_repeat(chr(0xFF), $bits >> 3), 256);
+        if (MATH_BIGINTEGER_MODE != self::MODE_BCMATH) {
+            $this->bitmask = new static(chr((1 << ($bits & 0x7)) - 1) . str_repeat(chr(0xFF), $bits >> 3), 256);
         } else {
-            $this->bitmask = new Math_BigInteger(bcpow('2', $bits, 0));
+            $this->bitmask = new static(bcpow('2', $bits, 0));
         }
 
         $temp = $this->_normalize($this);
@@ -2645,20 +2781,20 @@ class Math_BigInteger {
     /**
      * Logical And
      *
-     * @param Math_BigInteger $x
+     * @param \phpseclib\Math\BigInteger $x
      * @access public
      * @internal Implemented per a request by Lluis Pamies i Juarez <lluis _a_ pamies.cat>
-     * @return Math_BigInteger
+     * @return \phpseclib\Math\BigInteger
      */
     function bitwise_and($x)
     {
-        switch ( MATH_BIGINTEGER_MODE ) {
-            case MATH_BIGINTEGER_MODE_GMP:
-                $temp = new Math_BigInteger();
+        switch (MATH_BIGINTEGER_MODE) {
+            case self::MODE_GMP:
+                $temp = new static();
                 $temp->value = gmp_and($this->value, $x->value);
 
                 return $this->_normalize($temp);
-            case MATH_BIGINTEGER_MODE_BCMATH:
+            case self::MODE_BCMATH:
                 $left = $this->toBytes();
                 $right = $x->toBytes();
 
@@ -2667,7 +2803,7 @@ class Math_BigInteger {
                 $left = str_pad($left, $length, chr(0), STR_PAD_LEFT);
                 $right = str_pad($right, $length, chr(0), STR_PAD_LEFT);
 
-                return $this->_normalize(new Math_BigInteger($left & $right, 256));
+                return $this->_normalize(new static($left & $right, 256));
         }
 
         $result = $this->copy();
@@ -2677,7 +2813,7 @@ class Math_BigInteger {
         $result->value = array_slice($result->value, 0, $length);
 
         for ($i = 0; $i < $length; ++$i) {
-            $result->value[$i] = $result->value[$i] & $x->value[$i];
+            $result->value[$i]&= $x->value[$i];
         }
 
         return $this->_normalize($result);
@@ -2686,20 +2822,20 @@ class Math_BigInteger {
     /**
      * Logical Or
      *
-     * @param Math_BigInteger $x
+     * @param \phpseclib\Math\BigInteger $x
      * @access public
      * @internal Implemented per a request by Lluis Pamies i Juarez <lluis _a_ pamies.cat>
-     * @return Math_BigInteger
+     * @return \phpseclib\Math\BigInteger
      */
     function bitwise_or($x)
     {
-        switch ( MATH_BIGINTEGER_MODE ) {
-            case MATH_BIGINTEGER_MODE_GMP:
-                $temp = new Math_BigInteger();
+        switch (MATH_BIGINTEGER_MODE) {
+            case self::MODE_GMP:
+                $temp = new static();
                 $temp->value = gmp_or($this->value, $x->value);
 
                 return $this->_normalize($temp);
-            case MATH_BIGINTEGER_MODE_BCMATH:
+            case self::MODE_BCMATH:
                 $left = $this->toBytes();
                 $right = $x->toBytes();
 
@@ -2708,16 +2844,16 @@ class Math_BigInteger {
                 $left = str_pad($left, $length, chr(0), STR_PAD_LEFT);
                 $right = str_pad($right, $length, chr(0), STR_PAD_LEFT);
 
-                return $this->_normalize(new Math_BigInteger($left | $right, 256));
+                return $this->_normalize(new static($left | $right, 256));
         }
 
         $length = max(count($this->value), count($x->value));
         $result = $this->copy();
-        $result->value = array_pad($result->value, 0, $length);
-        $x->value = array_pad($x->value, 0, $length);
+        $result->value = array_pad($result->value, $length, 0);
+        $x->value = array_pad($x->value, $length, 0);
 
         for ($i = 0; $i < $length; ++$i) {
-            $result->value[$i] = $this->value[$i] | $x->value[$i];
+            $result->value[$i]|= $x->value[$i];
         }
 
         return $this->_normalize($result);
@@ -2726,20 +2862,19 @@ class Math_BigInteger {
     /**
      * Logical Exclusive-Or
      *
-     * @param Math_BigInteger $x
+     * @param \phpseclib\Math\BigInteger $x
      * @access public
      * @internal Implemented per a request by Lluis Pamies i Juarez <lluis _a_ pamies.cat>
-     * @return Math_BigInteger
+     * @return \phpseclib\Math\BigInteger
      */
     function bitwise_xor($x)
     {
-        switch ( MATH_BIGINTEGER_MODE ) {
-            case MATH_BIGINTEGER_MODE_GMP:
-                $temp = new Math_BigInteger();
-                $temp->value = gmp_xor($this->value, $x->value);
-
+        switch (MATH_BIGINTEGER_MODE) {
+            case self::MODE_GMP:
+                $temp = new static();
+                $temp->value = gmp_xor(gmp_abs($this->value), gmp_abs($x->value));
                 return $this->_normalize($temp);
-            case MATH_BIGINTEGER_MODE_BCMATH:
+            case self::MODE_BCMATH:
                 $left = $this->toBytes();
                 $right = $x->toBytes();
 
@@ -2748,16 +2883,17 @@ class Math_BigInteger {
                 $left = str_pad($left, $length, chr(0), STR_PAD_LEFT);
                 $right = str_pad($right, $length, chr(0), STR_PAD_LEFT);
 
-                return $this->_normalize(new Math_BigInteger($left ^ $right, 256));
+                return $this->_normalize(new static($left ^ $right, 256));
         }
 
         $length = max(count($this->value), count($x->value));
         $result = $this->copy();
-        $result->value = array_pad($result->value, 0, $length);
-        $x->value = array_pad($x->value, 0, $length);
+        $result->is_negative = false;
+        $result->value = array_pad($result->value, $length, 0);
+        $x->value = array_pad($x->value, $length, 0);
 
         for ($i = 0; $i < $length; ++$i) {
-            $result->value[$i] = $this->value[$i] ^ $x->value[$i];
+            $result->value[$i]^= $x->value[$i];
         }
 
         return $this->_normalize($result);
@@ -2768,13 +2904,16 @@ class Math_BigInteger {
      *
      * @access public
      * @internal Implemented per a request by Lluis Pamies i Juarez <lluis _a_ pamies.cat>
-     * @return Math_BigInteger
+     * @return \phpseclib\Math\BigInteger
      */
     function bitwise_not()
     {
         // calculuate "not" without regard to $this->precision
         // (will always result in a smaller number.  ie. ~1 isn't 1111 1110 - it's 0)
         $temp = $this->toBytes();
+        if ($temp == '') {
+            return $this->_normalize(new static());
+        }
         $pre_msb = decbin(ord($temp[0]));
         $temp = ~$temp;
         $msb = decbin(ord($temp[0]));
@@ -2787,16 +2926,16 @@ class Math_BigInteger {
         $current_bits = strlen($pre_msb) + 8 * strlen($temp) - 8;
         $new_bits = $this->precision - $current_bits;
         if ($new_bits <= 0) {
-            return $this->_normalize(new Math_BigInteger($temp, 256));
+            return $this->_normalize(new static($temp, 256));
         }
 
         // generate as many leading 1's as we need to.
         $leading_ones = chr((1 << ($new_bits & 0x7)) - 1) . str_repeat(chr(0xFF), $new_bits >> 3);
         $this->_base256_lshift($leading_ones, $current_bits);
 
-        $temp = str_pad($temp, ceil($this->bits / 8), chr(0), STR_PAD_LEFT);
+        $temp = str_pad($temp, strlen($leading_ones), chr(0), STR_PAD_LEFT);
 
-        return $this->_normalize(new Math_BigInteger($leading_ones | $temp, 256));
+        return $this->_normalize(new static($leading_ones | $temp, 256));
     }
 
     /**
@@ -2804,17 +2943,17 @@ class Math_BigInteger {
      *
      * Shifts BigInteger's by $shift bits, effectively dividing by 2**$shift.
      *
-     * @param Integer $shift
-     * @return Math_BigInteger
+     * @param int $shift
+     * @return \phpseclib\Math\BigInteger
      * @access public
      * @internal The only version that yields any speed increases is the internal version.
      */
     function bitwise_rightShift($shift)
     {
-        $temp = new Math_BigInteger();
+        $temp = new static();
 
-        switch ( MATH_BIGINTEGER_MODE ) {
-            case MATH_BIGINTEGER_MODE_GMP:
+        switch (MATH_BIGINTEGER_MODE) {
+            case self::MODE_GMP:
                 static $two;
 
                 if (!isset($two)) {
@@ -2824,7 +2963,7 @@ class Math_BigInteger {
                 $temp->value = gmp_div_q($this->value, gmp_pow($two, $shift));
 
                 break;
-            case MATH_BIGINTEGER_MODE_BCMATH:
+            case self::MODE_BCMATH:
                 $temp->value = bcdiv($this->value, bcpow('2', $shift, 0), 0);
 
                 break;
@@ -2842,17 +2981,17 @@ class Math_BigInteger {
      *
      * Shifts BigInteger's by $shift bits, effectively multiplying by 2**$shift.
      *
-     * @param Integer $shift
-     * @return Math_BigInteger
+     * @param int $shift
+     * @return \phpseclib\Math\BigInteger
      * @access public
      * @internal The only version that yields any speed increases is the internal version.
      */
     function bitwise_leftShift($shift)
     {
-        $temp = new Math_BigInteger();
+        $temp = new static();
 
-        switch ( MATH_BIGINTEGER_MODE ) {
-            case MATH_BIGINTEGER_MODE_GMP:
+        switch (MATH_BIGINTEGER_MODE) {
+            case self::MODE_GMP:
                 static $two;
 
                 if (!isset($two)) {
@@ -2862,7 +3001,7 @@ class Math_BigInteger {
                 $temp->value = gmp_mul($this->value, gmp_pow($two, $shift));
 
                 break;
-            case MATH_BIGINTEGER_MODE_BCMATH:
+            case self::MODE_BCMATH:
                 $temp->value = bcmul($this->value, bcpow('2', $shift, 0), 0);
 
                 break;
@@ -2880,8 +3019,8 @@ class Math_BigInteger {
      *
      * Instead of the top x bits being dropped they're appended to the shifted bit string.
      *
-     * @param Integer $shift
-     * @return Math_BigInteger
+     * @param int $shift
+     * @return \phpseclib\Math\BigInteger
      * @access public
      */
     function bitwise_leftRotate($shift)
@@ -2890,15 +3029,16 @@ class Math_BigInteger {
 
         if ($this->precision > 0) {
             $precision = $this->precision;
-            if ( MATH_BIGINTEGER_MODE == MATH_BIGINTEGER_MODE_BCMATH ) {
-                $mask = $this->bitmask->subtract(new Math_BigInteger(1));
+            if (MATH_BIGINTEGER_MODE == self::MODE_BCMATH) {
+                $mask = $this->bitmask->subtract(new static(1));
                 $mask = $mask->toBytes();
             } else {
                 $mask = $this->bitmask->toBytes();
             }
         } else {
             $temp = ord($bits[0]);
-            for ($i = 0; $temp >> $i; ++$i);
+            for ($i = 0; $temp >> $i; ++$i) {
+            }
             $precision = 8 * strlen($bits) - 8 + $i;
             $mask = chr((1 << ($precision & 0x7)) - 1) . str_repeat(chr(0xFF), $precision >> 3);
         }
@@ -2913,9 +3053,9 @@ class Math_BigInteger {
         }
 
         $left = $this->bitwise_leftShift($shift);
-        $left = $left->bitwise_and(new Math_BigInteger($mask, 256));
+        $left = $left->bitwise_and(new static($mask, 256));
         $right = $this->bitwise_rightShift($precision - $shift);
-        $result = MATH_BIGINTEGER_MODE != MATH_BIGINTEGER_MODE_BCMATH ? $left->bitwise_or($right) : $left->add($right);
+        $result = MATH_BIGINTEGER_MODE != self::MODE_BCMATH ? $left->bitwise_or($right) : $left->add($right);
         return $this->_normalize($result);
     }
 
@@ -2924,8 +3064,8 @@ class Math_BigInteger {
      *
      * Instead of the bottom x bits being dropped they're prepended to the shifted bit string.
      *
-     * @param Integer $shift
-     * @return Math_BigInteger
+     * @param int $shift
+     * @return \phpseclib\Math\BigInteger
      * @access public
      */
     function bitwise_rightRotate($shift)
@@ -2934,79 +3074,115 @@ class Math_BigInteger {
     }
 
     /**
-     * Set random number generator function
-     *
-     * $generator should be the name of a random generating function whose first parameter is the minimum
-     * value and whose second parameter is the maximum value.  If this function needs to be seeded, it should
-     * be seeded prior to calling Math_BigInteger::random() or Math_BigInteger::randomPrime()
+     * Generates a random BigInteger
      *
-     * If the random generating function is not explicitly set, it'll be assumed to be mt_rand().
+     * Byte length is equal to $length. Uses \phpseclib\Crypt\Random if it's loaded and mt_rand if it's not.
      *
-     * @see random()
-     * @see randomPrime()
-     * @param optional String $generator
-     * @access public
+     * @param int $length
+     * @return \phpseclib\Math\BigInteger
+     * @access private
      */
-    function setRandomGenerator($generator)
+    function _random_number_helper($size)
     {
-        $this->generator = $generator;
+        if (class_exists('\phpseclib\Crypt\Random')) {
+            $random = Random::string($size);
+        } else {
+            $random = '';
+
+            if ($size & 1) {
+                $random.= chr(mt_rand(0, 255));
+            }
+
+            $blocks = $size >> 1;
+            for ($i = 0; $i < $blocks; ++$i) {
+                // mt_rand(-2147483648, 0x7FFFFFFF) always produces -2147483648 on some systems
+                $random.= pack('n', mt_rand(0, 0xFFFF));
+            }
+        }
+
+        return new static($random, 256);
     }
 
     /**
      * Generate a random number
      *
-     * @param optional Integer $min
-     * @param optional Integer $max
-     * @return Math_BigInteger
+     * Returns a random number between $min and $max where $min and $max
+     * can be defined using one of the two methods:
+     *
+     * $min->random($max)
+     * $max->random($min)
+     *
+     * @param \phpseclib\Math\BigInteger $arg1
+     * @param \phpseclib\Math\BigInteger $arg2
+     * @return \phpseclib\Math\BigInteger
      * @access public
+     * @internal The API for creating random numbers used to be $a->random($min, $max), where $a was a BigInteger object.
+     *           That method is still supported for BC purposes.
      */
-    function random($min = false, $max = false)
+    function random($arg1, $arg2 = false)
     {
-        if ($min === false) {
-            $min = new Math_BigInteger(0);
+        if ($arg1 === false) {
+            return false;
         }
 
-        if ($max === false) {
-            $max = new Math_BigInteger(0x7FFFFFFF);
+        if ($arg2 === false) {
+            $max = $arg1;
+            $min = $this;
+        } else {
+            $min = $arg1;
+            $max = $arg2;
         }
 
         $compare = $max->compare($min);
 
         if (!$compare) {
             return $this->_normalize($min);
-        } else if ($compare < 0) {
+        } elseif ($compare < 0) {
             // if $min is bigger then $max, swap $min and $max
             $temp = $max;
             $max = $min;
             $min = $temp;
         }
 
-        $generator = $this->generator;
+        static $one;
+        if (!isset($one)) {
+            $one = new static(1);
+        }
 
-        $max = $max->subtract($min);
-        $max = ltrim($max->toBytes(), chr(0));
-        $size = strlen($max) - 1;
-        $random = '';
+        $max = $max->subtract($min->subtract($one));
+        $size = strlen(ltrim($max->toBytes(), chr(0)));
 
-        $bytes = $size & 1;
-        for ($i = 0; $i < $bytes; ++$i) {
-            $random.= chr($generator(0, 255));
-        }
+        /*
+            doing $random % $max doesn't work because some numbers will be more likely to occur than others.
+            eg. if $max is 140 and $random's max is 255 then that'd mean both $random = 5 and $random = 145
+            would produce 5 whereas the only value of random that could produce 139 would be 139. ie.
+            not all numbers would be equally likely. some would be more likely than others.
 
-        $blocks = $size >> 1;
-        for ($i = 0; $i < $blocks; ++$i) {
-            // mt_rand(-2147483648, 0x7FFFFFFF) always produces -2147483648 on some systems
-            $random.= pack('n', $generator(0, 0xFFFF));
-        }
+            creating a whole new random number until you find one that is within the range doesn't work
+            because, for sufficiently small ranges, the likelihood that you'd get a number within that range
+            would be pretty small. eg. with $random's max being 255 and if your $max being 1 the probability
+            would be pretty high that $random would be greater than $max.
 
-        $temp = new Math_BigInteger($random, 256);
-        if ($temp->compare(new Math_BigInteger(substr($max, 1), 256)) > 0) {
-            $random = chr($generator(0, ord($max[0]) - 1)) . $random;
-        } else {
-            $random = chr($generator(0, ord($max[0])    )) . $random;
-        }
+            phpseclib works around this using the technique described here:
+
+            http://crypto.stackexchange.com/questions/5708/creating-a-small-number-from-a-cryptographically-secure-random-string
+        */
+        $random_max = new static(chr(1) . str_repeat("\0", $size), 256);
+        $random = $this->_random_number_helper($size);
+
+        list($max_multiple) = $random_max->divide($max);
+        $max_multiple = $max_multiple->multiply($max);
 
-        $random = new Math_BigInteger($random, 256);
+        while ($random->compare($max_multiple) >= 0) {
+            $random = $random->subtract($max_multiple);
+            $random_max = $random_max->subtract($max_multiple);
+            $random = $random->bitwise_leftShift(8);
+            $random = $random->add($this->_random_number_helper(1));
+            $random_max = $random_max->bitwise_leftShift(8);
+            list($max_multiple) = $random_max->divide($max);
+            $max_multiple = $max_multiple->multiply($max);
+        }
+        list(, $random) = $random->divide($max);
 
         return $this->_normalize($random->add($min));
     }
@@ -3014,68 +3190,67 @@ class Math_BigInteger {
     /**
      * Generate a random prime number.
      *
-     * If there's not a prime within the given range, false will be returned.  If more than $timeout seconds have elapsed,
-     * give up and return false.
+     * If there's not a prime within the given range, false will be returned.
+     * If more than $timeout seconds have elapsed, give up and return false.
      *
-     * @param optional Integer $min
-     * @param optional Integer $max
-     * @param optional Integer $timeout
-     * @return Math_BigInteger
+     * @param \phpseclib\Math\BigInteger $arg1
+     * @param \phpseclib\Math\BigInteger $arg2
+     * @param int $timeout
+     * @return Math_BigInteger|false
      * @access public
      * @internal See {@link http://www.cacr.math.uwaterloo.ca/hac/about/chap4.pdf#page=15 HAC 4.44}.
      */
-    function randomPrime($min = false, $max = false, $timeout = false)
+    function randomPrime($arg1, $arg2 = false, $timeout = false)
     {
+        if ($arg1 === false) {
+            return false;
+        }
+
+        if ($arg2 === false) {
+            $max = $arg1;
+            $min = $this;
+        } else {
+            $min = $arg1;
+            $max = $arg2;
+        }
+
         $compare = $max->compare($min);
 
         if (!$compare) {
-            return $min;
-        } else if ($compare < 0) {
+            return $min->isPrime() ? $min : false;
+        } elseif ($compare < 0) {
             // if $min is bigger then $max, swap $min and $max
             $temp = $max;
             $max = $min;
             $min = $temp;
         }
 
-        // gmp_nextprime() requires PHP 5 >= 5.2.0 per <http://php.net/gmp-nextprime>.
-        if ( MATH_BIGINTEGER_MODE == MATH_BIGINTEGER_MODE_GMP && function_exists('gmp_nextprime') ) {
-            // we don't rely on Math_BigInteger::random()'s min / max when gmp_nextprime() is being used since this function
-            // does its own checks on $max / $min when gmp_nextprime() is used.  When gmp_nextprime() is not used, however,
-            // the same $max / $min checks are not performed.
-            if ($min === false) {
-                $min = new Math_BigInteger(0);
-            }
+        static $one, $two;
+        if (!isset($one)) {
+            $one = new static(1);
+            $two = new static(2);
+        }
 
-            if ($max === false) {
-                $max = new Math_BigInteger(0x7FFFFFFF);
-            }
+        $start = time();
 
-            $x = $this->random($min, $max);
+        $x = $this->random($min, $max);
 
-            $x->value = gmp_nextprime($x->value);
+        // gmp_nextprime() requires PHP 5 >= 5.2.0 per <http://php.net/gmp-nextprime>.
+        if (MATH_BIGINTEGER_MODE == self::MODE_GMP && extension_loaded('gmp')) {
+            $p = new static();
+            $p->value = gmp_nextprime($x->value);
 
-            if ($x->compare($max) <= 0) {
-                return $x;
+            if ($p->compare($max) <= 0) {
+                return $p;
             }
 
-            $x->value = gmp_nextprime($min->value);
-
-            if ($x->compare($max) <= 0) {
-                return $x;
+            if (!$min->equals($x)) {
+                $x = $x->subtract($one);
             }
 
-            return false;
+            return $x->randomPrime($min, $x);
         }
 
-        static $one, $two;
-        if (!isset($one)) {
-            $one = new Math_BigInteger(1);
-            $two = new Math_BigInteger(2);
-        }
-
-        $start = time();
-
-        $x = $this->random($min, $max);
         if ($x->equals($two)) {
             return $x;
         }
@@ -3122,16 +3297,16 @@ class Math_BigInteger {
      *
      * If the current number is odd it'll be unchanged.  If it's even, one will be added to it.
      *
-     * @see randomPrime()
+     * @see self::randomPrime()
      * @access private
      */
     function _make_odd()
     {
-        switch ( MATH_BIGINTEGER_MODE ) {
-            case MATH_BIGINTEGER_MODE_GMP:
+        switch (MATH_BIGINTEGER_MODE) {
+            case self::MODE_GMP:
                 gmp_setbit($this->value, 0);
                 break;
-            case MATH_BIGINTEGER_MODE_BCMATH:
+            case self::MODE_BCMATH:
                 if ($this->value[strlen($this->value) - 1] % 2 == 0) {
                     $this->value = bcadd($this->value, '1');
                 }
@@ -3145,14 +3320,14 @@ class Math_BigInteger {
      * Checks a numer to see if it's prime
      *
      * Assuming the $t parameter is not set, this function has an error rate of 2**-80.  The main motivation for the
-     * $t parameter is distributability.  Math_BigInteger::randomPrime() can be distributed accross multiple pageloads
+     * $t parameter is distributability.  BigInteger::randomPrime() can be distributed across multiple pageloads
      * on a website instead of just one.
      *
-     * @param optional Integer $t
-     * @return Boolean
+     * @param \phpseclib\Math\BigInteger $t
+     * @return bool
      * @access public
      * @internal Uses the
-     *     {@link http://en.wikipedia.org/wiki/Miller%E2%80%93Rabin_primality_test Miller-Rabin primality test}.  See 
+     *     {@link http://en.wikipedia.org/wiki/Miller%E2%80%93Rabin_primality_test Miller-Rabin primality test}.  See
      *     {@link http://www.cacr.math.uwaterloo.ca/hac/about/chap4.pdf#page=8 HAC 4.24}.
      */
     function isPrime($t = false)
@@ -3161,6 +3336,7 @@ class Math_BigInteger {
 
         if (!$t) {
             // see HAC 4.49 "Note (controlling the error probability)"
+            // @codingStandardsIgnoreStart
                  if ($length >= 163) { $t =  2; } // floor(1300 / 8)
             else if ($length >= 106) { $t =  3; } // floor( 850 / 8)
             else if ($length >= 81 ) { $t =  4; } // floor( 650 / 8)
@@ -3173,14 +3349,15 @@ class Math_BigInteger {
             else if ($length >= 25 ) { $t = 15; } // floor( 200 / 8)
             else if ($length >= 18 ) { $t = 18; } // floor( 150 / 8)
             else                     { $t = 27; }
+            // @codingStandardsIgnoreEnd
         }
 
         // ie. gmp_testbit($this, 0)
         // ie. isEven() or !isOdd()
-        switch ( MATH_BIGINTEGER_MODE ) {
-            case MATH_BIGINTEGER_MODE_GMP:
+        switch (MATH_BIGINTEGER_MODE) {
+            case self::MODE_GMP:
                 return gmp_prob_prime($this->value, $t) != 0;
-            case MATH_BIGINTEGER_MODE_BCMATH:
+            case self::MODE_BCMATH:
                 if ($this->value === '2') {
                     return true;
                 }
@@ -3201,28 +3378,28 @@ class Math_BigInteger {
 
         if (!isset($primes)) {
             $primes = array(
-                3,    5,    7,    11,   13,   17,   19,   23,   29,   31,   37,   41,   43,   47,   53,   59,   
-                61,   67,   71,   73,   79,   83,   89,   97,   101,  103,  107,  109,  113,  127,  131,  137,  
-                139,  149,  151,  157,  163,  167,  173,  179,  181,  191,  193,  197,  199,  211,  223,  227,  
-                229,  233,  239,  241,  251,  257,  263,  269,  271,  277,  281,  283,  293,  307,  311,  313,  
-                317,  331,  337,  347,  349,  353,  359,  367,  373,  379,  383,  389,  397,  401,  409,  419,  
-                421,  431,  433,  439,  443,  449,  457,  461,  463,  467,  479,  487,  491,  499,  503,  509,  
-                521,  523,  541,  547,  557,  563,  569,  571,  577,  587,  593,  599,  601,  607,  613,  617,  
-                619,  631,  641,  643,  647,  653,  659,  661,  673,  677,  683,  691,  701,  709,  719,  727,  
-                733,  739,  743,  751,  757,  761,  769,  773,  787,  797,  809,  811,  821,  823,  827,  829,  
-                839,  853,  857,  859,  863,  877,  881,  883,  887,  907,  911,  919,  929,  937,  941,  947,  
+                3,    5,    7,    11,   13,   17,   19,   23,   29,   31,   37,   41,   43,   47,   53,   59,
+                61,   67,   71,   73,   79,   83,   89,   97,   101,  103,  107,  109,  113,  127,  131,  137,
+                139,  149,  151,  157,  163,  167,  173,  179,  181,  191,  193,  197,  199,  211,  223,  227,
+                229,  233,  239,  241,  251,  257,  263,  269,  271,  277,  281,  283,  293,  307,  311,  313,
+                317,  331,  337,  347,  349,  353,  359,  367,  373,  379,  383,  389,  397,  401,  409,  419,
+                421,  431,  433,  439,  443,  449,  457,  461,  463,  467,  479,  487,  491,  499,  503,  509,
+                521,  523,  541,  547,  557,  563,  569,  571,  577,  587,  593,  599,  601,  607,  613,  617,
+                619,  631,  641,  643,  647,  653,  659,  661,  673,  677,  683,  691,  701,  709,  719,  727,
+                733,  739,  743,  751,  757,  761,  769,  773,  787,  797,  809,  811,  821,  823,  827,  829,
+                839,  853,  857,  859,  863,  877,  881,  883,  887,  907,  911,  919,  929,  937,  941,  947,
                 953,  967,  971,  977,  983,  991,  997
             );
 
-            if ( MATH_BIGINTEGER_MODE != MATH_BIGINTEGER_MODE_INTERNAL ) {
+            if (MATH_BIGINTEGER_MODE != self::MODE_INTERNAL) {
                 for ($i = 0; $i < count($primes); ++$i) {
-                    $primes[$i] = new Math_BigInteger($primes[$i]);
+                    $primes[$i] = new static($primes[$i]);
                 }
             }
 
-            $zero = new Math_BigInteger();
-            $one = new Math_BigInteger(1);
-            $two = new Math_BigInteger(2);
+            $zero = new static();
+            $one = new static(1);
+            $two = new static(2);
         }
 
         if ($this->equals($one)) {
@@ -3230,7 +3407,7 @@ class Math_BigInteger {
         }
 
         // see HAC 4.4.1 "Random search for probable primes"
-        if ( MATH_BIGINTEGER_MODE != MATH_BIGINTEGER_MODE_INTERNAL ) {
+        if (MATH_BIGINTEGER_MODE != self::MODE_INTERNAL) {
             foreach ($primes as $prime) {
                 list(, $r) = $this->divide($prime);
                 if ($r->equals($zero)) {
@@ -3254,7 +3431,7 @@ class Math_BigInteger {
         $r = $n_1->copy();
         $r_value = $r->value;
         // ie. $s = gmp_scan1($n, 0) and $r = gmp_div_q($n, gmp_pow(gmp_init('2'), $s));
-        if ( MATH_BIGINTEGER_MODE == MATH_BIGINTEGER_MODE_BCMATH ) {
+        if (MATH_BIGINTEGER_MODE == self::MODE_BCMATH) {
             $s = 0;
             // if $n was 1, $r would be 0 and this would be an infinite loop, hence our $this->equals($one) check earlier
             while ($r->value[strlen($r->value) - 1] % 2 == 0) {
@@ -3264,12 +3441,13 @@ class Math_BigInteger {
         } else {
             for ($i = 0, $r_length = count($r_value); $i < $r_length; ++$i) {
                 $temp = ~$r_value[$i] & 0xFFFFFF;
-                for ($j = 1; ($temp >> $j) & 1; ++$j);
+                for ($j = 1; ($temp >> $j) & 1; ++$j) {
+                }
                 if ($j != 25) {
                     break;
                 }
             }
-            $s = 26 * $i + $j - 1;
+            $s = 26 * $i + $j;
             $r->_rshift($s);
         }
 
@@ -3298,29 +3476,29 @@ class Math_BigInteger {
      *
      * Shifts BigInteger's by $shift bits.
      *
-     * @param Integer $shift
+     * @param int $shift
      * @access private
      */
     function _lshift($shift)
     {
-        if ( $shift == 0 ) {
+        if ($shift == 0) {
             return;
         }
 
-        $num_digits = (int) ($shift / 26);
-        $shift %= 26;
+        $num_digits = (int) ($shift / self::$base);
+        $shift %= self::$base;
         $shift = 1 << $shift;
 
         $carry = 0;
 
         for ($i = 0; $i < count($this->value); ++$i) {
             $temp = $this->value[$i] * $shift + $carry;
-            $carry = (int) ($temp / 0x4000000);
-            $this->value[$i] = (int) ($temp - $carry * 0x4000000);
+            $carry = self::$base === 26 ? intval($temp / 0x4000000) : ($temp >> 31);
+            $this->value[$i] = (int) ($temp - $carry * self::$baseFull);
         }
 
-        if ( $carry ) {
-            $this->value[] = $carry;
+        if ($carry) {
+            $this->value[count($this->value)] = $carry;
         }
 
         while ($num_digits--) {
@@ -3333,7 +3511,7 @@ class Math_BigInteger {
      *
      * Shifts BigInteger's by $shift bits.
      *
-     * @param Integer $shift
+     * @param int $shift
      * @access private
      */
     function _rshift($shift)
@@ -3342,12 +3520,12 @@ class Math_BigInteger {
             return;
         }
 
-        $num_digits = (int) ($shift / 26);
-        $shift %= 26;
-        $carry_shift = 26 - $shift;
+        $num_digits = (int) ($shift / self::$base);
+        $shift %= self::$base;
+        $carry_shift = self::$base - $shift;
         $carry_mask = (1 << $shift) - 1;
 
-        if ( $num_digits ) {
+        if ($num_digits) {
             $this->value = array_slice($this->value, $num_digits);
         }
 
@@ -3367,9 +3545,9 @@ class Math_BigInteger {
      *
      * Removes leading zeros and truncates (if necessary) to maintain the appropriate precision
      *
-     * @param Math_BigInteger
-     * @return Math_BigInteger
-     * @see _trim()
+     * @param \phpseclib\Math\BigInteger
+     * @return \phpseclib\Math\BigInteger
+     * @see self::_trim()
      * @access private
      */
     function _normalize($result)
@@ -3377,14 +3555,14 @@ class Math_BigInteger {
         $result->precision = $this->precision;
         $result->bitmask = $this->bitmask;
 
-        switch ( MATH_BIGINTEGER_MODE ) {
-            case MATH_BIGINTEGER_MODE_GMP:
-                if (!empty($result->bitmask->value)) {
+        switch (MATH_BIGINTEGER_MODE) {
+            case self::MODE_GMP:
+                if ($this->bitmask !== false) {
                     $result->value = gmp_and($result->value, $result->bitmask->value);
                 }
 
                 return $result;
-            case MATH_BIGINTEGER_MODE_BCMATH:
+            case self::MODE_BCMATH:
                 if (!empty($result->bitmask->value)) {
                     $result->value = bcmod($result->value, $result->bitmask->value);
                 }
@@ -3394,7 +3572,7 @@ class Math_BigInteger {
 
         $value = &$result->value;
 
-        if ( !count($value) ) {
+        if (!count($value)) {
             return $result;
         }
 
@@ -3417,13 +3595,14 @@ class Math_BigInteger {
      *
      * Removes leading zeros
      *
-     * @return Math_BigInteger
+     * @param array $value
+     * @return \phpseclib\Math\BigInteger
      * @access private
      */
     function _trim($value)
     {
         for ($i = count($value) - 1; $i >= 0; --$i) {
-            if ( $value[$i] ) {
+            if ($value[$i]) {
                 break;
             }
             unset($value[$i]);
@@ -3437,7 +3616,7 @@ class Math_BigInteger {
      *
      * @param $input Array
      * @param $multiplier mixed
-     * @return Array
+     * @return array
      * @access private
      */
     function _array_repeat($input, $multiplier)
@@ -3452,7 +3631,7 @@ class Math_BigInteger {
      *
      * @param $x String
      * @param $shift Integer
-     * @return String
+     * @return string
      * @access private
      */
     function _base256_lshift(&$x, $shift)
@@ -3481,7 +3660,7 @@ class Math_BigInteger {
      *
      * @param $x String
      * @param $shift Integer
-     * @return String
+     * @return string
      * @access private
      */
     function _base256_rshift(&$x, $shift)
@@ -3521,8 +3700,8 @@ class Math_BigInteger {
     /**
      * Converts 32-bit integers to bytes.
      *
-     * @param Integer $x
-     * @return String
+     * @param int $x
+     * @return string
      * @access private
      */
     function _int2bytes($x)
@@ -3533,8 +3712,8 @@ class Math_BigInteger {
     /**
      * Converts bytes to 32-bit integers
      *
-     * @param String $x
-     * @return Integer
+     * @param string $x
+     * @return int
      * @access private
      */
     function _bytes2int($x)
@@ -3542,4 +3721,47 @@ class Math_BigInteger {
         $temp = unpack('Nint', str_pad($x, 4, chr(0), STR_PAD_LEFT));
         return $temp['int'];
     }
+
+    /**
+     * DER-encode an integer
+     *
+     * The ability to DER-encode integers is needed to create RSA public keys for use with OpenSSL
+     *
+     * @see self::modPow()
+     * @access private
+     * @param int $length
+     * @return string
+     */
+    function _encodeASN1Length($length)
+    {
+        if ($length <= 0x7F) {
+            return chr($length);
+        }
+
+        $temp = ltrim(pack('N', $length), chr(0));
+        return pack('Ca*', 0x80 | strlen($temp), $temp);
+    }
+
+    /**
+     * Single digit division
+     *
+     * Even if int64 is being used the division operator will return a float64 value
+     * if the dividend is not evenly divisible by the divisor. Since a float64 doesn't
+     * have the precision of int64 this is a problem so, when int64 is being used,
+     * we'll guarantee that the dividend is divisible by first subtracting the remainder.
+     *
+     * @access private
+     * @param int $x
+     * @param int $y
+     * @return int
+     */
+    function _safe_divide($x, $y)
+    {
+        if (self::$base === 26) {
+            return (int) ($x / $y);
+        }
+
+        // self::$base === 31
+        return ($x - ($x % $y)) / $y;
+    }
 }
diff --git a/lib/phpseclib/Net/SCP.php b/lib/phpseclib/Net/SCP.php
new file mode 100644
index 0000000..f95bce6
--- /dev/null
+++ b/lib/phpseclib/Net/SCP.php
@@ -0,0 +1,337 @@
+<?php
+
+/**
+ * Pure-PHP implementation of SCP.
+ *
+ * PHP version 5
+ *
+ * The API for this library is modeled after the API from PHP's {@link http://php.net/book.ftp FTP extension}.
+ *
+ * Here's a short example of how to use this library:
+ * <code>
+ * <?php
+ *    include 'vendor/autoload.php';
+ *
+ *    $ssh = new \phpseclib\Net\SSH2('www.domain.tld');
+ *    if (!$ssh->login('username', 'password')) {
+ *        exit('bad login');
+ *    }
+ *    $scp = new \phpseclib\Net\SCP($ssh);
+ *
+ *    $scp->put('abcd', str_repeat('x', 1024*1024));
+ * ?>
+ * </code>
+ *
+ * @category  Net
+ * @package   SCP
+ * @author    Jim Wigginton <terrafrost@php.net>
+ * @copyright 2010 Jim Wigginton
+ * @license   http://www.opensource.org/licenses/mit-license.html  MIT License
+ * @link      http://phpseclib.sourceforge.net
+ */
+
+namespace phpseclib\Net;
+
+/**
+ * Pure-PHP implementations of SCP.
+ *
+ * @package SCP
+ * @author  Jim Wigginton <terrafrost@php.net>
+ * @access  public
+ */
+class SCP
+{
+    /**#@+
+     * @access public
+     * @see \phpseclib\Net\SCP::put()
+     */
+    /**
+     * Reads data from a local file.
+     */
+    const SOURCE_LOCAL_FILE = 1;
+    /**
+     * Reads data from a string.
+     */
+    const SOURCE_STRING = 2;
+    /**#@-*/
+
+    /**#@+
+     * @access private
+     * @see \phpseclib\Net\SCP::_send()
+     * @see \phpseclib\Net\SCP::_receive()
+    */
+    /**
+     * SSH1 is being used.
+     */
+    const MODE_SSH1 = 1;
+    /**
+     * SSH2 is being used.
+     */
+    const MODE_SSH2 =  2;
+    /**#@-*/
+
+    /**
+     * SSH Object
+     *
+     * @var object
+     * @access private
+     */
+    var $ssh;
+
+    /**
+     * Packet Size
+     *
+     * @var int
+     * @access private
+     */
+    var $packet_size;
+
+    /**
+     * Mode
+     *
+     * @var int
+     * @access private
+     */
+    var $mode;
+
+    /**
+     * Default Constructor.
+     *
+     * Connects to an SSH server
+     *
+     * @param \phpseclib\Net\SSH1|\phpseclib\Net\SSH2 $ssh
+     * @return \phpseclib\Net\SCP
+     * @access public
+     */
+    function __construct($ssh)
+    {
+        if ($ssh instanceof SSH2) {
+            $this->mode = self::MODE_SSH2;
+        } elseif ($ssh instanceof SSH1) {
+            $this->packet_size = 50000;
+            $this->mode = self::MODE_SSH1;
+        } else {
+            return;
+        }
+
+        $this->ssh = $ssh;
+    }
+
+    /**
+     * Uploads a file to the SCP server.
+     *
+     * By default, \phpseclib\Net\SCP::put() does not read from the local filesystem.  $data is dumped directly into $remote_file.
+     * So, for example, if you set $data to 'filename.ext' and then do \phpseclib\Net\SCP::get(), you will get a file, twelve bytes
+     * long, containing 'filename.ext' as its contents.
+     *
+     * Setting $mode to self::SOURCE_LOCAL_FILE will change the above behavior.  With self::SOURCE_LOCAL_FILE, $remote_file will
+     * contain as many bytes as filename.ext does on your local filesystem.  If your filename.ext is 1MB then that is how
+     * large $remote_file will be, as well.
+     *
+     * Currently, only binary mode is supported.  As such, if the line endings need to be adjusted, you will need to take
+     * care of that, yourself.
+     *
+     * @param string $remote_file
+     * @param string $data
+     * @param int $mode
+     * @param callable $callback
+     * @return bool
+     * @access public
+     */
+    function put($remote_file, $data, $mode = self::SOURCE_STRING, $callback = null)
+    {
+        if (!isset($this->ssh)) {
+            return false;
+        }
+
+        if (!$this->ssh->exec('scp -t ' . escapeshellarg($remote_file), false)) { // -t = to
+            return false;
+        }
+
+        $temp = $this->_receive();
+        if ($temp !== chr(0)) {
+            return false;
+        }
+
+        if ($this->mode == self::MODE_SSH2) {
+            $this->packet_size = $this->ssh->packet_size_client_to_server[SSH2::CHANNEL_EXEC] - 4;
+        }
+
+        $remote_file = basename($remote_file);
+
+        if ($mode == self::SOURCE_STRING) {
+            $size = strlen($data);
+        } else {
+            if (!is_file($data)) {
+                user_error("$data is not a valid file", E_USER_NOTICE);
+                return false;
+            }
+
+            $fp = @fopen($data, 'rb');
+            if (!$fp) {
+                return false;
+            }
+            $size = filesize($data);
+        }
+
+        $this->_send('C0644 ' . $size . ' ' . $remote_file . "\n");
+
+        $temp = $this->_receive();
+        if ($temp !== chr(0)) {
+            return false;
+        }
+
+        $sent = 0;
+        while ($sent < $size) {
+            $temp = $mode & self::SOURCE_STRING ? substr($data, $sent, $this->packet_size) : fread($fp, $this->packet_size);
+            $this->_send($temp);
+            $sent+= strlen($temp);
+
+            if (is_callable($callback)) {
+                call_user_func($callback, $sent);
+            }
+        }
+        $this->_close();
+
+        if ($mode != self::SOURCE_STRING) {
+            fclose($fp);
+        }
+
+        return true;
+    }
+
+    /**
+     * Downloads a file from the SCP server.
+     *
+     * Returns a string containing the contents of $remote_file if $local_file is left undefined or a boolean false if
+     * the operation was unsuccessful.  If $local_file is defined, returns true or false depending on the success of the
+     * operation
+     *
+     * @param string $remote_file
+     * @param string $local_file
+     * @return mixed
+     * @access public
+     */
+    function get($remote_file, $local_file = false)
+    {
+        if (!isset($this->ssh)) {
+            return false;
+        }
+
+        if (!$this->ssh->exec('scp -f ' . escapeshellarg($remote_file), false)) { // -f = from
+            return false;
+        }
+
+        $this->_send("\0");
+
+        if (!preg_match('#(?<perms>[^ ]+) (?<size>\d+) (?<name>.+)#', rtrim($this->_receive()), $info)) {
+            return false;
+        }
+
+        $this->_send("\0");
+
+        $size = 0;
+
+        if ($local_file !== false) {
+            $fp = @fopen($local_file, 'wb');
+            if (!$fp) {
+                return false;
+            }
+        }
+
+        $content = '';
+        while ($size < $info['size']) {
+            $data = $this->_receive();
+            // SCP usually seems to split stuff out into 16k chunks
+            $size+= strlen($data);
+
+            if ($local_file === false) {
+                $content.= $data;
+            } else {
+                fputs($fp, $data);
+            }
+        }
+
+        $this->_close();
+
+        if ($local_file !== false) {
+            fclose($fp);
+            return true;
+        }
+
+        return $content;
+    }
+
+    /**
+     * Sends a packet to an SSH server
+     *
+     * @param string $data
+     * @access private
+     */
+    function _send($data)
+    {
+        switch ($this->mode) {
+            case self::MODE_SSH2:
+                $this->ssh->_send_channel_packet(SSH2::CHANNEL_EXEC, $data);
+                break;
+            case self::MODE_SSH1:
+                $data = pack('CNa*', NET_SSH1_CMSG_STDIN_DATA, strlen($data), $data);
+                $this->ssh->_send_binary_packet($data);
+        }
+    }
+
+    /**
+     * Receives a packet from an SSH server
+     *
+     * @return string
+     * @access private
+     */
+    function _receive()
+    {
+        switch ($this->mode) {
+            case self::MODE_SSH2:
+                return $this->ssh->_get_channel_packet(SSH2::CHANNEL_EXEC, true);
+            case self::MODE_SSH1:
+                if (!$this->ssh->bitmap) {
+                    return false;
+                }
+                while (true) {
+                    $response = $this->ssh->_get_binary_packet();
+                    switch ($response[SSH1::RESPONSE_TYPE]) {
+                        case NET_SSH1_SMSG_STDOUT_DATA:
+                            if (strlen($response[SSH1::RESPONSE_DATA]) < 4) {
+                                return false;
+                            }
+                            extract(unpack('Nlength', $response[SSH1::RESPONSE_DATA]));
+                            return $this->ssh->_string_shift($response[SSH1::RESPONSE_DATA], $length);
+                        case NET_SSH1_SMSG_STDERR_DATA:
+                            break;
+                        case NET_SSH1_SMSG_EXITSTATUS:
+                            $this->ssh->_send_binary_packet(chr(NET_SSH1_CMSG_EXIT_CONFIRMATION));
+                            fclose($this->ssh->fsock);
+                            $this->ssh->bitmap = 0;
+                            return false;
+                        default:
+                            user_error('Unknown packet received', E_USER_NOTICE);
+                            return false;
+                    }
+                }
+        }
+    }
+
+    /**
+     * Closes the connection to an SSH server
+     *
+     * @access private
+     */
+    function _close()
+    {
+        switch ($this->mode) {
+            case self::MODE_SSH2:
+                $this->ssh->_close_channel(SSH2::CHANNEL_EXEC, true);
+                break;
+            case self::MODE_SSH1:
+                $this->ssh->disconnect();
+        }
+    }
+}
diff --git a/lib/phpseclib/Net/SFTP.php b/lib/phpseclib/Net/SFTP.php
index ad75056..8825f30 100644
--- a/lib/phpseclib/Net/SFTP.php
+++ b/lib/phpseclib/Net/SFTP.php
@@ -1,12 +1,11 @@
 <?php
-/* vim: set expandtab tabstop=4 shiftwidth=4 softtabstop=4: */
 
 /**
  * Pure-PHP implementation of SFTP.
  *
- * PHP versions 4 and 5
+ * PHP version 5
  *
- * Currently only supports SFTPv3, which, according to wikipedia.org, "is the most widely used version,
+ * Currently only supports SFTPv2 and v3, which, according to wikipedia.org, "is the most widely used version,
  * implemented by the popular OpenSSH SFTP server".  If you want SFTPv4/5/6 support, provide me with access
  * to an SFTPv4/5/6 server.
  *
@@ -15,9 +14,9 @@
  * Here's a short example of how to use this library:
  * <code>
  * <?php
- *    include('Net/SFTP.php');
+ *    include 'vendor/autoload.php';
  *
- *    $sftp = new Net_SFTP('www.domain.tld');
+ *    $sftp = new \phpseclib\Net\SFTP('www.domain.tld');
  *    if (!$sftp->login('username', 'password')) {
  *        exit('Login Failed');
  *    }
@@ -28,88 +27,69 @@
  * ?>
  * </code>
  *
- * LICENSE: This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA  02111-1307  USA
- *
- * @category   Net
- * @package    Net_SFTP
- * @author     Jim Wigginton <terrafrost@php.net>
- * @copyright  MMIX Jim Wigginton
- * @license    http://www.gnu.org/licenses/lgpl.txt
- * @version    $Id: SFTP.php,v 1.21 2010/04/09 02:31:34 terrafrost Exp $
- * @link       http://phpseclib.sourceforge.net
- */
-
-/**
- * Include Net_SSH2
- */
-require_once('phpseclib/Net/SSH2.php');
-
-/**#@+
- * @access public
- * @see Net_SFTP::getLog()
- */
-/**
- * Returns the message numbers
- */
-define('NET_SFTP_LOG_SIMPLE',  NET_SSH2_LOG_SIMPLE);
-/**
- * Returns the message content
- */
-define('NET_SFTP_LOG_COMPLEX', NET_SSH2_LOG_COMPLEX);
-/**#@-*/
-
-/**
- * SFTP channel constant
- *
- * Net_SSH2::exec() uses 0 and Net_SSH2::interactiveRead() / Net_SSH2::interactiveWrite() use 1.
- *
- * @see Net_SSH2::_send_channel_packet()
- * @see Net_SSH2::_get_channel_packet()
- * @access private
+ * @category  Net
+ * @package   SFTP
+ * @author    Jim Wigginton <terrafrost@php.net>
+ * @copyright 2009 Jim Wigginton
+ * @license   http://www.opensource.org/licenses/mit-license.html  MIT License
+ * @link      http://phpseclib.sourceforge.net
  */
-define('NET_SFTP_CHANNEL', 2);
 
-/**#@+
- * @access public
- * @see Net_SFTP::put()
- */
-/**
- * Reads data from a local file.
- */
-define('NET_SFTP_LOCAL_FILE', 1);
-/**
- * Reads data from a string.
- */
-define('NET_SFTP_STRING',  2);
-/**#@-*/
+namespace phpseclib\Net;
 
 /**
  * Pure-PHP implementations of SFTP.
  *
+ * @package SFTP
  * @author  Jim Wigginton <terrafrost@php.net>
- * @version 0.1.0
  * @access  public
- * @package Net_SFTP
  */
-class Net_SFTP extends Net_SSH2 {
+class SFTP extends SSH2
+{
+    /**
+     * SFTP channel constant
+     *
+     * \phpseclib\Net\SSH2::exec() uses 0 and \phpseclib\Net\SSH2::read() / \phpseclib\Net\SSH2::write() use 1.
+     *
+     * @see \phpseclib\Net\SSH2::_send_channel_packet()
+     * @see \phpseclib\Net\SSH2::_get_channel_packet()
+     * @access private
+     */
+    const CHANNEL = 0x100;
+
+    /**#@+
+     * @access public
+     * @see \phpseclib\Net\SFTP::put()
+    */
+    /**
+     * Reads data from a local file.
+     */
+    const SOURCE_LOCAL_FILE = 1;
+    /**
+     * Reads data from a string.
+     */
+    // this value isn't really used anymore but i'm keeping it reserved for historical reasons
+    const SOURCE_STRING = 2;
+    /**
+     * Reads data from callback:
+     * function callback($length) returns string to proceed, null for EOF
+     */
+    const SOURCE_CALLBACK = 16;
+    /**
+     * Resumes an upload
+     */
+    const RESUME = 4;
+    /**
+     * Append a local file to an already existing remote file
+     */
+    const RESUME_START = 8;
+    /**#@-*/
+
     /**
      * Packet Types
      *
-     * @see Net_SFTP::Net_SFTP()
-     * @var Array
+     * @see self::__construct()
+     * @var array
      * @access private
      */
     var $packet_types = array();
@@ -117,8 +97,8 @@ class Net_SFTP extends Net_SSH2 {
     /**
      * Status Codes
      *
-     * @see Net_SFTP::Net_SFTP()
-     * @var Array
+     * @see self::__construct()
+     * @var array
      * @access private
      */
     var $status_codes = array();
@@ -129,8 +109,8 @@ class Net_SFTP extends Net_SSH2 {
      * The request ID exists in the off chance that a packet is sent out-of-order.  Of course, this library doesn't support
      * concurrent actions, so it's somewhat academic, here.
      *
-     * @var Integer
-     * @see Net_SFTP::_send_sftp_packet()
+     * @var int
+     * @see self::_send_sftp_packet()
      * @access private
      */
     var $request_id = false;
@@ -141,8 +121,8 @@ class Net_SFTP extends Net_SSH2 {
      * The request ID exists in the off chance that a packet is sent out-of-order.  Of course, this library doesn't support
      * concurrent actions, so it's somewhat academic, here.
      *
-     * @var Integer
-     * @see Net_SFTP::_get_sftp_packet()
+     * @var int
+     * @see self::_get_sftp_packet()
      * @access private
      */
     var $packet_type = -1;
@@ -150,8 +130,8 @@ class Net_SFTP extends Net_SSH2 {
     /**
      * Packet Buffer
      *
-     * @var String
-     * @see Net_SFTP::_get_sftp_packet()
+     * @var string
+     * @see self::_get_sftp_packet()
      * @access private
      */
     var $packet_buffer = '';
@@ -159,8 +139,8 @@ class Net_SFTP extends Net_SSH2 {
     /**
      * Extensions supported by the server
      *
-     * @var Array
-     * @see Net_SFTP::_initChannel()
+     * @var array
+     * @see self::_initChannel()
      * @access private
      */
     var $extensions = array();
@@ -168,8 +148,8 @@ class Net_SFTP extends Net_SSH2 {
     /**
      * Server SFTP version
      *
-     * @var Integer
-     * @see Net_SFTP::_initChannel()
+     * @var int
+     * @see self::_initChannel()
      * @access private
      */
     var $version;
@@ -177,9 +157,9 @@ class Net_SFTP extends Net_SSH2 {
     /**
      * Current working directory
      *
-     * @var String
-     * @see Net_SFTP::_realpath()
-     * @see Net_SFTP::chdir()
+     * @var string
+     * @see self::realpath()
+     * @see self::chdir()
      * @access private
      */
     var $pwd = false;
@@ -187,8 +167,8 @@ class Net_SFTP extends Net_SSH2 {
     /**
      * Packet Type Log
      *
-     * @see Net_SFTP::getLog()
-     * @var Array
+     * @see self::getLog()
+     * @var array
      * @access private
      */
     var $packet_type_log = array();
@@ -196,8 +176,8 @@ class Net_SFTP extends Net_SSH2 {
     /**
      * Packet Log
      *
-     * @see Net_SFTP::getLog()
-     * @var Array
+     * @see self::getLog()
+     * @var array
      * @access private
      */
     var $packet_log = array();
@@ -205,27 +185,88 @@ class Net_SFTP extends Net_SSH2 {
     /**
      * Error information
      *
-     * @see Net_SFTP::getSFTPErrors()
-     * @see Net_SFTP::getLastSFTPError()
-     * @var String
+     * @see self::getSFTPErrors()
+     * @see self::getLastSFTPError()
+     * @var array
+     * @access private
+     */
+    var $sftp_errors = array();
+
+    /**
+     * Stat Cache
+     *
+     * Rather than always having to open a directory and close it immediately there after to see if a file is a directory
+     * we'll cache the results.
+     *
+     * @see self::_update_stat_cache()
+     * @see self::_remove_from_stat_cache()
+     * @see self::_query_stat_cache()
+     * @var array
+     * @access private
+     */
+    var $stat_cache = array();
+
+    /**
+     * Max SFTP Packet Size
+     *
+     * @see self::__construct()
+     * @see self::get()
+     * @var array
+     * @access private
+     */
+    var $max_sftp_packet;
+
+    /**
+     * Stat Cache Flag
+     *
+     * @see self::disableStatCache()
+     * @see self::enableStatCache()
+     * @var bool
+     * @access private
+     */
+    var $use_stat_cache = true;
+
+    /**
+     * Sort Options
+     *
+     * @see self::_comparator()
+     * @see self::setListOrder()
+     * @var array
+     * @access private
+     */
+    var $sortOptions = array();
+
+    /**
+     * Canonicalization Flag
+     *
+     * Determines whether or not paths should be canonicalized before being
+     * passed on to the remote server.
+     *
+     * @see self::enablePathCanonicalization()
+     * @see self::disablePathCanonicalization()
+     * @see self::realpath()
+     * @var bool
      * @access private
      */
-    var $errors = array();
+    var $canonicalize_paths = true;
 
     /**
      * Default Constructor.
      *
      * Connects to an SFTP server
      *
-     * @param String $host
-     * @param optional Integer $port
-     * @param optional Integer $timeout
-     * @return Net_SFTP
+     * @param string $host
+     * @param int $port
+     * @param int $timeout
+     * @return \phpseclib\Net\SFTP
      * @access public
      */
-    function Net_SFTP($host, $port = 22, $timeout = 10)
+    function __construct($host, $port = 22, $timeout = 10)
     {
-        parent::Net_SSH2($host, $port, $timeout);
+        parent::__construct($host, $port, $timeout);
+
+        $this->max_sftp_packet = 1 << 15;
+
         $this->packet_types = array(
             1  => 'NET_SFTP_INIT',
             2  => 'NET_SFTP_VERSION',
@@ -236,7 +277,7 @@ class Net_SFTP extends Net_SSH2 {
             4  => 'NET_SFTP_CLOSE',
             5  => 'NET_SFTP_READ',
             6  => 'NET_SFTP_WRITE',
-            8  => 'NET_SFTP_FSTAT',
+            7  => 'NET_SFTP_LSTAT',
             9  => 'NET_SFTP_SETSTAT',
             11 => 'NET_SFTP_OPENDIR',
             12 => 'NET_SFTP_READDIR',
@@ -249,6 +290,8 @@ class Net_SFTP extends Net_SSH2 {
                    SFTPv5+: http://tools.ietf.org/html/draft-ietf-secsh-filexfer-13#section-8.3
                pre-SFTPv5 : http://tools.ietf.org/html/draft-ietf-secsh-filexfer-04#section-6.5 */
             18 => 'NET_SFTP_RENAME',
+            19 => 'NET_SFTP_READLINK',
+            20 => 'NET_SFTP_SYMLINK',
 
             101=> 'NET_SFTP_STATUS',
             102=> 'NET_SFTP_HANDLE',
@@ -270,78 +313,168 @@ class Net_SFTP extends Net_SSH2 {
             5 => 'NET_SFTP_STATUS_BAD_MESSAGE',
             6 => 'NET_SFTP_STATUS_NO_CONNECTION',
             7 => 'NET_SFTP_STATUS_CONNECTION_LOST',
-            8 => 'NET_SFTP_STATUS_OP_UNSUPPORTED'
+            8 => 'NET_SFTP_STATUS_OP_UNSUPPORTED',
+            9 => 'NET_SFTP_STATUS_INVALID_HANDLE',
+            10 => 'NET_SFTP_STATUS_NO_SUCH_PATH',
+            11 => 'NET_SFTP_STATUS_FILE_ALREADY_EXISTS',
+            12 => 'NET_SFTP_STATUS_WRITE_PROTECT',
+            13 => 'NET_SFTP_STATUS_NO_MEDIA',
+            14 => 'NET_SFTP_STATUS_NO_SPACE_ON_FILESYSTEM',
+            15 => 'NET_SFTP_STATUS_QUOTA_EXCEEDED',
+            16 => 'NET_SFTP_STATUS_UNKNOWN_PRINCIPAL',
+            17 => 'NET_SFTP_STATUS_LOCK_CONFLICT',
+            18 => 'NET_SFTP_STATUS_DIR_NOT_EMPTY',
+            19 => 'NET_SFTP_STATUS_NOT_A_DIRECTORY',
+            20 => 'NET_SFTP_STATUS_INVALID_FILENAME',
+            21 => 'NET_SFTP_STATUS_LINK_LOOP',
+            22 => 'NET_SFTP_STATUS_CANNOT_DELETE',
+            23 => 'NET_SFTP_STATUS_INVALID_PARAMETER',
+            24 => 'NET_SFTP_STATUS_FILE_IS_A_DIRECTORY',
+            25 => 'NET_SFTP_STATUS_BYTE_RANGE_LOCK_CONFLICT',
+            26 => 'NET_SFTP_STATUS_BYTE_RANGE_LOCK_REFUSED',
+            27 => 'NET_SFTP_STATUS_DELETE_PENDING',
+            28 => 'NET_SFTP_STATUS_FILE_CORRUPT',
+            29 => 'NET_SFTP_STATUS_OWNER_INVALID',
+            30 => 'NET_SFTP_STATUS_GROUP_INVALID',
+            31 => 'NET_SFTP_STATUS_NO_MATCHING_BYTE_RANGE_LOCK'
         );
         // http://tools.ietf.org/html/draft-ietf-secsh-filexfer-13#section-7.1
-        // the order, in this case, matters quite a lot - see Net_SFTP::_parseAttributes() to understand why
+        // the order, in this case, matters quite a lot - see \phpseclib\Net\SFTP::_parseAttributes() to understand why
         $this->attributes = array(
             0x00000001 => 'NET_SFTP_ATTR_SIZE',
             0x00000002 => 'NET_SFTP_ATTR_UIDGID', // defined in SFTPv3, removed in SFTPv4+
             0x00000004 => 'NET_SFTP_ATTR_PERMISSIONS',
             0x00000008 => 'NET_SFTP_ATTR_ACCESSTIME',
-                    -1 => 'NET_SFTP_ATTR_EXTENDED' // unpack('N', "\xFF\xFF\xFF\xFF") == array(1 => int(-1))
+            // 0x80000000 will yield a floating point on 32-bit systems and converting floating points to integers
+            // yields inconsistent behavior depending on how php is compiled.  so we left shift -1 (which, in
+            // two's compliment, consists of all 1 bits) by 31.  on 64-bit systems this'll yield 0xFFFFFFFF80000000.
+            // that's not a problem, however, and 'anded' and a 32-bit number, as all the leading 1 bits are ignored.
+            (-1 << 31) & 0xFFFFFFFF => 'NET_SFTP_ATTR_EXTENDED'
         );
         // http://tools.ietf.org/html/draft-ietf-secsh-filexfer-04#section-6.3
         // the flag definitions change somewhat in SFTPv5+.  if SFTPv5+ support is added to this library, maybe name
-        // the array for that $this->open5_flags and similarily alter the constant names.
+        // the array for that $this->open5_flags and similarly alter the constant names.
         $this->open_flags = array(
             0x00000001 => 'NET_SFTP_OPEN_READ',
             0x00000002 => 'NET_SFTP_OPEN_WRITE',
+            0x00000004 => 'NET_SFTP_OPEN_APPEND',
             0x00000008 => 'NET_SFTP_OPEN_CREATE',
-            0x00000010 => 'NET_SFTP_OPEN_TRUNCATE'
+            0x00000010 => 'NET_SFTP_OPEN_TRUNCATE',
+            0x00000020 => 'NET_SFTP_OPEN_EXCL'
+        );
+        // http://tools.ietf.org/html/draft-ietf-secsh-filexfer-04#section-5.2
+        // see \phpseclib\Net\SFTP::_parseLongname() for an explanation
+        $this->file_types = array(
+            1 => 'NET_SFTP_TYPE_REGULAR',
+            2 => 'NET_SFTP_TYPE_DIRECTORY',
+            3 => 'NET_SFTP_TYPE_SYMLINK',
+            4 => 'NET_SFTP_TYPE_SPECIAL',
+            5 => 'NET_SFTP_TYPE_UNKNOWN',
+            // the followin types were first defined for use in SFTPv5+
+            // http://tools.ietf.org/html/draft-ietf-secsh-filexfer-05#section-5.2
+            6 => 'NET_SFTP_TYPE_SOCKET',
+            7 => 'NET_SFTP_TYPE_CHAR_DEVICE',
+            8 => 'NET_SFTP_TYPE_BLOCK_DEVICE',
+            9 => 'NET_SFTP_TYPE_FIFO'
         );
         $this->_define_array(
             $this->packet_types,
             $this->status_codes,
             $this->attributes,
-            $this->open_flags
+            $this->open_flags,
+            $this->file_types
         );
+
+        if (!defined('NET_SFTP_QUEUE_SIZE')) {
+            define('NET_SFTP_QUEUE_SIZE', 32);
+        }
     }
 
     /**
      * Login
      *
-     * @param String $username
-     * @param optional String $password
-     * @return Boolean
+     * @param string $username
+     * @param string $password
+     * @return bool
      * @access public
      */
-    function login($username, $password = '')
+    function login($username)
     {
-        if (!parent::login($username, $password)) {
+        $args = func_get_args();
+        if (!call_user_func_array(array(&$this, '_login'), $args)) {
             return false;
         }
 
-        $this->window_size_client_to_server[NET_SFTP_CHANNEL] = $this->window_size;
+        $this->window_size_server_to_client[self::CHANNEL] = $this->window_size;
 
-        $packet = pack('CNa*N3',
-            NET_SSH2_MSG_CHANNEL_OPEN, strlen('session'), 'session', NET_SFTP_CHANNEL, $this->window_size, 0x4000);
+        $packet = pack(
+            'CNa*N3',
+            NET_SSH2_MSG_CHANNEL_OPEN,
+            strlen('session'),
+            'session',
+            self::CHANNEL,
+            $this->window_size,
+            0x4000
+        );
 
         if (!$this->_send_binary_packet($packet)) {
             return false;
         }
 
-        $this->channel_status[NET_SFTP_CHANNEL] = NET_SSH2_MSG_CHANNEL_OPEN;
+        $this->channel_status[self::CHANNEL] = NET_SSH2_MSG_CHANNEL_OPEN;
 
-        $response = $this->_get_channel_packet(NET_SFTP_CHANNEL);
+        $response = $this->_get_channel_packet(self::CHANNEL, true);
         if ($response === false) {
             return false;
         }
 
-        $packet = pack('CNNa*CNa*',
-            NET_SSH2_MSG_CHANNEL_REQUEST, $this->server_channels[NET_SFTP_CHANNEL], strlen('subsystem'), 'subsystem', 1, strlen('sftp'), 'sftp');
+        $packet = pack(
+            'CNNa*CNa*',
+            NET_SSH2_MSG_CHANNEL_REQUEST,
+            $this->server_channels[self::CHANNEL],
+            strlen('subsystem'),
+            'subsystem',
+            1,
+            strlen('sftp'),
+            'sftp'
+        );
         if (!$this->_send_binary_packet($packet)) {
             return false;
         }
 
-        $this->channel_status[NET_SFTP_CHANNEL] = NET_SSH2_MSG_CHANNEL_REQUEST;
+        $this->channel_status[self::CHANNEL] = NET_SSH2_MSG_CHANNEL_REQUEST;
 
-        $response = $this->_get_channel_packet(NET_SFTP_CHANNEL);
+        $response = $this->_get_channel_packet(self::CHANNEL, true);
         if ($response === false) {
-            return false;
+            // from PuTTY's psftp.exe
+            $command = "test -x /usr/lib/sftp-server && exec /usr/lib/sftp-server\n" .
+                       "test -x /usr/local/lib/sftp-server && exec /usr/local/lib/sftp-server\n" .
+                       "exec sftp-server";
+            // we don't do $this->exec($command, false) because exec() operates on a different channel and plus the SSH_MSG_CHANNEL_OPEN that exec() does
+            // is redundant
+            $packet = pack(
+                'CNNa*CNa*',
+                NET_SSH2_MSG_CHANNEL_REQUEST,
+                $this->server_channels[self::CHANNEL],
+                strlen('exec'),
+                'exec',
+                1,
+                strlen($command),
+                $command
+            );
+            if (!$this->_send_binary_packet($packet)) {
+                return false;
+            }
+
+            $this->channel_status[self::CHANNEL] = NET_SSH2_MSG_CHANNEL_REQUEST;
+
+            $response = $this->_get_channel_packet(self::CHANNEL, true);
+            if ($response === false) {
+                return false;
+            }
         }
 
-        $this->channel_status[NET_SFTP_CHANNEL] = NET_SSH2_MSG_CHANNEL_DATA;
+        $this->channel_status[self::CHANNEL] = NET_SSH2_MSG_CHANNEL_DATA;
 
         if (!$this->_send_sftp_packet(NET_SFTP_INIT, "\0\0\0\3")) {
             return false;
@@ -349,15 +482,24 @@ class Net_SFTP extends Net_SSH2 {
 
         $response = $this->_get_sftp_packet();
         if ($this->packet_type != NET_SFTP_VERSION) {
-            user_error('Expected SSH_FXP_VERSION', E_USER_NOTICE);
+            user_error('Expected SSH_FXP_VERSION');
             return false;
         }
 
+        if (strlen($response) < 4) {
+            return false;
+        }
         extract(unpack('Nversion', $this->_string_shift($response, 4)));
         $this->version = $version;
         while (!empty($response)) {
+            if (strlen($response) < 4) {
+                return false;
+            }
             extract(unpack('Nlength', $this->_string_shift($response, 4)));
             $key = $this->_string_shift($response, $length);
+            if (strlen($response) < 4) {
+                return false;
+            }
             extract(unpack('Nlength', $this->_string_shift($response, 4)));
             $value = $this->_string_shift($response, $length);
             $this->extensions[$key] = $value;
@@ -399,22 +541,78 @@ class Net_SFTP extends Net_SSH2 {
          So what do you do if you have a client whose initial SSH_FXP_INIT packet says it implements v3 and
          a server whose initial SSH_FXP_VERSION reply says it implements v4 and only v4?  If it only implements
          v4, the "versions" extension is likely not going to have been sent so version re-negotiation as discussed
-         in draft-ietf-secsh-filexfer-13 would be quite impossible.  As such, what Net_SFTP would do is close the
+         in draft-ietf-secsh-filexfer-13 would be quite impossible.  As such, what \phpseclib\Net\SFTP would do is close the
          channel and reopen it with a new and updated SSH_FXP_INIT packet.
         */
-        if ($this->version != 3) {
-            return false;
+        switch ($this->version) {
+            case 2:
+            case 3:
+                break;
+            default:
+                return false;
         }
 
         $this->pwd = $this->_realpath('.');
 
+        $this->_update_stat_cache($this->pwd, array());
+
         return true;
     }
 
     /**
+     * Disable the stat cache
+     *
+     * @access public
+     */
+    function disableStatCache()
+    {
+        $this->use_stat_cache = false;
+    }
+
+    /**
+     * Enable the stat cache
+     *
+     * @access public
+     */
+    function enableStatCache()
+    {
+        $this->use_stat_cache = true;
+    }
+
+    /**
+     * Clear the stat cache
+     *
+     * @access public
+     */
+    function clearStatCache()
+    {
+        $this->stat_cache = array();
+    }
+
+    /**
+     * Enable path canonicalization
+     *
+     * @access public
+     */
+    function enablePathCanonicalization()
+    {
+        $this->canonicalize_paths = true;
+    }
+
+    /**
+     * Enable path canonicalization
+     *
+     * @access public
+     */
+    function disablePathCanonicalization()
+    {
+        $this->canonicalize_paths = false;
+    }
+
+    /**
      * Returns the current directory name
      *
-     * @return Mixed
+     * @return mixed
      * @access public
      */
     function pwd()
@@ -423,144 +621,173 @@ class Net_SFTP extends Net_SSH2 {
     }
 
     /**
+     * Logs errors
+     *
+     * @param string $response
+     * @param int $status
+     * @access public
+     */
+    function _logError($response, $status = -1)
+    {
+        if ($status == -1) {
+            if (strlen($response) < 4) {
+                return;
+            }
+            extract(unpack('Nstatus', $this->_string_shift($response, 4)));
+        }
+
+        $error = $this->status_codes[$status];
+
+        if ($this->version > 2 || strlen($response) < 4) {
+            extract(unpack('Nlength', $this->_string_shift($response, 4)));
+            $this->sftp_errors[] = $error . ': ' . $this->_string_shift($response, $length);
+        } else {
+            $this->sftp_errors[] = $error;
+        }
+    }
+
+    /**
+     * Returns canonicalized absolute pathname
+     *
+     * realpath() expands all symbolic links and resolves references to '/./', '/../' and extra '/' characters in the input
+     * path and returns the canonicalized absolute pathname.
+     *
+     * @param string $path
+     * @return mixed
+     * @access public
+     */
+    function realpath($path)
+    {
+        return $this->_realpath($path);
+    }
+
+    /**
      * Canonicalize the Server-Side Path Name
      *
      * SFTP doesn't provide a mechanism by which the current working directory can be changed, so we'll emulate it.  Returns
-     * the absolute (canonicalized) path.  If $mode is set to NET_SFTP_CONFIRM_DIR (as opposed to NET_SFTP_CONFIRM_NONE,
-     * which is what it is set to by default), false is returned if $dir is not a valid directory.
+     * the absolute (canonicalized) path.
      *
-     * @see Net_SFTP::chdir()
-     * @param String $dir
-     * @param optional Integer $mode
-     * @return Mixed
+     * If canonicalize_paths has been disabled using disablePathCanonicalization(), $path is returned as-is.
+     *
+     * @see self::chdir()
+     * @see self::disablePathCanonicalization()
+     * @param string $path
+     * @return mixed
      * @access private
      */
-    function _realpath($dir)
+    function _realpath($path)
     {
-        /*
-        "This protocol represents file names as strings.  File names are
-         assumed to use the slash ('/') character as a directory separator.
-
-         File names starting with a slash are "absolute", and are relative to
-         the root of the file system.  Names starting with any other character
-         are relative to the user's default directory (home directory).  Note
-         that identifying the user is assumed to take place outside of this
-         protocol."
-
-         -- http://tools.ietf.org/html/draft-ietf-secsh-filexfer-13#section-6
-        */
-        $file = '';
-        if ($this->pwd !== false) {
-            // if the SFTP server returned the canonicalized path even for non-existant files this wouldn't be necessary
-            // on OpenSSH it isn't necessary but on other SFTP servers it is.  that and since the specs say nothing on
-            // the subject, we'll go ahead and work around it with the following.
-            if ($dir[strlen($dir) - 1] != '/') {
-                $file = basename($dir);
-                $dir = dirname($dir);
-            }
+        if (!$this->canonicalize_paths) {
+            return $path;
+        }
 
-            if ($dir == '.' || $dir == $this->pwd) {
-                return $this->pwd . $file;
+        if ($this->pwd === false) {
+            // http://tools.ietf.org/html/draft-ietf-secsh-filexfer-13#section-8.9
+            if (!$this->_send_sftp_packet(NET_SFTP_REALPATH, pack('Na*', strlen($path), $path))) {
+                return false;
             }
 
-            if ($dir[0] != '/') {
-                $dir = $this->pwd . '/' . $dir;
+            $response = $this->_get_sftp_packet();
+            switch ($this->packet_type) {
+                case NET_SFTP_NAME:
+                    // although SSH_FXP_NAME is implemented differently in SFTPv3 than it is in SFTPv4+, the following
+                    // should work on all SFTP versions since the only part of the SSH_FXP_NAME packet the following looks
+                    // at is the first part and that part is defined the same in SFTP versions 3 through 6.
+                    $this->_string_shift($response, 4); // skip over the count - it should be 1, anyway
+                    if (strlen($response) < 4) {
+                        return false;
+                    }
+                    extract(unpack('Nlength', $this->_string_shift($response, 4)));
+                    return $this->_string_shift($response, $length);
+                case NET_SFTP_STATUS:
+                    $this->_logError($response);
+                    return false;
+                default:
+                    user_error('Expected SSH_FXP_NAME or SSH_FXP_STATUS');
+                    return false;
             }
-            // on the surface it seems like maybe resolving a path beginning with / is unnecessary, but such paths
-            // can contain .'s and ..'s just like any other.  we could parse those out as appropriate or we can let
-            // the server do it.  we'll do the latter.
         }
 
-        /*
-         that SSH_FXP_REALPATH returns SSH_FXP_NAME does not necessarily mean that anything actually exists at the
-         specified path.  generally speaking, no attributes are returned with this particular SSH_FXP_NAME packet
-         regardless of whether or not a file actually exists.  and in SFTPv3, the longname field and the filename
-         field match for this particular SSH_FXP_NAME packet.  for other SSH_FXP_NAME packets, this will likely
-         not be the case, but for this one, it is.
-        */
-        // http://tools.ietf.org/html/draft-ietf-secsh-filexfer-13#section-8.9
-        if (!$this->_send_sftp_packet(NET_SFTP_REALPATH, pack('Na*', strlen($dir), $dir))) {
-            return false;
+        if ($path[0] != '/') {
+            $path = $this->pwd . '/' . $path;
         }
 
-        $response = $this->_get_sftp_packet();
-        switch ($this->packet_type) {
-            case NET_SFTP_NAME:
-                // although SSH_FXP_NAME is implemented differently in SFTPv3 than it is in SFTPv4+, the following
-                // should work on all SFTP versions since the only part of the SSH_FXP_NAME packet the following looks
-                // at is the first part and that part is defined the same in SFTP versions 3 through 6.
-                $this->_string_shift($response, 4); // skip over the count - it should be 1, anyway
-                extract(unpack('Nlength', $this->_string_shift($response, 4)));
-                $realpath = $this->_string_shift($response, $length);
-                break;
-            case NET_SFTP_STATUS:
-                extract(unpack('Nstatus/Nlength', $this->_string_shift($response, 8)));
-                $this->sftp_errors[] = $this->status_codes[$status] . ': ' . $this->_string_shift($response, $length);
-                return false;
-            default:
-                user_error('Expected SSH_FXP_NAME or SSH_FXP_STATUS', E_USER_NOTICE);
-                return false;
+        $path = explode('/', $path);
+        $new = array();
+        foreach ($path as $dir) {
+            if (!strlen($dir)) {
+                continue;
+            }
+            switch ($dir) {
+                case '..':
+                    array_pop($new);
+                case '.':
+                    break;
+                default:
+                    $new[] = $dir;
+            }
         }
 
-        // if $this->pwd isn't set than the only thing $realpath could be is for '.', which is pretty much guaranteed to
-        // be a bonafide directory
-        return $realpath . '/' . $file;
+        return '/' . implode('/', $new);
     }
 
     /**
      * Changes the current directory
      *
-     * @param String $dir
-     * @return Boolean
+     * @param string $dir
+     * @return bool
      * @access public
      */
     function chdir($dir)
     {
-        if (!($this->bitmap & NET_SSH2_MASK_LOGIN)) {
+        if (!($this->bitmap & SSH2::MASK_LOGIN)) {
             return false;
         }
 
-        if ($dir[strlen($dir) - 1] != '/') {
+        // assume current dir if $dir is empty
+        if ($dir === '') {
+            $dir = './';
+        // suffix a slash if needed
+        } elseif ($dir[strlen($dir) - 1] != '/') {
             $dir.= '/';
         }
+
         $dir = $this->_realpath($dir);
 
         // confirm that $dir is, in fact, a valid directory
+        if ($this->use_stat_cache && is_array($this->_query_stat_cache($dir))) {
+            $this->pwd = $dir;
+            return true;
+        }
+
+        // we could do a stat on the alleged $dir to see if it's a directory but that doesn't tell us
+        // the currently logged in user has the appropriate permissions or not. maybe you could see if
+        // the file's uid / gid match the currently logged in user's uid / gid but how there's no easy
+        // way to get those with SFTP
+
         if (!$this->_send_sftp_packet(NET_SFTP_OPENDIR, pack('Na*', strlen($dir), $dir))) {
             return false;
         }
 
-        // see Net_SFTP::nlist() for a more thorough explanation of the following
+        // see \phpseclib\Net\SFTP::nlist() for a more thorough explanation of the following
         $response = $this->_get_sftp_packet();
         switch ($this->packet_type) {
             case NET_SFTP_HANDLE:
                 $handle = substr($response, 4);
                 break;
             case NET_SFTP_STATUS:
-                extract(unpack('Nstatus/Nlength', $this->_string_shift($response, 8)));
-                $this->sftp_errors[] = $this->status_codes[$status] . ': ' . $this->_string_shift($response, $length);
+                $this->_logError($response);
                 return false;
             default:
-                user_error('Expected SSH_FXP_HANDLE or SSH_FXP_STATUS', E_USER_NOTICE);
+                user_error('Expected SSH_FXP_HANDLE or SSH_FXP_STATUS');
                 return false;
         }
 
-        if (!$this->_send_sftp_packet(NET_SFTP_CLOSE, pack('Na*', strlen($handle), $handle))) {
-            return false;
-        }
-
-        $response = $this->_get_sftp_packet();
-        if ($this->packet_type != NET_SFTP_STATUS) {
-            user_error('Expected SSH_FXP_STATUS', E_USER_NOTICE);
+        if (!$this->_close_handle($handle)) {
             return false;
         }
 
-        extract(unpack('Nstatus', $this->_string_shift($response, 4)));
-        if ($status != NET_SFTP_STATUS_OK) {
-            extract(unpack('Nlength', $this->_string_shift($response, 4)));
-            $this->sftp_errors[] = $this->status_codes[$status] . ': ' . $this->_string_shift($response, $length);
-            return false;
-        }
+        $this->_update_stat_cache($dir, array());
 
         $this->pwd = $dir;
         return true;
@@ -569,34 +796,101 @@ class Net_SFTP extends Net_SSH2 {
     /**
      * Returns a list of files in the given directory
      *
-     * @param optional String $dir
-     * @return Mixed
+     * @param string $dir
+     * @param bool $recursive
+     * @return mixed
      * @access public
      */
-    function nlist($dir = '.')
+    function nlist($dir = '.', $recursive = false)
     {
-        return $this->_list($dir, false);
+        return $this->_nlist_helper($dir, $recursive, '');
     }
 
     /**
-     * Returns a list of files in the given directory
+     * Helper method for nlist
+     *
+     * @param string $dir
+     * @param bool $recursive
+     * @param string $relativeDir
+     * @return mixed
+     * @access private
+     */
+    function _nlist_helper($dir, $recursive, $relativeDir)
+    {
+        $files = $this->_list($dir, false);
+
+        if (!$recursive || $files === false) {
+            return $files;
+        }
+
+        $result = array();
+        foreach ($files as $value) {
+            if ($value == '.' || $value == '..') {
+                if ($relativeDir == '') {
+                    $result[] = $value;
+                }
+                continue;
+            }
+            if (is_array($this->_query_stat_cache($this->_realpath($dir . '/' . $value)))) {
+                $temp = $this->_nlist_helper($dir . '/' . $value, true, $relativeDir . $value . '/');
+                $result = array_merge($result, $temp);
+            } else {
+                $result[] = $relativeDir . $value;
+            }
+        }
+
+        return $result;
+    }
+
+    /**
+     * Returns a detailed list of files in the given directory
      *
-     * @param optional String $dir
-     * @return Mixed
+     * @param string $dir
+     * @param bool $recursive
+     * @return mixed
      * @access public
      */
-    function rawlist($dir = '.')
+    function rawlist($dir = '.', $recursive = false)
     {
-        return $this->_list($dir, true);
+        $files = $this->_list($dir, true);
+        if (!$recursive || $files === false) {
+            return $files;
+        }
+
+        static $depth = 0;
+
+        foreach ($files as $key => $value) {
+            if ($depth != 0 && $key == '..') {
+                unset($files[$key]);
+                continue;
+            }
+            if ($key != '.' && $key != '..' && is_array($this->_query_stat_cache($this->_realpath($dir . '/' . $key)))) {
+                $depth++;
+                $files[$key] = $this->rawlist($dir . '/' . $key, true);
+                $depth--;
+            } else {
+                $files[$key] = (object) $value;
+            }
+        }
+
+        return $files;
     }
 
+    /**
+     * Reads a list, be it detailed or not, of files in the given directory
+     *
+     * @param string $dir
+     * @param bool $raw
+     * @return mixed
+     * @access private
+     */
     function _list($dir, $raw = true)
     {
-        if (!($this->bitmap & NET_SSH2_MASK_LOGIN)) {
+        if (!($this->bitmap & SSH2::MASK_LOGIN)) {
             return false;
         }
 
-        $dir = $this->_realpath($dir);
+        $dir = $this->_realpath($dir . '/');
         if ($dir === false) {
             return false;
         }
@@ -616,14 +910,15 @@ class Net_SFTP extends Net_SSH2 {
                 break;
             case NET_SFTP_STATUS:
                 // presumably SSH_FX_NO_SUCH_FILE or SSH_FX_PERMISSION_DENIED
-                extract(unpack('Nstatus/Nlength', $this->_string_shift($response, 8)));
-                $this->sftp_errors[] = $this->status_codes[$status] . ': ' . $this->_string_shift($response, $length);
+                $this->_logError($response);
                 return false;
             default:
-                user_error('Expected SSH_FXP_HANDLE or SSH_FXP_STATUS', E_USER_NOTICE);
+                user_error('Expected SSH_FXP_HANDLE or SSH_FXP_STATUS');
                 return false;
         }
 
+        $this->_update_stat_cache($dir, array());
+
         $contents = array();
         while (true) {
             // http://tools.ietf.org/html/draft-ietf-secsh-filexfer-13#section-8.2.2
@@ -636,112 +931,468 @@ class Net_SFTP extends Net_SSH2 {
             $response = $this->_get_sftp_packet();
             switch ($this->packet_type) {
                 case NET_SFTP_NAME:
+                    if (strlen($response) < 4) {
+                        return false;
+                    }
                     extract(unpack('Ncount', $this->_string_shift($response, 4)));
                     for ($i = 0; $i < $count; $i++) {
+                        if (strlen($response) < 4) {
+                            return false;
+                        }
                         extract(unpack('Nlength', $this->_string_shift($response, 4)));
                         $shortname = $this->_string_shift($response, $length);
+                        if (strlen($response) < 4) {
+                            return false;
+                        }
                         extract(unpack('Nlength', $this->_string_shift($response, 4)));
-                        $this->_string_shift($response, $length); // SFTPv4+ drop this field - the "longname" field
-                        $attributes = $this->_parseAttributes($response); // we also don't care about the attributes
-                        if (!$raw) {
-                            $contents[] = $shortname;
+                        $longname = $this->_string_shift($response, $length);
+                        $attributes = $this->_parseAttributes($response);
+                        if (!isset($attributes['type'])) {
+                            $fileType = $this->_parseLongname($longname);
+                            if ($fileType) {
+                                $attributes['type'] = $fileType;
+                            }
+                        }
+                        $contents[$shortname] = $attributes + array('filename' => $shortname);
+
+                        if (isset($attributes['type']) && $attributes['type'] == NET_SFTP_TYPE_DIRECTORY && ($shortname != '.' && $shortname != '..')) {
+                            $this->_update_stat_cache($dir . '/' . $shortname, array());
                         } else {
-                            $contents[$shortname] = $attributes;
+                            if ($shortname == '..') {
+                                $temp = $this->_realpath($dir . '/..') . '/.';
+                            } else {
+                                $temp = $dir . '/' . $shortname;
+                            }
+                            $this->_update_stat_cache($temp, (object) array('lstat' => $attributes));
                         }
                         // SFTPv6 has an optional boolean end-of-list field, but we'll ignore that, since the
                         // final SSH_FXP_STATUS packet should tell us that, already.
                     }
                     break;
                 case NET_SFTP_STATUS:
+                    if (strlen($response) < 4) {
+                        return false;
+                    }
                     extract(unpack('Nstatus', $this->_string_shift($response, 4)));
                     if ($status != NET_SFTP_STATUS_EOF) {
-                        extract(unpack('Nlength', $this->_string_shift($response, 4)));
-                        $this->sftp_errors[] = $this->status_codes[$status] . ': ' . $this->_string_shift($response, $length);
+                        $this->_logError($response, $status);
                         return false;
                     }
                     break 2;
                 default:
-                    user_error('Expected SSH_FXP_NAME or SSH_FXP_STATUS', E_USER_NOTICE);
+                    user_error('Expected SSH_FXP_NAME or SSH_FXP_STATUS');
                     return false;
             }
         }
 
-        if (!$this->_send_sftp_packet(NET_SFTP_CLOSE, pack('Na*', strlen($handle), $handle))) {
-            return false;
-        }
-
-        // "The client MUST release all resources associated with the handle regardless of the status."
-        //  -- http://tools.ietf.org/html/draft-ietf-secsh-filexfer-13#section-8.1.3
-        $response = $this->_get_sftp_packet();
-        if ($this->packet_type != NET_SFTP_STATUS) {
-            user_error('Expected SSH_FXP_STATUS', E_USER_NOTICE);
+        if (!$this->_close_handle($handle)) {
             return false;
         }
 
-        extract(unpack('Nstatus', $this->_string_shift($response, 4)));
-        if ($status != NET_SFTP_STATUS_OK) {
-            extract(unpack('Nlength', $this->_string_shift($response, 4)));
-            $this->sftp_errors[] = $this->status_codes[$status] . ': ' . $this->_string_shift($response, $length);
-            return false;
+        if (count($this->sortOptions)) {
+            uasort($contents, array(&$this, '_comparator'));
         }
 
-        return $contents;
+        return $raw ? $contents : array_keys($contents);
     }
 
     /**
-     * Returns the file size, in bytes, or false, on failure
+     * Compares two rawlist entries using parameters set by setListOrder()
      *
-     * Files larger than 4GB will show up as being exactly 4GB.
+     * Intended for use with uasort()
      *
-     * @param optional String $dir
-     * @return Mixed
-     * @access public
+     * @param array $a
+     * @param array $b
+     * @return int
+     * @access private
      */
-    function size($filename)
+    function _comparator($a, $b)
     {
-        if (!($this->bitmap & NET_SSH2_MASK_LOGIN)) {
-            return false;
-        }
-
+        switch (true) {
+            case $a['filename'] === '.' || $b['filename'] === '.':
+                if ($a['filename'] === $b['filename']) {
+                    return 0;
+                }
+                return $a['filename'] === '.' ? -1 : 1;
+            case $a['filename'] === '..' || $b['filename'] === '..':
+                if ($a['filename'] === $b['filename']) {
+                    return 0;
+                }
+                return $a['filename'] === '..' ? -1 : 1;
+            case isset($a['type']) && $a['type'] === NET_SFTP_TYPE_DIRECTORY:
+                if (!isset($b['type'])) {
+                    return 1;
+                }
+                if ($b['type'] !== $a['type']) {
+                    return -1;
+                }
+                break;
+            case isset($b['type']) && $b['type'] === NET_SFTP_TYPE_DIRECTORY:
+                return 1;
+        }
+        foreach ($this->sortOptions as $sort => $order) {
+            if (!isset($a[$sort]) || !isset($b[$sort])) {
+                if (isset($a[$sort])) {
+                    return -1;
+                }
+                if (isset($b[$sort])) {
+                    return 1;
+                }
+                return 0;
+            }
+            switch ($sort) {
+                case 'filename':
+                    $result = strcasecmp($a['filename'], $b['filename']);
+                    if ($result) {
+                        return $order === SORT_DESC ? -$result : $result;
+                    }
+                    break;
+                case 'permissions':
+                case 'mode':
+                    $a[$sort]&= 07777;
+                    $b[$sort]&= 07777;
+                default:
+                    if ($a[$sort] === $b[$sort]) {
+                        break;
+                    }
+                    return $order === SORT_ASC ? $a[$sort] - $b[$sort] : $b[$sort] - $a[$sort];
+            }
+        }
+    }
+
+    /**
+     * Defines how nlist() and rawlist() will be sorted - if at all.
+     *
+     * If sorting is enabled directories and files will be sorted independently with
+     * directories appearing before files in the resultant array that is returned.
+     *
+     * Any parameter returned by stat is a valid sort parameter for this function.
+     * Filename comparisons are case insensitive.
+     *
+     * Examples:
+     *
+     * $sftp->setListOrder('filename', SORT_ASC);
+     * $sftp->setListOrder('size', SORT_DESC, 'filename', SORT_ASC);
+     * $sftp->setListOrder(true);
+     *    Separates directories from files but doesn't do any sorting beyond that
+     * $sftp->setListOrder();
+     *    Don't do any sort of sorting
+     *
+     * @access public
+     */
+    function setListOrder()
+    {
+        $this->sortOptions = array();
+        $args = func_get_args();
+        if (empty($args)) {
+            return;
+        }
+        $len = count($args) & 0x7FFFFFFE;
+        for ($i = 0; $i < $len; $i+=2) {
+            $this->sortOptions[$args[$i]] = $args[$i + 1];
+        }
+        if (!count($this->sortOptions)) {
+            $this->sortOptions = array('bogus' => true);
+        }
+    }
+
+    /**
+     * Returns the file size, in bytes, or false, on failure
+     *
+     * Files larger than 4GB will show up as being exactly 4GB.
+     *
+     * @param string $filename
+     * @return mixed
+     * @access public
+     */
+    function size($filename)
+    {
+        if (!($this->bitmap & SSH2::MASK_LOGIN)) {
+            return false;
+        }
+
+        $result = $this->stat($filename);
+        if ($result === false) {
+            return false;
+        }
+        return isset($result['size']) ? $result['size'] : -1;
+    }
+
+    /**
+     * Save files / directories to cache
+     *
+     * @param string $path
+     * @param mixed $value
+     * @access private
+     */
+    function _update_stat_cache($path, $value)
+    {
+        if ($this->use_stat_cache === false) {
+            return;
+        }
+
+        // preg_replace('#^/|/(?=/)|/$#', '', $dir) == str_replace('//', '/', trim($path, '/'))
+        $dirs = explode('/', preg_replace('#^/|/(?=/)|/$#', '', $path));
+
+        $temp = &$this->stat_cache;
+        $max = count($dirs) - 1;
+        foreach ($dirs as $i => $dir) {
+            // if $temp is an object that means one of two things.
+            //  1. a file was deleted and changed to a directory behind phpseclib's back
+            //  2. it's a symlink. when lstat is done it's unclear what it's a symlink to
+            if (is_object($temp)) {
+                $temp = array();
+            }
+            if (!isset($temp[$dir])) {
+                $temp[$dir] = array();
+            }
+            if ($i === $max) {
+                if (is_object($temp[$dir]) && is_object($value)) {
+                    if (!isset($value->stat) && isset($temp[$dir]->stat)) {
+                        $value->stat = $temp[$dir]->stat;
+                    }
+                    if (!isset($value->lstat) && isset($temp[$dir]->lstat)) {
+                        $value->lstat = $temp[$dir]->lstat;
+                    }
+                }
+                $temp[$dir] = $value;
+                break;
+            }
+            $temp = &$temp[$dir];
+        }
+    }
+
+    /**
+     * Remove files / directories from cache
+     *
+     * @param string $path
+     * @return bool
+     * @access private
+     */
+    function _remove_from_stat_cache($path)
+    {
+        $dirs = explode('/', preg_replace('#^/|/(?=/)|/$#', '', $path));
+
+        $temp = &$this->stat_cache;
+        $max = count($dirs) - 1;
+        foreach ($dirs as $i => $dir) {
+            if ($i === $max) {
+                unset($temp[$dir]);
+                return true;
+            }
+            if (!isset($temp[$dir])) {
+                return false;
+            }
+            $temp = &$temp[$dir];
+        }
+    }
+
+    /**
+     * Checks cache for path
+     *
+     * Mainly used by file_exists
+     *
+     * @param string $dir
+     * @return mixed
+     * @access private
+     */
+    function _query_stat_cache($path)
+    {
+        $dirs = explode('/', preg_replace('#^/|/(?=/)|/$#', '', $path));
+
+        $temp = &$this->stat_cache;
+        foreach ($dirs as $dir) {
+            if (!isset($temp[$dir])) {
+                return null;
+            }
+            $temp = &$temp[$dir];
+        }
+        return $temp;
+    }
+
+    /**
+     * Returns general information about a file.
+     *
+     * Returns an array on success and false otherwise.
+     *
+     * @param string $filename
+     * @return mixed
+     * @access public
+     */
+    function stat($filename)
+    {
+        if (!($this->bitmap & SSH2::MASK_LOGIN)) {
+            return false;
+        }
+
+        $filename = $this->_realpath($filename);
+        if ($filename === false) {
+            return false;
+        }
+
+        if ($this->use_stat_cache) {
+            $result = $this->_query_stat_cache($filename);
+            if (is_array($result) && isset($result['.']) && isset($result['.']->stat)) {
+                return $result['.']->stat;
+            }
+            if (is_object($result) && isset($result->stat)) {
+                return $result->stat;
+            }
+        }
+
+        $stat = $this->_stat($filename, NET_SFTP_STAT);
+        if ($stat === false) {
+            $this->_remove_from_stat_cache($filename);
+            return false;
+        }
+        if (isset($stat['type'])) {
+            if ($stat['type'] == NET_SFTP_TYPE_DIRECTORY) {
+                $filename.= '/.';
+            }
+            $this->_update_stat_cache($filename, (object) array('stat' => $stat));
+            return $stat;
+        }
+
+        $pwd = $this->pwd;
+        $stat['type'] = $this->chdir($filename) ?
+            NET_SFTP_TYPE_DIRECTORY :
+            NET_SFTP_TYPE_REGULAR;
+        $this->pwd = $pwd;
+
+        if ($stat['type'] == NET_SFTP_TYPE_DIRECTORY) {
+            $filename.= '/.';
+        }
+        $this->_update_stat_cache($filename, (object) array('stat' => $stat));
+
+        return $stat;
+    }
+
+    /**
+     * Returns general information about a file or symbolic link.
+     *
+     * Returns an array on success and false otherwise.
+     *
+     * @param string $filename
+     * @return mixed
+     * @access public
+     */
+    function lstat($filename)
+    {
+        if (!($this->bitmap & SSH2::MASK_LOGIN)) {
+            return false;
+        }
+
         $filename = $this->_realpath($filename);
         if ($filename === false) {
             return false;
         }
 
+        if ($this->use_stat_cache) {
+            $result = $this->_query_stat_cache($filename);
+            if (is_array($result) && isset($result['.']) && isset($result['.']->lstat)) {
+                return $result['.']->lstat;
+            }
+            if (is_object($result) && isset($result->lstat)) {
+                return $result->lstat;
+            }
+        }
+
+        $lstat = $this->_stat($filename, NET_SFTP_LSTAT);
+        if ($lstat === false) {
+            $this->_remove_from_stat_cache($filename);
+            return false;
+        }
+        if (isset($lstat['type'])) {
+            if ($lstat['type'] == NET_SFTP_TYPE_DIRECTORY) {
+                $filename.= '/.';
+            }
+            $this->_update_stat_cache($filename, (object) array('lstat' => $lstat));
+            return $lstat;
+        }
+
+        $stat = $this->_stat($filename, NET_SFTP_STAT);
+
+        if ($lstat != $stat) {
+            $lstat = array_merge($lstat, array('type' => NET_SFTP_TYPE_SYMLINK));
+            $this->_update_stat_cache($filename, (object) array('lstat' => $lstat));
+            return $stat;
+        }
+
+        $pwd = $this->pwd;
+        $lstat['type'] = $this->chdir($filename) ?
+            NET_SFTP_TYPE_DIRECTORY :
+            NET_SFTP_TYPE_REGULAR;
+        $this->pwd = $pwd;
+
+        if ($lstat['type'] == NET_SFTP_TYPE_DIRECTORY) {
+            $filename.= '/.';
+        }
+        $this->_update_stat_cache($filename, (object) array('lstat' => $lstat));
+
+        return $lstat;
+    }
+
+    /**
+     * Returns general information about a file or symbolic link
+     *
+     * Determines information without calling \phpseclib\Net\SFTP::realpath().
+     * The second parameter can be either NET_SFTP_STAT or NET_SFTP_LSTAT.
+     *
+     * @param string $filename
+     * @param int $type
+     * @return mixed
+     * @access private
+     */
+    function _stat($filename, $type)
+    {
         // SFTPv4+ adds an additional 32-bit integer field - flags - to the following:
         $packet = pack('Na*', strlen($filename), $filename);
-        if (!$this->_send_sftp_packet(NET_SFTP_STAT, $packet)) {
+        if (!$this->_send_sftp_packet($type, $packet)) {
             return false;
         }
 
         $response = $this->_get_sftp_packet();
         switch ($this->packet_type) {
             case NET_SFTP_ATTRS:
-                $attrs = $this->_parseAttributes($response);
-                return $attrs['size'];
+                return $this->_parseAttributes($response);
             case NET_SFTP_STATUS:
-                extract(unpack('Nstatus/Nlength', $this->_string_shift($response, 8)));
-                $this->sftp_errors[] = $this->status_codes[$status] . ': ' . $this->_string_shift($response, $length);
+                $this->_logError($response);
                 return false;
         }
 
-        user_error('Expected SSH_FXP_ATTRS or SSH_FXP_STATUS', E_USER_NOTICE);
+        user_error('Expected SSH_FXP_ATTRS or SSH_FXP_STATUS');
         return false;
     }
 
     /**
-     * Set permissions on a file.
+     * Truncates a file to a given length
+     *
+     * @param string $filename
+     * @param int $new_size
+     * @return bool
+     * @access public
+     */
+    function truncate($filename, $new_size)
+    {
+        $attr = pack('N3', NET_SFTP_ATTR_SIZE, $new_size / 4294967296, $new_size); // 4294967296 == 0x100000000 == 1<<32
+
+        return $this->_setstat($filename, $attr, false);
+    }
+
+    /**
+     * Sets access and modification time of file.
      *
-     * Returns the new file permissions on success or FALSE on error.
+     * If the file does not exist, it will be created.
      *
-     * @param Integer $mode
-     * @param String $filename
-     * @return Mixed
+     * @param string $filename
+     * @param int $time
+     * @param int $atime
+     * @return bool
      * @access public
      */
-    function chmod($mode, $filename)
+    function touch($filename, $time = null, $atime = null)
     {
-        if (!($this->bitmap & NET_SSH2_MASK_LOGIN)) {
+        if (!($this->bitmap & SSH2::MASK_LOGIN)) {
             return false;
         }
 
@@ -750,32 +1401,102 @@ class Net_SFTP extends Net_SSH2 {
             return false;
         }
 
-        // SFTPv4+ has an additional byte field - type - that would need to be sent, as well. setting it to
-        // SSH_FILEXFER_TYPE_UNKNOWN might work. if not, we'd have to do an SSH_FXP_STAT before doing an SSH_FXP_SETSTAT.
-        $attr = pack('N2', NET_SFTP_ATTR_PERMISSIONS, $mode & 07777);
-        if (!$this->_send_sftp_packet(NET_SFTP_SETSTAT, pack('Na*a*', strlen($filename), $filename, $attr))) {
-            return false;
+        if (!isset($time)) {
+            $time = time();
+        }
+        if (!isset($atime)) {
+            $atime = $time;
         }
 
-        /*
-         "Because some systems must use separate system calls to set various attributes, it is possible that a failure 
-          response will be returned, but yet some of the attributes may be have been successfully modified.  If possible,
-          servers SHOULD avoid this situation; however, clients MUST be aware that this is possible."
+        $flags = NET_SFTP_OPEN_WRITE | NET_SFTP_OPEN_CREATE | NET_SFTP_OPEN_EXCL;
+        $attr = pack('N3', NET_SFTP_ATTR_ACCESSTIME, $time, $atime);
+        $packet = pack('Na*Na*', strlen($filename), $filename, $flags, $attr);
+        if (!$this->_send_sftp_packet(NET_SFTP_OPEN, $packet)) {
+            return false;
+        }
 
-          -- http://tools.ietf.org/html/draft-ietf-secsh-filexfer-13#section-8.6
-        */
         $response = $this->_get_sftp_packet();
-        if ($this->packet_type != NET_SFTP_STATUS) {
-            user_error('Expected SSH_FXP_STATUS', E_USER_NOTICE);
-            return false;
+        switch ($this->packet_type) {
+            case NET_SFTP_HANDLE:
+                return $this->_close_handle(substr($response, 4));
+            case NET_SFTP_STATUS:
+                $this->_logError($response);
+                break;
+            default:
+                user_error('Expected SSH_FXP_HANDLE or SSH_FXP_STATUS');
+                return false;
         }
 
-        extract(unpack('Nstatus', $this->_string_shift($response, 4)));
-        if ($status != NET_SFTP_STATUS_EOF) {
-            extract(unpack('Nlength', $this->_string_shift($response, 4)));
-            $this->sftp_errors[] = $this->status_codes[$status] . ': ' . $this->_string_shift($response, $length);
+        return $this->_setstat($filename, $attr, false);
+    }
+
+    /**
+     * Changes file or directory owner
+     *
+     * Returns true on success or false on error.
+     *
+     * @param string $filename
+     * @param int $uid
+     * @param bool $recursive
+     * @return bool
+     * @access public
+     */
+    function chown($filename, $uid, $recursive = false)
+    {
+        // quoting from <http://www.kernel.org/doc/man-pages/online/pages/man2/chown.2.html>,
+        // "if the owner or group is specified as -1, then that ID is not changed"
+        $attr = pack('N3', NET_SFTP_ATTR_UIDGID, $uid, -1);
+
+        return $this->_setstat($filename, $attr, $recursive);
+    }
+
+    /**
+     * Changes file or directory group
+     *
+     * Returns true on success or false on error.
+     *
+     * @param string $filename
+     * @param int $gid
+     * @param bool $recursive
+     * @return bool
+     * @access public
+     */
+    function chgrp($filename, $gid, $recursive = false)
+    {
+        $attr = pack('N3', NET_SFTP_ATTR_UIDGID, -1, $gid);
+
+        return $this->_setstat($filename, $attr, $recursive);
+    }
+
+    /**
+     * Set permissions on a file.
+     *
+     * Returns the new file permissions on success or false on error.
+     * If $recursive is true than this just returns true or false.
+     *
+     * @param int $mode
+     * @param string $filename
+     * @param bool $recursive
+     * @return mixed
+     * @access public
+     */
+    function chmod($mode, $filename, $recursive = false)
+    {
+        if (is_string($mode) && is_int($filename)) {
+            $temp = $mode;
+            $mode = $filename;
+            $filename = $temp;
+        }
+
+        $attr = pack('N2', NET_SFTP_ATTR_PERMISSIONS, $mode & 07777);
+        if (!$this->_setstat($filename, $attr, $recursive)) {
+            return false;
+        }
+        if ($recursive) {
+            return true;
         }
 
+        $filename = $this->realpath($filename);
         // rather than return what the permissions *should* be, we'll return what they actually are.  this will also
         // tell us if the file actually exists.
         // incidentally, SFTPv4+ adds an additional 32-bit integer field - flags - to the following:
@@ -790,49 +1511,68 @@ class Net_SFTP extends Net_SSH2 {
                 $attrs = $this->_parseAttributes($response);
                 return $attrs['permissions'];
             case NET_SFTP_STATUS:
-                extract(unpack('Nstatus/Nlength', $this->_string_shift($response, 8)));
-                $this->sftp_errors[] = $this->status_codes[$status] . ': ' . $this->_string_shift($response, $length);
+                $this->_logError($response);
                 return false;
         }
 
-        user_error('Expected SSH_FXP_ATTRS or SSH_FXP_STATUS', E_USER_NOTICE);
+        user_error('Expected SSH_FXP_ATTRS or SSH_FXP_STATUS');
         return false;
     }
 
     /**
-     * Creates a directory.
+     * Sets information about a file
      *
-     * @param String $dir
-     * @return Boolean
-     * @access public
+     * @param string $filename
+     * @param string $attr
+     * @param bool $recursive
+     * @return bool
+     * @access private
      */
-    function mkdir($dir)
+    function _setstat($filename, $attr, $recursive)
     {
-        if (!($this->bitmap & NET_SSH2_MASK_LOGIN)) {
+        if (!($this->bitmap & SSH2::MASK_LOGIN)) {
             return false;
         }
 
-        $dir = $this->_realpath(rtrim($dir, '/'));
-        if ($dir === false) {
+        $filename = $this->_realpath($filename);
+        if ($filename === false) {
             return false;
         }
 
-        // by not providing any permissions, hopefully the server will use the logged in users umask - their 
-        // default permissions.
-        if (!$this->_send_sftp_packet(NET_SFTP_MKDIR, pack('Na*N', strlen($dir), $dir, 0))) {
+        $this->_remove_from_stat_cache($filename);
+
+        if ($recursive) {
+            $i = 0;
+            $result = $this->_setstat_recursive($filename, $attr, $i);
+            $this->_read_put_responses($i);
+            return $result;
+        }
+
+        // SFTPv4+ has an additional byte field - type - that would need to be sent, as well. setting it to
+        // SSH_FILEXFER_TYPE_UNKNOWN might work. if not, we'd have to do an SSH_FXP_STAT before doing an SSH_FXP_SETSTAT.
+        if (!$this->_send_sftp_packet(NET_SFTP_SETSTAT, pack('Na*a*', strlen($filename), $filename, $attr))) {
             return false;
         }
 
+        /*
+         "Because some systems must use separate system calls to set various attributes, it is possible that a failure
+          response will be returned, but yet some of the attributes may be have been successfully modified.  If possible,
+          servers SHOULD avoid this situation; however, clients MUST be aware that this is possible."
+
+          -- http://tools.ietf.org/html/draft-ietf-secsh-filexfer-13#section-8.6
+        */
         $response = $this->_get_sftp_packet();
         if ($this->packet_type != NET_SFTP_STATUS) {
-            user_error('Expected SSH_FXP_STATUS', E_USER_NOTICE);
+            user_error('Expected SSH_FXP_STATUS');
             return false;
         }
 
+        if (strlen($response) < 4) {
+            return false;
+        }
         extract(unpack('Nstatus', $this->_string_shift($response, 4)));
         if ($status != NET_SFTP_STATUS_OK) {
-            extract(unpack('Nlength', $this->_string_shift($response, 4)));
-            $this->sftp_errors[] = $this->status_codes[$status] . ': ' . $this->_string_shift($response, $length);
+            $this->_logError($response, $status);
             return false;
         }
 
@@ -840,38 +1580,226 @@ class Net_SFTP extends Net_SSH2 {
     }
 
     /**
-     * Removes a directory.
+     * Recursively sets information on directories on the SFTP server
      *
-     * @param String $dir
-     * @return Boolean
-     * @access public
+     * Minimizes directory lookups and SSH_FXP_STATUS requests for speed.
+     *
+     * @param string $path
+     * @param string $attr
+     * @param int $i
+     * @return bool
+     * @access private
      */
-    function rmdir($dir)
+    function _setstat_recursive($path, $attr, &$i)
     {
-        if (!($this->bitmap & NET_SSH2_MASK_LOGIN)) {
+        if (!$this->_read_put_responses($i)) {
             return false;
         }
+        $i = 0;
+        $entries = $this->_list($path, true);
 
-        $dir = $this->_realpath($dir);
-        if ($dir === false) {
-            return false;
+        if ($entries === false) {
+            return $this->_setstat($path, $attr, false);
         }
 
-        if (!$this->_send_sftp_packet(NET_SFTP_RMDIR, pack('Na*', strlen($dir), $dir))) {
+        // normally $entries would have at least . and .. but it might not if the directories
+        // permissions didn't allow reading
+        if (empty($entries)) {
             return false;
         }
 
-        $response = $this->_get_sftp_packet();
-        if ($this->packet_type != NET_SFTP_STATUS) {
-            user_error('Expected SSH_FXP_STATUS', E_USER_NOTICE);
-            return false;
-        }
+        unset($entries['.'], $entries['..']);
+        foreach ($entries as $filename => $props) {
+            if (!isset($props['type'])) {
+                return false;
+            }
 
-        extract(unpack('Nstatus', $this->_string_shift($response, 4)));
-        if ($status != NET_SFTP_STATUS_OK) {
-            // presumably SSH_FX_NO_SUCH_FILE or SSH_FX_PERMISSION_DENIED?
-            extract(unpack('Nlength', $this->_string_shift($response, 4)));
-            $this->sftp_errors[] = $this->status_codes[$status] . ': ' . $this->_string_shift($response, $length);
+            $temp = $path . '/' . $filename;
+            if ($props['type'] == NET_SFTP_TYPE_DIRECTORY) {
+                if (!$this->_setstat_recursive($temp, $attr, $i)) {
+                    return false;
+                }
+            } else {
+                if (!$this->_send_sftp_packet(NET_SFTP_SETSTAT, pack('Na*a*', strlen($temp), $temp, $attr))) {
+                    return false;
+                }
+
+                $i++;
+
+                if ($i >= NET_SFTP_QUEUE_SIZE) {
+                    if (!$this->_read_put_responses($i)) {
+                        return false;
+                    }
+                    $i = 0;
+                }
+            }
+        }
+
+        if (!$this->_send_sftp_packet(NET_SFTP_SETSTAT, pack('Na*a*', strlen($path), $path, $attr))) {
+            return false;
+        }
+
+        $i++;
+
+        if ($i >= NET_SFTP_QUEUE_SIZE) {
+            if (!$this->_read_put_responses($i)) {
+                return false;
+            }
+            $i = 0;
+        }
+
+        return true;
+    }
+
+    /**
+     * Return the target of a symbolic link
+     *
+     * @param string $link
+     * @return mixed
+     * @access public
+     */
+    function readlink($link)
+    {
+        if (!($this->bitmap & SSH2::MASK_LOGIN)) {
+            return false;
+        }
+
+        $link = $this->_realpath($link);
+
+        if (!$this->_send_sftp_packet(NET_SFTP_READLINK, pack('Na*', strlen($link), $link))) {
+            return false;
+        }
+
+        $response = $this->_get_sftp_packet();
+        switch ($this->packet_type) {
+            case NET_SFTP_NAME:
+                break;
+            case NET_SFTP_STATUS:
+                $this->_logError($response);
+                return false;
+            default:
+                user_error('Expected SSH_FXP_NAME or SSH_FXP_STATUS');
+                return false;
+        }
+
+        if (strlen($response) < 4) {
+            return false;
+        }
+        extract(unpack('Ncount', $this->_string_shift($response, 4)));
+        // the file isn't a symlink
+        if (!$count) {
+            return false;
+        }
+
+        if (strlen($response) < 4) {
+            return false;
+        }
+        extract(unpack('Nlength', $this->_string_shift($response, 4)));
+        return $this->_string_shift($response, $length);
+    }
+
+    /**
+     * Create a symlink
+     *
+     * symlink() creates a symbolic link to the existing target with the specified name link.
+     *
+     * @param string $target
+     * @param string $link
+     * @return bool
+     * @access public
+     */
+    function symlink($target, $link)
+    {
+        if (!($this->bitmap & SSH2::MASK_LOGIN)) {
+            return false;
+        }
+
+        //$target = $this->_realpath($target);
+        $link = $this->_realpath($link);
+
+        $packet = pack('Na*Na*', strlen($target), $target, strlen($link), $link);
+        if (!$this->_send_sftp_packet(NET_SFTP_SYMLINK, $packet)) {
+            return false;
+        }
+
+        $response = $this->_get_sftp_packet();
+        if ($this->packet_type != NET_SFTP_STATUS) {
+            user_error('Expected SSH_FXP_STATUS');
+            return false;
+        }
+
+        if (strlen($response) < 4) {
+            return false;
+        }
+        extract(unpack('Nstatus', $this->_string_shift($response, 4)));
+        if ($status != NET_SFTP_STATUS_OK) {
+            $this->_logError($response, $status);
+            return false;
+        }
+
+        return true;
+    }
+
+    /**
+     * Creates a directory.
+     *
+     * @param string $dir
+     * @return bool
+     * @access public
+     */
+    function mkdir($dir, $mode = -1, $recursive = false)
+    {
+        if (!($this->bitmap & SSH2::MASK_LOGIN)) {
+            return false;
+        }
+
+        $dir = $this->_realpath($dir);
+        // by not providing any permissions, hopefully the server will use the logged in users umask - their
+        // default permissions.
+        $attr = $mode == -1 ? "\0\0\0\0" : pack('N2', NET_SFTP_ATTR_PERMISSIONS, $mode & 07777);
+
+        if ($recursive) {
+            $dirs = explode('/', preg_replace('#/(?=/)|/$#', '', $dir));
+            if (empty($dirs[0])) {
+                array_shift($dirs);
+                $dirs[0] = '/' . $dirs[0];
+            }
+            for ($i = 0; $i < count($dirs); $i++) {
+                $temp = array_slice($dirs, 0, $i + 1);
+                $temp = implode('/', $temp);
+                $result = $this->_mkdir_helper($temp, $attr);
+            }
+            return $result;
+        }
+
+        return $this->_mkdir_helper($dir, $attr);
+    }
+
+    /**
+     * Helper function for directory creation
+     *
+     * @param string $dir
+     * @return bool
+     * @access private
+     */
+    function _mkdir_helper($dir, $attr)
+    {
+        if (!$this->_send_sftp_packet(NET_SFTP_MKDIR, pack('Na*a*', strlen($dir), $dir, $attr))) {
+            return false;
+        }
+
+        $response = $this->_get_sftp_packet();
+        if ($this->packet_type != NET_SFTP_STATUS) {
+            user_error('Expected SSH_FXP_STATUS');
+            return false;
+        }
+
+        if (strlen($response) < 4) {
+            return false;
+        }
+        extract(unpack('Nstatus', $this->_string_shift($response, 4)));
+        if ($status != NET_SFTP_STATUS_OK) {
+            $this->_logError($response, $status);
             return false;
         }
 
@@ -879,29 +1807,100 @@ class Net_SFTP extends Net_SSH2 {
     }
 
     /**
+     * Removes a directory.
+     *
+     * @param string $dir
+     * @return bool
+     * @access public
+     */
+    function rmdir($dir)
+    {
+        if (!($this->bitmap & SSH2::MASK_LOGIN)) {
+            return false;
+        }
+
+        $dir = $this->_realpath($dir);
+        if ($dir === false) {
+            return false;
+        }
+
+        if (!$this->_send_sftp_packet(NET_SFTP_RMDIR, pack('Na*', strlen($dir), $dir))) {
+            return false;
+        }
+
+        $response = $this->_get_sftp_packet();
+        if ($this->packet_type != NET_SFTP_STATUS) {
+            user_error('Expected SSH_FXP_STATUS');
+            return false;
+        }
+
+        if (strlen($response) < 4) {
+            return false;
+        }
+        extract(unpack('Nstatus', $this->_string_shift($response, 4)));
+        if ($status != NET_SFTP_STATUS_OK) {
+            // presumably SSH_FX_NO_SUCH_FILE or SSH_FX_PERMISSION_DENIED?
+            $this->_logError($response, $status);
+            return false;
+        }
+
+        $this->_remove_from_stat_cache($dir);
+        // the following will do a soft delete, which would be useful if you deleted a file
+        // and then tried to do a stat on the deleted file. the above, in contrast, does
+        // a hard delete
+        //$this->_update_stat_cache($dir, false);
+
+        return true;
+    }
+
+    /**
      * Uploads a file to the SFTP server.
      *
-     * By default, Net_SFTP::put() does not read from the local filesystem.  $data is dumped directly into $remote_file.
-     * So, for example, if you set $data to 'filename.ext' and then do Net_SFTP::get(), you will get a file, twelve bytes
+     * By default, \phpseclib\Net\SFTP::put() does not read from the local filesystem.  $data is dumped directly into $remote_file.
+     * So, for example, if you set $data to 'filename.ext' and then do \phpseclib\Net\SFTP::get(), you will get a file, twelve bytes
      * long, containing 'filename.ext' as its contents.
      *
-     * Setting $mode to NET_SFTP_LOCAL_FILE will change the above behavior.  With NET_SFTP_LOCAL_FILE, $remote_file will 
+     * Setting $mode to self::SOURCE_LOCAL_FILE will change the above behavior.  With self::SOURCE_LOCAL_FILE, $remote_file will
      * contain as many bytes as filename.ext does on your local filesystem.  If your filename.ext is 1MB then that is how
      * large $remote_file will be, as well.
      *
+     * Setting $mode to self::SOURCE_CALLBACK will use $data as callback function, which gets only one parameter -- number of bytes to return, and returns a string if there is some data or null if there is no more data
+     *
+     * If $data is a resource then it'll be used as a resource instead.
+     *
      * Currently, only binary mode is supported.  As such, if the line endings need to be adjusted, you will need to take
      * care of that, yourself.
      *
-     * @param String $remote_file
-     * @param String $data
-     * @param optional Integer $flags
-     * @return Boolean
+     * $mode can take an additional two parameters - self::RESUME and self::RESUME_START. These are bitwise AND'd with
+     * $mode. So if you want to resume upload of a 300mb file on the local file system you'd set $mode to the following:
+     *
+     * self::SOURCE_LOCAL_FILE | self::RESUME
+     *
+     * If you wanted to simply append the full contents of a local file to the full contents of a remote file you'd replace
+     * self::RESUME with self::RESUME_START.
+     *
+     * If $mode & (self::RESUME | self::RESUME_START) then self::RESUME_START will be assumed.
+     *
+     * $start and $local_start give you more fine grained control over this process and take precident over self::RESUME
+     * when they're non-negative. ie. $start could let you write at the end of a file (like self::RESUME) or in the middle
+     * of one. $local_start could let you start your reading from the end of a file (like self::RESUME_START) or in the
+     * middle of one.
+     *
+     * Setting $local_start to > 0 or $mode | self::RESUME_START doesn't do anything unless $mode | self::SOURCE_LOCAL_FILE.
+     *
+     * @param string $remote_file
+     * @param string|resource $data
+     * @param int $mode
+     * @param int $start
+     * @param int $local_start
+     * @param callable|null $progressCallback
+     * @return bool
      * @access public
-     * @internal ASCII mode for SFTPv4/5/6 can be supported by adding a new function - Net_SFTP::setMode().
+     * @internal ASCII mode for SFTPv4/5/6 can be supported by adding a new function - \phpseclib\Net\SFTP::setMode().
      */
-    function put($remote_file, $data, $mode = NET_SFTP_STRING)
+    function put($remote_file, $data, $mode = self::SOURCE_STRING, $start = -1, $local_start = -1, $progressCallback = null)
     {
-        if (!($this->bitmap & NET_SSH2_MASK_LOGIN)) {
+        if (!($this->bitmap & SSH2::MASK_LOGIN)) {
             return false;
         }
 
@@ -910,7 +1909,25 @@ class Net_SFTP extends Net_SSH2 {
             return false;
         }
 
-        $packet = pack('Na*N2', strlen($remote_file), $remote_file, NET_SFTP_OPEN_WRITE | NET_SFTP_OPEN_CREATE | NET_SFTP_OPEN_TRUNCATE, 0);
+        $this->_remove_from_stat_cache($remote_file);
+
+        $flags = NET_SFTP_OPEN_WRITE | NET_SFTP_OPEN_CREATE;
+        // according to the SFTP specs, NET_SFTP_OPEN_APPEND should "force all writes to append data at the end of the file."
+        // in practice, it doesn't seem to do that.
+        //$flags|= ($mode & self::RESUME) ? NET_SFTP_OPEN_APPEND : NET_SFTP_OPEN_TRUNCATE;
+
+        if ($start >= 0) {
+            $offset = $start;
+        } elseif ($mode & self::RESUME) {
+            // if NET_SFTP_OPEN_APPEND worked as it should _size() wouldn't need to be called
+            $size = $this->size($remote_file);
+            $offset = $size !== false ? $size : 0;
+        } else {
+            $offset = 0;
+            $flags|= NET_SFTP_OPEN_TRUNCATE;
+        }
+
+        $packet = pack('Na*N2', strlen($remote_file), $remote_file, $flags, 0);
         if (!$this->_send_sftp_packet(NET_SFTP_OPEN, $packet)) {
             return false;
         }
@@ -921,137 +1938,545 @@ class Net_SFTP extends Net_SSH2 {
                 $handle = substr($response, 4);
                 break;
             case NET_SFTP_STATUS:
-                extract(unpack('Nstatus/Nlength', $this->_string_shift($response, 8)));
-                $this->sftp_errors[] = $this->status_codes[$status] . ': ' . $this->_string_shift($response, $length);
+                $this->_logError($response);
                 return false;
             default:
-                user_error('Expected SSH_FXP_HANDLE or SSH_FXP_STATUS', E_USER_NOTICE);
+                user_error('Expected SSH_FXP_HANDLE or SSH_FXP_STATUS');
                 return false;
         }
 
-        $initialize = true;
-
         // http://tools.ietf.org/html/draft-ietf-secsh-filexfer-13#section-8.2.3
-        if ($mode == NET_SFTP_LOCAL_FILE) {
-            if (!is_file($data)) {
-                user_error("$data is not a valid file", E_USER_NOTICE);
+        $dataCallback = false;
+        switch (true) {
+            case $mode & self::SOURCE_CALLBACK:
+                if (!is_callable($data)) {
+                    user_error("\$data should be is_callable() if you specify SOURCE_CALLBACK flag");
+                }
+                $dataCallback = $data;
+                // do nothing
+                break;
+            case is_resource($data):
+                $mode = $mode & ~self::SOURCE_LOCAL_FILE;
+                $info = stream_get_meta_data($data);
+                if ($info['wrapper_type'] == 'PHP' && $info['stream_type'] == 'Input') {
+                    $fp = fopen('php://memory', 'w+');
+                    stream_copy_to_stream($data, $fp);
+                    rewind($fp);
+                } else {
+                    $fp = $data;
+                }
+                break;
+            case $mode & self::SOURCE_LOCAL_FILE:
+                if (!is_file($data)) {
+                    user_error("$data is not a valid file");
+                    return false;
+                }
+                $fp = @fopen($data, 'rb');
+                if (!$fp) {
+                    return false;
+                }
+        }
+
+        if (isset($fp)) {
+            $stat = fstat($fp);
+            $size = !empty($stat) ? $stat['size'] : 0;
+
+            if ($local_start >= 0) {
+                fseek($fp, $local_start);
+                $size-= $local_start;
+            }
+        } elseif ($dataCallback) {
+            $size = 0;
+        } else {
+            $size = strlen($data);
+        }
+
+        $sent = 0;
+        $size = $size < 0 ? ($size & 0x7FFFFFFF) + 0x80000000 : $size;
+
+        $sftp_packet_size = 4096; // PuTTY uses 4096
+        // make the SFTP packet be exactly 4096 bytes by including the bytes in the NET_SFTP_WRITE packets "header"
+        $sftp_packet_size-= strlen($handle) + 25;
+        $i = 0;
+        while ($dataCallback || ($size === 0 || $sent < $size)) {
+            if ($dataCallback) {
+                $temp = call_user_func($dataCallback, $sftp_packet_size);
+                if (is_null($temp)) {
+                    break;
+                }
+            } else {
+                $temp = isset($fp) ? fread($fp, $sftp_packet_size) : substr($data, $sent, $sftp_packet_size);
+                if ($temp === false || $temp === '') {
+                    break;
+                }
+            }
+
+            $subtemp = $offset + $sent;
+            $packet = pack('Na*N3a*', strlen($handle), $handle, $subtemp / 4294967296, $subtemp, strlen($temp), $temp);
+            if (!$this->_send_sftp_packet(NET_SFTP_WRITE, $packet)) {
+                if ($mode & self::SOURCE_LOCAL_FILE) {
+                    fclose($fp);
+                }
                 return false;
             }
-            $fp = fopen($data, 'rb');
-            if (!$fp) {
+            $sent+= strlen($temp);
+            if (is_callable($progressCallback)) {
+                call_user_func($progressCallback, $sent);
+            }
+
+            $i++;
+
+            if ($i == NET_SFTP_QUEUE_SIZE) {
+                if (!$this->_read_put_responses($i)) {
+                    $i = 0;
+                    break;
+                }
+                $i = 0;
+            }
+        }
+
+        if (!$this->_read_put_responses($i)) {
+            if ($mode & self::SOURCE_LOCAL_FILE) {
+                fclose($fp);
+            }
+            $this->_close_handle($handle);
+            return false;
+        }
+
+        if ($mode & self::SOURCE_LOCAL_FILE) {
+            fclose($fp);
+        }
+
+        return $this->_close_handle($handle);
+    }
+
+    /**
+     * Reads multiple successive SSH_FXP_WRITE responses
+     *
+     * Sending an SSH_FXP_WRITE packet and immediately reading its response isn't as efficient as blindly sending out $i
+     * SSH_FXP_WRITEs, in succession, and then reading $i responses.
+     *
+     * @param int $i
+     * @return bool
+     * @access private
+     */
+    function _read_put_responses($i)
+    {
+        while ($i--) {
+            $response = $this->_get_sftp_packet();
+            if ($this->packet_type != NET_SFTP_STATUS) {
+                user_error('Expected SSH_FXP_STATUS');
+                return false;
+            }
+
+            if (strlen($response) < 4) {
                 return false;
             }
-            $sent = 0;
-            $size = filesize($data);
+            extract(unpack('Nstatus', $this->_string_shift($response, 4)));
+            if ($status != NET_SFTP_STATUS_OK) {
+                $this->_logError($response, $status);
+                break;
+            }
+        }
+
+        return $i < 0;
+    }
+
+    /**
+     * Close handle
+     *
+     * @param string $handle
+     * @return bool
+     * @access private
+     */
+    function _close_handle($handle)
+    {
+        if (!$this->_send_sftp_packet(NET_SFTP_CLOSE, pack('Na*', strlen($handle), $handle))) {
+            return false;
+        }
+
+        // "The client MUST release all resources associated with the handle regardless of the status."
+        //  -- http://tools.ietf.org/html/draft-ietf-secsh-filexfer-13#section-8.1.3
+        $response = $this->_get_sftp_packet();
+        if ($this->packet_type != NET_SFTP_STATUS) {
+            user_error('Expected SSH_FXP_STATUS');
+            return false;
+        }
+
+        if (strlen($response) < 4) {
+            return false;
+        }
+        extract(unpack('Nstatus', $this->_string_shift($response, 4)));
+        if ($status != NET_SFTP_STATUS_OK) {
+            $this->_logError($response, $status);
+            return false;
+        }
+
+        return true;
+    }
+
+    /**
+     * Downloads a file from the SFTP server.
+     *
+     * Returns a string containing the contents of $remote_file if $local_file is left undefined or a boolean false if
+     * the operation was unsuccessful.  If $local_file is defined, returns true or false depending on the success of the
+     * operation.
+     *
+     * $offset and $length can be used to download files in chunks.
+     *
+     * @param string $remote_file
+     * @param string $local_file
+     * @param int $offset
+     * @param int $length
+     * @return mixed
+     * @access public
+     */
+    function get($remote_file, $local_file = false, $offset = 0, $length = -1)
+    {
+        if (!($this->bitmap & SSH2::MASK_LOGIN)) {
+            return false;
+        }
+
+        $remote_file = $this->_realpath($remote_file);
+        if ($remote_file === false) {
+            return false;
+        }
+
+        $packet = pack('Na*N2', strlen($remote_file), $remote_file, NET_SFTP_OPEN_READ, 0);
+        if (!$this->_send_sftp_packet(NET_SFTP_OPEN, $packet)) {
+            return false;
+        }
+
+        $response = $this->_get_sftp_packet();
+        switch ($this->packet_type) {
+            case NET_SFTP_HANDLE:
+                $handle = substr($response, 4);
+                break;
+            case NET_SFTP_STATUS: // presumably SSH_FX_NO_SUCH_FILE or SSH_FX_PERMISSION_DENIED
+                $this->_logError($response);
+                return false;
+            default:
+                user_error('Expected SSH_FXP_HANDLE or SSH_FXP_STATUS');
+                return false;
+        }
+
+        if (is_resource($local_file)) {
+            $fp = $local_file;
+            $stat = fstat($fp);
+            $res_offset = $stat['size'];
         } else {
-            $sent = 0;
-            $size = strlen($data);
+            $res_offset = 0;
+            if ($local_file !== false) {
+                $fp = fopen($local_file, 'wb');
+                if (!$fp) {
+                    return false;
+                }
+            } else {
+                $content = '';
+            }
+        }
+
+        $fclose_check = $local_file !== false && !is_resource($local_file);
+
+        $start = $offset;
+        $read = 0;
+        while (true) {
+            $i = 0;
+
+            while ($i < NET_SFTP_QUEUE_SIZE && ($length < 0 || $read < $length)) {
+                $tempoffset = $start + $read;
+
+                $packet_size = $length > 0 ? min($this->max_sftp_packet, $length - $read) : $this->max_sftp_packet;
+
+                $packet = pack('Na*N3', strlen($handle), $handle, $tempoffset / 4294967296, $tempoffset, $packet_size);
+                if (!$this->_send_sftp_packet(NET_SFTP_READ, $packet)) {
+                    if ($fclose_check) {
+                        fclose($fp);
+                    }
+                    return false;
+                }
+                $packet = null;
+                $read+= $packet_size;
+                $i++;
+            }
+
+            if (!$i) {
+                break;
+            }
+
+            $clear_responses = false;
+            while ($i > 0) {
+                $i--;
+
+                if ($clear_responses) {
+                    $this->_get_sftp_packet();
+                    continue;
+                } else {
+                    $response = $this->_get_sftp_packet();
+                }
+
+                switch ($this->packet_type) {
+                    case NET_SFTP_DATA:
+                        $temp = substr($response, 4);
+                        $offset+= strlen($temp);
+                        if ($local_file === false) {
+                            $content.= $temp;
+                        } else {
+                            fputs($fp, $temp);
+                        }
+                        $temp = null;
+                        break;
+                    case NET_SFTP_STATUS:
+                        // could, in theory, return false if !strlen($content) but we'll hold off for the time being
+                        $this->_logError($response);
+                        $clear_responses = true; // don't break out of the loop yet, so we can read the remaining responses
+                        break;
+                    default:
+                        if ($fclose_check) {
+                            fclose($fp);
+                        }
+                        user_error('Expected SSH_FX_DATA or SSH_FXP_STATUS');
+                }
+                $response = null;
+            }
+
+            if ($clear_responses) {
+                break;
+            }
+        }
+
+        if ($length > 0 && $length <= $offset - $start) {
+            if ($local_file === false) {
+                $content = substr($content, 0, $length);
+            } else {
+                ftruncate($fp, $length + $res_offset);
+            }
+        }
+
+        if ($fclose_check) {
+            fclose($fp);
+        }
+
+        if (!$this->_close_handle($handle)) {
+            return false;
+        }
+
+        // if $content isn't set that means a file was written to
+        return isset($content) ? $content : true;
+    }
+
+    /**
+     * Deletes a file on the SFTP server.
+     *
+     * @param string $path
+     * @param bool $recursive
+     * @return bool
+     * @access public
+     */
+    function delete($path, $recursive = true)
+    {
+        if (!($this->bitmap & SSH2::MASK_LOGIN)) {
+            return false;
+        }
+
+        if (is_object($path)) {
+            // It's an object. Cast it as string before we check anything else.
+            $path = (string) $path;
+        }
+
+        if (!is_string($path) || $path == '') {
+            return false;
+        }
+
+        $path = $this->_realpath($path);
+        if ($path === false) {
+            return false;
+        }
+
+        // http://tools.ietf.org/html/draft-ietf-secsh-filexfer-13#section-8.3
+        if (!$this->_send_sftp_packet(NET_SFTP_REMOVE, pack('Na*', strlen($path), $path))) {
+            return false;
+        }
+
+        $response = $this->_get_sftp_packet();
+        if ($this->packet_type != NET_SFTP_STATUS) {
+            user_error('Expected SSH_FXP_STATUS');
+            return false;
+        }
+
+        // if $status isn't SSH_FX_OK it's probably SSH_FX_NO_SUCH_FILE or SSH_FX_PERMISSION_DENIED
+        if (strlen($response) < 4) {
+            return false;
+        }
+        extract(unpack('Nstatus', $this->_string_shift($response, 4)));
+        if ($status != NET_SFTP_STATUS_OK) {
+            $this->_logError($response, $status);
+            if (!$recursive) {
+                return false;
+            }
+            $i = 0;
+            $result = $this->_delete_recursive($path, $i);
+            $this->_read_put_responses($i);
+            return $result;
+        }
+
+        $this->_remove_from_stat_cache($path);
+
+        return true;
+    }
+
+    /**
+     * Recursively deletes directories on the SFTP server
+     *
+     * Minimizes directory lookups and SSH_FXP_STATUS requests for speed.
+     *
+     * @param string $path
+     * @param int $i
+     * @return bool
+     * @access private
+     */
+    function _delete_recursive($path, &$i)
+    {
+        if (!$this->_read_put_responses($i)) {
+            return false;
         }
+        $i = 0;
+        $entries = $this->_list($path, true);
 
-        $size = $size < 0 ? ($size & 0x7FFFFFFF) + 0x80000000 : $size;
+        // normally $entries would have at least . and .. but it might not if the directories
+        // permissions didn't allow reading
+        if (empty($entries)) {
+            return false;
+        }
 
-        $sftp_packet_size = 34000; // PuTTY uses 4096
-        $i = 0;
-        while ($sent < $size) {
-            $temp = $mode == NET_SFTP_LOCAL_FILE ? fread($fp, $sftp_packet_size) : $this->_string_shift($data, $sftp_packet_size);
-            $packet = pack('Na*N3a*', strlen($handle), $handle, 0, $sent, strlen($temp), $temp);
-            if (!$this->_send_sftp_packet(NET_SFTP_WRITE, $packet)) {
-                fclose($fp);
+        unset($entries['.'], $entries['..']);
+        foreach ($entries as $filename => $props) {
+            if (!isset($props['type'])) {
                 return false;
             }
-            $sent+= strlen($temp);
 
-            $i++;
+            $temp = $path . '/' . $filename;
+            if ($props['type'] == NET_SFTP_TYPE_DIRECTORY) {
+                if (!$this->_delete_recursive($temp, $i)) {
+                    return false;
+                }
+            } else {
+                if (!$this->_send_sftp_packet(NET_SFTP_REMOVE, pack('Na*', strlen($temp), $temp))) {
+                    return false;
+                }
+                $this->_remove_from_stat_cache($temp);
 
-            if ($i == 50) {
-                if (!$this->_read_put_responses($i)) {
+                $i++;
+
+                if ($i >= NET_SFTP_QUEUE_SIZE) {
+                    if (!$this->_read_put_responses($i)) {
+                        return false;
+                    }
                     $i = 0;
-                    break;
                 }
-                $i = 0;
             }
         }
 
-        $this->_read_put_responses($i);
-
-        if ($mode == NET_SFTP_LOCAL_FILE) {
-            fclose($fp);
-        }
-
-        if (!$this->_send_sftp_packet(NET_SFTP_CLOSE, pack('Na*', strlen($handle), $handle))) {
+        if (!$this->_send_sftp_packet(NET_SFTP_RMDIR, pack('Na*', strlen($path), $path))) {
             return false;
         }
+        $this->_remove_from_stat_cache($path);
 
-        $response = $this->_get_sftp_packet();
-        if ($this->packet_type != NET_SFTP_STATUS) {
-            user_error('Expected SSH_FXP_STATUS', E_USER_NOTICE);
-            return false;
-        }
+        $i++;
 
-        extract(unpack('Nstatus', $this->_string_shift($response, 4)));
-        if ($status != NET_SFTP_STATUS_OK) {
-            extract(unpack('Nlength', $this->_string_shift($response, 4)));
-            $this->sftp_errors[] = $this->status_codes[$status] . ': ' . $this->_string_shift($response, $length);
-            return false;
+        if ($i >= NET_SFTP_QUEUE_SIZE) {
+            if (!$this->_read_put_responses($i)) {
+                return false;
+            }
+            $i = 0;
         }
 
         return true;
     }
 
     /**
-     * Reads multiple successive SSH_FXP_WRITE responses
+     * Checks whether a file or directory exists
      *
-     * Sending an SSH_FXP_WRITE packet and immediately reading its response isn't as efficient as blindly sending out $i
-     * SSH_FXP_WRITEs, in succession, and then reading $i responses.
-     *
-     * @param Integer $i
-     * @return Boolean
-     * @access private
+     * @param string $path
+     * @return bool
+     * @access public
      */
-    function _read_put_responses($i)
+    function file_exists($path)
     {
-        while ($i--) {
-            $response = $this->_get_sftp_packet();
-            if ($this->packet_type != NET_SFTP_STATUS) {
-                user_error('Expected SSH_FXP_STATUS', E_USER_NOTICE);
-                return false;
-            }
+        if ($this->use_stat_cache) {
+            $path = $this->_realpath($path);
 
-            extract(unpack('Nstatus', $this->_string_shift($response, 4)));
-            if ($status != NET_SFTP_STATUS_OK) {
-                extract(unpack('Nlength', $this->_string_shift($response, 4)));
-                $this->sftp_errors[] = $this->status_codes[$status] . ': ' . $this->_string_shift($response, $length);
-                break;
+            $result = $this->_query_stat_cache($path);
+
+            if (isset($result)) {
+                // return true if $result is an array or if it's an stdClass object
+                return $result !== false;
             }
         }
 
-        return $i < 0;
+        return $this->stat($path) !== false;
     }
 
     /**
-     * Downloads a file from the SFTP server.
+     * Tells whether the filename is a directory
      *
-     * Returns a string containing the contents of $remote_file if $local_file is left undefined or a boolean false if
-     * the operation was unsuccessful.  If $local_file is defined, returns true or false depending on the success of the
-     * operation
+     * @param string $path
+     * @return bool
+     * @access public
+     */
+    function is_dir($path)
+    {
+        $result = $this->_get_stat_cache_prop($path, 'type');
+        if ($result === false) {
+            return false;
+        }
+        return $result === NET_SFTP_TYPE_DIRECTORY;
+    }
+
+    /**
+     * Tells whether the filename is a regular file
      *
-     * @param String $remote_file
-     * @param optional String $local_file
-     * @return Mixed
+     * @param string $path
+     * @return bool
      * @access public
      */
-    function get($remote_file, $local_file = false)
+    function is_file($path)
     {
-        if (!($this->bitmap & NET_SSH2_MASK_LOGIN)) {
+        $result = $this->_get_stat_cache_prop($path, 'type');
+        if ($result === false) {
             return false;
         }
+        return $result === NET_SFTP_TYPE_REGULAR;
+    }
 
-        $remote_file = $this->_realpath($remote_file);
-        if ($remote_file === false) {
+    /**
+     * Tells whether the filename is a symbolic link
+     *
+     * @param string $path
+     * @return bool
+     * @access public
+     */
+    function is_link($path)
+    {
+        $result = $this->_get_lstat_cache_prop($path, 'type');
+        if ($result === false) {
             return false;
         }
+        return $result === NET_SFTP_TYPE_SYMLINK;
+    }
 
-        $packet = pack('Na*N2', strlen($remote_file), $remote_file, NET_SFTP_OPEN_READ, 0);
+    /**
+     * Tells whether a file exists and is readable
+     *
+     * @param string $path
+     * @return bool
+     * @access public
+     */
+    function is_readable($path)
+    {
+        $path = $this->_realpath($path);
+
+        $packet = pack('Na*N2', strlen($path), $path, NET_SFTP_OPEN_READ, 0);
         if (!$this->_send_sftp_packet(NET_SFTP_OPEN, $packet)) {
             return false;
         }
@@ -1059,149 +2484,233 @@ class Net_SFTP extends Net_SSH2 {
         $response = $this->_get_sftp_packet();
         switch ($this->packet_type) {
             case NET_SFTP_HANDLE:
-                $handle = substr($response, 4);
-                break;
+                return true;
             case NET_SFTP_STATUS: // presumably SSH_FX_NO_SUCH_FILE or SSH_FX_PERMISSION_DENIED
-                extract(unpack('Nstatus/Nlength', $this->_string_shift($response, 8)));
-                $this->sftp_errors[] = $this->status_codes[$status] . ': ' . $this->_string_shift($response, $length);
                 return false;
             default:
-                user_error('Expected SSH_FXP_HANDLE or SSH_FXP_STATUS', E_USER_NOTICE);
+                user_error('Expected SSH_FXP_HANDLE or SSH_FXP_STATUS');
                 return false;
         }
+    }
+
+    /**
+     * Tells whether the filename is writable
+     *
+     * @param string $path
+     * @return bool
+     * @access public
+     */
+    function is_writable($path)
+    {
+        $path = $this->_realpath($path);
 
-        $packet = pack('Na*', strlen($handle), $handle);
-        if (!$this->_send_sftp_packet(NET_SFTP_FSTAT, $packet)) {
+        $packet = pack('Na*N2', strlen($path), $path, NET_SFTP_OPEN_WRITE, 0);
+        if (!$this->_send_sftp_packet(NET_SFTP_OPEN, $packet)) {
             return false;
         }
 
         $response = $this->_get_sftp_packet();
         switch ($this->packet_type) {
-            case NET_SFTP_ATTRS:
-                $attrs = $this->_parseAttributes($response);
-                break;
-            case NET_SFTP_STATUS:
-                extract(unpack('Nstatus/Nlength', $this->_string_shift($response, 8)));
-                $this->sftp_errors[] = $this->status_codes[$status] . ': ' . $this->_string_shift($response, $length);
+            case NET_SFTP_HANDLE:
+                return true;
+            case NET_SFTP_STATUS: // presumably SSH_FX_NO_SUCH_FILE or SSH_FX_PERMISSION_DENIED
                 return false;
             default:
-                user_error('Expected SSH_FXP_ATTRS or SSH_FXP_STATUS', E_USER_NOTICE);
-                return false;
-        }
-
-        if ($local_file !== false) {
-            $fp = fopen($local_file, 'wb');
-            if (!$fp) {
+                user_error('Expected SSH_FXP_HANDLE or SSH_FXP_STATUS');
                 return false;
-            }
-        } else {
-            $content = '';
         }
+    }
 
-        $read = 0;
-        while ($read < $attrs['size']) {
-            $packet = pack('Na*N3', strlen($handle), $handle, 0, $read, 1 << 20);
-            if (!$this->_send_sftp_packet(NET_SFTP_READ, $packet)) {
-                return false;
-            }
+    /**
+     * Tells whether the filename is writeable
+     *
+     * Alias of is_writable
+     *
+     * @param string $path
+     * @return bool
+     * @access public
+     */
+    function is_writeable($path)
+    {
+        return $this->is_writable($path);
+    }
 
-            $response = $this->_get_sftp_packet();
-            switch ($this->packet_type) {
-                case NET_SFTP_DATA:
-                    $temp = substr($response, 4);
-                    $read+= strlen($temp);
-                    if ($local_file === false) {
-                        $content.= $temp;
-                    } else {
-                        fputs($fp, $temp);
-                    }
-                    break;
-                case NET_SFTP_STATUS:
-                    extract(unpack('Nstatus/Nlength', $this->_string_shift($response, 8)));
-                    $this->sftp_errors[] = $this->status_codes[$status] . ': ' . $this->_string_shift($response, $length);
-                    break 2;
-                default:
-                    user_error('Expected SSH_FXP_DATA or SSH_FXP_STATUS', E_USER_NOTICE);
-                    return false;
-            }
-        }
+    /**
+     * Gets last access time of file
+     *
+     * @param string $path
+     * @return mixed
+     * @access public
+     */
+    function fileatime($path)
+    {
+        return $this->_get_stat_cache_prop($path, 'atime');
+    }
 
-        if (!$this->_send_sftp_packet(NET_SFTP_CLOSE, pack('Na*', strlen($handle), $handle))) {
-            return false;
-        }
+    /**
+     * Gets file modification time
+     *
+     * @param string $path
+     * @return mixed
+     * @access public
+     */
+    function filemtime($path)
+    {
+        return $this->_get_stat_cache_prop($path, 'mtime');
+    }
 
-        $response = $this->_get_sftp_packet();
-        if ($this->packet_type != NET_SFTP_STATUS) {
-            user_error('Expected SSH_FXP_STATUS', E_USER_NOTICE);
-            return false;
-        }
+    /**
+     * Gets file permissions
+     *
+     * @param string $path
+     * @return mixed
+     * @access public
+     */
+    function fileperms($path)
+    {
+        return $this->_get_stat_cache_prop($path, 'permissions');
+    }
 
-        extract(unpack('Nstatus', $this->_string_shift($response, 4)));
-        if ($status != NET_SFTP_STATUS_OK) {
-            extract(unpack('Nlength', $this->_string_shift($response, 4)));
-            $this->sftp_errors[] = $this->status_codes[$status] . ': ' . $this->_string_shift($response, $length);
-            return false;
-        }
+    /**
+     * Gets file owner
+     *
+     * @param string $path
+     * @return mixed
+     * @access public
+     */
+    function fileowner($path)
+    {
+        return $this->_get_stat_cache_prop($path, 'uid');
+    }
 
-        if (isset($content)) {
-            return $content;
-        }
+    /**
+     * Gets file group
+     *
+     * @param string $path
+     * @return mixed
+     * @access public
+     */
+    function filegroup($path)
+    {
+        return $this->_get_stat_cache_prop($path, 'gid');
+    }
 
-        fclose($fp);
-        return true;
+    /**
+     * Gets file size
+     *
+     * @param string $path
+     * @return mixed
+     * @access public
+     */
+    function filesize($path)
+    {
+        return $this->_get_stat_cache_prop($path, 'size');
     }
 
     /**
-     * Deletes a file on the SFTP server.
+     * Gets file type
      *
-     * @param String $path
-     * @return Boolean
+     * @param string $path
+     * @return mixed
      * @access public
      */
-    function delete($path)
+    function filetype($path)
     {
-        if (!($this->bitmap & NET_SSH2_MASK_LOGIN)) {
+        $type = $this->_get_stat_cache_prop($path, 'type');
+        if ($type === false) {
             return false;
         }
 
-        $remote_file = $this->_realpath($path);
-        if ($path === false) {
-            return false;
+        switch ($type) {
+            case NET_SFTP_TYPE_BLOCK_DEVICE:
+                return 'block';
+            case NET_SFTP_TYPE_CHAR_DEVICE:
+                return 'char';
+            case NET_SFTP_TYPE_DIRECTORY:
+                return 'dir';
+            case NET_SFTP_TYPE_FIFO:
+                return 'fifo';
+            case NET_SFTP_TYPE_REGULAR:
+                return 'file';
+            case NET_SFTP_TYPE_SYMLINK:
+                return 'link';
+            default:
+                return false;
         }
+    }
 
-        // http://tools.ietf.org/html/draft-ietf-secsh-filexfer-13#section-8.3
-        if (!$this->_send_sftp_packet(NET_SFTP_REMOVE, pack('Na*', strlen($path), $path))) {
-            return false;
-        }
+    /**
+     * Return a stat properity
+     *
+     * Uses cache if appropriate.
+     *
+     * @param string $path
+     * @param string $prop
+     * @return mixed
+     * @access private
+     */
+    function _get_stat_cache_prop($path, $prop)
+    {
+        return $this->_get_xstat_cache_prop($path, $prop, 'stat');
+    }
 
-        $response = $this->_get_sftp_packet();
-        if ($this->packet_type != NET_SFTP_STATUS) {
-            user_error('Expected SSH_FXP_STATUS', E_USER_NOTICE);
-            return false;
+    /**
+     * Return an lstat properity
+     *
+     * Uses cache if appropriate.
+     *
+     * @param string $path
+     * @param string $prop
+     * @return mixed
+     * @access private
+     */
+    function _get_lstat_cache_prop($path, $prop)
+    {
+        return $this->_get_xstat_cache_prop($path, $prop, 'lstat');
+    }
+
+    /**
+     * Return a stat or lstat properity
+     *
+     * Uses cache if appropriate.
+     *
+     * @param string $path
+     * @param string $prop
+     * @return mixed
+     * @access private
+     */
+    function _get_xstat_cache_prop($path, $prop, $type)
+    {
+        if ($this->use_stat_cache) {
+            $path = $this->_realpath($path);
+
+            $result = $this->_query_stat_cache($path);
+
+            if (is_object($result) && isset($result->$type)) {
+                return $result->{$type}[$prop];
+            }
         }
 
-        // if $status isn't SSH_FX_OK it's probably SSH_FX_NO_SUCH_FILE or SSH_FX_PERMISSION_DENIED
-        extract(unpack('Nstatus', $this->_string_shift($response, 4)));
-        if ($status != NET_SFTP_STATUS_OK) {
-            extract(unpack('Nlength', $this->_string_shift($response, 4)));
-            $this->sftp_errors[] = $this->status_codes[$status] . ': ' . $this->_string_shift($response, $length);
+        $result = $this->$type($path);
+
+        if ($result === false || !isset($result[$prop])) {
             return false;
         }
 
-        return true;
+        return $result[$prop];
     }
 
     /**
      * Renames a file or a directory on the SFTP server
      *
-     * @param String $oldname
-     * @param String $newname
-     * @return Boolean
+     * @param string $oldname
+     * @param string $newname
+     * @return bool
      * @access public
      */
     function rename($oldname, $newname)
     {
-        if (!($this->bitmap & NET_SSH2_MASK_LOGIN)) {
+        if (!($this->bitmap & SSH2::MASK_LOGIN)) {
             return false;
         }
 
@@ -1219,18 +2728,26 @@ class Net_SFTP extends Net_SSH2 {
 
         $response = $this->_get_sftp_packet();
         if ($this->packet_type != NET_SFTP_STATUS) {
-            user_error('Expected SSH_FXP_STATUS', E_USER_NOTICE);
+            user_error('Expected SSH_FXP_STATUS');
             return false;
         }
 
         // if $status isn't SSH_FX_OK it's probably SSH_FX_NO_SUCH_FILE or SSH_FX_PERMISSION_DENIED
+        if (strlen($response) < 4) {
+            return false;
+        }
         extract(unpack('Nstatus', $this->_string_shift($response, 4)));
         if ($status != NET_SFTP_STATUS_OK) {
-            extract(unpack('Nlength', $this->_string_shift($response, 4)));
-            $this->sftp_errors[] = $this->status_codes[$status] . ': ' . $this->_string_shift($response, $length);
+            $this->_logError($response, $status);
             return false;
         }
 
+        // don't move the stat cache entry over since this operation could very well change the
+        // atime and mtime attributes
+        //$this->_update_stat_cache($newname, $this->_query_stat_cache($oldname));
+        $this->_remove_from_stat_cache($oldname);
+        $this->_remove_from_stat_cache($newname);
+
         return true;
     }
 
@@ -1239,46 +2756,77 @@ class Net_SFTP extends Net_SSH2 {
      *
      * See '7.  File Attributes' of draft-ietf-secsh-filexfer-13 for more info.
      *
-     * @param String $response
-     * @return Array
+     * @param string $response
+     * @return array
      * @access private
      */
     function _parseAttributes(&$response)
     {
         $attr = array();
+        if (strlen($response) < 4) {
+            user_error('Malformed file attributes');
+            return array();
+        }
         extract(unpack('Nflags', $this->_string_shift($response, 4)));
         // SFTPv4+ have a type field (a byte) that follows the above flag field
         foreach ($this->attributes as $key => $value) {
             switch ($flags & $key) {
                 case NET_SFTP_ATTR_SIZE: // 0x00000001
-                    // size is represented by a 64-bit integer, so we perhaps ought to be doing the following:
-                    // $attr['size'] = new Math_BigInteger($this->_string_shift($response, 8), 256);
-                    // of course, you shouldn't be using Net_SFTP to transfer files that are in excess of 4GB
-                    // (0xFFFFFFFF bytes), anyway.  as such, we'll just represent all file sizes that are bigger than
-                    // 4GB as being 4GB.
-                    extract(unpack('Nupper/Nsize', $this->_string_shift($response, 8)));
-                    if ($upper) {
-                        $attr['size'] = 0xFFFFFFFF;
-                    } else {
-                        $attr['size'] = $size < 0 ? ($size & 0x7FFFFFFF) + 0x80000000 : $size;
-                    }
+                    // The size attribute is defined as an unsigned 64-bit integer.
+                    // The following will use floats on 32-bit platforms, if necessary.
+                    // As can be seen in the BigInteger class, floats are generally
+                    // IEEE 754 binary64 "double precision" on such platforms and
+                    // as such can represent integers of at least 2^50 without loss
+                    // of precision. Interpreted in filesize, 2^50 bytes = 1024 TiB.
+                    $attr['size'] = hexdec(bin2hex($this->_string_shift($response, 8)));
                     break;
                 case NET_SFTP_ATTR_UIDGID: // 0x00000002 (SFTPv3 only)
+                    if (strlen($response) < 8) {
+                        user_error('Malformed file attributes');
+                        return $attr;
+                    }
                     $attr+= unpack('Nuid/Ngid', $this->_string_shift($response, 8));
                     break;
                 case NET_SFTP_ATTR_PERMISSIONS: // 0x00000004
+                    if (strlen($response) < 4) {
+                        user_error('Malformed file attributes');
+                        return $attr;
+                    }
                     $attr+= unpack('Npermissions', $this->_string_shift($response, 4));
+                    // mode == permissions; permissions was the original array key and is retained for bc purposes.
+                    // mode was added because that's the more industry standard terminology
+                    $attr+= array('mode' => $attr['permissions']);
+                    $fileType = $this->_parseMode($attr['permissions']);
+                    if ($fileType !== false) {
+                        $attr+= array('type' => $fileType);
+                    }
                     break;
                 case NET_SFTP_ATTR_ACCESSTIME: // 0x00000008
+                    if (strlen($response) < 8) {
+                        user_error('Malformed file attributes');
+                        return $attr;
+                    }
                     $attr+= unpack('Natime/Nmtime', $this->_string_shift($response, 8));
                     break;
                 case NET_SFTP_ATTR_EXTENDED: // 0x80000000
+                    if (strlen($response) < 4) {
+                        user_error('Malformed file attributes');
+                        return $attr;
+                    }
                     extract(unpack('Ncount', $this->_string_shift($response, 4)));
                     for ($i = 0; $i < $count; $i++) {
+                        if (strlen($response) < 4) {
+                            user_error('Malformed file attributes');
+                            return $attr;
+                        }
                         extract(unpack('Nlength', $this->_string_shift($response, 4)));
                         $key = $this->_string_shift($response, $length);
+                        if (strlen($response) < 4) {
+                            user_error('Malformed file attributes');
+                            return $attr;
+                        }
                         extract(unpack('Nlength', $this->_string_shift($response, 4)));
-                        $attr[$key] = $this->_string_shift($response, $length);                        
+                        $attr[$key] = $this->_string_shift($response, $length);
                     }
             }
         }
@@ -1286,15 +2834,91 @@ class Net_SFTP extends Net_SSH2 {
     }
 
     /**
+     * Attempt to identify the file type
+     *
+     * Quoting the SFTP RFC, "Implementations MUST NOT send bits that are not defined" but they seem to anyway
+     *
+     * @param int $mode
+     * @return int
+     * @access private
+     */
+    function _parseMode($mode)
+    {
+        // values come from http://lxr.free-electrons.com/source/include/uapi/linux/stat.h#L12
+        // see, also, http://linux.die.net/man/2/stat
+        switch ($mode & 0170000) {// ie. 1111 0000 0000 0000
+            case 0000000: // no file type specified - figure out the file type using alternative means
+                return false;
+            case 0040000:
+                return NET_SFTP_TYPE_DIRECTORY;
+            case 0100000:
+                return NET_SFTP_TYPE_REGULAR;
+            case 0120000:
+                return NET_SFTP_TYPE_SYMLINK;
+            // new types introduced in SFTPv5+
+            // http://tools.ietf.org/html/draft-ietf-secsh-filexfer-05#section-5.2
+            case 0010000: // named pipe (fifo)
+                return NET_SFTP_TYPE_FIFO;
+            case 0020000: // character special
+                return NET_SFTP_TYPE_CHAR_DEVICE;
+            case 0060000: // block special
+                return NET_SFTP_TYPE_BLOCK_DEVICE;
+            case 0140000: // socket
+                return NET_SFTP_TYPE_SOCKET;
+            case 0160000: // whiteout
+                // "SPECIAL should be used for files that are of
+                //  a known type which cannot be expressed in the protocol"
+                return NET_SFTP_TYPE_SPECIAL;
+            default:
+                return NET_SFTP_TYPE_UNKNOWN;
+        }
+    }
+
+    /**
+     * Parse Longname
+     *
+     * SFTPv3 doesn't provide any easy way of identifying a file type.  You could try to open
+     * a file as a directory and see if an error is returned or you could try to parse the
+     * SFTPv3-specific longname field of the SSH_FXP_NAME packet.  That's what this function does.
+     * The result is returned using the
+     * {@link http://tools.ietf.org/html/draft-ietf-secsh-filexfer-04#section-5.2 SFTPv4 type constants}.
+     *
+     * If the longname is in an unrecognized format bool(false) is returned.
+     *
+     * @param string $longname
+     * @return mixed
+     * @access private
+     */
+    function _parseLongname($longname)
+    {
+        // http://en.wikipedia.org/wiki/Unix_file_types
+        // http://en.wikipedia.org/wiki/Filesystem_permissions#Notation_of_traditional_Unix_permissions
+        if (preg_match('#^[^/]([r-][w-][xstST-]){3}#', $longname)) {
+            switch ($longname[0]) {
+                case '-':
+                    return NET_SFTP_TYPE_REGULAR;
+                case 'd':
+                    return NET_SFTP_TYPE_DIRECTORY;
+                case 'l':
+                    return NET_SFTP_TYPE_SYMLINK;
+                default:
+                    return NET_SFTP_TYPE_SPECIAL;
+            }
+        }
+
+        return false;
+    }
+
+    /**
      * Sends SFTP Packets
      *
      * See '6. General Packet Format' of draft-ietf-secsh-filexfer-13 for more info.
      *
-     * @param Integer $type
-     * @param String $data
-     * @see Net_SFTP::_get_sftp_packet()
-     * @see Net_SSH2::_send_channel_packet()
-     * @return Boolean
+     * @param int $type
+     * @param string $data
+     * @see self::_get_sftp_packet()
+     * @see self::_send_channel_packet()
+     * @return bool
      * @access private
      */
     function _send_sftp_packet($type, $data)
@@ -1304,14 +2928,21 @@ class Net_SFTP extends Net_SSH2 {
             pack('NCa*',  strlen($data) + 1, $type, $data);
 
         $start = strtok(microtime(), ' ') + strtok(''); // http://php.net/microtime#61838
-        $result = $this->_send_channel_packet(NET_SFTP_CHANNEL, $packet);
+        $result = $this->_send_channel_packet(self::CHANNEL, $packet);
         $stop = strtok(microtime(), ' ') + strtok('');
 
         if (defined('NET_SFTP_LOGGING')) {
-            $this->packet_type_log[] = '-> ' . $this->packet_types[$type] . 
-                                       ' (' . round($stop - $start, 4) . 's)';
-            if (NET_SFTP_LOGGING == NET_SFTP_LOG_COMPLEX) {
-                $this->packet_log[] = $data;
+            $packet_type = '-> ' . $this->packet_types[$type] .
+                           ' (' . round($stop - $start, 4) . 's)';
+            if (NET_SFTP_LOGGING == self::LOG_REALTIME) {
+                echo "<pre>\r\n" . $this->_format_log(array($data), array($packet_type)) . "\r\n</pre>\r\n";
+                flush();
+                ob_flush();
+            } else {
+                $this->packet_type_log[] = $packet_type;
+                if (NET_SFTP_LOGGING == self::LOG_COMPLEX) {
+                    $this->packet_log[] = $data;
+                }
             }
         }
 
@@ -1327,17 +2958,19 @@ class Net_SFTP extends Net_SSH2 {
      * There can be one SSH_MSG_CHANNEL_DATA messages containing two SFTP packets or there can be two SSH_MSG_CHANNEL_DATA
      * messages containing one SFTP packet.
      *
-     * @see Net_SFTP::_send_sftp_packet()
-     * @return String
+     * @see self::_send_sftp_packet()
+     * @return string
      * @access private
      */
     function _get_sftp_packet()
     {
+        $this->curTimeout = false;
+
         $start = strtok(microtime(), ' ') + strtok(''); // http://php.net/microtime#61838
 
         // SFTP packet length
         while (strlen($this->packet_buffer) < 4) {
-            $temp = $this->_get_channel_packet(NET_SFTP_CHANNEL);
+            $temp = $this->_get_channel_packet(self::CHANNEL, true);
             if (is_bool($temp)) {
                 $this->packet_type = false;
                 $this->packet_buffer = '';
@@ -1345,13 +2978,16 @@ class Net_SFTP extends Net_SSH2 {
             }
             $this->packet_buffer.= $temp;
         }
+        if (strlen($this->packet_buffer) < 4) {
+            return false;
+        }
         extract(unpack('Nlength', $this->_string_shift($this->packet_buffer, 4)));
         $tempLength = $length;
         $tempLength-= strlen($this->packet_buffer);
 
         // SFTP packet type and data payload
         while ($tempLength > 0) {
-            $temp = $this->_get_channel_packet(NET_SFTP_CHANNEL);
+            $temp = $this->_get_channel_packet(self::CHANNEL, true);
             if (is_bool($temp)) {
                 $this->packet_type = false;
                 $this->packet_buffer = '';
@@ -1375,10 +3011,17 @@ class Net_SFTP extends Net_SSH2 {
         $packet = $this->_string_shift($this->packet_buffer, $length);
 
         if (defined('NET_SFTP_LOGGING')) {
-            $this->packet_type_log[] = '<- ' . $this->packet_types[$this->packet_type] . 
-                                       ' (' . round($stop - $start, 4) . 's)';
-            if (NET_SFTP_LOGGING == NET_SFTP_LOG_COMPLEX) {
-                $this->packet_log[] = $packet;
+            $packet_type = '<- ' . $this->packet_types[$this->packet_type] .
+                           ' (' . round($stop - $start, 4) . 's)';
+            if (NET_SFTP_LOGGING == self::LOG_REALTIME) {
+                echo "<pre>\r\n" . $this->_format_log(array($packet), array($packet_type)) . "\r\n</pre>\r\n";
+                flush();
+                ob_flush();
+            } else {
+                $this->packet_type_log[] = $packet_type;
+                if (NET_SFTP_LOGGING == self::LOG_COMPLEX) {
+                    $this->packet_log[] = $packet;
+                }
             }
         }
 
@@ -1391,7 +3034,7 @@ class Net_SFTP extends Net_SSH2 {
      * Returns a string if NET_SFTP_LOGGING == NET_SFTP_LOG_COMPLEX, an array if NET_SFTP_LOGGING == NET_SFTP_LOG_SIMPLE and false if !defined('NET_SFTP_LOGGING')
      *
      * @access public
-     * @return String or Array
+     * @return string or Array
      */
     function getSFTPLog()
     {
@@ -1400,10 +3043,10 @@ class Net_SFTP extends Net_SSH2 {
         }
 
         switch (NET_SFTP_LOGGING) {
-            case NET_SFTP_LOG_COMPLEX:
+            case self::LOG_COMPLEX:
                 return $this->_format_log($this->packet_log, $this->packet_type_log);
                 break;
-            //case NET_SFTP_LOG_SIMPLE:
+            //case self::LOG_SIMPLE:
             default:
                 return $this->packet_type_log;
         }
@@ -1412,7 +3055,7 @@ class Net_SFTP extends Net_SSH2 {
     /**
      * Returns all errors
      *
-     * @return String
+     * @return array
      * @access public
      */
     function getSFTPErrors()
@@ -1423,18 +3066,18 @@ class Net_SFTP extends Net_SSH2 {
     /**
      * Returns the last error
      *
-     * @return String
+     * @return string
      * @access public
      */
     function getLastSFTPError()
     {
-        return $this->sftp_errors[count($this->sftp_errors) - 1];
+        return count($this->sftp_errors) ? $this->sftp_errors[count($this->sftp_errors) - 1] : '';
     }
 
     /**
      * Get supported SFTP versions
      *
-     * @return Array
+     * @return array
      * @access public
      */
     function getSupportedVersions()
@@ -1449,8 +3092,8 @@ class Net_SFTP extends Net_SSH2 {
     /**
      * Disconnect
      *
-     * @param Integer $reason
-     * @return Boolean
+     * @param int $reason
+     * @return bool
      * @access private
      */
     function _disconnect($reason)
diff --git a/lib/phpseclib/Net/SFTP/Stream.php b/lib/phpseclib/Net/SFTP/Stream.php
new file mode 100644
index 0000000..d2c4425
--- /dev/null
+++ b/lib/phpseclib/Net/SFTP/Stream.php
@@ -0,0 +1,795 @@
+<?php
+
+/**
+ * SFTP Stream Wrapper
+ *
+ * Creates an sftp:// protocol handler that can be used with, for example, fopen(), dir(), etc.
+ *
+ * PHP version 5
+ *
+ * @category  Net
+ * @package   SFTP
+ * @author    Jim Wigginton <terrafrost@php.net>
+ * @copyright 2013 Jim Wigginton
+ * @license   http://www.opensource.org/licenses/mit-license.html  MIT License
+ * @link      http://phpseclib.sourceforge.net
+ */
+
+namespace phpseclib\Net\SFTP;
+
+use phpseclib\Crypt\RSA;
+use phpseclib\Net\SFTP;
+
+/**
+ * SFTP Stream Wrapper
+ *
+ * @package SFTP
+ * @author  Jim Wigginton <terrafrost@php.net>
+ * @access  public
+ */
+class Stream
+{
+    /**
+     * SFTP instances
+     *
+     * Rather than re-create the connection we re-use instances if possible
+     *
+     * @var array
+     */
+    static $instances;
+
+    /**
+     * SFTP instance
+     *
+     * @var object
+     * @access private
+     */
+    var $sftp;
+
+    /**
+     * Path
+     *
+     * @var string
+     * @access private
+     */
+    var $path;
+
+    /**
+     * Mode
+     *
+     * @var string
+     * @access private
+     */
+    var $mode;
+
+    /**
+     * Position
+     *
+     * @var int
+     * @access private
+     */
+    var $pos;
+
+    /**
+     * Size
+     *
+     * @var int
+     * @access private
+     */
+    var $size;
+
+    /**
+     * Directory entries
+     *
+     * @var array
+     * @access private
+     */
+    var $entries;
+
+    /**
+     * EOF flag
+     *
+     * @var bool
+     * @access private
+     */
+    var $eof;
+
+    /**
+     * Context resource
+     *
+     * Technically this needs to be publically accessible so PHP can set it directly
+     *
+     * @var resource
+     * @access public
+     */
+    var $context;
+
+    /**
+     * Notification callback function
+     *
+     * @var callable
+     * @access public
+     */
+    var $notification;
+
+    /**
+     * Registers this class as a URL wrapper.
+     *
+     * @param string $protocol The wrapper name to be registered.
+     * @return bool True on success, false otherwise.
+     * @access public
+     */
+    static function register($protocol = 'sftp')
+    {
+        if (in_array($protocol, stream_get_wrappers(), true)) {
+            return false;
+        }
+        return stream_wrapper_register($protocol, get_called_class());
+    }
+
+    /**
+     * The Constructor
+     *
+     * @access public
+     */
+    function __construct()
+    {
+        if (defined('NET_SFTP_STREAM_LOGGING')) {
+            echo "__construct()\r\n";
+        }
+    }
+
+    /**
+     * Path Parser
+     *
+     * Extract a path from a URI and actually connect to an SSH server if appropriate
+     *
+     * If "notification" is set as a context parameter the message code for successful login is
+     * NET_SSH2_MSG_USERAUTH_SUCCESS. For a failed login it's NET_SSH2_MSG_USERAUTH_FAILURE.
+     *
+     * @param string $path
+     * @return string
+     * @access private
+     */
+    function _parse_path($path)
+    {
+        $orig = $path;
+        extract(parse_url($path) + array('port' => 22));
+        if (isset($query)) {
+            $path.= '?' . $query;
+        } elseif (preg_match('/(\?|\?#)$/', $orig)) {
+            $path.= '?';
+        }
+        if (isset($fragment)) {
+            $path.= '#' . $fragment;
+        } elseif ($orig[strlen($orig) - 1] == '#') {
+            $path.= '#';
+        }
+
+        if (!isset($host)) {
+            return false;
+        }
+
+        if (isset($this->context)) {
+            $context = stream_context_get_params($this->context);
+            if (isset($context['notification'])) {
+                $this->notification = $context['notification'];
+            }
+        }
+
+        if ($host[0] == '$') {
+            $host = substr($host, 1);
+            global ${$host};
+            if (($$host instanceof SFTP) === false) {
+                return false;
+            }
+            $this->sftp = $$host;
+        } else {
+            if (isset($this->context)) {
+                $context = stream_context_get_options($this->context);
+            }
+            if (isset($context[$scheme]['session'])) {
+                $sftp = $context[$scheme]['session'];
+            }
+            if (isset($context[$scheme]['sftp'])) {
+                $sftp = $context[$scheme]['sftp'];
+            }
+            if (isset($sftp) && $sftp instanceof SFTP) {
+                $this->sftp = $sftp;
+                return $path;
+            }
+            if (isset($context[$scheme]['username'])) {
+                $user = $context[$scheme]['username'];
+            }
+            if (isset($context[$scheme]['password'])) {
+                $pass = $context[$scheme]['password'];
+            }
+            if (isset($context[$scheme]['privkey']) && $context[$scheme]['privkey'] instanceof RSA) {
+                $pass = $context[$scheme]['privkey'];
+            }
+
+            if (!isset($user) || !isset($pass)) {
+                return false;
+            }
+
+            // casting $pass to a string is necessary in the event that it's a \phpseclib\Crypt\RSA object
+            if (isset(self::$instances[$host][$port][$user][(string) $pass])) {
+                $this->sftp = self::$instances[$host][$port][$user][(string) $pass];
+            } else {
+                $this->sftp = new SFTP($host, $port);
+                $this->sftp->disableStatCache();
+                if (isset($this->notification) && is_callable($this->notification)) {
+                    /* if !is_callable($this->notification) we could do this:
+
+                       user_error('fopen(): failed to call user notifier', E_USER_WARNING);
+
+                       the ftp wrapper gives errors like that when the notifier isn't callable.
+                       i've opted not to do that, however, since the ftp wrapper gives the line
+                       on which the fopen occurred as the line number - not the line that the
+                       user_error is on.
+                    */
+                    call_user_func($this->notification, STREAM_NOTIFY_CONNECT, STREAM_NOTIFY_SEVERITY_INFO, '', 0, 0, 0);
+                    call_user_func($this->notification, STREAM_NOTIFY_AUTH_REQUIRED, STREAM_NOTIFY_SEVERITY_INFO, '', 0, 0, 0);
+                    if (!$this->sftp->login($user, $pass)) {
+                        call_user_func($this->notification, STREAM_NOTIFY_AUTH_RESULT, STREAM_NOTIFY_SEVERITY_ERR, 'Login Failure', NET_SSH2_MSG_USERAUTH_FAILURE, 0, 0);
+                        return false;
+                    }
+                    call_user_func($this->notification, STREAM_NOTIFY_AUTH_RESULT, STREAM_NOTIFY_SEVERITY_INFO, 'Login Success', NET_SSH2_MSG_USERAUTH_SUCCESS, 0, 0);
+                } else {
+                    if (!$this->sftp->login($user, $pass)) {
+                        return false;
+                    }
+                }
+                self::$instances[$host][$port][$user][(string) $pass] = $this->sftp;
+            }
+        }
+
+        return $path;
+    }
+
+    /**
+     * Opens file or URL
+     *
+     * @param string $path
+     * @param string $mode
+     * @param int $options
+     * @param string $opened_path
+     * @return bool
+     * @access public
+     */
+    function _stream_open($path, $mode, $options, &$opened_path)
+    {
+        $path = $this->_parse_path($path);
+
+        if ($path === false) {
+            return false;
+        }
+        $this->path = $path;
+
+        $this->size = $this->sftp->size($path);
+        $this->mode = preg_replace('#[bt]$#', '', $mode);
+        $this->eof = false;
+
+        if ($this->size === false) {
+            if ($this->mode[0] == 'r') {
+                return false;
+            } else {
+                $this->sftp->touch($path);
+                $this->size = 0;
+            }
+        } else {
+            switch ($this->mode[0]) {
+                case 'x':
+                    return false;
+                case 'w':
+                    $this->sftp->truncate($path, 0);
+                    $this->size = 0;
+            }
+        }
+
+        $this->pos = $this->mode[0] != 'a' ? 0 : $this->size;
+
+        return true;
+    }
+
+    /**
+     * Read from stream
+     *
+     * @param int $count
+     * @return mixed
+     * @access public
+     */
+    function _stream_read($count)
+    {
+        switch ($this->mode) {
+            case 'w':
+            case 'a':
+            case 'x':
+            case 'c':
+                return false;
+        }
+
+        // commented out because some files - eg. /dev/urandom - will say their size is 0 when in fact it's kinda infinite
+        //if ($this->pos >= $this->size) {
+        //    $this->eof = true;
+        //    return false;
+        //}
+
+        $result = $this->sftp->get($this->path, false, $this->pos, $count);
+        if (isset($this->notification) && is_callable($this->notification)) {
+            if ($result === false) {
+                call_user_func($this->notification, STREAM_NOTIFY_FAILURE, STREAM_NOTIFY_SEVERITY_ERR, $this->sftp->getLastSFTPError(), NET_SFTP_OPEN, 0, 0);
+                return 0;
+            }
+            // seems that PHP calls stream_read in 8k chunks
+            call_user_func($this->notification, STREAM_NOTIFY_PROGRESS, STREAM_NOTIFY_SEVERITY_INFO, '', 0, strlen($result), $this->size);
+        }
+
+        if (empty($result)) { // ie. false or empty string
+            $this->eof = true;
+            return false;
+        }
+        $this->pos+= strlen($result);
+
+        return $result;
+    }
+
+    /**
+     * Write to stream
+     *
+     * @param string $data
+     * @return mixed
+     * @access public
+     */
+    function _stream_write($data)
+    {
+        switch ($this->mode) {
+            case 'r':
+                return false;
+        }
+
+        $result = $this->sftp->put($this->path, $data, SFTP::SOURCE_STRING, $this->pos);
+        if (isset($this->notification) && is_callable($this->notification)) {
+            if (!$result) {
+                call_user_func($this->notification, STREAM_NOTIFY_FAILURE, STREAM_NOTIFY_SEVERITY_ERR, $this->sftp->getLastSFTPError(), NET_SFTP_OPEN, 0, 0);
+                return 0;
+            }
+            // seems that PHP splits up strings into 8k blocks before calling stream_write
+            call_user_func($this->notification, STREAM_NOTIFY_PROGRESS, STREAM_NOTIFY_SEVERITY_INFO, '', 0, strlen($data), strlen($data));
+        }
+
+        if ($result === false) {
+            return false;
+        }
+        $this->pos+= strlen($data);
+        if ($this->pos > $this->size) {
+            $this->size = $this->pos;
+        }
+        $this->eof = false;
+        return strlen($data);
+    }
+
+    /**
+     * Retrieve the current position of a stream
+     *
+     * @return int
+     * @access public
+     */
+    function _stream_tell()
+    {
+        return $this->pos;
+    }
+
+    /**
+     * Tests for end-of-file on a file pointer
+     *
+     * In my testing there are four classes functions that normally effect the pointer:
+     * fseek, fputs  / fwrite, fgets / fread and ftruncate.
+     *
+     * Only fgets / fread, however, results in feof() returning true. do fputs($fp, 'aaa') on a blank file and feof()
+     * will return false. do fread($fp, 1) and feof() will then return true. do fseek($fp, 10) on ablank file and feof()
+     * will return false. do fread($fp, 1) and feof() will then return true.
+     *
+     * @return bool
+     * @access public
+     */
+    function _stream_eof()
+    {
+        return $this->eof;
+    }
+
+    /**
+     * Seeks to specific location in a stream
+     *
+     * @param int $offset
+     * @param int $whence
+     * @return bool
+     * @access public
+     */
+    function _stream_seek($offset, $whence)
+    {
+        switch ($whence) {
+            case SEEK_SET:
+                if ($offset >= $this->size || $offset < 0) {
+                    return false;
+                }
+                break;
+            case SEEK_CUR:
+                $offset+= $this->pos;
+                break;
+            case SEEK_END:
+                $offset+= $this->size;
+        }
+
+        $this->pos = $offset;
+        $this->eof = false;
+        return true;
+    }
+
+    /**
+     * Change stream options
+     *
+     * @param string $path
+     * @param int $option
+     * @param mixed $var
+     * @return bool
+     * @access public
+     */
+    function _stream_metadata($path, $option, $var)
+    {
+        $path = $this->_parse_path($path);
+        if ($path === false) {
+            return false;
+        }
+
+        // stream_metadata was introduced in PHP 5.4.0 but as of 5.4.11 the constants haven't been defined
+        // see http://www.php.net/streamwrapper.stream-metadata and https://bugs.php.net/64246
+        //     and https://github.com/php/php-src/blob/master/main/php_streams.h#L592
+        switch ($option) {
+            case 1: // PHP_STREAM_META_TOUCH
+                return $this->sftp->touch($path, $var[0], $var[1]);
+            case 2: // PHP_STREAM_OWNER_NAME
+            case 3: // PHP_STREAM_GROUP_NAME
+                return false;
+            case 4: // PHP_STREAM_META_OWNER
+                return $this->sftp->chown($path, $var);
+            case 5: // PHP_STREAM_META_GROUP
+                return $this->sftp->chgrp($path, $var);
+            case 6: // PHP_STREAM_META_ACCESS
+                return $this->sftp->chmod($path, $var) !== false;
+        }
+    }
+
+    /**
+     * Retrieve the underlaying resource
+     *
+     * @param int $cast_as
+     * @return resource
+     * @access public
+     */
+    function _stream_cast($cast_as)
+    {
+        return $this->sftp->fsock;
+    }
+
+    /**
+     * Advisory file locking
+     *
+     * @param int $operation
+     * @return bool
+     * @access public
+     */
+    function _stream_lock($operation)
+    {
+        return false;
+    }
+
+    /**
+     * Renames a file or directory
+     *
+     * Attempts to rename oldname to newname, moving it between directories if necessary.
+     * If newname exists, it will be overwritten.  This is a departure from what \phpseclib\Net\SFTP
+     * does.
+     *
+     * @param string $path_from
+     * @param string $path_to
+     * @return bool
+     * @access public
+     */
+    function _rename($path_from, $path_to)
+    {
+        $path1 = parse_url($path_from);
+        $path2 = parse_url($path_to);
+        unset($path1['path'], $path2['path']);
+        if ($path1 != $path2) {
+            return false;
+        }
+
+        $path_from = $this->_parse_path($path_from);
+        $path_to = parse_url($path_to);
+        if ($path_from === false) {
+            return false;
+        }
+
+        $path_to = $path_to['path']; // the $component part of parse_url() was added in PHP 5.1.2
+        // "It is an error if there already exists a file with the name specified by newpath."
+        //  -- http://tools.ietf.org/html/draft-ietf-secsh-filexfer-02#section-6.5
+        if (!$this->sftp->rename($path_from, $path_to)) {
+            if ($this->sftp->stat($path_to)) {
+                return $this->sftp->delete($path_to, true) && $this->sftp->rename($path_from, $path_to);
+            }
+            return false;
+        }
+
+        return true;
+    }
+
+    /**
+     * Open directory handle
+     *
+     * The only $options is "whether or not to enforce safe_mode (0x04)". Since safe mode was deprecated in 5.3 and
+     * removed in 5.4 I'm just going to ignore it.
+     *
+     * Also, nlist() is the best that this function is realistically going to be able to do. When an SFTP client
+     * sends a SSH_FXP_READDIR packet you don't generally get info on just one file but on multiple files. Quoting
+     * the SFTP specs:
+     *
+     *    The SSH_FXP_NAME response has the following format:
+     *
+     *        uint32     id
+     *        uint32     count
+     *        repeats count times:
+     *                string     filename
+     *                string     longname
+     *                ATTRS      attrs
+     *
+     * @param string $path
+     * @param int $options
+     * @return bool
+     * @access public
+     */
+    function _dir_opendir($path, $options)
+    {
+        $path = $this->_parse_path($path);
+        if ($path === false) {
+            return false;
+        }
+        $this->pos = 0;
+        $this->entries = $this->sftp->nlist($path);
+        return $this->entries !== false;
+    }
+
+    /**
+     * Read entry from directory handle
+     *
+     * @return mixed
+     * @access public
+     */
+    function _dir_readdir()
+    {
+        if (isset($this->entries[$this->pos])) {
+            return $this->entries[$this->pos++];
+        }
+        return false;
+    }
+
+    /**
+     * Rewind directory handle
+     *
+     * @return bool
+     * @access public
+     */
+    function _dir_rewinddir()
+    {
+        $this->pos = 0;
+        return true;
+    }
+
+    /**
+     * Close directory handle
+     *
+     * @return bool
+     * @access public
+     */
+    function _dir_closedir()
+    {
+        return true;
+    }
+
+    /**
+     * Create a directory
+     *
+     * Only valid $options is STREAM_MKDIR_RECURSIVE
+     *
+     * @param string $path
+     * @param int $mode
+     * @param int $options
+     * @return bool
+     * @access public
+     */
+    function _mkdir($path, $mode, $options)
+    {
+        $path = $this->_parse_path($path);
+        if ($path === false) {
+            return false;
+        }
+
+        return $this->sftp->mkdir($path, $mode, $options & STREAM_MKDIR_RECURSIVE);
+    }
+
+    /**
+     * Removes a directory
+     *
+     * Only valid $options is STREAM_MKDIR_RECURSIVE per <http://php.net/streamwrapper.rmdir>, however,
+     * <http://php.net/rmdir>  does not have a $recursive parameter as mkdir() does so I don't know how
+     * STREAM_MKDIR_RECURSIVE is supposed to be set. Also, when I try it out with rmdir() I get 8 as
+     * $options. What does 8 correspond to?
+     *
+     * @param string $path
+     * @param int $mode
+     * @param int $options
+     * @return bool
+     * @access public
+     */
+    function _rmdir($path, $options)
+    {
+        $path = $this->_parse_path($path);
+        if ($path === false) {
+            return false;
+        }
+
+        return $this->sftp->rmdir($path);
+    }
+
+    /**
+     * Flushes the output
+     *
+     * See <http://php.net/fflush>. Always returns true because \phpseclib\Net\SFTP doesn't cache stuff before writing
+     *
+     * @return bool
+     * @access public
+     */
+    function _stream_flush()
+    {
+        return true;
+    }
+
+    /**
+     * Retrieve information about a file resource
+     *
+     * @return mixed
+     * @access public
+     */
+    function _stream_stat()
+    {
+        $results = $this->sftp->stat($this->path);
+        if ($results === false) {
+            return false;
+        }
+        return $results;
+    }
+
+    /**
+     * Delete a file
+     *
+     * @param string $path
+     * @return bool
+     * @access public
+     */
+    function _unlink($path)
+    {
+        $path = $this->_parse_path($path);
+        if ($path === false) {
+            return false;
+        }
+
+        return $this->sftp->delete($path, false);
+    }
+
+    /**
+     * Retrieve information about a file
+     *
+     * Ignores the STREAM_URL_STAT_QUIET flag because the entirety of \phpseclib\Net\SFTP\Stream is quiet by default
+     * might be worthwhile to reconstruct bits 12-16 (ie. the file type) if mode doesn't have them but we'll
+     * cross that bridge when and if it's reached
+     *
+     * @param string $path
+     * @param int $flags
+     * @return mixed
+     * @access public
+     */
+    function _url_stat($path, $flags)
+    {
+        $path = $this->_parse_path($path);
+        if ($path === false) {
+            return false;
+        }
+
+        $results = $flags & STREAM_URL_STAT_LINK ? $this->sftp->lstat($path) : $this->sftp->stat($path);
+        if ($results === false) {
+            return false;
+        }
+
+        return $results;
+    }
+
+    /**
+     * Truncate stream
+     *
+     * @param int $new_size
+     * @return bool
+     * @access public
+     */
+    function _stream_truncate($new_size)
+    {
+        if (!$this->sftp->truncate($this->path, $new_size)) {
+            return false;
+        }
+
+        $this->eof = false;
+        $this->size = $new_size;
+
+        return true;
+    }
+
+    /**
+     * Change stream options
+     *
+     * STREAM_OPTION_WRITE_BUFFER isn't supported for the same reason stream_flush isn't.
+     * The other two aren't supported because of limitations in \phpseclib\Net\SFTP.
+     *
+     * @param int $option
+     * @param int $arg1
+     * @param int $arg2
+     * @return bool
+     * @access public
+     */
+    function _stream_set_option($option, $arg1, $arg2)
+    {
+        return false;
+    }
+
+    /**
+     * Close an resource
+     *
+     * @access public
+     */
+    function _stream_close()
+    {
+    }
+
+    /**
+     * __call Magic Method
+     *
+     * When you're utilizing an SFTP stream you're not calling the methods in this class directly - PHP is calling them for you.
+     * Which kinda begs the question... what methods is PHP calling and what parameters is it passing to them? This function
+     * lets you figure that out.
+     *
+     * If NET_SFTP_STREAM_LOGGING is defined all calls will be output on the screen and then (regardless of whether or not
+     * NET_SFTP_STREAM_LOGGING is enabled) the parameters will be passed through to the appropriate method.
+     *
+     * @param string
+     * @param array
+     * @return mixed
+     * @access public
+     */
+    function __call($name, $arguments)
+    {
+        if (defined('NET_SFTP_STREAM_LOGGING')) {
+            echo $name . '(';
+            $last = count($arguments) - 1;
+            foreach ($arguments as $i => $argument) {
+                var_export($argument);
+                if ($i != $last) {
+                    echo ',';
+                }
+            }
+            echo ")\r\n";
+        }
+        $name = '_' . $name;
+        if (!method_exists($this, $name)) {
+            return false;
+        }
+        return call_user_func_array(array($this, $name), $arguments);
+    }
+}
diff --git a/lib/phpseclib/Net/SSH1.php b/lib/phpseclib/Net/SSH1.php
index 1872700..514b20a 100644
--- a/lib/phpseclib/Net/SSH1.php
+++ b/lib/phpseclib/Net/SSH1.php
@@ -1,263 +1,230 @@
 <?php
-/* vim: set expandtab tabstop=4 shiftwidth=4 softtabstop=4: */
 
 /**
  * Pure-PHP implementation of SSHv1.
  *
- * PHP versions 4 and 5
+ * PHP version 5
  *
  * Here's a short example of how to use this library:
  * <code>
  * <?php
- *    include('Net/SSH1.php');
+ *    include 'vendor/autoload.php';
  *
- *    $ssh = new Net_SSH1('www.domain.tld');
+ *    $ssh = new \phpseclib\Net\SSH1('www.domain.tld');
  *    if (!$ssh->login('username', 'password')) {
  *        exit('Login Failed');
  *    }
  *
- *    while (true) {
- *        echo $ssh->interactiveRead();
- *
- *        $read = array(STDIN);
- *        $write = $except = NULL;
- *        if (stream_select($read, $write, $except, 0)) {
- *            $ssh->interactiveWrite(fread(STDIN, 1));
- *        }
- *    }
+ *    echo $ssh->exec('ls -la');
  * ?>
  * </code>
  *
  * Here's another short example:
  * <code>
  * <?php
- *    include('Net/SSH1.php');
+ *    include 'vendor/autoload.php';
  *
- *    $ssh = new Net_SSH1('www.domain.tld');
+ *    $ssh = new \phpseclib\Net\SSH1('www.domain.tld');
  *    if (!$ssh->login('username', 'password')) {
  *        exit('Login Failed');
  *    }
  *
- *    echo $ssh->exec('ls -la');
+ *    echo $ssh->read('username@username:~$');
+ *    $ssh->write("ls -la\n");
+ *    echo $ssh->read('username@username:~$');
  * ?>
  * </code>
  *
- * More information on the SSHv1 specification can be found by reading 
+ * More information on the SSHv1 specification can be found by reading
  * {@link http://www.snailbook.com/docs/protocol-1.5.txt protocol-1.5.txt}.
  *
- * LICENSE: This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA  02111-1307  USA
- *
- * @category   Net
- * @package    Net_SSH1
- * @author     Jim Wigginton <terrafrost@php.net>
- * @copyright  MMVII Jim Wigginton
- * @license    http://www.gnu.org/licenses/lgpl.txt
- * @version    $Id: SSH1.php,v 1.15 2010/03/22 22:01:38 terrafrost Exp $
- * @link       http://phpseclib.sourceforge.net
- */
-
-/**
- * Include Math_BigInteger
- *
- * Used to do RSA encryption.
- */
-require_once('phpseclib/Math/BigInteger.php');
-
-/**
- * Include Crypt_Null
+ * @category  Net
+ * @package   SSH1
+ * @author    Jim Wigginton <terrafrost@php.net>
+ * @copyright 2007 Jim Wigginton
+ * @license   http://www.opensource.org/licenses/mit-license.html  MIT License
+ * @link      http://phpseclib.sourceforge.net
  */
-//require_once('Crypt/Null.php');
 
-/**
- * Include Crypt_DES
- */
-require_once('phpseclib/Crypt/DES.php');
+namespace phpseclib\Net;
 
-/**
- * Include Crypt_TripleDES
- */
-require_once('phpseclib/Crypt/TripleDES.php');
+use phpseclib\Crypt\DES;
+use phpseclib\Crypt\Random;
+use phpseclib\Crypt\TripleDES;
+use phpseclib\Math\BigInteger;
 
 /**
- * Include Crypt_RC4
- */
-require_once('phpseclib/Crypt/RC4.php');
-
-/**
- * Include Crypt_Random
- */
-require_once('phpseclib/Crypt/Random.php');
-
-/**#@+
- * Protocol Flags
- *
- * @access private
- */
-define('NET_SSH1_MSG_DISCONNECT',          1);
-define('NET_SSH1_SMSG_PUBLIC_KEY',         2);
-define('NET_SSH1_CMSG_SESSION_KEY',        3);
-define('NET_SSH1_CMSG_USER',               4);
-define('NET_SSH1_CMSG_AUTH_PASSWORD',      9);
-define('NET_SSH1_CMSG_REQUEST_PTY',       10);
-define('NET_SSH1_CMSG_EXEC_SHELL',        12);
-define('NET_SSH1_CMSG_EXEC_CMD',          13);
-define('NET_SSH1_SMSG_SUCCESS',           14);
-define('NET_SSH1_SMSG_FAILURE',           15);
-define('NET_SSH1_CMSG_STDIN_DATA',        16);
-define('NET_SSH1_SMSG_STDOUT_DATA',       17);
-define('NET_SSH1_SMSG_STDERR_DATA',       18);
-define('NET_SSH1_SMSG_EXITSTATUS',        20);
-define('NET_SSH1_CMSG_EXIT_CONFIRMATION', 33);
-/**#@-*/
-
-/**#@+
- * Encryption Methods
- *
- * @see Net_SSH1::getSupportedCiphers()
- * @access public
- */
-/**
- * No encryption
- *
- * Not supported.
- */
-define('NET_SSH1_CIPHER_NONE',       0);
-/**
- * IDEA in CFB mode
- *
- * Not supported.
- */
-define('NET_SSH1_CIPHER_IDEA',       1);
-/**
- * DES in CBC mode
- */
-define('NET_SSH1_CIPHER_DES',        2);
-/**
- * Triple-DES in CBC mode
- *
- * All implementations are required to support this
- */
-define('NET_SSH1_CIPHER_3DES',       3);
-/**
- * TRI's Simple Stream encryption CBC
- *
- * Not supported nor is it defined in the official SSH1 specs.  OpenSSH, however, does define it (see cipher.h),
- * although it doesn't use it (see cipher.c)
- */
-define('NET_SSH1_CIPHER_BROKEN_TSS', 4);
-/**
- * RC4
- *
- * Not supported.
- *
- * @internal According to the SSH1 specs:
- *
- *        "The first 16 bytes of the session key are used as the key for
- *         the server to client direction.  The remaining 16 bytes are used
- *         as the key for the client to server direction.  This gives
- *         independent 128-bit keys for each direction."
- *
- *     This library currently only supports encryption when the same key is being used for both directions.  This is
- *     because there's only one $crypto object.  Two could be added ($encrypt and $decrypt, perhaps).
- */
-define('NET_SSH1_CIPHER_RC4',        5);
-/**
- * Blowfish
+ * Pure-PHP implementation of SSHv1.
  *
- * Not supported nor is it defined in the official SSH1 specs.  OpenSSH, however, defines it (see cipher.h) and
- * uses it (see cipher.c)
+ * @package SSH1
+ * @author  Jim Wigginton <terrafrost@php.net>
+ * @access  public
  */
-define('NET_SSH1_CIPHER_BLOWFISH',   6);
-/**#@-*/
+class SSH1
+{
+    /**#@+
+     * Encryption Methods
+     *
+     * @see \phpseclib\Net\SSH1::getSupportedCiphers()
+     * @access public
+     */
+    /**
+     * No encryption
+     *
+     * Not supported.
+     */
+    const CIPHER_NONE = 0;
+    /**
+     * IDEA in CFB mode
+     *
+     * Not supported.
+     */
+    const CIPHER_IDEA = 1;
+    /**
+     * DES in CBC mode
+     */
+    const CIPHER_DES = 2;
+    /**
+     * Triple-DES in CBC mode
+     *
+     * All implementations are required to support this
+     */
+    const CIPHER_3DES = 3;
+    /**
+     * TRI's Simple Stream encryption CBC
+     *
+     * Not supported nor is it defined in the official SSH1 specs.  OpenSSH, however, does define it (see cipher.h),
+     * although it doesn't use it (see cipher.c)
+     */
+    const CIPHER_BROKEN_TSS = 4;
+    /**
+     * RC4
+     *
+     * Not supported.
+     *
+     * @internal According to the SSH1 specs:
+     *
+     *        "The first 16 bytes of the session key are used as the key for
+     *         the server to client direction.  The remaining 16 bytes are used
+     *         as the key for the client to server direction.  This gives
+     *         independent 128-bit keys for each direction."
+     *
+     *     This library currently only supports encryption when the same key is being used for both directions.  This is
+     *     because there's only one $crypto object.  Two could be added ($encrypt and $decrypt, perhaps).
+     */
+    const CIPHER_RC4 = 5;
+    /**
+     * Blowfish
+     *
+     * Not supported nor is it defined in the official SSH1 specs.  OpenSSH, however, defines it (see cipher.h) and
+     * uses it (see cipher.c)
+     */
+    const CIPHER_BLOWFISH = 6;
+    /**#@-*/
 
-/**#@+
- * Authentication Methods
- *
- * @see Net_SSH1::getSupportedAuthentications()
- * @access public
- */
-/**
- * .rhosts or /etc/hosts.equiv
- */
-define('NET_SSH1_AUTH_RHOSTS',     1);
-/**
- * pure RSA authentication
- */
-define('NET_SSH1_AUTH_RSA',        2);
-/**
- * password authentication
- *
- * This is the only method that is supported by this library.
- */
-define('NET_SSH1_AUTH_PASSWORD',   3);
-/**
- * .rhosts with RSA host authentication
- */
-define('NET_SSH1_AUTH_RHOSTS_RSA', 4);
-/**#@-*/
+    /**#@+
+     * Authentication Methods
+     *
+     * @see \phpseclib\Net\SSH1::getSupportedAuthentications()
+     * @access public
+    */
+    /**
+     * .rhosts or /etc/hosts.equiv
+     */
+    const AUTH_RHOSTS = 1;
+    /**
+     * pure RSA authentication
+     */
+    const AUTH_RSA = 2;
+    /**
+     * password authentication
+     *
+     * This is the only method that is supported by this library.
+     */
+    const AUTH_PASSWORD = 3;
+    /**
+     * .rhosts with RSA host authentication
+     */
+    const AUTH_RHOSTS_RSA = 4;
+    /**#@-*/
 
-/**#@+
- * Terminal Modes
- *
- * @link http://3sp.com/content/developer/maverick-net/docs/Maverick.SSH.PseudoTerminalModesMembers.html
- * @access private
- */
-define('NET_SSH1_TTY_OP_END',  0);
-/**#@-*/
+    /**#@+
+     * Terminal Modes
+     *
+     * @link http://3sp.com/content/developer/maverick-net/docs/Maverick.SSH.PseudoTerminalModesMembers.html
+     * @access private
+    */
+    const TTY_OP_END = 0;
+    /**#@-*/
 
-/**
- * The Response Type
- *
- * @see Net_SSH1::_get_binary_packet()
- * @access private
- */
-define('NET_SSH1_RESPONSE_TYPE', 1);
+    /**
+     * The Response Type
+     *
+     * @see \phpseclib\Net\SSH1::_get_binary_packet()
+     * @access private
+     */
+    const RESPONSE_TYPE = 1;
 
-/**
- * The Response Data
- *
- * @see Net_SSH1::_get_binary_packet()
- * @access private
- */
-define('NET_SSH1_RESPONSE_DATA', 2);
+    /**
+     * The Response Data
+     *
+     * @see \phpseclib\Net\SSH1::_get_binary_packet()
+     * @access private
+     */
+    const RESPONSE_DATA = 2;
 
-/**#@+
- * Execution Bitmap Masks
- *
- * @see Net_SSH1::bitmap
- * @access private
- */
-define('NET_SSH1_MASK_CONSTRUCTOR', 0x00000001);
-define('NET_SSH1_MASK_LOGIN',       0x00000002);
-define('NET_SSH1_MASK_SHELL',       0x00000004);
-/**#@-*/
+    /**#@+
+     * Execution Bitmap Masks
+     *
+     * @see \phpseclib\Net\SSH1::bitmap
+     * @access private
+    */
+    const MASK_CONSTRUCTOR = 0x00000001;
+    const MASK_CONNECTED   = 0x00000002;
+    const MASK_LOGIN       = 0x00000004;
+    const MASK_SHELL       = 0x00000008;
+    /**#@-*/
+
+    /**#@+
+     * @access public
+     * @see \phpseclib\Net\SSH1::getLog()
+    */
+    /**
+     * Returns the message numbers
+     */
+    const LOG_SIMPLE = 1;
+    /**
+     * Returns the message content
+     */
+    const LOG_COMPLEX = 2;
+    /**
+     * Outputs the content real-time
+     */
+    const LOG_REALTIME = 3;
+    /**
+     * Dumps the content real-time to a file
+     */
+    const LOG_REALTIME_FILE = 4;
+    /**#@-*/
+
+    /**#@+
+     * @access public
+     * @see \phpseclib\Net\SSH1::read()
+    */
+    /**
+     * Returns when a string matching $expect exactly is found
+     */
+    const READ_SIMPLE = 1;
+    /**
+     * Returns when a string matching the regular expression $expect is found
+     */
+    const READ_REGEX = 2;
+    /**#@-*/
 
-/**
- * Pure-PHP implementation of SSHv1.
- *
- * @author  Jim Wigginton <terrafrost@php.net>
- * @version 0.1.0
- * @access  public
- * @package Net_SSH1
- */
-class Net_SSH1 {
     /**
      * The SSH identifier
      *
-     * @var String
+     * @var string
      * @access private
      */
     var $identifier = 'SSH-1.5-phpseclib';
@@ -265,7 +232,7 @@ class Net_SSH1 {
     /**
      * The Socket Object
      *
-     * @var Object
+     * @var object
      * @access private
      */
     var $fsock;
@@ -273,7 +240,7 @@ class Net_SSH1 {
     /**
      * The cryptography object
      *
-     * @var Object
+     * @var object
      * @access private
      */
     var $crypto = false;
@@ -281,10 +248,10 @@ class Net_SSH1 {
     /**
      * Execution Bitmap
      *
-     * The bits that are set reprsent functions that have been called already.  This is used to determine
+     * The bits that are set represent functions that have been called already.  This is used to determine
      * if a requisite function has been successfully executed.  If not, an error should be thrown.
      *
-     * @var Integer
+     * @var int
      * @access private
      */
     var $bitmap = 0;
@@ -294,8 +261,8 @@ class Net_SSH1 {
      *
      * Logged for debug purposes
      *
-     * @see Net_SSH1::getServerKeyPublicExponent()
-     * @var String
+     * @see self::getServerKeyPublicExponent()
+     * @var string
      * @access private
      */
     var $server_key_public_exponent;
@@ -305,8 +272,8 @@ class Net_SSH1 {
      *
      * Logged for debug purposes
      *
-     * @see Net_SSH1::getServerKeyPublicModulus()
-     * @var String
+     * @see self::getServerKeyPublicModulus()
+     * @var string
      * @access private
      */
     var $server_key_public_modulus;
@@ -316,8 +283,8 @@ class Net_SSH1 {
      *
      * Logged for debug purposes
      *
-     * @see Net_SSH1::getHostKeyPublicExponent()
-     * @var String
+     * @see self::getHostKeyPublicExponent()
+     * @var string
      * @access private
      */
     var $host_key_public_exponent;
@@ -327,8 +294,8 @@ class Net_SSH1 {
      *
      * Logged for debug purposes
      *
-     * @see Net_SSH1::getHostKeyPublicModulus()
-     * @var String
+     * @see self::getHostKeyPublicModulus()
+     * @var string
      * @access private
      */
     var $host_key_public_modulus;
@@ -338,18 +305,18 @@ class Net_SSH1 {
      *
      * Logged for debug purposes
      *
-     * @see Net_SSH1::getSupportedCiphers()
-     * @var Array
+     * @see self::getSupportedCiphers()
+     * @var array
      * @access private
      */
     var $supported_ciphers = array(
-        NET_SSH1_CIPHER_NONE       => 'No encryption',
-        NET_SSH1_CIPHER_IDEA       => 'IDEA in CFB mode',
-        NET_SSH1_CIPHER_DES        => 'DES in CBC mode',
-        NET_SSH1_CIPHER_3DES       => 'Triple-DES in CBC mode',
-        NET_SSH1_CIPHER_BROKEN_TSS => 'TRI\'s Simple Stream encryption CBC',
-        NET_SSH1_CIPHER_RC4        => 'RC4',
-        NET_SSH1_CIPHER_BLOWFISH   => 'Blowfish'
+        self::CIPHER_NONE       => 'No encryption',
+        self::CIPHER_IDEA       => 'IDEA in CFB mode',
+        self::CIPHER_DES        => 'DES in CBC mode',
+        self::CIPHER_3DES       => 'Triple-DES in CBC mode',
+        self::CIPHER_BROKEN_TSS => 'TRI\'s Simple Stream encryption CBC',
+        self::CIPHER_RC4        => 'RC4',
+        self::CIPHER_BLOWFISH   => 'Blowfish'
     );
 
     /**
@@ -357,99 +324,309 @@ class Net_SSH1 {
      *
      * Logged for debug purposes
      *
-     * @see Net_SSH1::getSupportedAuthentications()
-     * @var Array
+     * @see self::getSupportedAuthentications()
+     * @var array
      * @access private
      */
     var $supported_authentications = array(
-        NET_SSH1_AUTH_RHOSTS     => '.rhosts or /etc/hosts.equiv',
-        NET_SSH1_AUTH_RSA        => 'pure RSA authentication',
-        NET_SSH1_AUTH_PASSWORD   => 'password authentication',
-        NET_SSH1_AUTH_RHOSTS_RSA => '.rhosts with RSA host authentication'
+        self::AUTH_RHOSTS     => '.rhosts or /etc/hosts.equiv',
+        self::AUTH_RSA        => 'pure RSA authentication',
+        self::AUTH_PASSWORD   => 'password authentication',
+        self::AUTH_RHOSTS_RSA => '.rhosts with RSA host authentication'
     );
 
     /**
      * Server Identification
      *
-     * @see Net_SSH1::getServerIdentification()
-     * @var String
+     * @see self::getServerIdentification()
+     * @var string
      * @access private
      */
     var $server_identification = '';
 
     /**
+     * Protocol Flags
+     *
+     * @see self::__construct()
+     * @var array
+     * @access private
+     */
+    var $protocol_flags = array();
+
+    /**
+     * Protocol Flag Log
+     *
+     * @see self::getLog()
+     * @var array
+     * @access private
+     */
+    var $protocol_flag_log = array();
+
+    /**
+     * Message Log
+     *
+     * @see self::getLog()
+     * @var array
+     * @access private
+     */
+    var $message_log = array();
+
+    /**
+     * Real-time log file pointer
+     *
+     * @see self::_append_log()
+     * @var resource
+     * @access private
+     */
+    var $realtime_log_file;
+
+    /**
+     * Real-time log file size
+     *
+     * @see self::_append_log()
+     * @var int
+     * @access private
+     */
+    var $realtime_log_size;
+
+    /**
+     * Real-time log file wrap boolean
+     *
+     * @see self::_append_log()
+     * @var bool
+     * @access private
+     */
+    var $realtime_log_wrap;
+
+    /**
+     * Interactive Buffer
+     *
+     * @see self::read()
+     * @var array
+     * @access private
+     */
+    var $interactiveBuffer = '';
+
+    /**
+     * Timeout
+     *
+     * @see self::setTimeout()
+     * @access private
+     */
+    var $timeout;
+
+    /**
+     * Current Timeout
+     *
+     * @see self::_get_channel_packet()
+     * @access private
+     */
+    var $curTimeout;
+
+    /**
+     * Log Boundary
+     *
+     * @see self::_format_log()
+     * @access private
+     */
+    var $log_boundary = ':';
+
+    /**
+     * Log Long Width
+     *
+     * @see self::_format_log()
+     * @access private
+     */
+    var $log_long_width = 65;
+
+    /**
+     * Log Short Width
+     *
+     * @see self::_format_log()
+     * @access private
+     */
+    var $log_short_width = 16;
+
+    /**
+     * Hostname
+     *
+     * @see self::__construct()
+     * @see self::_connect()
+     * @var string
+     * @access private
+     */
+    var $host;
+
+    /**
+     * Port Number
+     *
+     * @see self::__construct()
+     * @see self::_connect()
+     * @var int
+     * @access private
+     */
+    var $port;
+
+    /**
+     * Timeout for initial connection
+     *
+     * Set by the constructor call. Calling setTimeout() is optional. If it's not called functions like
+     * exec() won't timeout unless some PHP setting forces it too. The timeout specified in the constructor,
+     * however, is non-optional. There will be a timeout, whether or not you set it. If you don't it'll be
+     * 10 seconds. It is used by fsockopen() in that function.
+     *
+     * @see self::__construct()
+     * @see self::_connect()
+     * @var int
+     * @access private
+     */
+    var $connectionTimeout;
+
+    /**
+     * Default cipher
+     *
+     * @see self::__construct()
+     * @see self::_connect()
+     * @var int
+     * @access private
+     */
+    var $cipher;
+
+    /**
      * Default Constructor.
      *
      * Connects to an SSHv1 server
      *
-     * @param String $host
-     * @param optional Integer $port
-     * @param optional Integer $timeout
-     * @param optional Integer $cipher
-     * @return Net_SSH1
+     * @param string $host
+     * @param int $port
+     * @param int $timeout
+     * @param int $cipher
+     * @return \phpseclib\Net\SSH1
      * @access public
      */
-    function Net_SSH1($host, $port = 22, $timeout = 10, $cipher = NET_SSH1_CIPHER_3DES)
+    function __construct($host, $port = 22, $timeout = 10, $cipher = self::CIPHER_3DES)
     {
-        $this->fsock = @fsockopen($host, $port, $errno, $errstr, $timeout);
+        $this->protocol_flags = array(
+            1  => 'NET_SSH1_MSG_DISCONNECT',
+            2  => 'NET_SSH1_SMSG_PUBLIC_KEY',
+            3  => 'NET_SSH1_CMSG_SESSION_KEY',
+            4  => 'NET_SSH1_CMSG_USER',
+            9  => 'NET_SSH1_CMSG_AUTH_PASSWORD',
+            10 => 'NET_SSH1_CMSG_REQUEST_PTY',
+            12 => 'NET_SSH1_CMSG_EXEC_SHELL',
+            13 => 'NET_SSH1_CMSG_EXEC_CMD',
+            14 => 'NET_SSH1_SMSG_SUCCESS',
+            15 => 'NET_SSH1_SMSG_FAILURE',
+            16 => 'NET_SSH1_CMSG_STDIN_DATA',
+            17 => 'NET_SSH1_SMSG_STDOUT_DATA',
+            18 => 'NET_SSH1_SMSG_STDERR_DATA',
+            19 => 'NET_SSH1_CMSG_EOF',
+            20 => 'NET_SSH1_SMSG_EXITSTATUS',
+            33 => 'NET_SSH1_CMSG_EXIT_CONFIRMATION'
+        );
+
+        $this->_define_array($this->protocol_flags);
+
+        $this->host = $host;
+        $this->port = $port;
+        $this->connectionTimeout = $timeout;
+        $this->cipher = $cipher;
+    }
+
+    /**
+     * Connect to an SSHv1 server
+     *
+     * @return bool
+     * @access private
+     */
+    function _connect()
+    {
+        $this->fsock = @fsockopen($this->host, $this->port, $errno, $errstr, $this->connectionTimeout);
         if (!$this->fsock) {
-            user_error(rtrim("Cannot connect to $host. Error $errno. $errstr"), E_USER_NOTICE);
-            return;
+            user_error(rtrim("Cannot connect to {$this->host}:{$this->port}. Error $errno. $errstr"));
+            return false;
         }
 
         $this->server_identification = $init_line = fgets($this->fsock, 255);
+
+        if (defined('NET_SSH1_LOGGING')) {
+            $this->_append_log('<-', $this->server_identification);
+            $this->_append_log('->', $this->identifier . "\r\n");
+        }
+
         if (!preg_match('#SSH-([0-9\.]+)-(.+)#', $init_line, $parts)) {
-            user_error('Can only connect to SSH servers', E_USER_NOTICE);
-            return;
+            user_error('Can only connect to SSH servers');
+            return false;
         }
         if ($parts[1][0] != 1) {
-            user_error("Cannot connect to SSH $parts[1] servers", E_USER_NOTICE);
-            return;
+            user_error("Cannot connect to SSH $parts[1] servers");
+            return false;
         }
 
         fputs($this->fsock, $this->identifier."\r\n");
 
         $response = $this->_get_binary_packet();
-        if ($response[NET_SSH1_RESPONSE_TYPE] != NET_SSH1_SMSG_PUBLIC_KEY) {
-            user_error('Expected SSH_SMSG_PUBLIC_KEY', E_USER_NOTICE);
-            return;
+        if ($response[self::RESPONSE_TYPE] != NET_SSH1_SMSG_PUBLIC_KEY) {
+            user_error('Expected SSH_SMSG_PUBLIC_KEY');
+            return false;
         }
 
-        $anti_spoofing_cookie = $this->_string_shift($response[NET_SSH1_RESPONSE_DATA], 8);
+        $anti_spoofing_cookie = $this->_string_shift($response[self::RESPONSE_DATA], 8);
 
-        $this->_string_shift($response[NET_SSH1_RESPONSE_DATA], 4);
+        $this->_string_shift($response[self::RESPONSE_DATA], 4);
 
-        $temp = unpack('nlen', $this->_string_shift($response[NET_SSH1_RESPONSE_DATA], 2));
-        $server_key_public_exponent = new Math_BigInteger($this->_string_shift($response[NET_SSH1_RESPONSE_DATA], ceil($temp['len'] / 8)), 256);
+        if (strlen($response[self::RESPONSE_DATA]) < 2) {
+            return false;
+        }
+        $temp = unpack('nlen', $this->_string_shift($response[self::RESPONSE_DATA], 2));
+        $server_key_public_exponent = new BigInteger($this->_string_shift($response[self::RESPONSE_DATA], ceil($temp['len'] / 8)), 256);
         $this->server_key_public_exponent = $server_key_public_exponent;
 
-        $temp = unpack('nlen', $this->_string_shift($response[NET_SSH1_RESPONSE_DATA], 2));
-        $server_key_public_modulus = new Math_BigInteger($this->_string_shift($response[NET_SSH1_RESPONSE_DATA], ceil($temp['len'] / 8)), 256);
+        if (strlen($response[self::RESPONSE_DATA]) < 2) {
+            return false;
+        }
+        $temp = unpack('nlen', $this->_string_shift($response[self::RESPONSE_DATA], 2));
+        $server_key_public_modulus = new BigInteger($this->_string_shift($response[self::RESPONSE_DATA], ceil($temp['len'] / 8)), 256);
+
         $this->server_key_public_modulus = $server_key_public_modulus;
 
-        $this->_string_shift($response[NET_SSH1_RESPONSE_DATA], 4);
+        $this->_string_shift($response[self::RESPONSE_DATA], 4);
 
-        $temp = unpack('nlen', $this->_string_shift($response[NET_SSH1_RESPONSE_DATA], 2));
-        $host_key_public_exponent = new Math_BigInteger($this->_string_shift($response[NET_SSH1_RESPONSE_DATA], ceil($temp['len'] / 8)), 256);
+        if (strlen($response[self::RESPONSE_DATA]) < 2) {
+            return false;
+        }
+        $temp = unpack('nlen', $this->_string_shift($response[self::RESPONSE_DATA], 2));
+        $host_key_public_exponent = new BigInteger($this->_string_shift($response[self::RESPONSE_DATA], ceil($temp['len'] / 8)), 256);
         $this->host_key_public_exponent = $host_key_public_exponent;
 
-        $temp = unpack('nlen', $this->_string_shift($response[NET_SSH1_RESPONSE_DATA], 2));
-        $host_key_public_modulus = new Math_BigInteger($this->_string_shift($response[NET_SSH1_RESPONSE_DATA], ceil($temp['len'] / 8)), 256);
+        if (strlen($response[self::RESPONSE_DATA]) < 2) {
+            return false;
+        }
+        $temp = unpack('nlen', $this->_string_shift($response[self::RESPONSE_DATA], 2));
+        $host_key_public_modulus = new BigInteger($this->_string_shift($response[self::RESPONSE_DATA], ceil($temp['len'] / 8)), 256);
+
         $this->host_key_public_modulus = $host_key_public_modulus;
 
-        $this->_string_shift($response[NET_SSH1_RESPONSE_DATA], 4);
+        $this->_string_shift($response[self::RESPONSE_DATA], 4);
 
         // get a list of the supported ciphers
-        extract(unpack('Nsupported_ciphers_mask', $this->_string_shift($response[NET_SSH1_RESPONSE_DATA], 4)));
-        foreach ($this->supported_ciphers as $mask=>$name) {
+        if (strlen($response[self::RESPONSE_DATA]) < 4) {
+            return false;
+        }
+        extract(unpack('Nsupported_ciphers_mask', $this->_string_shift($response[self::RESPONSE_DATA], 4)));
+
+        foreach ($this->supported_ciphers as $mask => $name) {
             if (($supported_ciphers_mask & (1 << $mask)) == 0) {
                 unset($this->supported_ciphers[$mask]);
             }
         }
 
         // get a list of the supported authentications
-        extract(unpack('Nsupported_authentications_mask', $this->_string_shift($response[NET_SSH1_RESPONSE_DATA], 4)));
-        foreach ($this->supported_authentications as $mask=>$name) {
+        if (strlen($response[self::RESPONSE_DATA]) < 4) {
+            return false;
+        }
+        extract(unpack('Nsupported_authentications_mask', $this->_string_shift($response[self::RESPONSE_DATA], 4)));
+        foreach ($this->supported_authentications as $mask => $name) {
             if (($supported_authentications_mask & (1 << $mask)) == 0) {
                 unset($this->supported_authentications[$mask]);
             }
@@ -457,10 +634,7 @@ class Net_SSH1 {
 
         $session_id = pack('H*', md5($host_key_public_modulus->toBytes() . $server_key_public_modulus->toBytes() . $anti_spoofing_cookie));
 
-        $session_key = '';
-        for ($i = 0; $i < 32; $i++) {
-            $session_key.= chr(crypt_random(0, 255));
-        }
+        $session_key = Random::string(32);
         $double_encrypted_session_key = $session_key ^ str_pad($session_id, 32, chr(0));
 
         if ($server_key_public_modulus->compare($host_key_public_modulus) < 0) {
@@ -495,32 +669,32 @@ class Net_SSH1 {
             );
         }
 
-        $cipher = isset($this->supported_ciphers[$cipher]) ? $cipher : NET_SSH1_CIPHER_3DES;
+        $cipher = isset($this->supported_ciphers[$this->cipher]) ? $this->cipher : self::CIPHER_3DES;
         $data = pack('C2a*na*N', NET_SSH1_CMSG_SESSION_KEY, $cipher, $anti_spoofing_cookie, 8 * strlen($double_encrypted_session_key), $double_encrypted_session_key, 0);
 
         if (!$this->_send_binary_packet($data)) {
-            user_error('Error sending SSH_CMSG_SESSION_KEY', E_USER_NOTICE);
-            return;
+            user_error('Error sending SSH_CMSG_SESSION_KEY');
+            return false;
         }
 
         switch ($cipher) {
-            //case NET_SSH1_CIPHER_NONE:
-            //    $this->crypto = new Crypt_Null();
+            //case self::CIPHER_NONE:
+            //    $this->crypto = new \phpseclib\Crypt\Null();
             //    break;
-            case NET_SSH1_CIPHER_DES:
-                $this->crypto = new Crypt_DES();
+            case self::CIPHER_DES:
+                $this->crypto = new DES();
                 $this->crypto->disablePadding();
                 $this->crypto->enableContinuousBuffer();
                 $this->crypto->setKey(substr($session_key, 0,  8));
                 break;
-            case NET_SSH1_CIPHER_3DES:
-                $this->crypto = new Crypt_TripleDES(CRYPT_DES_MODE_3CBC);
+            case self::CIPHER_3DES:
+                $this->crypto = new TripleDES(TripleDES::MODE_3CBC);
                 $this->crypto->disablePadding();
                 $this->crypto->enableContinuousBuffer();
                 $this->crypto->setKey(substr($session_key, 0, 24));
                 break;
-            //case NET_SSH1_CIPHER_RC4:
-            //    $this->crypto = new Crypt_RC4();
+            //case self::CIPHER_RC4:
+            //    $this->crypto = new RC4();
             //    $this->crypto->enableContinuousBuffer();
             //    $this->crypto->setKey(substr($session_key, 0,  16));
             //    break;
@@ -528,66 +702,100 @@ class Net_SSH1 {
 
         $response = $this->_get_binary_packet();
 
-        if ($response[NET_SSH1_RESPONSE_TYPE] != NET_SSH1_SMSG_SUCCESS) {
-            user_error('Expected SSH_SMSG_SUCCESS', E_USER_NOTICE);
-            return;
+        if ($response[self::RESPONSE_TYPE] != NET_SSH1_SMSG_SUCCESS) {
+            user_error('Expected SSH_SMSG_SUCCESS');
+            return false;
         }
 
-        $this->bitmap = NET_SSH1_MASK_CONSTRUCTOR;
+        $this->bitmap = self::MASK_CONNECTED;
+
+        return true;
     }
 
     /**
      * Login
      *
-     * @param String $username
-     * @param optional String $password
-     * @return Boolean
+     * @param string $username
+     * @param string $password
+     * @return bool
      * @access public
      */
     function login($username, $password = '')
     {
-        if (!($this->bitmap & NET_SSH1_MASK_CONSTRUCTOR)) {
+        if (!($this->bitmap & self::MASK_CONSTRUCTOR)) {
+            $this->bitmap |= self::MASK_CONSTRUCTOR;
+            if (!$this->_connect()) {
+                return false;
+            }
+        }
+
+        if (!($this->bitmap & self::MASK_CONNECTED)) {
             return false;
         }
 
         $data = pack('CNa*', NET_SSH1_CMSG_USER, strlen($username), $username);
 
         if (!$this->_send_binary_packet($data)) {
-            user_error('Error sending SSH_CMSG_USER', E_USER_NOTICE);
+            user_error('Error sending SSH_CMSG_USER');
             return false;
         }
 
         $response = $this->_get_binary_packet();
 
-        if ($response[NET_SSH1_RESPONSE_TYPE] == NET_SSH1_SMSG_SUCCESS) {
-            $this->bitmap |= NET_SSH1_MASK_LOGIN;
+        if ($response === true) {
+            return false;
+        }
+        if ($response[self::RESPONSE_TYPE] == NET_SSH1_SMSG_SUCCESS) {
+            $this->bitmap |= self::MASK_LOGIN;
             return true;
-        } else if ($response[NET_SSH1_RESPONSE_TYPE] != NET_SSH1_SMSG_FAILURE) {
-            user_error('Expected SSH_SMSG_SUCCESS or SSH_SMSG_FAILURE', E_USER_NOTICE);
+        } elseif ($response[self::RESPONSE_TYPE] != NET_SSH1_SMSG_FAILURE) {
+            user_error('Expected SSH_SMSG_SUCCESS or SSH_SMSG_FAILURE');
             return false;
         }
 
         $data = pack('CNa*', NET_SSH1_CMSG_AUTH_PASSWORD, strlen($password), $password);
 
         if (!$this->_send_binary_packet($data)) {
-            user_error('Error sending SSH_CMSG_AUTH_PASSWORD', E_USER_NOTICE);
+            user_error('Error sending SSH_CMSG_AUTH_PASSWORD');
             return false;
         }
 
+        // remove the username and password from the last logged packet
+        if (defined('NET_SSH1_LOGGING') && NET_SSH1_LOGGING == self::LOG_COMPLEX) {
+            $data = pack('CNa*', NET_SSH1_CMSG_AUTH_PASSWORD, strlen('password'), 'password');
+            $this->message_log[count($this->message_log) - 1] = $data;
+        }
+
         $response = $this->_get_binary_packet();
 
-        if ($response[NET_SSH1_RESPONSE_TYPE] == NET_SSH1_SMSG_SUCCESS) {
-            $this->bitmap |= NET_SSH1_MASK_LOGIN;
+        if ($response === true) {
+            return false;
+        }
+        if ($response[self::RESPONSE_TYPE] == NET_SSH1_SMSG_SUCCESS) {
+            $this->bitmap |= self::MASK_LOGIN;
             return true;
-        } else if ($response[NET_SSH1_RESPONSE_TYPE] == NET_SSH1_SMSG_FAILURE) {
+        } elseif ($response[self::RESPONSE_TYPE] == NET_SSH1_SMSG_FAILURE) {
             return false;
         } else {
-            user_error('Expected SSH_SMSG_SUCCESS or SSH_SMSG_FAILURE', E_USER_NOTICE);
+            user_error('Expected SSH_SMSG_SUCCESS or SSH_SMSG_FAILURE');
             return false;
         }
     }
 
     /**
+     * Set Timeout
+     *
+     * $ssh->exec('ping 127.0.0.1'); on a Linux host will never return and will run indefinitely.  setTimeout() makes it so it'll timeout.
+     * Setting $timeout to false or 0 will mean there is no timeout.
+     *
+     * @param mixed $timeout
+     */
+    function setTimeout($timeout)
+    {
+        $this->timeout = $this->curTimeout = $timeout;
+    }
+
+    /**
      * Executes a command on a non-interactive shell, returns the output, and quits.
      *
      * An SSH1 server will close the connection after a command has been executed on a non-interactive shell.  SSH2
@@ -597,54 +805,43 @@ class Net_SSH1 {
      * {@link http://www.faqs.org/docs/bashman/bashref_65.html http://www.faqs.org/docs/bashman/bashref_65.html}
      * {@link http://www.faqs.org/docs/bashman/bashref_62.html http://www.faqs.org/docs/bashman/bashref_62.html}
      *
-     * To execute further commands, a new Net_SSH1 object will need to be created.
+     * To execute further commands, a new \phpseclib\Net\SSH1 object will need to be created.
      *
      * Returns false on failure and the output, otherwise.
      *
-     * @see Net_SSH1::interactiveRead()
-     * @see Net_SSH1::interactiveWrite()
-     * @param String $cmd
+     * @see self::interactiveRead()
+     * @see self::interactiveWrite()
+     * @param string $cmd
      * @return mixed
      * @access public
      */
-    function exec($cmd)
+    function exec($cmd, $block = true)
     {
-        if (!($this->bitmap & NET_SSH1_MASK_LOGIN)) {
-            user_error('Operation disallowed prior to login()', E_USER_NOTICE);
+        if (!($this->bitmap & self::MASK_LOGIN)) {
+            user_error('Operation disallowed prior to login()');
             return false;
         }
 
-        // connect using the sample parameters in protocol-1.5.txt.
-        // according to wikipedia.org's entry on text terminals, "the fundamental type of application running on a text
-        // terminal is a command line interpreter or shell".  thus, opening a terminal session to run the shell.
-        $data = pack('CNa*N4C', NET_SSH1_CMSG_REQUEST_PTY, strlen('vt100'), 'vt100', 24, 80, 0, 0, NET_SSH1_TTY_OP_END);
+        $data = pack('CNa*', NET_SSH1_CMSG_EXEC_CMD, strlen($cmd), $cmd);
 
         if (!$this->_send_binary_packet($data)) {
-            user_error('Error sending SSH_CMSG_REQUEST_PTY', E_USER_NOTICE);
-            return false;
-        }
-
-        $response = $this->_get_binary_packet();
-
-        if ($response[NET_SSH1_RESPONSE_TYPE] != NET_SSH1_SMSG_SUCCESS) {
-            user_error('Expected SSH_SMSG_SUCCESS', E_USER_NOTICE);
+            user_error('Error sending SSH_CMSG_EXEC_CMD');
             return false;
         }
 
-        $data = pack('CNa*', NET_SSH1_CMSG_EXEC_CMD, strlen($cmd), $cmd);
-
-        if (!$this->_send_binary_packet($data)) {
-            user_error('Error sending SSH_CMSG_EXEC_CMD', E_USER_NOTICE);
-            return false;
+        if (!$block) {
+            return true;
         }
 
         $output = '';
         $response = $this->_get_binary_packet();
 
-        do {
-            $output.= substr($response[NET_SSH1_RESPONSE_DATA], 4);
-            $response = $this->_get_binary_packet();
-        } while ($response[NET_SSH1_RESPONSE_TYPE] != NET_SSH1_SMSG_EXITSTATUS);
+        if ($response !== false) {
+            do {
+                $output.= substr($response[self::RESPONSE_DATA], 4);
+                $response = $this->_get_binary_packet();
+            } while (is_array($response) && $response[self::RESPONSE_TYPE] != NET_SSH1_SMSG_EXITSTATUS);
+        }
 
         $data = pack('C', NET_SSH1_CMSG_EXIT_CONFIRMATION);
 
@@ -653,7 +850,7 @@ class Net_SSH1 {
 
         fclose($this->fsock);
 
-        // reset the execution bitmap - a new Net_SSH1 object needs to be created.
+        // reset the execution bitmap - a new \phpseclib\Net\SSH1 object needs to be created.
         $this->bitmap = 0;
 
         return $output;
@@ -662,35 +859,41 @@ class Net_SSH1 {
     /**
      * Creates an interactive shell
      *
-     * @see Net_SSH1::interactiveRead()
-     * @see Net_SSH1::interactiveWrite()
-     * @return Boolean
+     * @see self::interactiveRead()
+     * @see self::interactiveWrite()
+     * @return bool
      * @access private
      */
     function _initShell()
     {
-        $data = pack('CNa*N4C', NET_SSH1_CMSG_REQUEST_PTY, strlen('vt100'), 'vt100', 24, 80, 0, 0, NET_SSH1_TTY_OP_END);
+        // connect using the sample parameters in protocol-1.5.txt.
+        // according to wikipedia.org's entry on text terminals, "the fundamental type of application running on a text
+        // terminal is a command line interpreter or shell".  thus, opening a terminal session to run the shell.
+        $data = pack('CNa*N4C', NET_SSH1_CMSG_REQUEST_PTY, strlen('vt100'), 'vt100', 24, 80, 0, 0, self::TTY_OP_END);
 
         if (!$this->_send_binary_packet($data)) {
-            user_error('Error sending SSH_CMSG_REQUEST_PTY', E_USER_NOTICE);
+            user_error('Error sending SSH_CMSG_REQUEST_PTY');
             return false;
         }
 
         $response = $this->_get_binary_packet();
 
-        if ($response[NET_SSH1_RESPONSE_TYPE] != NET_SSH1_SMSG_SUCCESS) {
-            user_error('Expected SSH_SMSG_SUCCESS', E_USER_NOTICE);
+        if ($response === true) {
+            return false;
+        }
+        if ($response[self::RESPONSE_TYPE] != NET_SSH1_SMSG_SUCCESS) {
+            user_error('Expected SSH_SMSG_SUCCESS');
             return false;
         }
 
         $data = pack('C', NET_SSH1_CMSG_EXEC_SHELL);
 
         if (!$this->_send_binary_packet($data)) {
-            user_error('Error sending SSH_CMSG_EXEC_SHELL', E_USER_NOTICE);
+            user_error('Error sending SSH_CMSG_EXEC_SHELL');
             return false;
         }
 
-        $this->bitmap |= NET_SSH1_MASK_SHELL;
+        $this->bitmap |= self::MASK_SHELL;
 
         //stream_set_blocking($this->fsock, 0);
 
@@ -700,27 +903,83 @@ class Net_SSH1 {
     /**
      * Inputs a command into an interactive shell.
      *
-     * @see Net_SSH1::interactiveRead()
-     * @param String $cmd
-     * @return Boolean
+     * @see self::interactiveWrite()
+     * @param string $cmd
+     * @return bool
+     * @access public
+     */
+    function write($cmd)
+    {
+        return $this->interactiveWrite($cmd);
+    }
+
+    /**
+     * Returns the output of an interactive shell when there's a match for $expect
+     *
+     * $expect can take the form of a string literal or, if $mode == self::READ_REGEX,
+     * a regular expression.
+     *
+     * @see self::write()
+     * @param string $expect
+     * @param int $mode
+     * @return bool
+     * @access public
+     */
+    function read($expect, $mode = self::READ_SIMPLE)
+    {
+        if (!($this->bitmap & self::MASK_LOGIN)) {
+            user_error('Operation disallowed prior to login()');
+            return false;
+        }
+
+        if (!($this->bitmap & self::MASK_SHELL) && !$this->_initShell()) {
+            user_error('Unable to initiate an interactive shell session');
+            return false;
+        }
+
+        $match = $expect;
+        while (true) {
+            if ($mode == self::READ_REGEX) {
+                preg_match($expect, $this->interactiveBuffer, $matches);
+                $match = isset($matches[0]) ? $matches[0] : '';
+            }
+            $pos = strlen($match) ? strpos($this->interactiveBuffer, $match) : false;
+            if ($pos !== false) {
+                return $this->_string_shift($this->interactiveBuffer, $pos + strlen($match));
+            }
+            $response = $this->_get_binary_packet();
+
+            if ($response === true) {
+                return $this->_string_shift($this->interactiveBuffer, strlen($this->interactiveBuffer));
+            }
+            $this->interactiveBuffer.= substr($response[self::RESPONSE_DATA], 4);
+        }
+    }
+
+    /**
+     * Inputs a command into an interactive shell.
+     *
+     * @see self::interactiveRead()
+     * @param string $cmd
+     * @return bool
      * @access public
      */
     function interactiveWrite($cmd)
     {
-        if (!($this->bitmap & NET_SSH1_MASK_LOGIN)) {
-            user_error('Operation disallowed prior to login()', E_USER_NOTICE);
+        if (!($this->bitmap & self::MASK_LOGIN)) {
+            user_error('Operation disallowed prior to login()');
             return false;
         }
 
-        if (!($this->bitmap & NET_SSH1_MASK_SHELL) && !$this->_initShell()) {
-            user_error('Unable to initiate an interactive shell session', E_USER_NOTICE);
+        if (!($this->bitmap & self::MASK_SHELL) && !$this->_initShell()) {
+            user_error('Unable to initiate an interactive shell session');
             return false;
         }
 
         $data = pack('CNa*', NET_SSH1_CMSG_STDIN_DATA, strlen($cmd), $cmd);
 
         if (!$this->_send_binary_packet($data)) {
-            user_error('Error sending SSH_CMSG_STDIN', E_USER_NOTICE);
+            user_error('Error sending SSH_CMSG_STDIN');
             return false;
         }
 
@@ -728,27 +987,27 @@ class Net_SSH1 {
     }
 
     /**
-     * Reads the output of an interactive shell.
+     * Returns the output of an interactive shell when no more output is available.
      *
      * Requires PHP 4.3.0 or later due to the use of the stream_select() function.  If you see stuff like
-     * "[00m", you're seeing ANSI escape codes.  According to
+     * "^[[00m", you're seeing ANSI escape codes.  According to
      * {@link http://support.microsoft.com/kb/101875 How to Enable ANSI.SYS in a Command Window}, "Windows NT
      * does not support ANSI escape sequences in Win32 Console applications", so if you're a Windows user,
      * there's not going to be much recourse.
      *
-     * @see Net_SSH1::interactiveRead()
-     * @return String
+     * @see self::interactiveRead()
+     * @return string
      * @access public
      */
     function interactiveRead()
     {
-        if (!($this->bitmap & NET_SSH1_MASK_LOGIN)) {
-            user_error('Operation disallowed prior to login()', E_USER_NOTICE);
+        if (!($this->bitmap & self::MASK_LOGIN)) {
+            user_error('Operation disallowed prior to login()');
             return false;
         }
 
-        if (!($this->bitmap & NET_SSH1_MASK_SHELL) && !$this->_initShell()) {
-            user_error('Unable to initiate an interactive shell session', E_USER_NOTICE);
+        if (!($this->bitmap & self::MASK_SHELL) && !$this->_initShell()) {
+            user_error('Unable to initiate an interactive shell session');
             return false;
         }
 
@@ -756,7 +1015,7 @@ class Net_SSH1 {
         $write = $except = null;
         if (stream_select($read, $write, $except, 0)) {
             $response = $this->_get_binary_packet();
-            return substr($response[NET_SSH1_RESPONSE_DATA], 4);
+            return substr($response[self::RESPONSE_DATA], 4);
         } else {
             return '';
         }
@@ -788,13 +1047,29 @@ class Net_SSH1 {
     /**
      * Disconnect
      *
-     * @param String $msg
+     * @param string $msg
      * @access private
      */
     function _disconnect($msg = 'Client Quit')
     {
         if ($this->bitmap) {
+            $data = pack('C', NET_SSH1_CMSG_EOF);
+            $this->_send_binary_packet($data);
+            /*
+            $response = $this->_get_binary_packet();
+            if ($response === true) {
+                $response = array(self::RESPONSE_TYPE => -1);
+            }
+            switch ($response[self::RESPONSE_TYPE]) {
+                case NET_SSH1_SMSG_EXITSTATUS:
+                    $data = pack('C', NET_SSH1_CMSG_EXIT_CONFIRMATION);
+                    break;
+                default:
+                    $data = pack('CNa*', NET_SSH1_MSG_DISCONNECT, strlen($msg), $msg);
+            }
+            */
             $data = pack('CNa*', NET_SSH1_MSG_DISCONNECT, strlen($msg), $msg);
+
             $this->_send_binary_packet($data);
             fclose($this->fsock);
             $this->bitmap = 0;
@@ -809,25 +1084,52 @@ class Net_SSH1 {
      * Also, this function could be improved upon by adding detection for the following exploit:
      * http://www.securiteam.com/securitynews/5LP042K3FY.html
      *
-     * @see Net_SSH1::_send_binary_packet()
-     * @return Array
+     * @see self::_send_binary_packet()
+     * @return array
      * @access private
      */
     function _get_binary_packet()
     {
         if (feof($this->fsock)) {
-            //user_error('connection closed prematurely', E_USER_NOTICE);
+            //user_error('connection closed prematurely');
             return false;
         }
 
-        $temp = unpack('Nlength', fread($this->fsock, 4));
+        if ($this->curTimeout) {
+            $read = array($this->fsock);
+            $write = $except = null;
+
+            $start = strtok(microtime(), ' ') + strtok(''); // http://php.net/microtime#61838
+            $sec = floor($this->curTimeout);
+            $usec = 1000000 * ($this->curTimeout - $sec);
+            // on windows this returns a "Warning: Invalid CRT parameters detected" error
+            if (!@stream_select($read, $write, $except, $sec, $usec) && !count($read)) {
+                //$this->_disconnect('Timeout');
+                return true;
+            }
+            $elapsed = strtok(microtime(), ' ') + strtok('') - $start;
+            $this->curTimeout-= $elapsed;
+        }
+
+        $start = strtok(microtime(), ' ') + strtok(''); // http://php.net/microtime#61838
+        $data = fread($this->fsock, 4);
+        if (strlen($data) < 4) {
+            return false;
+        }
+        $temp = unpack('Nlength', $data);
 
         $padding_length = 8 - ($temp['length'] & 7);
         $length = $temp['length'] + $padding_length;
+        $raw = '';
 
-        $raw = fread($this->fsock, $length);
+        while ($length > 0) {
+            $temp = fread($this->fsock, $length);
+            $raw.= $temp;
+            $length-= strlen($temp);
+        }
+        $stop = strtok(microtime(), ' ') + strtok('');
 
-        if ($this->crypto !== false) {
+        if (strlen($raw) && $this->crypto !== false) {
             $raw = $this->crypto->decrypt($raw);
         }
 
@@ -835,16 +1137,28 @@ class Net_SSH1 {
         $type = $raw[$padding_length];
         $data = substr($raw, $padding_length + 1, -4);
 
+        if (strlen($raw) < 4) {
+            return false;
+        }
         $temp = unpack('Ncrc', substr($raw, -4));
 
         //if ( $temp['crc'] != $this->_crc($padding . $type . $data) ) {
-        //    user_error('Bad CRC in packet from server', E_USER_NOTICE);
+        //    user_error('Bad CRC in packet from server');
         //    return false;
         //}
 
+        $type = ord($type);
+
+        if (defined('NET_SSH1_LOGGING')) {
+            $temp = isset($this->protocol_flags[$type]) ? $this->protocol_flags[$type] : 'UNKNOWN';
+            $temp = '<- ' . $temp .
+                    ' (' . round($stop - $start, 4) . 's)';
+            $this->_append_log($temp, $data);
+        }
+
         return array(
-            NET_SSH1_RESPONSE_TYPE => ord($type),
-            NET_SSH1_RESPONSE_DATA => $data
+            self::RESPONSE_TYPE => $type,
+            self::RESPONSE_DATA => $data
         );
     }
 
@@ -853,25 +1167,23 @@ class Net_SSH1 {
      *
      * Returns true on success, false on failure.
      *
-     * @see Net_SSH1::_get_binary_packet()
-     * @param String $data
-     * @return Boolean
+     * @see self::_get_binary_packet()
+     * @param string $data
+     * @return bool
      * @access private
      */
-    function _send_binary_packet($data) {
+    function _send_binary_packet($data)
+    {
         if (feof($this->fsock)) {
-            //user_error('connection closed prematurely', E_USER_NOTICE);
+            //user_error('connection closed prematurely');
             return false;
         }
 
         $length = strlen($data) + 4;
 
-        $padding_length = 8 - ($length & 7);
-        $padding = '';
-        for ($i = 0; $i < $padding_length; $i++) {
-            $padding.= chr(crypt_random(0, 255));
-        }
+        $padding = Random::string(8 - ($length & 7));
 
+        $orig = $data;
         $data = $padding . $data;
         $data.= pack('N', $this->_crc($data));
 
@@ -881,7 +1193,18 @@ class Net_SSH1 {
 
         $packet = pack('Na*', $length, $data);
 
-        return strlen($packet) == fputs($this->fsock, $packet);
+        $start = strtok(microtime(), ' ') + strtok(''); // http://php.net/microtime#61838
+        $result = strlen($packet) == fputs($this->fsock, $packet);
+        $stop = strtok(microtime(), ' ') + strtok('');
+
+        if (defined('NET_SSH1_LOGGING')) {
+            $temp = isset($this->protocol_flags[ord($orig[0])]) ? $this->protocol_flags[ord($orig[0])] : 'UNKNOWN';
+            $temp = '-> ' . $temp .
+                    ' (' . round($stop - $start, 4) . 's)';
+            $this->_append_log($temp, $orig);
+        }
+
+        return $result;
     }
 
     /**
@@ -891,10 +1214,10 @@ class Net_SSH1 {
      * we've reimplemented it. A more detailed discussion of the differences can be found after
      * $crc_lookup_table's initialization.
      *
-     * @see Net_SSH1::_get_binary_packet()
-     * @see Net_SSH1::_send_binary_packet()
-     * @param String $data
-     * @return Integer
+     * @see self::_get_binary_packet()
+     * @see self::_send_binary_packet()
+     * @param string $data
+     * @return int
      * @access private
      */
     function _crc($data)
@@ -971,7 +1294,7 @@ class Net_SSH1 {
         $crc = 0x00000000;
         $length = strlen($data);
 
-        for ($i=0;$i<$length;$i++) {
+        for ($i=0; $i<$length; $i++) {
             // We AND $crc >> 8 with 0x00FFFFFF because we want the eight newly added bits to all
             // be zero.  PHP, unfortunately, doesn't always do this.  0x80000000 >> 8, as an example,
             // yields 0xFF800000 - not 0x00800000.  The following link elaborates:
@@ -989,9 +1312,9 @@ class Net_SSH1 {
      *
      * Inspired by array_shift
      *
-     * @param String $string
-     * @param optional Integer $index
-     * @return String
+     * @param string $string
+     * @param int $index
+     * @return string
      * @access private
      */
     function _string_shift(&$string, $index = 1)
@@ -1008,22 +1331,18 @@ class Net_SSH1 {
      * should be a number with the property that gcd($e, ($p - 1) * ($q - 1)) == 1.  Could just make anything that
      * calls this call modexp, instead, but I think this makes things clearer, maybe...
      *
-     * @see Net_SSH1::Net_SSH1()
-     * @param Math_BigInteger $m
-     * @param Array $key
-     * @return Math_BigInteger
+     * @see self::__construct()
+     * @param BigInteger $m
+     * @param array $key
+     * @return BigInteger
      * @access private
      */
     function _rsa_crypt($m, $key)
     {
         /*
-        if (!class_exists('Crypt_RSA')) {
-            require_once('Crypt/RSA.php');
-        }
-
-        $rsa = new Crypt_RSA();
-        $rsa->loadKey($key, CRYPT_RSA_PUBLIC_FORMAT_RAW);
-        $rsa->setEncryptionMode(CRYPT_RSA_ENCRYPTION_PKCS1);
+        $rsa = new RSA();
+        $rsa->loadKey($key, RSA::PUBLIC_FORMAT_RAW);
+        $rsa->setEncryptionMode(RSA::ENCRYPTION_PKCS1);
         return $rsa->encrypt($m);
         */
 
@@ -1040,28 +1359,128 @@ class Net_SSH1 {
         // Presumably the part of PKCS#1 they're refering to is "Section 7.2.1 Encryption Operation",
         // under "7.2 RSAES-PKCS1-v1.5" and "7 Encryption schemes" of the following URL:
         // ftp://ftp.rsasecurity.com/pub/pkcs/pkcs-1/pkcs-1v2-1.pdf
-        $temp = chr(0) . chr(2);
         $modulus = $key[1]->toBytes();
         $length = strlen($modulus) - strlen($m) - 3;
-        for ($i = 0; $i < $length; $i++) {
-            $temp.= chr(crypt_random(1, 255));
+        $random = '';
+        while (strlen($random) != $length) {
+            $block = Random::string($length - strlen($random));
+            $block = str_replace("\x00", '', $block);
+            $random.= $block;
         }
-        $temp.= chr(0) . $m;
+        $temp = chr(0) . chr(2) . $random . chr(0) . $m;
 
-        $m = new Math_BigInteger($temp, 256);
+        $m = new BigInteger($temp, 256);
         $m = $m->modPow($key[0], $key[1]);
 
         return $m->toBytes();
     }
 
     /**
+     * Define Array
+     *
+     * Takes any number of arrays whose indices are integers and whose values are strings and defines a bunch of
+     * named constants from it, using the value as the name of the constant and the index as the value of the constant.
+     * If any of the constants that would be defined already exists, none of the constants will be defined.
+     *
+     * @param array $array
+     * @access private
+     */
+    function _define_array()
+    {
+        $args = func_get_args();
+        foreach ($args as $arg) {
+            foreach ($arg as $key => $value) {
+                if (!defined($value)) {
+                    define($value, $key);
+                } else {
+                    break 2;
+                }
+            }
+        }
+    }
+
+    /**
+     * Returns a log of the packets that have been sent and received.
+     *
+     * Returns a string if NET_SSH1_LOGGING == self::LOG_COMPLEX, an array if NET_SSH1_LOGGING == self::LOG_SIMPLE and false if !defined('NET_SSH1_LOGGING')
+     *
+     * @access public
+     * @return array|false|string
+     */
+    function getLog()
+    {
+        if (!defined('NET_SSH1_LOGGING')) {
+            return false;
+        }
+
+        switch (NET_SSH1_LOGGING) {
+            case self::LOG_SIMPLE:
+                return $this->message_number_log;
+                break;
+            case self::LOG_COMPLEX:
+                return $this->_format_log($this->message_log, $this->protocol_flags_log);
+                break;
+            default:
+                return false;
+        }
+    }
+
+    /**
+     * Formats a log for printing
+     *
+     * @param array $message_log
+     * @param array $message_number_log
+     * @access private
+     * @return string
+     */
+    function _format_log($message_log, $message_number_log)
+    {
+        $output = '';
+        for ($i = 0; $i < count($message_log); $i++) {
+            $output.= $message_number_log[$i] . "\r\n";
+            $current_log = $message_log[$i];
+            $j = 0;
+            do {
+                if (strlen($current_log)) {
+                    $output.= str_pad(dechex($j), 7, '0', STR_PAD_LEFT) . '0  ';
+                }
+                $fragment = $this->_string_shift($current_log, $this->log_short_width);
+                $hex = substr(preg_replace_callback('#.#s', array($this, '_format_log_helper'), $fragment), strlen($this->log_boundary));
+                // replace non ASCII printable characters with dots
+                // http://en.wikipedia.org/wiki/ASCII#ASCII_printable_characters
+                // also replace < with a . since < messes up the output on web browsers
+                $raw = preg_replace('#[^\x20-\x7E]|<#', '.', $fragment);
+                $output.= str_pad($hex, $this->log_long_width - $this->log_short_width, ' ') . $raw . "\r\n";
+                $j++;
+            } while (strlen($current_log));
+            $output.= "\r\n";
+        }
+
+        return $output;
+    }
+
+    /**
+     * Helper function for _format_log
+     *
+     * For use with preg_replace_callback()
+     *
+     * @param array $matches
+     * @access private
+     * @return string
+     */
+    function _format_log_helper($matches)
+    {
+        return $this->log_boundary . str_pad(dechex(ord($matches[0])), 2, '0', STR_PAD_LEFT);
+    }
+
+    /**
      * Return the server key public exponent
      *
      * Returns, by default, the base-10 representation.  If $raw_output is set to true, returns, instead,
      * the raw bytes.  This behavior is similar to PHP's md5() function.
      *
-     * @param optional Boolean $raw_output
-     * @return String
+     * @param bool $raw_output
+     * @return string
      * @access public
      */
     function getServerKeyPublicExponent($raw_output = false)
@@ -1075,8 +1494,8 @@ class Net_SSH1 {
      * Returns, by default, the base-10 representation.  If $raw_output is set to true, returns, instead,
      * the raw bytes.  This behavior is similar to PHP's md5() function.
      *
-     * @param optional Boolean $raw_output
-     * @return String
+     * @param bool $raw_output
+     * @return string
      * @access public
      */
     function getServerKeyPublicModulus($raw_output = false)
@@ -1090,8 +1509,8 @@ class Net_SSH1 {
      * Returns, by default, the base-10 representation.  If $raw_output is set to true, returns, instead,
      * the raw bytes.  This behavior is similar to PHP's md5() function.
      *
-     * @param optional Boolean $raw_output
-     * @return String
+     * @param bool $raw_output
+     * @return string
      * @access public
      */
     function getHostKeyPublicExponent($raw_output = false)
@@ -1105,8 +1524,8 @@ class Net_SSH1 {
      * Returns, by default, the base-10 representation.  If $raw_output is set to true, returns, instead,
      * the raw bytes.  This behavior is similar to PHP's md5() function.
      *
-     * @param optional Boolean $raw_output
-     * @return String
+     * @param bool $raw_output
+     * @return string
      * @access public
      */
     function getHostKeyPublicModulus($raw_output = false)
@@ -1119,10 +1538,10 @@ class Net_SSH1 {
      *
      * Just because a cipher is supported by an SSH1 server doesn't mean it's supported by this library. If $raw_output
      * is set to true, returns, instead, an array of constants.  ie. instead of array('Triple-DES in CBC mode'), you'll
-     * get array(NET_SSH1_CIPHER_3DES).
+     * get array(self::CIPHER_3DES).
      *
-     * @param optional Boolean $raw_output
-     * @return Array
+     * @param bool $raw_output
+     * @return array
      * @access public
      */
     function getSupportedCiphers($raw_output = false)
@@ -1135,10 +1554,10 @@ class Net_SSH1 {
      *
      * Just because a cipher is supported by an SSH1 server doesn't mean it's supported by this library. If $raw_output
      * is set to true, returns, instead, an array of constants.  ie. instead of array('password authentication'), you'll
-     * get array(NET_SSH1_AUTH_PASSWORD).
+     * get array(self::AUTH_PASSWORD).
      *
-     * @param optional Boolean $raw_output
-     * @return Array
+     * @param bool $raw_output
+     * @return array
      * @access public
      */
     function getSupportedAuthentications($raw_output = false)
@@ -1149,11 +1568,75 @@ class Net_SSH1 {
     /**
      * Return the server identification.
      *
-     * @return String
+     * @return string
      * @access public
      */
     function getServerIdentification()
     {
         return rtrim($this->server_identification);
     }
+
+    /**
+     * Logs data packets
+     *
+     * Makes sure that only the last 1MB worth of packets will be logged
+     *
+     * @param string $data
+     * @access private
+     */
+    function _append_log($protocol_flags, $message)
+    {
+        switch (NET_SSH1_LOGGING) {
+            // useful for benchmarks
+            case self::LOG_SIMPLE:
+                $this->protocol_flags_log[] = $protocol_flags;
+                break;
+            // the most useful log for SSH1
+            case self::LOG_COMPLEX:
+                $this->protocol_flags_log[] = $protocol_flags;
+                $this->_string_shift($message);
+                $this->log_size+= strlen($message);
+                $this->message_log[] = $message;
+                while ($this->log_size > self::LOG_MAX_SIZE) {
+                    $this->log_size-= strlen(array_shift($this->message_log));
+                    array_shift($this->protocol_flags_log);
+                }
+                break;
+            // dump the output out realtime; packets may be interspersed with non packets,
+            // passwords won't be filtered out and select other packets may not be correctly
+            // identified
+            case self::LOG_REALTIME:
+                echo "<pre>\r\n" . $this->_format_log(array($message), array($protocol_flags)) . "\r\n</pre>\r\n";
+                @flush();
+                @ob_flush();
+                break;
+            // basically the same thing as self::LOG_REALTIME with the caveat that self::LOG_REALTIME_FILE
+            // needs to be defined and that the resultant log file will be capped out at self::LOG_MAX_SIZE.
+            // the earliest part of the log file is denoted by the first <<< START >>> and is not going to necessarily
+            // at the beginning of the file
+            case self::LOG_REALTIME_FILE:
+                if (!isset($this->realtime_log_file)) {
+                    // PHP doesn't seem to like using constants in fopen()
+                    $filename = self::LOG_REALTIME_FILE;
+                    $fp = fopen($filename, 'w');
+                    $this->realtime_log_file = $fp;
+                }
+                if (!is_resource($this->realtime_log_file)) {
+                    break;
+                }
+                $entry = $this->_format_log(array($message), array($protocol_flags));
+                if ($this->realtime_log_wrap) {
+                    $temp = "<<< START >>>\r\n";
+                    $entry.= $temp;
+                    fseek($this->realtime_log_file, ftell($this->realtime_log_file) - strlen($temp));
+                }
+                $this->realtime_log_size+= strlen($entry);
+                if ($this->realtime_log_size > self::LOG_MAX_SIZE) {
+                    fseek($this->realtime_log_file, 0);
+                    $this->realtime_log_size = strlen($entry);
+                    $this->realtime_log_wrap = true;
+                }
+                fputs($this->realtime_log_file, $entry);
+        }
+    }
 }
diff --git a/lib/phpseclib/Net/SSH2.php b/lib/phpseclib/Net/SSH2.php
index 93a5905..cdb7cb3 100644
--- a/lib/phpseclib/Net/SSH2.php
+++ b/lib/phpseclib/Net/SSH2.php
@@ -1,17 +1,16 @@
 <?php
-/* vim: set expandtab tabstop=4 shiftwidth=4 softtabstop=4: */
 
 /**
  * Pure-PHP implementation of SSHv2.
  *
- * PHP versions 4 and 5
+ * PHP version 5
  *
  * Here are some examples of how to use this library:
  * <code>
  * <?php
- *    include('Net/SSH2.php');
+ *    include 'vendor/autoload.php';
  *
- *    $ssh = new Net_SSH2('www.domain.tld');
+ *    $ssh = new \phpseclib\Net\SSH2('www.domain.tld');
  *    if (!$ssh->login('username', 'password')) {
  *        exit('Login Failed');
  *    }
@@ -23,143 +22,146 @@
  *
  * <code>
  * <?php
- *    include('Crypt/RSA.php');
- *    include('Net/SSH2.php');
+ *    include 'vendor/autoload.php';
  *
- *    $key = new Crypt_RSA();
+ *    $key = new \phpseclib\Crypt\RSA();
  *    //$key->setPassword('whatever');
  *    $key->loadKey(file_get_contents('privatekey'));
  *
- *    $ssh = new Net_SSH2('www.domain.tld');
+ *    $ssh = new \phpseclib\Net\SSH2('www.domain.tld');
  *    if (!$ssh->login('username', $key)) {
  *        exit('Login Failed');
  *    }
  *
- *    echo $ssh->exec('pwd');
- *    echo $ssh->exec('ls -la');
+ *    echo $ssh->read('username@username:~$');
+ *    $ssh->write("ls -la\n");
+ *    echo $ssh->read('username@username:~$');
  * ?>
  * </code>
  *
- * LICENSE: This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA  02111-1307  USA
- *
- * @category   Net
- * @package    Net_SSH2
- * @author     Jim Wigginton <terrafrost@php.net>
- * @copyright  MMVII Jim Wigginton
- * @license    http://www.gnu.org/licenses/lgpl.txt
- * @version    $Id: SSH2.php,v 1.46 2010/04/27 21:29:36 terrafrost Exp $
- * @link       http://phpseclib.sourceforge.net
- */
-
-/**
- * Include Math_BigInteger
- *
- * Used to do Diffie-Hellman key exchange and DSA/RSA signature verification.
- */
-require_once('phpseclib/Math/BigInteger.php');
-
-/**
- * Include Crypt_Random
- */
-require_once('phpseclib/Crypt/Random.php');
-
-/**
- * Include Crypt_Hash
- */
-require_once('phpseclib/Crypt/Hash.php');
-
-/**
- * Include Crypt_TripleDES
- */
-require_once('phpseclib/Crypt/TripleDES.php');
-
-/**
- * Include Crypt_RC4
- */
-require_once('phpseclib/Crypt/RC4.php');
-
-/**
- * Include Crypt_AES
- */
-require_once('phpseclib/Crypt/AES.php');
-
-/**#@+
- * Execution Bitmap Masks
- *
- * @see Net_SSH2::bitmap
- * @access private
+ * @category  Net
+ * @package   SSH2
+ * @author    Jim Wigginton <terrafrost@php.net>
+ * @copyright 2007 Jim Wigginton
+ * @license   http://www.opensource.org/licenses/mit-license.html  MIT License
+ * @link      http://phpseclib.sourceforge.net
  */
-define('NET_SSH2_MASK_CONSTRUCTOR', 0x00000001);
-define('NET_SSH2_MASK_LOGIN',       0x00000002);
-/**#@-*/
 
-/**#@+
- * Channel constants
- *
- * RFC4254 refers not to client and server channels but rather to sender and recipient channels.  we don't refer
- * to them in that way because RFC4254 toggles the meaning. the client sends a SSH_MSG_CHANNEL_OPEN message with
- * a sender channel and the server sends a SSH_MSG_CHANNEL_OPEN_CONFIRMATION in response, with a sender and a
- * recepient channel.  at first glance, you might conclude that SSH_MSG_CHANNEL_OPEN_CONFIRMATION's sender channel
- * would be the same thing as SSH_MSG_CHANNEL_OPEN's sender channel, but it's not, per this snipet:
- *     The 'recipient channel' is the channel number given in the original
- *     open request, and 'sender channel' is the channel number allocated by
- *     the other side.
- *
- * @see Net_SSH2::_send_channel_packet()
- * @see Net_SSH2::_get_channel_packet()
- * @access private
- */
-define('NET_SSH2_CHANNEL_EXEC', 0); // PuTTy uses 0x100
-/**#@-*/
+namespace phpseclib\Net;
 
-/**#@+
- * @access public
- * @see Net_SSH2::getLog()
- */
-/**
- * Returns the message numbers
- */
-define('NET_SSH2_LOG_SIMPLE',  1);
-/**
- * Returns the message content
- */
-define('NET_SSH2_LOG_COMPLEX', 2);
-/**#@-*/
+use phpseclib\Crypt\Base;
+use phpseclib\Crypt\Blowfish;
+use phpseclib\Crypt\Hash;
+use phpseclib\Crypt\Random;
+use phpseclib\Crypt\RC4;
+use phpseclib\Crypt\Rijndael;
+use phpseclib\Crypt\RSA;
+use phpseclib\Crypt\TripleDES;
+use phpseclib\Crypt\Twofish;
+use phpseclib\Math\BigInteger; // Used to do Diffie-Hellman key exchange and DSA/RSA signature verification.
+use phpseclib\System\SSH\Agent;
 
 /**
  * Pure-PHP implementation of SSHv2.
  *
+ * @package SSH2
  * @author  Jim Wigginton <terrafrost@php.net>
- * @version 0.1.0
  * @access  public
- * @package Net_SSH2
  */
-class Net_SSH2 {
+class SSH2
+{
+    /**#@+
+     * Execution Bitmap Masks
+     *
+     * @see \phpseclib\Net\SSH2::bitmap
+     * @access private
+     */
+    const MASK_CONSTRUCTOR   = 0x00000001;
+    const MASK_CONNECTED     = 0x00000002;
+    const MASK_LOGIN_REQ     = 0x00000004;
+    const MASK_LOGIN         = 0x00000008;
+    const MASK_SHELL         = 0x00000010;
+    const MASK_WINDOW_ADJUST = 0x00000020;
+    /**#@-*/
+
+    /**#@+
+     * Channel constants
+     *
+     * RFC4254 refers not to client and server channels but rather to sender and recipient channels.  we don't refer
+     * to them in that way because RFC4254 toggles the meaning. the client sends a SSH_MSG_CHANNEL_OPEN message with
+     * a sender channel and the server sends a SSH_MSG_CHANNEL_OPEN_CONFIRMATION in response, with a sender and a
+     * recepient channel.  at first glance, you might conclude that SSH_MSG_CHANNEL_OPEN_CONFIRMATION's sender channel
+     * would be the same thing as SSH_MSG_CHANNEL_OPEN's sender channel, but it's not, per this snipet:
+     *     The 'recipient channel' is the channel number given in the original
+     *     open request, and 'sender channel' is the channel number allocated by
+     *     the other side.
+     *
+     * @see \phpseclib\Net\SSH2::_send_channel_packet()
+     * @see \phpseclib\Net\SSH2::_get_channel_packet()
+     * @access private
+    */
+    const CHANNEL_EXEC          = 1; // PuTTy uses 0x100
+    const CHANNEL_SHELL         = 2;
+    const CHANNEL_SUBSYSTEM     = 3;
+    const CHANNEL_AGENT_FORWARD = 4;
+    /**#@-*/
+
+    /**#@+
+     * @access public
+     * @see \phpseclib\Net\SSH2::getLog()
+    */
+    /**
+     * Returns the message numbers
+     */
+    const LOG_SIMPLE = 1;
+    /**
+     * Returns the message content
+     */
+    const LOG_COMPLEX = 2;
+    /**
+     * Outputs the content real-time
+     */
+    const LOG_REALTIME = 3;
+    /**
+     * Dumps the content real-time to a file
+     */
+    const LOG_REALTIME_FILE = 4;
+    /**
+     * Make sure that the log never gets larger than this
+     */
+    const LOG_MAX_SIZE = 1048576; // 1024 * 1024
+    /**#@-*/
+
+    /**#@+
+     * @access public
+     * @see \phpseclib\Net\SSH2::read()
+    */
+    /**
+     * Returns when a string matching $expect exactly is found
+     */
+    const READ_SIMPLE = 1;
+    /**
+     * Returns when a string matching the regular expression $expect is found
+     */
+    const READ_REGEX = 2;
+    /**
+     * Returns when a string matching the regular expression $expect is found
+     */
+    const READ_NEXT = 3;
+    /**#@-*/
+
     /**
      * The SSH identifier
      *
-     * @var String
+     * @var string
      * @access private
      */
-    var $identifier = 'SSH-2.0-phpseclib_0.2';
+    var $identifier;
 
     /**
      * The Socket Object
      *
-     * @var Object
+     * @var object
      * @access private
      */
     var $fsock;
@@ -167,10 +169,10 @@ class Net_SSH2 {
     /**
      * Execution Bitmap
      *
-     * The bits that are set reprsent functions that have been called already.  This is used to determine
+     * The bits that are set represent functions that have been called already.  This is used to determine
      * if a requisite function has been successfully executed.  If not, an error should be thrown.
      *
-     * @var Integer
+     * @var int
      * @access private
      */
     var $bitmap = 0;
@@ -178,9 +180,9 @@ class Net_SSH2 {
     /**
      * Error information
      *
-     * @see Net_SSH2::getErrors()
-     * @see Net_SSH2::getLastError()
-     * @var String
+     * @see self::getErrors()
+     * @see self::getLastError()
+     * @var string
      * @access private
      */
     var $errors = array();
@@ -188,101 +190,128 @@ class Net_SSH2 {
     /**
      * Server Identifier
      *
-     * @see Net_SSH2::getServerIdentification()
-     * @var String
+     * @see self::getServerIdentification()
+     * @var array|false
      * @access private
      */
-    var $server_identifier = '';
+    var $server_identifier = false;
 
     /**
      * Key Exchange Algorithms
      *
-     * @see Net_SSH2::getKexAlgorithims()
-     * @var Array
+     * @see self::getKexAlgorithims()
+     * @var array|false
+     * @access private
+     */
+    var $kex_algorithms = false;
+
+    /**
+     * Minimum Diffie-Hellman Group Bit Size in RFC 4419 Key Exchange Methods
+     *
+     * @see self::_key_exchange()
+     * @var int
+     * @access private
+     */
+    var $kex_dh_group_size_min = 1536;
+
+    /**
+     * Preferred Diffie-Hellman Group Bit Size in RFC 4419 Key Exchange Methods
+     *
+     * @see self::_key_exchange()
+     * @var int
+     * @access private
+     */
+    var $kex_dh_group_size_preferred = 2048;
+
+    /**
+     * Maximum Diffie-Hellman Group Bit Size in RFC 4419 Key Exchange Methods
+     *
+     * @see self::_key_exchange()
+     * @var int
      * @access private
      */
-    var $kex_algorithms;
+    var $kex_dh_group_size_max = 4096;
 
     /**
      * Server Host Key Algorithms
      *
-     * @see Net_SSH2::getServerHostKeyAlgorithms()
-     * @var Array
+     * @see self::getServerHostKeyAlgorithms()
+     * @var array|false
      * @access private
      */
-    var $server_host_key_algorithms;
+    var $server_host_key_algorithms = false;
 
     /**
      * Encryption Algorithms: Client to Server
      *
-     * @see Net_SSH2::getEncryptionAlgorithmsClient2Server()
-     * @var Array
+     * @see self::getEncryptionAlgorithmsClient2Server()
+     * @var array|false
      * @access private
      */
-    var $encryption_algorithms_client_to_server;
+    var $encryption_algorithms_client_to_server = false;
 
     /**
      * Encryption Algorithms: Server to Client
      *
-     * @see Net_SSH2::getEncryptionAlgorithmsServer2Client()
-     * @var Array
+     * @see self::getEncryptionAlgorithmsServer2Client()
+     * @var array|false
      * @access private
      */
-    var $encryption_algorithms_server_to_client;
+    var $encryption_algorithms_server_to_client = false;
 
     /**
      * MAC Algorithms: Client to Server
      *
-     * @see Net_SSH2::getMACAlgorithmsClient2Server()
-     * @var Array
+     * @see self::getMACAlgorithmsClient2Server()
+     * @var array|false
      * @access private
      */
-    var $mac_algorithms_client_to_server;
+    var $mac_algorithms_client_to_server = false;
 
     /**
      * MAC Algorithms: Server to Client
      *
-     * @see Net_SSH2::getMACAlgorithmsServer2Client()
-     * @var Array
+     * @see self::getMACAlgorithmsServer2Client()
+     * @var array|false
      * @access private
      */
-    var $mac_algorithms_server_to_client;
+    var $mac_algorithms_server_to_client = false;
 
     /**
      * Compression Algorithms: Client to Server
      *
-     * @see Net_SSH2::getCompressionAlgorithmsClient2Server()
-     * @var Array
+     * @see self::getCompressionAlgorithmsClient2Server()
+     * @var array|false
      * @access private
      */
-    var $compression_algorithms_client_to_server;
+    var $compression_algorithms_client_to_server = false;
 
     /**
      * Compression Algorithms: Server to Client
      *
-     * @see Net_SSH2::getCompressionAlgorithmsServer2Client()
-     * @var Array
+     * @see self::getCompressionAlgorithmsServer2Client()
+     * @var array|false
      * @access private
      */
-    var $compression_algorithms_server_to_client;
+    var $compression_algorithms_server_to_client = false;
 
     /**
      * Languages: Server to Client
      *
-     * @see Net_SSH2::getLanguagesServer2Client()
-     * @var Array
+     * @see self::getLanguagesServer2Client()
+     * @var array|false
      * @access private
      */
-    var $languages_server_to_client;
+    var $languages_server_to_client = false;
 
     /**
      * Languages: Client to Server
      *
-     * @see Net_SSH2::getLanguagesClient2Server()
-     * @var Array
+     * @see self::getLanguagesClient2Server()
+     * @var array|false
      * @access private
      */
-    var $languages_client_to_server;
+    var $languages_client_to_server = false;
 
     /**
      * Block Size for Server to Client Encryption
@@ -294,9 +323,9 @@ class Net_SSH2 {
      *
      *  -- http://tools.ietf.org/html/rfc4253#section-6
      *
-     * @see Net_SSH2::Net_SSH2()
-     * @see Net_SSH2::_send_binary_packet()
-     * @var Integer
+     * @see self::__construct()
+     * @see self::_send_binary_packet()
+     * @var int
      * @access private
      */
     var $encrypt_block_size = 8;
@@ -304,9 +333,9 @@ class Net_SSH2 {
     /**
      * Block Size for Client to Server Encryption
      *
-     * @see Net_SSH2::Net_SSH2()
-     * @see Net_SSH2::_get_binary_packet()
-     * @var Integer
+     * @see self::__construct()
+     * @see self::_get_binary_packet()
+     * @var int
      * @access private
      */
     var $decrypt_block_size = 8;
@@ -314,8 +343,8 @@ class Net_SSH2 {
     /**
      * Server to Client Encryption Object
      *
-     * @see Net_SSH2::_get_binary_packet()
-     * @var Object
+     * @see self::_get_binary_packet()
+     * @var object
      * @access private
      */
     var $decrypt = false;
@@ -323,8 +352,8 @@ class Net_SSH2 {
     /**
      * Client to Server Encryption Object
      *
-     * @see Net_SSH2::_send_binary_packet()
-     * @var Object
+     * @see self::_send_binary_packet()
+     * @var object
      * @access private
      */
     var $encrypt = false;
@@ -332,8 +361,8 @@ class Net_SSH2 {
     /**
      * Client to Server HMAC Object
      *
-     * @see Net_SSH2::_send_binary_packet()
-     * @var Object
+     * @see self::_send_binary_packet()
+     * @var object
      * @access private
      */
     var $hmac_create = false;
@@ -341,8 +370,8 @@ class Net_SSH2 {
     /**
      * Server to Client HMAC Object
      *
-     * @see Net_SSH2::_get_binary_packet()
-     * @var Object
+     * @see self::_get_binary_packet()
+     * @var object
      * @access private
      */
     var $hmac_check = false;
@@ -354,8 +383,8 @@ class Net_SSH2 {
      * For the client to server side, the HMAC object will make the HMAC as long as it needs to be.  All we need to do is
      * append it.
      *
-     * @see Net_SSH2::_get_binary_packet()
-     * @var Integer
+     * @see self::_get_binary_packet()
+     * @var int
      * @access private
      */
     var $hmac_size = false;
@@ -363,14 +392,14 @@ class Net_SSH2 {
     /**
      * Server Public Host Key
      *
-     * @see Net_SSH2::getServerPublicHostKey()
-     * @var String
+     * @see self::getServerPublicHostKey()
+     * @var string
      * @access private
      */
     var $server_public_host_key;
 
     /**
-     * Session identifer
+     * Session identifier
      *
      * "The exchange hash H from the first key exchange is additionally
      *  used as the session identifier, which is a unique identifier for
@@ -378,17 +407,28 @@ class Net_SSH2 {
      *
      *  -- http://tools.ietf.org/html/rfc4253#section-7.2
      *
-     * @see Net_SSH2::_key_exchange()
-     * @var String
+     * @see self::_key_exchange()
+     * @var string
      * @access private
      */
     var $session_id = false;
 
     /**
+     * Exchange hash
+     *
+     * The current exchange hash
+     *
+     * @see self::_key_exchange()
+     * @var string
+     * @access private
+     */
+    var $exchange_hash = false;
+
+    /**
      * Message Numbers
      *
-     * @see Net_SSH2::Net_SSH2()
-     * @var Array
+     * @see self::__construct()
+     * @var array
      * @access private
      */
     var $message_numbers = array();
@@ -396,8 +436,8 @@ class Net_SSH2 {
     /**
      * Disconnection Message 'reason codes' defined in RFC4253
      *
-     * @see Net_SSH2::Net_SSH2()
-     * @var Array
+     * @see self::__construct()
+     * @var array
      * @access private
      */
     var $disconnect_reasons = array();
@@ -405,8 +445,8 @@ class Net_SSH2 {
     /**
      * SSH_MSG_CHANNEL_OPEN_FAILURE 'reason codes', defined in RFC4254
      *
-     * @see Net_SSH2::Net_SSH2()
-     * @var Array
+     * @see self::__construct()
+     * @var array
      * @access private
      */
     var $channel_open_failure_reasons = array();
@@ -415,8 +455,8 @@ class Net_SSH2 {
      * Terminal Modes
      *
      * @link http://tools.ietf.org/html/rfc4254#section-8
-     * @see Net_SSH2::Net_SSH2()
-     * @var Array
+     * @see self::__construct()
+     * @var array
      * @access private
      */
     var $terminal_modes = array();
@@ -425,8 +465,8 @@ class Net_SSH2 {
      * SSH_MSG_CHANNEL_EXTENDED_DATA's data_type_codes
      *
      * @link http://tools.ietf.org/html/rfc4254#section-5.2
-     * @see Net_SSH2::Net_SSH2()
-     * @var Array
+     * @see self::__construct()
+     * @var array
      * @access private
      */
     var $channel_extended_data_type_codes = array();
@@ -436,8 +476,8 @@ class Net_SSH2 {
      *
      * See 'Section 6.4.  Data Integrity' of rfc4253 for more info.
      *
-     * @see Net_SSH2::_send_binary_packet()
-     * @var Integer
+     * @see self::_send_binary_packet()
+     * @var int
      * @access private
      */
     var $send_seq_no = 0;
@@ -447,8 +487,8 @@ class Net_SSH2 {
      *
      * See 'Section 6.4.  Data Integrity' of rfc4253 for more info.
      *
-     * @see Net_SSH2::_get_binary_packet()
-     * @var Integer
+     * @see self::_get_binary_packet()
+     * @var int
      * @access private
      */
     var $get_seq_no = 0;
@@ -458,9 +498,9 @@ class Net_SSH2 {
      *
      * Maps client channels to server channels
      *
-     * @see Net_SSH2::_get_channel_packet()
-     * @see Net_SSH2::exec()
-     * @var Array
+     * @see self::_get_channel_packet()
+     * @see self::exec()
+     * @var array
      * @access private
      */
     var $server_channels = array();
@@ -471,9 +511,9 @@ class Net_SSH2 {
      * If a client requests a packet from one channel but receives two packets from another those packets should
      * be placed in a buffer
      *
-     * @see Net_SSH2::_get_channel_packet()
-     * @see Net_SSH2::exec()
-     * @var Array
+     * @see self::_get_channel_packet()
+     * @see self::exec()
+     * @var array
      * @access private
      */
     var $channel_buffers = array();
@@ -483,8 +523,8 @@ class Net_SSH2 {
      *
      * Contains the type of the last sent message
      *
-     * @see Net_SSH2::_get_channel_packet()
-     * @var Array
+     * @see self::_get_channel_packet()
+     * @var array
      * @access private
      */
     var $channel_status = array();
@@ -494,8 +534,8 @@ class Net_SSH2 {
      *
      * Maximum packet size indexed by channel
      *
-     * @see Net_SSH2::_send_channel_packet()
-     * @var Array
+     * @see self::_send_channel_packet()
+     * @var array
      * @access private
      */
     var $packet_size_client_to_server = array();
@@ -503,8 +543,8 @@ class Net_SSH2 {
     /**
      * Message Number Log
      *
-     * @see Net_SSH2::getLog()
-     * @var Array
+     * @see self::getLog()
+     * @var array
      * @access private
      */
     var $message_number_log = array();
@@ -512,8 +552,8 @@ class Net_SSH2 {
     /**
      * Message Log
      *
-     * @see Net_SSH2::getLog()
-     * @var Array
+     * @see self::getLog()
+     * @var array
      * @access private
      */
     var $message_log = array();
@@ -521,22 +561,33 @@ class Net_SSH2 {
     /**
      * The Window Size
      *
-     * Bytes the other party can send before it must wait for the window to be adjusted (0x7FFFFFFF = 4GB)
+     * Bytes the other party can send before it must wait for the window to be adjusted (0x7FFFFFFF = 2GB)
      *
-     * @var Integer
-     * @see Net_SSH2::_send_channel_packet()
-     * @see Net_SSH2::exec()
+     * @var int
+     * @see self::_send_channel_packet()
+     * @see self::exec()
      * @access private
      */
     var $window_size = 0x7FFFFFFF;
 
     /**
-     * Window size
+     * Window size, server to client
+     *
+     * Window size indexed by channel
+     *
+     * @see self::_send_channel_packet()
+     * @var array
+     * @access private
+     */
+    var $window_size_server_to_client = array();
+
+    /**
+     * Window size, client to server
      *
      * Window size indexed by channel
      *
-     * @see Net_SSH2::_send_channel_packet()
-     * @var Array
+     * @see self::_get_channel_packet()
+     * @var array
      * @access private
      */
     var $window_size_client_to_server = array();
@@ -546,8 +597,8 @@ class Net_SSH2 {
      *
      * Verified against $this->session_id
      *
-     * @see Net_SSH2::getServerPublicHostKey()
-     * @var String
+     * @see self::getServerPublicHostKey()
+     * @var string
      * @access private
      */
     var $signature = '';
@@ -557,714 +608,2260 @@ class Net_SSH2 {
      *
      * ssh-rsa or ssh-dss.
      *
-     * @see Net_SSH2::getServerPublicHostKey()
-     * @var String
+     * @see self::getServerPublicHostKey()
+     * @var string
      * @access private
      */
     var $signature_format = '';
 
     /**
-     * Default Constructor.
+     * Interactive Buffer
      *
-     * Connects to an SSHv2 server
-     *
-     * @param String $host
-     * @param optional Integer $port
-     * @param optional Integer $timeout
-     * @return Net_SSH2
-     * @access public
+     * @see self::read()
+     * @var array
+     * @access private
      */
-    function Net_SSH2($host, $port = 22, $timeout = 10)
-    {
-        $this->message_numbers = array(
-            1 => 'NET_SSH2_MSG_DISCONNECT',
-            2 => 'NET_SSH2_MSG_IGNORE',
-            3 => 'NET_SSH2_MSG_UNIMPLEMENTED',
-            4 => 'NET_SSH2_MSG_DEBUG',
-            5 => 'NET_SSH2_MSG_SERVICE_REQUEST',
-            6 => 'NET_SSH2_MSG_SERVICE_ACCEPT',
-            20 => 'NET_SSH2_MSG_KEXINIT',
-            21 => 'NET_SSH2_MSG_NEWKEYS',
-            30 => 'NET_SSH2_MSG_KEXDH_INIT',
-            31 => 'NET_SSH2_MSG_KEXDH_REPLY',
-            50 => 'NET_SSH2_MSG_USERAUTH_REQUEST',
-            51 => 'NET_SSH2_MSG_USERAUTH_FAILURE',
-            52 => 'NET_SSH2_MSG_USERAUTH_SUCCESS',
-            53 => 'NET_SSH2_MSG_USERAUTH_BANNER',
-
-            80 => 'NET_SSH2_MSG_GLOBAL_REQUEST',
-            81 => 'NET_SSH2_MSG_REQUEST_SUCCESS',
-            82 => 'NET_SSH2_MSG_REQUEST_FAILURE',
-            90 => 'NET_SSH2_MSG_CHANNEL_OPEN',
-            91 => 'NET_SSH2_MSG_CHANNEL_OPEN_CONFIRMATION',
-            92 => 'NET_SSH2_MSG_CHANNEL_OPEN_FAILURE',
-            93 => 'NET_SSH2_MSG_CHANNEL_WINDOW_ADJUST',
-            94 => 'NET_SSH2_MSG_CHANNEL_DATA',
-            95 => 'NET_SSH2_MSG_CHANNEL_EXTENDED_DATA',
-            96 => 'NET_SSH2_MSG_CHANNEL_EOF',
-            97 => 'NET_SSH2_MSG_CHANNEL_CLOSE',
-            98 => 'NET_SSH2_MSG_CHANNEL_REQUEST',
-            99 => 'NET_SSH2_MSG_CHANNEL_SUCCESS',
-            100 => 'NET_SSH2_MSG_CHANNEL_FAILURE'
-        );
-        $this->disconnect_reasons = array(
-            1 => 'NET_SSH2_DISCONNECT_HOST_NOT_ALLOWED_TO_CONNECT',
-            2 => 'NET_SSH2_DISCONNECT_PROTOCOL_ERROR',
-            3 => 'NET_SSH2_DISCONNECT_KEY_EXCHANGE_FAILED',
-            4 => 'NET_SSH2_DISCONNECT_RESERVED',
-            5 => 'NET_SSH2_DISCONNECT_MAC_ERROR',
-            6 => 'NET_SSH2_DISCONNECT_COMPRESSION_ERROR',
-            7 => 'NET_SSH2_DISCONNECT_SERVICE_NOT_AVAILABLE',
-            8 => 'NET_SSH2_DISCONNECT_PROTOCOL_VERSION_NOT_SUPPORTED',
-            9 => 'NET_SSH2_DISCONNECT_HOST_KEY_NOT_VERIFIABLE',
-            10 => 'NET_SSH2_DISCONNECT_CONNECTION_LOST',
-            11 => 'NET_SSH2_DISCONNECT_BY_APPLICATION',
-            12 => 'NET_SSH2_DISCONNECT_TOO_MANY_CONNECTIONS',
-            13 => 'NET_SSH2_DISCONNECT_AUTH_CANCELLED_BY_USER',
-            14 => 'NET_SSH2_DISCONNECT_NO_MORE_AUTH_METHODS_AVAILABLE',
-            15 => 'NET_SSH2_DISCONNECT_ILLEGAL_USER_NAME'
-        );
-        $this->channel_open_failure_reasons = array(
-            1 => 'NET_SSH2_OPEN_ADMINISTRATIVELY_PROHIBITED'
-        );
-        $this->terminal_modes = array(
-            0 => 'NET_SSH2_TTY_OP_END'
-        );
-        $this->channel_extended_data_type_codes = array(
-            1 => 'NET_SSH2_EXTENDED_DATA_STDERR'
-        );
-
-        $this->_define_array(
-            $this->message_numbers,
-            $this->disconnect_reasons,
-            $this->channel_open_failure_reasons,
-            $this->terminal_modes,
-            $this->channel_extended_data_type_codes,
-            array(60 => 'NET_SSH2_MSG_USERAUTH_PASSWD_CHANGEREQ'),
-            array(60 => 'NET_SSH2_MSG_USERAUTH_PK_OK')
-        );
+    var $interactiveBuffer = '';
 
-        $this->fsock = @fsockopen($host, $port, $errno, $errstr, $timeout);
-        if (!$this->fsock) {
-            user_error(rtrim("Cannot connect to $host. Error $errno. $errstr"), E_USER_NOTICE);
-            return;
-        }
+    /**
+     * Current log size
+     *
+     * Should never exceed self::LOG_MAX_SIZE
+     *
+     * @see self::_send_binary_packet()
+     * @see self::_get_binary_packet()
+     * @var int
+     * @access private
+     */
+    var $log_size;
 
-        /* According to the SSH2 specs,
+    /**
+     * Timeout
+     *
+     * @see self::setTimeout()
+     * @access private
+     */
+    var $timeout;
 
-          "The server MAY send other lines of data before sending the version
-           string.  Each line SHOULD be terminated by a Carriage Return and Line
-           Feed.  Such lines MUST NOT begin with "SSH-", and SHOULD be encoded
-           in ISO-10646 UTF-8 [RFC3629] (language is not specified).  Clients
-           MUST be able to process such lines." */
-        $temp = '';
-        $extra = '';
-        while (!feof($this->fsock) && !preg_match('#^SSH-(\d\.\d+)#', $temp, $matches)) {
-            if (substr($temp, -2) == "\r\n") {
-                $extra.= $temp;
-                $temp = '';
-            }
-            $temp.= fgets($this->fsock, 255);
-        }
+    /**
+     * Current Timeout
+     *
+     * @see self::_get_channel_packet()
+     * @access private
+     */
+    var $curTimeout;
 
-        $ext = array();
-        if (extension_loaded('mcrypt')) {
-            $ext[] = 'mcrypt';
-        }
-        if (extension_loaded('gmp')) {
-            $ext[] = 'gmp';
-        } else if (extension_loaded('bcmath')) {
-            $ext[] = 'bcmath';
-        }
+    /**
+     * Real-time log file pointer
+     *
+     * @see self::_append_log()
+     * @var resource
+     * @access private
+     */
+    var $realtime_log_file;
 
-        if (!empty($ext)) {
-            $this->identifier.= ' (' . implode(', ', $ext) . ')';
-        }
+    /**
+     * Real-time log file size
+     *
+     * @see self::_append_log()
+     * @var int
+     * @access private
+     */
+    var $realtime_log_size;
 
-        if (defined('NET_SSH2_LOGGING')) {
-            $this->message_number_log[] = '<-';
-            $this->message_number_log[] = '->';
+    /**
+     * Has the signature been validated?
+     *
+     * @see self::getServerPublicHostKey()
+     * @var bool
+     * @access private
+     */
+    var $signature_validated = false;
 
-            if (NET_SSH2_LOGGING == NET_SSH2_LOG_COMPLEX) {
-                $this->message_log[] = $temp;
-                $this->message_log[] = $this->identifier . "\r\n";
-            }
-        }
+    /**
+     * Real-time log file wrap boolean
+     *
+     * @see self::_append_log()
+     * @access private
+     */
+    var $realtime_log_wrap;
 
-        $this->server_identifier = trim($temp, "\r\n");
-        if (!empty($extra)) {
-            $this->errors[] = utf8_decode($extra);
-        }
+    /**
+     * Flag to suppress stderr from output
+     *
+     * @see self::enableQuietMode()
+     * @access private
+     */
+    var $quiet_mode = false;
 
-        if ($matches[1] != '1.99' && $matches[1] != '2.0') {
-            user_error("Cannot connect to SSH $matches[1] servers", E_USER_NOTICE);
-            return;
-        }
+    /**
+     * Time of first network activity
+     *
+     * @var int
+     * @access private
+     */
+    var $last_packet;
 
-        fputs($this->fsock, $this->identifier . "\r\n");
+    /**
+     * Exit status returned from ssh if any
+     *
+     * @var int
+     * @access private
+     */
+    var $exit_status;
 
-        $response = $this->_get_binary_packet();
-        if ($response === false) {
-            user_error('Connection closed by server', E_USER_NOTICE);
-            return;
-        }
+    /**
+     * Flag to request a PTY when using exec()
+     *
+     * @var bool
+     * @see self::enablePTY()
+     * @access private
+     */
+    var $request_pty = false;
 
-        if (ord($response[0]) != NET_SSH2_MSG_KEXINIT) {
-            user_error('Expected SSH_MSG_KEXINIT', E_USER_NOTICE);
-            return;
-        }
+    /**
+     * Flag set while exec() is running when using enablePTY()
+     *
+     * @var bool
+     * @access private
+     */
+    var $in_request_pty_exec = false;
 
-        if (!$this->_key_exchange($response)) {
-            return;
-        }
+    /**
+     * Flag set after startSubsystem() is called
+     *
+     * @var bool
+     * @access private
+     */
+    var $in_subsystem;
 
-        $this->bitmap = NET_SSH2_MASK_CONSTRUCTOR;
-    }
+    /**
+     * Contents of stdError
+     *
+     * @var string
+     * @access private
+     */
+    var $stdErrorLog;
 
     /**
-     * Key Exchange
+     * The Last Interactive Response
      *
-     * @param String $kexinit_payload_server
+     * @see self::_keyboard_interactive_process()
+     * @var string
      * @access private
      */
-    function _key_exchange($kexinit_payload_server)
-    {
-        static $kex_algorithms = array(
-            'diffie-hellman-group1-sha1', // REQUIRED
-            'diffie-hellman-group14-sha1' // REQUIRED
-        );
+    var $last_interactive_response = '';
 
-        static $server_host_key_algorithms = array(
+    /**
+     * Keyboard Interactive Request / Responses
+     *
+     * @see self::_keyboard_interactive_process()
+     * @var array
+     * @access private
+     */
+    var $keyboard_requests_responses = array();
+
+    /**
+     * Banner Message
+     *
+     * Quoting from the RFC, "in some jurisdictions, sending a warning message before
+     * authentication may be relevant for getting legal protection."
+     *
+     * @see self::_filter()
+     * @see self::getBannerMessage()
+     * @var string
+     * @access private
+     */
+    var $banner_message = '';
+
+    /**
+     * Did read() timeout or return normally?
+     *
+     * @see self::isTimeout()
+     * @var bool
+     * @access private
+     */
+    var $is_timeout = false;
+
+    /**
+     * Log Boundary
+     *
+     * @see self::_format_log()
+     * @var string
+     * @access private
+     */
+    var $log_boundary = ':';
+
+    /**
+     * Log Long Width
+     *
+     * @see self::_format_log()
+     * @var int
+     * @access private
+     */
+    var $log_long_width = 65;
+
+    /**
+     * Log Short Width
+     *
+     * @see self::_format_log()
+     * @var int
+     * @access private
+     */
+    var $log_short_width = 16;
+
+    /**
+     * Hostname
+     *
+     * @see self::__construct()
+     * @see self::_connect()
+     * @var string
+     * @access private
+     */
+    var $host;
+
+    /**
+     * Port Number
+     *
+     * @see self::__construct()
+     * @see self::_connect()
+     * @var int
+     * @access private
+     */
+    var $port;
+
+    /**
+     * Number of columns for terminal window size
+     *
+     * @see self::getWindowColumns()
+     * @see self::setWindowColumns()
+     * @see self::setWindowSize()
+     * @var int
+     * @access private
+     */
+    var $windowColumns = 80;
+
+    /**
+     * Number of columns for terminal window size
+     *
+     * @see self::getWindowRows()
+     * @see self::setWindowRows()
+     * @see self::setWindowSize()
+     * @var int
+     * @access private
+     */
+    var $windowRows = 24;
+
+    /**
+     * Crypto Engine
+     *
+     * @see self::setCryptoEngine()
+     * @see self::_key_exchange()
+     * @var int
+     * @access private
+     */
+    var $crypto_engine = false;
+
+    /**
+     * A System_SSH_Agent for use in the SSH2 Agent Forwarding scenario
+     *
+     * @var System_SSH_Agent
+     * @access private
+     */
+    var $agent;
+
+    /**
+     * Send the identification string first?
+     *
+     * @var bool
+     * @access private
+     */
+    var $send_id_string_first = true;
+
+    /**
+     * Send the key exchange initiation packet first?
+     *
+     * @var bool
+     * @access private
+     */
+    var $send_kex_first = true;
+
+    /**
+     * Some versions of OpenSSH incorrectly calculate the key size
+     *
+     * @var bool
+     * @access private
+     */
+    var $bad_key_size_fix = false;
+
+    /**
+     * The selected decryption algorithm
+     *
+     * @var string
+     * @access private
+     */
+    var $decrypt_algorithm = '';
+
+    /**
+     * Should we try to re-connect to re-establish keys?
+     *
+     * @var bool
+     * @access private
+     */
+    var $retry_connect = false;
+
+    /**
+     * Binary Packet Buffer
+     *
+     * @var string|false
+     * @access private
+     */
+    var $binary_packet_buffer = false;
+
+    /**
+     * Default Constructor.
+     *
+     * $host can either be a string, representing the host, or a stream resource.
+     *
+     * @param mixed $host
+     * @param int $port
+     * @param int $timeout
+     * @see self::login()
+     * @return \phpseclib\Net\SSH2
+     * @access public
+     */
+    function __construct($host, $port = 22, $timeout = 10)
+    {
+        $this->message_numbers = array(
+            1 => 'NET_SSH2_MSG_DISCONNECT',
+            2 => 'NET_SSH2_MSG_IGNORE',
+            3 => 'NET_SSH2_MSG_UNIMPLEMENTED',
+            4 => 'NET_SSH2_MSG_DEBUG',
+            5 => 'NET_SSH2_MSG_SERVICE_REQUEST',
+            6 => 'NET_SSH2_MSG_SERVICE_ACCEPT',
+            20 => 'NET_SSH2_MSG_KEXINIT',
+            21 => 'NET_SSH2_MSG_NEWKEYS',
+            30 => 'NET_SSH2_MSG_KEXDH_INIT',
+            31 => 'NET_SSH2_MSG_KEXDH_REPLY',
+            50 => 'NET_SSH2_MSG_USERAUTH_REQUEST',
+            51 => 'NET_SSH2_MSG_USERAUTH_FAILURE',
+            52 => 'NET_SSH2_MSG_USERAUTH_SUCCESS',
+            53 => 'NET_SSH2_MSG_USERAUTH_BANNER',
+
+            80 => 'NET_SSH2_MSG_GLOBAL_REQUEST',
+            81 => 'NET_SSH2_MSG_REQUEST_SUCCESS',
+            82 => 'NET_SSH2_MSG_REQUEST_FAILURE',
+            90 => 'NET_SSH2_MSG_CHANNEL_OPEN',
+            91 => 'NET_SSH2_MSG_CHANNEL_OPEN_CONFIRMATION',
+            92 => 'NET_SSH2_MSG_CHANNEL_OPEN_FAILURE',
+            93 => 'NET_SSH2_MSG_CHANNEL_WINDOW_ADJUST',
+            94 => 'NET_SSH2_MSG_CHANNEL_DATA',
+            95 => 'NET_SSH2_MSG_CHANNEL_EXTENDED_DATA',
+            96 => 'NET_SSH2_MSG_CHANNEL_EOF',
+            97 => 'NET_SSH2_MSG_CHANNEL_CLOSE',
+            98 => 'NET_SSH2_MSG_CHANNEL_REQUEST',
+            99 => 'NET_SSH2_MSG_CHANNEL_SUCCESS',
+            100 => 'NET_SSH2_MSG_CHANNEL_FAILURE'
+        );
+        $this->disconnect_reasons = array(
+            1 => 'NET_SSH2_DISCONNECT_HOST_NOT_ALLOWED_TO_CONNECT',
+            2 => 'NET_SSH2_DISCONNECT_PROTOCOL_ERROR',
+            3 => 'NET_SSH2_DISCONNECT_KEY_EXCHANGE_FAILED',
+            4 => 'NET_SSH2_DISCONNECT_RESERVED',
+            5 => 'NET_SSH2_DISCONNECT_MAC_ERROR',
+            6 => 'NET_SSH2_DISCONNECT_COMPRESSION_ERROR',
+            7 => 'NET_SSH2_DISCONNECT_SERVICE_NOT_AVAILABLE',
+            8 => 'NET_SSH2_DISCONNECT_PROTOCOL_VERSION_NOT_SUPPORTED',
+            9 => 'NET_SSH2_DISCONNECT_HOST_KEY_NOT_VERIFIABLE',
+            10 => 'NET_SSH2_DISCONNECT_CONNECTION_LOST',
+            11 => 'NET_SSH2_DISCONNECT_BY_APPLICATION',
+            12 => 'NET_SSH2_DISCONNECT_TOO_MANY_CONNECTIONS',
+            13 => 'NET_SSH2_DISCONNECT_AUTH_CANCELLED_BY_USER',
+            14 => 'NET_SSH2_DISCONNECT_NO_MORE_AUTH_METHODS_AVAILABLE',
+            15 => 'NET_SSH2_DISCONNECT_ILLEGAL_USER_NAME'
+        );
+        $this->channel_open_failure_reasons = array(
+            1 => 'NET_SSH2_OPEN_ADMINISTRATIVELY_PROHIBITED'
+        );
+        $this->terminal_modes = array(
+            0 => 'NET_SSH2_TTY_OP_END'
+        );
+        $this->channel_extended_data_type_codes = array(
+            1 => 'NET_SSH2_EXTENDED_DATA_STDERR'
+        );
+
+        $this->_define_array(
+            $this->message_numbers,
+            $this->disconnect_reasons,
+            $this->channel_open_failure_reasons,
+            $this->terminal_modes,
+            $this->channel_extended_data_type_codes,
+            array(60 => 'NET_SSH2_MSG_USERAUTH_PASSWD_CHANGEREQ'),
+            array(60 => 'NET_SSH2_MSG_USERAUTH_PK_OK'),
+            array(60 => 'NET_SSH2_MSG_USERAUTH_INFO_REQUEST',
+                  61 => 'NET_SSH2_MSG_USERAUTH_INFO_RESPONSE'),
+            // RFC 4419 - diffie-hellman-group-exchange-sha{1,256}
+            array(30 => 'NET_SSH2_MSG_KEXDH_GEX_REQUEST_OLD',
+                  31 => 'NET_SSH2_MSG_KEXDH_GEX_GROUP',
+                  32 => 'NET_SSH2_MSG_KEXDH_GEX_INIT',
+                  33 => 'NET_SSH2_MSG_KEXDH_GEX_REPLY',
+                  34 => 'NET_SSH2_MSG_KEXDH_GEX_REQUEST'),
+            // RFC 5656 - Elliptic Curves (for curve25519-sha256@libssh.org)
+            array(30 => 'NET_SSH2_MSG_KEX_ECDH_INIT',
+                  31 => 'NET_SSH2_MSG_KEX_ECDH_REPLY')
+        );
+
+        if (is_resource($host)) {
+            $this->fsock = $host;
+            return;
+        }
+
+        if (is_string($host)) {
+            $this->host = $host;
+            $this->port = $port;
+            $this->timeout = $timeout;
+        }
+    }
+
+    /**
+     * Set Crypto Engine Mode
+     *
+     * Possible $engine values:
+     * CRYPT_MODE_INTERNAL, CRYPT_MODE_MCRYPT
+     *
+     * @param int $engine
+     * @access public
+     */
+    function setCryptoEngine($engine)
+    {
+        $this->crypto_engine = $engine;
+    }
+
+    /**
+     * Send Identification String First
+     *
+     * https://tools.ietf.org/html/rfc4253#section-4.2 says "when the connection has been established,
+     * both sides MUST send an identification string". It does not say which side sends it first. In
+     * theory it shouldn't matter but it is a fact of life that some SSH servers are simply buggy
+     *
+     * @access public
+     */
+    function sendIdentificationStringFirst()
+    {
+        $this->send_id_string_first = true;
+    }
+
+    /**
+     * Send Identification String Last
+     *
+     * https://tools.ietf.org/html/rfc4253#section-4.2 says "when the connection has been established,
+     * both sides MUST send an identification string". It does not say which side sends it first. In
+     * theory it shouldn't matter but it is a fact of life that some SSH servers are simply buggy
+     *
+     * @access public
+     */
+    function sendIdentificationStringLast()
+    {
+        $this->send_id_string_first = false;
+    }
+
+    /**
+     * Send SSH_MSG_KEXINIT First
+     *
+     * https://tools.ietf.org/html/rfc4253#section-7.1 says "key exchange begins by each sending
+     * sending the [SSH_MSG_KEXINIT] packet". It does not say which side sends it first. In theory
+     * it shouldn't matter but it is a fact of life that some SSH servers are simply buggy
+     *
+     * @access public
+     */
+    function sendKEXINITFirst()
+    {
+        $this->send_kex_first = true;
+    }
+
+    /**
+     * Send SSH_MSG_KEXINIT Last
+     *
+     * https://tools.ietf.org/html/rfc4253#section-7.1 says "key exchange begins by each sending
+     * sending the [SSH_MSG_KEXINIT] packet". It does not say which side sends it first. In theory
+     * it shouldn't matter but it is a fact of life that some SSH servers are simply buggy
+     *
+     * @access public
+     */
+    function sendKEXINITLast()
+    {
+        $this->send_kex_first = false;
+    }
+
+    /**
+     * Connect to an SSHv2 server
+     *
+     * @return bool
+     * @access private
+     */
+    function _connect()
+    {
+        if ($this->bitmap & self::MASK_CONSTRUCTOR) {
+            return false;
+        }
+
+        $this->bitmap |= self::MASK_CONSTRUCTOR;
+
+        $this->curTimeout = $this->timeout;
+
+        $this->last_packet = microtime(true);
+
+        if (!is_resource($this->fsock)) {
+            $start = microtime(true);
+            // with stream_select a timeout of 0 means that no timeout takes place;
+            // with fsockopen a timeout of 0 means that you instantly timeout
+            // to resolve this incompatibility a timeout of 100,000 will be used for fsockopen if timeout is 0
+            $this->fsock = @fsockopen($this->host, $this->port, $errno, $errstr, $this->curTimeout == 0 ? 100000 : $this->curTimeout);
+            if (!$this->fsock) {
+                $host = $this->host . ':' . $this->port;
+                user_error(rtrim("Cannot connect to $host. Error $errno. $errstr"));
+                return false;
+            }
+            $elapsed = microtime(true) - $start;
+
+            $this->curTimeout-= $elapsed;
+
+            if ($this->curTimeout <= 0) {
+                $this->is_timeout = true;
+                return false;
+            }
+        }
+
+        $this->identifier = $this->_generate_identifier();
+
+        if ($this->send_id_string_first) {
+            fputs($this->fsock, $this->identifier . "\r\n");
+        }
+
+        /* According to the SSH2 specs,
+
+          "The server MAY send other lines of data before sending the version
+           string.  Each line SHOULD be terminated by a Carriage Return and Line
+           Feed.  Such lines MUST NOT begin with "SSH-", and SHOULD be encoded
+           in ISO-10646 UTF-8 [RFC3629] (language is not specified).  Clients
+           MUST be able to process such lines." */
+        $data = '';
+        while (!feof($this->fsock) && !preg_match('#(.*)^(SSH-(\d\.\d+).*)#ms', $data, $matches)) {
+            $line = '';
+            while (true) {
+                if ($this->curTimeout) {
+                    if ($this->curTimeout < 0) {
+                        $this->is_timeout = true;
+                        return false;
+                    }
+                    $read = array($this->fsock);
+                    $write = $except = null;
+                    $start = microtime(true);
+                    $sec = floor($this->curTimeout);
+                    $usec = 1000000 * ($this->curTimeout - $sec);
+                    // on windows this returns a "Warning: Invalid CRT parameters detected" error
+                    // the !count() is done as a workaround for <https://bugs.php.net/42682>
+                    if (!@stream_select($read, $write, $except, $sec, $usec) && !count($read)) {
+                        $this->is_timeout = true;
+                        return false;
+                    }
+                    $elapsed = microtime(true) - $start;
+                    $this->curTimeout-= $elapsed;
+                }
+
+                $temp = stream_get_line($this->fsock, 255, "\n");
+                if (strlen($temp) == 255) {
+                    continue;
+                }
+
+                $line.= "$temp\n";
+
+                // quoting RFC4253, "Implementers who wish to maintain
+                // compatibility with older, undocumented versions of this protocol may
+                // want to process the identification string without expecting the
+                // presence of the carriage return character for reasons described in
+                // Section 5 of this document."
+
+                //if (substr($line, -2) == "\r\n") {
+                //    break;
+                //}
+
+                break;
+            }
+
+            $data.= $line;
+        }
+
+        if (feof($this->fsock)) {
+            user_error('Connection closed by server');
+            return false;
+        }
+
+        $extra = $matches[1];
+
+        if (defined('NET_SSH2_LOGGING')) {
+            $this->_append_log('<-', $matches[0]);
+            $this->_append_log('->', $this->identifier . "\r\n");
+        }
+
+        $this->server_identifier = trim($temp, "\r\n");
+        if (strlen($extra)) {
+            $this->errors[] = utf8_decode($data);
+        }
+
+        if (version_compare($matches[3], '1.99', '<')) {
+            user_error("Cannot connect to SSH $matches[3] servers");
+            return false;
+        }
+
+        if (!$this->send_id_string_first) {
+            fputs($this->fsock, $this->identifier . "\r\n");
+        }
+
+        if (!$this->send_kex_first) {
+            $response = $this->_get_binary_packet();
+            if ($response === false) {
+                user_error('Connection closed by server');
+                return false;
+            }
+
+            if (!strlen($response) || ord($response[0]) != NET_SSH2_MSG_KEXINIT) {
+                user_error('Expected SSH_MSG_KEXINIT');
+                return false;
+            }
+
+            if (!$this->_key_exchange($response)) {
+                return false;
+            }
+        }
+
+        if ($this->send_kex_first && !$this->_key_exchange()) {
+            return false;
+        }
+
+        $this->bitmap|= self::MASK_CONNECTED;
+
+        return true;
+    }
+
+    /**
+     * Generates the SSH identifier
+     *
+     * You should overwrite this method in your own class if you want to use another identifier
+     *
+     * @access protected
+     * @return string
+     */
+    function _generate_identifier()
+    {
+        $identifier = 'SSH-2.0-phpseclib_2.0';
+
+        $ext = array();
+        if (function_exists('\\Sodium\\library_version_major')) {
+            $ext[] = 'libsodium';
+        }
+
+        if (extension_loaded('openssl')) {
+            $ext[] = 'openssl';
+        } elseif (extension_loaded('mcrypt')) {
+            $ext[] = 'mcrypt';
+        }
+
+        if (extension_loaded('gmp')) {
+            $ext[] = 'gmp';
+        } elseif (extension_loaded('bcmath')) {
+            $ext[] = 'bcmath';
+        }
+
+        if (!empty($ext)) {
+            $identifier .= ' (' . implode(', ', $ext) . ')';
+        }
+
+        return $identifier;
+    }
+
+    /**
+     * Key Exchange
+     *
+     * @param string $kexinit_payload_server optional
+     * @access private
+     */
+    function _key_exchange($kexinit_payload_server = false)
+    {
+        $kex_algorithms = array(
+            // Elliptic Curve Diffie-Hellman Key Agreement (ECDH) using
+            // Curve25519. See doc/curve25519-sha256@libssh.org.txt in the
+            // libssh repository for more information.
+            'curve25519-sha256@libssh.org',
+
+            // Diffie-Hellman Key Agreement (DH) using integer modulo prime
+            // groups.
+            'diffie-hellman-group1-sha1', // REQUIRED
+            'diffie-hellman-group14-sha1', // REQUIRED
+            'diffie-hellman-group-exchange-sha1', // RFC 4419
+            'diffie-hellman-group-exchange-sha256', // RFC 4419
+        );
+        if (!function_exists('\\Sodium\\library_version_major')) {
+            $kex_algorithms = array_diff(
+                $kex_algorithms,
+                array('curve25519-sha256@libssh.org')
+            );
+        }
+
+        $server_host_key_algorithms = array(
             'ssh-rsa', // RECOMMENDED  sign   Raw RSA Key
             'ssh-dss'  // REQUIRED     sign   Raw DSS Key
         );
 
-        static $encryption_algorithms = array(
-            // from <http://tools.ietf.org/html/rfc4345#section-4>:
-            'arcfour256',
-            'arcfour128',
+        $encryption_algorithms = array(
+            // from <http://tools.ietf.org/html/rfc4345#section-4>:
+            'arcfour256',
+            'arcfour128',
+
+            //'arcfour',      // OPTIONAL          the ARCFOUR stream cipher with a 128-bit key
+
+            // CTR modes from <http://tools.ietf.org/html/rfc4344#section-4>:
+            'aes128-ctr',     // RECOMMENDED       AES (Rijndael) in SDCTR mode, with 128-bit key
+            'aes192-ctr',     // RECOMMENDED       AES with 192-bit key
+            'aes256-ctr',     // RECOMMENDED       AES with 256-bit key
+
+            'twofish128-ctr', // OPTIONAL          Twofish in SDCTR mode, with 128-bit key
+            'twofish192-ctr', // OPTIONAL          Twofish with 192-bit key
+            'twofish256-ctr', // OPTIONAL          Twofish with 256-bit key
+
+            'aes128-cbc',     // RECOMMENDED       AES with a 128-bit key
+            'aes192-cbc',     // OPTIONAL          AES with a 192-bit key
+            'aes256-cbc',     // OPTIONAL          AES in CBC mode, with a 256-bit key
+
+            'twofish128-cbc', // OPTIONAL          Twofish with a 128-bit key
+            'twofish192-cbc', // OPTIONAL          Twofish with a 192-bit key
+            'twofish256-cbc',
+            'twofish-cbc',    // OPTIONAL          alias for "twofish256-cbc"
+                              //                   (this is being retained for historical reasons)
+
+            'blowfish-ctr',   // OPTIONAL          Blowfish in SDCTR mode
+
+            'blowfish-cbc',   // OPTIONAL          Blowfish in CBC mode
+
+            '3des-ctr',       // RECOMMENDED       Three-key 3DES in SDCTR mode
+
+            '3des-cbc',       // REQUIRED          three-key 3DES in CBC mode
+                //'none'         // OPTIONAL          no encryption; NOT RECOMMENDED
+        );
+
+        if (extension_loaded('openssl') && !extension_loaded('mcrypt')) {
+            // OpenSSL does not support arcfour256 in any capacity and arcfour128 / arcfour support is limited to
+            // instances that do not use continuous buffers
+            $encryption_algorithms = array_diff(
+                $encryption_algorithms,
+                array('arcfour256', 'arcfour128', 'arcfour')
+            );
+        }
+
+        if (class_exists('\phpseclib\Crypt\RC4') === false) {
+            $encryption_algorithms = array_diff(
+                $encryption_algorithms,
+                array('arcfour256', 'arcfour128', 'arcfour')
+            );
+        }
+        if (class_exists('\phpseclib\Crypt\Rijndael') === false) {
+            $encryption_algorithms = array_diff(
+                $encryption_algorithms,
+                array('aes128-ctr', 'aes192-ctr', 'aes256-ctr', 'aes128-cbc', 'aes192-cbc', 'aes256-cbc')
+            );
+        }
+        if (class_exists('\phpseclib\Crypt\Twofish') === false) {
+            $encryption_algorithms = array_diff(
+                $encryption_algorithms,
+                array('twofish128-ctr', 'twofish192-ctr', 'twofish256-ctr', 'twofish128-cbc', 'twofish192-cbc', 'twofish256-cbc', 'twofish-cbc')
+            );
+        }
+        if (class_exists('\phpseclib\Crypt\Blowfish') === false) {
+            $encryption_algorithms = array_diff(
+                $encryption_algorithms,
+                array('blowfish-ctr', 'blowfish-cbc')
+            );
+        }
+        if (class_exists('\phpseclib\Crypt\TripleDES') === false) {
+            $encryption_algorithms = array_diff(
+                $encryption_algorithms,
+                array('3des-ctr', '3des-cbc')
+            );
+        }
+        $encryption_algorithms = array_values($encryption_algorithms);
+
+        $mac_algorithms = array(
+            // from <http://www.ietf.org/rfc/rfc6668.txt>:
+            'hmac-sha2-256',// RECOMMENDED     HMAC-SHA256 (digest length = key length = 32)
+
+            'hmac-sha1-96', // RECOMMENDED     first 96 bits of HMAC-SHA1 (digest length = 12, key length = 20)
+            'hmac-sha1',    // REQUIRED        HMAC-SHA1 (digest length = key length = 20)
+            'hmac-md5-96',  // OPTIONAL        first 96 bits of HMAC-MD5 (digest length = 12, key length = 16)
+            'hmac-md5',     // OPTIONAL        HMAC-MD5 (digest length = key length = 16)
+            //'none'          // OPTIONAL        no MAC; NOT RECOMMENDED
+        );
+
+        $compression_algorithms = array(
+            'none'   // REQUIRED        no compression
+            //'zlib' // OPTIONAL        ZLIB (LZ77) compression
+        );
+
+        // some SSH servers have buggy implementations of some of the above algorithms
+        switch (true) {
+            case $this->server_identifier == 'SSH-2.0-SSHD':
+            case substr($this->server_identifier, 0, 13) == 'SSH-2.0-DLINK':
+                $mac_algorithms = array_values(array_diff(
+                    $mac_algorithms,
+                    array('hmac-sha1-96', 'hmac-md5-96')
+                ));
+        }
+
+        $str_kex_algorithms = implode(',', $kex_algorithms);
+        $str_server_host_key_algorithms = implode(',', $server_host_key_algorithms);
+        $encryption_algorithms_server_to_client = $encryption_algorithms_client_to_server = implode(',', $encryption_algorithms);
+        $mac_algorithms_server_to_client = $mac_algorithms_client_to_server = implode(',', $mac_algorithms);
+        $compression_algorithms_server_to_client = $compression_algorithms_client_to_server = implode(',', $compression_algorithms);
+
+        $client_cookie = Random::string(16);
+
+        $kexinit_payload_client = pack(
+            'Ca*Na*Na*Na*Na*Na*Na*Na*Na*Na*Na*CN',
+            NET_SSH2_MSG_KEXINIT,
+            $client_cookie,
+            strlen($str_kex_algorithms),
+            $str_kex_algorithms,
+            strlen($str_server_host_key_algorithms),
+            $str_server_host_key_algorithms,
+            strlen($encryption_algorithms_client_to_server),
+            $encryption_algorithms_client_to_server,
+            strlen($encryption_algorithms_server_to_client),
+            $encryption_algorithms_server_to_client,
+            strlen($mac_algorithms_client_to_server),
+            $mac_algorithms_client_to_server,
+            strlen($mac_algorithms_server_to_client),
+            $mac_algorithms_server_to_client,
+            strlen($compression_algorithms_client_to_server),
+            $compression_algorithms_client_to_server,
+            strlen($compression_algorithms_server_to_client),
+            $compression_algorithms_server_to_client,
+            0,
+            '',
+            0,
+            '',
+            0,
+            0
+        );
+
+        if ($this->send_kex_first) {
+            if (!$this->_send_binary_packet($kexinit_payload_client)) {
+                return false;
+            }
+
+            $kexinit_payload_server = $this->_get_binary_packet();
+            if ($kexinit_payload_server === false) {
+                user_error('Connection closed by server');
+                return false;
+            }
+
+            if (!strlen($kexinit_payload_server) || ord($kexinit_payload_server[0]) != NET_SSH2_MSG_KEXINIT) {
+                user_error('Expected SSH_MSG_KEXINIT');
+                return false;
+            }
+        }
+
+        $response = $kexinit_payload_server;
+        $this->_string_shift($response, 1); // skip past the message number (it should be SSH_MSG_KEXINIT)
+        $server_cookie = $this->_string_shift($response, 16);
+
+        if (strlen($response) < 4) {
+            return false;
+        }
+        $temp = unpack('Nlength', $this->_string_shift($response, 4));
+        $this->kex_algorithms = explode(',', $this->_string_shift($response, $temp['length']));
+
+        if (strlen($response) < 4) {
+            return false;
+        }
+        $temp = unpack('Nlength', $this->_string_shift($response, 4));
+        $this->server_host_key_algorithms = explode(',', $this->_string_shift($response, $temp['length']));
+
+        if (strlen($response) < 4) {
+            return false;
+        }
+        $temp = unpack('Nlength', $this->_string_shift($response, 4));
+        $this->encryption_algorithms_client_to_server = explode(',', $this->_string_shift($response, $temp['length']));
+
+        if (strlen($response) < 4) {
+            return false;
+        }
+        $temp = unpack('Nlength', $this->_string_shift($response, 4));
+        $this->encryption_algorithms_server_to_client = explode(',', $this->_string_shift($response, $temp['length']));
+
+        if (strlen($response) < 4) {
+            return false;
+        }
+        $temp = unpack('Nlength', $this->_string_shift($response, 4));
+        $this->mac_algorithms_client_to_server = explode(',', $this->_string_shift($response, $temp['length']));
+
+        if (strlen($response) < 4) {
+            return false;
+        }
+        $temp = unpack('Nlength', $this->_string_shift($response, 4));
+        $this->mac_algorithms_server_to_client = explode(',', $this->_string_shift($response, $temp['length']));
+
+        if (strlen($response) < 4) {
+            return false;
+        }
+        $temp = unpack('Nlength', $this->_string_shift($response, 4));
+        $this->compression_algorithms_client_to_server = explode(',', $this->_string_shift($response, $temp['length']));
+
+        if (strlen($response) < 4) {
+            return false;
+        }
+        $temp = unpack('Nlength', $this->_string_shift($response, 4));
+        $this->compression_algorithms_server_to_client = explode(',', $this->_string_shift($response, $temp['length']));
+
+        if (strlen($response) < 4) {
+            return false;
+        }
+        $temp = unpack('Nlength', $this->_string_shift($response, 4));
+        $this->languages_client_to_server = explode(',', $this->_string_shift($response, $temp['length']));
+
+        if (strlen($response) < 4) {
+            return false;
+        }
+        $temp = unpack('Nlength', $this->_string_shift($response, 4));
+        $this->languages_server_to_client = explode(',', $this->_string_shift($response, $temp['length']));
+
+        if (!strlen($response)) {
+            return false;
+        }
+        extract(unpack('Cfirst_kex_packet_follows', $this->_string_shift($response, 1)));
+        $first_kex_packet_follows = $first_kex_packet_follows != 0;
+
+        if (!$this->send_kex_first && !$this->_send_binary_packet($kexinit_payload_client)) {
+            return false;
+        }
+
+        // we need to decide upon the symmetric encryption algorithms before we do the diffie-hellman key exchange
+        // we don't initialize any crypto-objects, yet - we do that, later. for now, we need the lengths to make the
+        // diffie-hellman key exchange as fast as possible
+        $decrypt = $this->_array_intersect_first($encryption_algorithms, $this->encryption_algorithms_server_to_client);
+        $decryptKeyLength = $this->_encryption_algorithm_to_key_size($decrypt);
+        if ($decryptKeyLength === null) {
+            user_error('No compatible server to client encryption algorithms found');
+            return $this->_disconnect(NET_SSH2_DISCONNECT_KEY_EXCHANGE_FAILED);
+        }
+
+        $encrypt = $this->_array_intersect_first($encryption_algorithms, $this->encryption_algorithms_client_to_server);
+        $encryptKeyLength = $this->_encryption_algorithm_to_key_size($encrypt);
+        if ($encryptKeyLength === null) {
+            user_error('No compatible client to server encryption algorithms found');
+            return $this->_disconnect(NET_SSH2_DISCONNECT_KEY_EXCHANGE_FAILED);
+        }
+
+        // through diffie-hellman key exchange a symmetric key is obtained
+        $kex_algorithm = $this->_array_intersect_first($kex_algorithms, $this->kex_algorithms);
+        if ($kex_algorithm === false) {
+            user_error('No compatible key exchange algorithms found');
+            return $this->_disconnect(NET_SSH2_DISCONNECT_KEY_EXCHANGE_FAILED);
+        }
+
+        // Only relevant in diffie-hellman-group-exchange-sha{1,256}, otherwise empty.
+        $exchange_hash_rfc4419 = '';
+
+        if ($kex_algorithm === 'curve25519-sha256@libssh.org') {
+            $x = Random::string(32);
+            $eBytes = \Sodium\crypto_box_publickey_from_secretkey($x);
+            $clientKexInitMessage = NET_SSH2_MSG_KEX_ECDH_INIT;
+            $serverKexReplyMessage = NET_SSH2_MSG_KEX_ECDH_REPLY;
+            $kexHash = new Hash('sha256');
+        } else {
+            if (strpos($kex_algorithm, 'diffie-hellman-group-exchange') === 0) {
+                $dh_group_sizes_packed = pack(
+                    'NNN',
+                    $this->kex_dh_group_size_min,
+                    $this->kex_dh_group_size_preferred,
+                    $this->kex_dh_group_size_max
+                );
+                $packet = pack(
+                    'Ca*',
+                    NET_SSH2_MSG_KEXDH_GEX_REQUEST,
+                    $dh_group_sizes_packed
+                );
+                if (!$this->_send_binary_packet($packet)) {
+                    return false;
+                }
+
+                $response = $this->_get_binary_packet();
+                if ($response === false) {
+                    user_error('Connection closed by server');
+                    return false;
+                }
+                extract(unpack('Ctype', $this->_string_shift($response, 1)));
+                if ($type != NET_SSH2_MSG_KEXDH_GEX_GROUP) {
+                    user_error('Expected SSH_MSG_KEX_DH_GEX_GROUP');
+                    return false;
+                }
+
+                if (strlen($response) < 4) {
+                    return false;
+                }
+                extract(unpack('NprimeLength', $this->_string_shift($response, 4)));
+                $primeBytes = $this->_string_shift($response, $primeLength);
+                $prime = new BigInteger($primeBytes, -256);
+
+                if (strlen($response) < 4) {
+                    return false;
+                }
+                extract(unpack('NgLength', $this->_string_shift($response, 4)));
+                $gBytes = $this->_string_shift($response, $gLength);
+                $g = new BigInteger($gBytes, -256);
+
+                $exchange_hash_rfc4419 = pack(
+                    'a*Na*Na*',
+                    $dh_group_sizes_packed,
+                    $primeLength,
+                    $primeBytes,
+                    $gLength,
+                    $gBytes
+                );
+
+                $clientKexInitMessage = NET_SSH2_MSG_KEXDH_GEX_INIT;
+                $serverKexReplyMessage = NET_SSH2_MSG_KEXDH_GEX_REPLY;
+            } else {
+                switch ($kex_algorithm) {
+                    // see http://tools.ietf.org/html/rfc2409#section-6.2 and
+                    // http://tools.ietf.org/html/rfc2412, appendex E
+                    case 'diffie-hellman-group1-sha1':
+                        $prime = 'FFFFFFFFFFFFFFFFC90FDAA22168C234C4C6628B80DC1CD129024E088A67CC74' .
+                                '020BBEA63B139B22514A08798E3404DDEF9519B3CD3A431B302B0A6DF25F1437' .
+                                '4FE1356D6D51C245E485B576625E7EC6F44C42E9A637ED6B0BFF5CB6F406B7ED' .
+                                'EE386BFB5A899FA5AE9F24117C4B1FE649286651ECE65381FFFFFFFFFFFFFFFF';
+                        break;
+                    // see http://tools.ietf.org/html/rfc3526#section-3
+                    case 'diffie-hellman-group14-sha1':
+                        $prime = 'FFFFFFFFFFFFFFFFC90FDAA22168C234C4C6628B80DC1CD129024E088A67CC74' .
+                                '020BBEA63B139B22514A08798E3404DDEF9519B3CD3A431B302B0A6DF25F1437' .
+                                '4FE1356D6D51C245E485B576625E7EC6F44C42E9A637ED6B0BFF5CB6F406B7ED' .
+                                'EE386BFB5A899FA5AE9F24117C4B1FE649286651ECE45B3DC2007CB8A163BF05' .
+                                '98DA48361C55D39A69163FA8FD24CF5F83655D23DCA3AD961C62F356208552BB' .
+                                '9ED529077096966D670C354E4ABC9804F1746C08CA18217C32905E462E36CE3B' .
+                                'E39E772C180E86039B2783A2EC07A28FB5C55DF06F4C52C9DE2BCBF695581718' .
+                                '3995497CEA956AE515D2261898FA051015728E5A8AACAA68FFFFFFFFFFFFFFFF';
+                        break;
+                }
+                // For both diffie-hellman-group1-sha1 and diffie-hellman-group14-sha1
+                // the generator field element is 2 (decimal) and the hash function is sha1.
+                $g = new BigInteger(2);
+                $prime = new BigInteger($prime, 16);
+                $clientKexInitMessage = NET_SSH2_MSG_KEXDH_INIT;
+                $serverKexReplyMessage = NET_SSH2_MSG_KEXDH_REPLY;
+            }
+
+            switch ($kex_algorithm) {
+                case 'diffie-hellman-group-exchange-sha256':
+                    $kexHash = new Hash('sha256');
+                    break;
+                default:
+                    $kexHash = new Hash('sha1');
+            }
+
+            /* To increase the speed of the key exchange, both client and server may
+            reduce the size of their private exponents.  It should be at least
+            twice as long as the key material that is generated from the shared
+            secret.  For more details, see the paper by van Oorschot and Wiener
+            [VAN-OORSCHOT].
+
+            -- http://tools.ietf.org/html/rfc4419#section-6.2 */
+            $one = new BigInteger(1);
+            $keyLength = min($kexHash->getLength(), max($encryptKeyLength, $decryptKeyLength));
+            $max = $one->bitwise_leftShift(16 * $keyLength); // 2 * 8 * $keyLength
+            $max = $max->subtract($one);
+
+            $x = $one->random($one, $max);
+            $e = $g->modPow($x, $prime);
+
+            $eBytes = $e->toBytes(true);
+        }
+        $data = pack('CNa*', $clientKexInitMessage, strlen($eBytes), $eBytes);
+
+        if (!$this->_send_binary_packet($data)) {
+            user_error('Connection closed by server');
+            return false;
+        }
+
+        $response = $this->_get_binary_packet();
+        if ($response === false) {
+            user_error('Connection closed by server');
+            return false;
+        }
+        if (!strlen($response)) {
+            return false;
+        }
+        extract(unpack('Ctype', $this->_string_shift($response, 1)));
+
+        if ($type != $serverKexReplyMessage) {
+            user_error('Expected SSH_MSG_KEXDH_REPLY');
+            return false;
+        }
+
+        if (strlen($response) < 4) {
+            return false;
+        }
+        $temp = unpack('Nlength', $this->_string_shift($response, 4));
+        $this->server_public_host_key = $server_public_host_key = $this->_string_shift($response, $temp['length']);
+
+        if (strlen($server_public_host_key) < 4) {
+            return false;
+        }
+        $temp = unpack('Nlength', $this->_string_shift($server_public_host_key, 4));
+        $public_key_format = $this->_string_shift($server_public_host_key, $temp['length']);
+
+        if (strlen($response) < 4) {
+            return false;
+        }
+        $temp = unpack('Nlength', $this->_string_shift($response, 4));
+        $fBytes = $this->_string_shift($response, $temp['length']);
+
+        if (strlen($response) < 4) {
+            return false;
+        }
+        $temp = unpack('Nlength', $this->_string_shift($response, 4));
+        $this->signature = $this->_string_shift($response, $temp['length']);
+
+        if (strlen($this->signature) < 4) {
+            return false;
+        }
+        $temp = unpack('Nlength', $this->_string_shift($this->signature, 4));
+        $this->signature_format = $this->_string_shift($this->signature, $temp['length']);
+
+        if ($kex_algorithm === 'curve25519-sha256@libssh.org') {
+            if (strlen($fBytes) !== 32) {
+                user_error('Received curve25519 public key of invalid length.');
+                return false;
+            }
+            $key = new BigInteger(\Sodium\crypto_scalarmult($x, $fBytes), 256);
+            \Sodium\memzero($x);
+        } else {
+            $f = new BigInteger($fBytes, -256);
+            $key = $f->modPow($x, $prime);
+        }
+        $keyBytes = $key->toBytes(true);
+
+        $this->exchange_hash = pack(
+            'Na*Na*Na*Na*Na*a*Na*Na*Na*',
+            strlen($this->identifier),
+            $this->identifier,
+            strlen($this->server_identifier),
+            $this->server_identifier,
+            strlen($kexinit_payload_client),
+            $kexinit_payload_client,
+            strlen($kexinit_payload_server),
+            $kexinit_payload_server,
+            strlen($this->server_public_host_key),
+            $this->server_public_host_key,
+            $exchange_hash_rfc4419,
+            strlen($eBytes),
+            $eBytes,
+            strlen($fBytes),
+            $fBytes,
+            strlen($keyBytes),
+            $keyBytes
+        );
+
+        $this->exchange_hash = $kexHash->hash($this->exchange_hash);
+
+        if ($this->session_id === false) {
+            $this->session_id = $this->exchange_hash;
+        }
+
+        $server_host_key_algorithm = $this->_array_intersect_first($server_host_key_algorithms, $this->server_host_key_algorithms);
+        if ($server_host_key_algorithm === false) {
+            user_error('No compatible server host key algorithms found');
+            return $this->_disconnect(NET_SSH2_DISCONNECT_KEY_EXCHANGE_FAILED);
+        }
+
+        if ($public_key_format != $server_host_key_algorithm || $this->signature_format != $server_host_key_algorithm) {
+            user_error('Server Host Key Algorithm Mismatch');
+            return $this->_disconnect(NET_SSH2_DISCONNECT_KEY_EXCHANGE_FAILED);
+        }
+
+        $packet = pack(
+            'C',
+            NET_SSH2_MSG_NEWKEYS
+        );
+
+        if (!$this->_send_binary_packet($packet)) {
+            return false;
+        }
+
+        $response = $this->_get_binary_packet();
+
+        if ($response === false) {
+            user_error('Connection closed by server');
+            return false;
+        }
+
+        if (!strlen($response)) {
+            return false;
+        }
+        extract(unpack('Ctype', $this->_string_shift($response, 1)));
+
+        if ($type != NET_SSH2_MSG_NEWKEYS) {
+            user_error('Expected SSH_MSG_NEWKEYS');
+            return false;
+        }
+
+        $this->decrypt_algorithm = $decrypt;
+
+        $keyBytes = pack('Na*', strlen($keyBytes), $keyBytes);
+
+        $this->encrypt = $this->_encryption_algorithm_to_crypt_instance($encrypt);
+        if ($this->encrypt) {
+            if ($this->crypto_engine) {
+                $this->encrypt->setEngine($this->crypto_engine);
+            }
+            if ($this->encrypt->block_size) {
+                $this->encrypt_block_size = $this->encrypt->block_size;
+            }
+            $this->encrypt->enableContinuousBuffer();
+            $this->encrypt->disablePadding();
+
+            $iv = $kexHash->hash($keyBytes . $this->exchange_hash . 'A' . $this->session_id);
+            while ($this->encrypt_block_size > strlen($iv)) {
+                $iv.= $kexHash->hash($keyBytes . $this->exchange_hash . $iv);
+            }
+            $this->encrypt->setIV(substr($iv, 0, $this->encrypt_block_size));
+
+            $key = $kexHash->hash($keyBytes . $this->exchange_hash . 'C' . $this->session_id);
+            while ($encryptKeyLength > strlen($key)) {
+                $key.= $kexHash->hash($keyBytes . $this->exchange_hash . $key);
+            }
+            $this->encrypt->setKey(substr($key, 0, $encryptKeyLength));
+        }
+
+        $this->decrypt = $this->_encryption_algorithm_to_crypt_instance($decrypt);
+        if ($this->decrypt) {
+            if ($this->crypto_engine) {
+                $this->decrypt->setEngine($this->crypto_engine);
+            }
+            if ($this->decrypt->block_size) {
+                $this->decrypt_block_size = $this->decrypt->block_size;
+            }
+            $this->decrypt->enableContinuousBuffer();
+            $this->decrypt->disablePadding();
+
+            $iv = $kexHash->hash($keyBytes . $this->exchange_hash . 'B' . $this->session_id);
+            while ($this->decrypt_block_size > strlen($iv)) {
+                $iv.= $kexHash->hash($keyBytes . $this->exchange_hash . $iv);
+            }
+            $this->decrypt->setIV(substr($iv, 0, $this->decrypt_block_size));
+
+            $key = $kexHash->hash($keyBytes . $this->exchange_hash . 'D' . $this->session_id);
+            while ($decryptKeyLength > strlen($key)) {
+                $key.= $kexHash->hash($keyBytes . $this->exchange_hash . $key);
+            }
+            $this->decrypt->setKey(substr($key, 0, $decryptKeyLength));
+        }
+
+        /* The "arcfour128" algorithm is the RC4 cipher, as described in
+           [SCHNEIER], using a 128-bit key.  The first 1536 bytes of keystream
+           generated by the cipher MUST be discarded, and the first byte of the
+           first encrypted packet MUST be encrypted using the 1537th byte of
+           keystream.
+
+           -- http://tools.ietf.org/html/rfc4345#section-4 */
+        if ($encrypt == 'arcfour128' || $encrypt == 'arcfour256') {
+            $this->encrypt->encrypt(str_repeat("\0", 1536));
+        }
+        if ($decrypt == 'arcfour128' || $decrypt == 'arcfour256') {
+            $this->decrypt->decrypt(str_repeat("\0", 1536));
+        }
+
+        $mac_algorithm = $this->_array_intersect_first($mac_algorithms, $this->mac_algorithms_client_to_server);
+        if ($mac_algorithm === false) {
+            user_error('No compatible client to server message authentication algorithms found');
+            return $this->_disconnect(NET_SSH2_DISCONNECT_KEY_EXCHANGE_FAILED);
+        }
+
+        $createKeyLength = 0; // ie. $mac_algorithm == 'none'
+        switch ($mac_algorithm) {
+            case 'hmac-sha2-256':
+                $this->hmac_create = new Hash('sha256');
+                $createKeyLength = 32;
+                break;
+            case 'hmac-sha1':
+                $this->hmac_create = new Hash('sha1');
+                $createKeyLength = 20;
+                break;
+            case 'hmac-sha1-96':
+                $this->hmac_create = new Hash('sha1-96');
+                $createKeyLength = 20;
+                break;
+            case 'hmac-md5':
+                $this->hmac_create = new Hash('md5');
+                $createKeyLength = 16;
+                break;
+            case 'hmac-md5-96':
+                $this->hmac_create = new Hash('md5-96');
+                $createKeyLength = 16;
+        }
+
+        $mac_algorithm = $this->_array_intersect_first($mac_algorithms, $this->mac_algorithms_server_to_client);
+        if ($mac_algorithm === false) {
+            user_error('No compatible server to client message authentication algorithms found');
+            return $this->_disconnect(NET_SSH2_DISCONNECT_KEY_EXCHANGE_FAILED);
+        }
+
+        $checkKeyLength = 0;
+        $this->hmac_size = 0;
+        switch ($mac_algorithm) {
+            case 'hmac-sha2-256':
+                $this->hmac_check = new Hash('sha256');
+                $checkKeyLength = 32;
+                $this->hmac_size = 32;
+                break;
+            case 'hmac-sha1':
+                $this->hmac_check = new Hash('sha1');
+                $checkKeyLength = 20;
+                $this->hmac_size = 20;
+                break;
+            case 'hmac-sha1-96':
+                $this->hmac_check = new Hash('sha1-96');
+                $checkKeyLength = 20;
+                $this->hmac_size = 12;
+                break;
+            case 'hmac-md5':
+                $this->hmac_check = new Hash('md5');
+                $checkKeyLength = 16;
+                $this->hmac_size = 16;
+                break;
+            case 'hmac-md5-96':
+                $this->hmac_check = new Hash('md5-96');
+                $checkKeyLength = 16;
+                $this->hmac_size = 12;
+        }
+
+        $key = $kexHash->hash($keyBytes . $this->exchange_hash . 'E' . $this->session_id);
+        while ($createKeyLength > strlen($key)) {
+            $key.= $kexHash->hash($keyBytes . $this->exchange_hash . $key);
+        }
+        $this->hmac_create->setKey(substr($key, 0, $createKeyLength));
+
+        $key = $kexHash->hash($keyBytes . $this->exchange_hash . 'F' . $this->session_id);
+        while ($checkKeyLength > strlen($key)) {
+            $key.= $kexHash->hash($keyBytes . $this->exchange_hash . $key);
+        }
+        $this->hmac_check->setKey(substr($key, 0, $checkKeyLength));
+
+        $compression_algorithm = $this->_array_intersect_first($compression_algorithms, $this->compression_algorithms_server_to_client);
+        if ($compression_algorithm === false) {
+            user_error('No compatible server to client compression algorithms found');
+            return $this->_disconnect(NET_SSH2_DISCONNECT_KEY_EXCHANGE_FAILED);
+        }
+        $this->decompress = $compression_algorithm == 'zlib';
+
+        $compression_algorithm = $this->_array_intersect_first($compression_algorithms, $this->compression_algorithms_client_to_server);
+        if ($compression_algorithm === false) {
+            user_error('No compatible client to server compression algorithms found');
+            return $this->_disconnect(NET_SSH2_DISCONNECT_KEY_EXCHANGE_FAILED);
+        }
+        $this->compress = $compression_algorithm == 'zlib';
+
+        return true;
+    }
+
+    /**
+     * Maps an encryption algorithm name to the number of key bytes.
+     *
+     * @param string $algorithm Name of the encryption algorithm
+     * @return int|null Number of bytes as an integer or null for unknown
+     * @access private
+     */
+    function _encryption_algorithm_to_key_size($algorithm)
+    {
+        if ($this->bad_key_size_fix && $this->_bad_algorithm_candidate($algorithm)) {
+            return 16;
+        }
+
+        switch ($algorithm) {
+            case 'none':
+                return 0;
+            case 'aes128-cbc':
+            case 'aes128-ctr':
+            case 'arcfour':
+            case 'arcfour128':
+            case 'blowfish-cbc':
+            case 'blowfish-ctr':
+            case 'twofish128-cbc':
+            case 'twofish128-ctr':
+                return 16;
+            case '3des-cbc':
+            case '3des-ctr':
+            case 'aes192-cbc':
+            case 'aes192-ctr':
+            case 'twofish192-cbc':
+            case 'twofish192-ctr':
+                return 24;
+            case 'aes256-cbc':
+            case 'aes256-ctr':
+            case 'arcfour256':
+            case 'twofish-cbc':
+            case 'twofish256-cbc':
+            case 'twofish256-ctr':
+                return 32;
+        }
+        return null;
+    }
+
+    /**
+     * Maps an encryption algorithm name to an instance of a subclass of
+     * \phpseclib\Crypt\Base.
+     *
+     * @param string $algorithm Name of the encryption algorithm
+     * @return mixed Instance of \phpseclib\Crypt\Base or null for unknown
+     * @access private
+     */
+    function _encryption_algorithm_to_crypt_instance($algorithm)
+    {
+        switch ($algorithm) {
+            case '3des-cbc':
+                return new TripleDES();
+            case '3des-ctr':
+                return new TripleDES(Base::MODE_CTR);
+            case 'aes256-cbc':
+            case 'aes192-cbc':
+            case 'aes128-cbc':
+                return new Rijndael();
+            case 'aes256-ctr':
+            case 'aes192-ctr':
+            case 'aes128-ctr':
+                return new Rijndael(Base::MODE_CTR);
+            case 'blowfish-cbc':
+                return new Blowfish();
+            case 'blowfish-ctr':
+                return new Blowfish(Base::MODE_CTR);
+            case 'twofish128-cbc':
+            case 'twofish192-cbc':
+            case 'twofish256-cbc':
+            case 'twofish-cbc':
+                return new Twofish();
+            case 'twofish128-ctr':
+            case 'twofish192-ctr':
+            case 'twofish256-ctr':
+                return new Twofish(Base::MODE_CTR);
+            case 'arcfour':
+            case 'arcfour128':
+            case 'arcfour256':
+                return new RC4();
+        }
+        return null;
+    }
+
+    /*
+     * Tests whether or not proposed algorithm has a potential for issues
+     *
+     * @link https://www.chiark.greenend.org.uk/~sgtatham/putty/wishlist/ssh2-aesctr-openssh.html
+     * @link https://bugzilla.mindrot.org/show_bug.cgi?id=1291
+     * @param string $algorithm Name of the encryption algorithm
+     * @return bool
+     * @access private
+     */
+    function _bad_algorithm_candidate($algorithm)
+    {
+        switch ($algorithm) {
+            case 'arcfour256':
+            case 'aes192-ctr':
+            case 'aes256-ctr':
+                return true;
+        }
+
+        return false;
+    }
+
+    /**
+     * Login
+     *
+     * The $password parameter can be a plaintext password, a \phpseclib\Crypt\RSA object or an array
+     *
+     * @param string $username
+     * @param mixed $password
+     * @param mixed $...
+     * @return bool
+     * @see self::_login()
+     * @access public
+     */
+    function login($username)
+    {
+        $args = func_get_args();
+        return call_user_func_array(array(&$this, '_login'), $args);
+    }
+
+    /**
+     * Login Helper
+     *
+     * @param string $username
+     * @param mixed $password
+     * @param mixed $...
+     * @return bool
+     * @see self::_login_helper()
+     * @access private
+     */
+    function _login($username)
+    {
+        if (!($this->bitmap & self::MASK_CONSTRUCTOR)) {
+            if (!$this->_connect()) {
+                return false;
+            }
+        }
+
+        $args = array_slice(func_get_args(), 1);
+        if (empty($args)) {
+            return $this->_login_helper($username);
+        }
+
+        foreach ($args as $arg) {
+            if ($this->_login_helper($username, $arg)) {
+                return true;
+            }
+        }
+        return false;
+    }
+
+    /**
+     * Login Helper
+     *
+     * @param string $username
+     * @param string $password
+     * @return bool
+     * @access private
+     * @internal It might be worthwhile, at some point, to protect against {@link http://tools.ietf.org/html/rfc4251#section-9.3.9 traffic analysis}
+     *           by sending dummy SSH_MSG_IGNORE messages.
+     */
+    function _login_helper($username, $password = null)
+    {
+        if (!($this->bitmap & self::MASK_CONNECTED)) {
+            return false;
+        }
+
+        if (!($this->bitmap & self::MASK_LOGIN_REQ)) {
+            $packet = pack(
+                'CNa*',
+                NET_SSH2_MSG_SERVICE_REQUEST,
+                strlen('ssh-userauth'),
+                'ssh-userauth'
+            );
 
-            'arcfour',    // OPTIONAL          the ARCFOUR stream cipher with a 128-bit key
+            if (!$this->_send_binary_packet($packet)) {
+                return false;
+            }
 
-            'aes128-cbc', // RECOMMENDED       AES with a 128-bit key
-            'aes192-cbc', // OPTIONAL          AES with a 192-bit key
-            'aes256-cbc', // OPTIONAL          AES in CBC mode, with a 256-bit key
+            $response = $this->_get_binary_packet();
+            if ($response === false) {
+                if ($this->retry_connect) {
+                    $this->retry_connect = false;
+                    if (!$this->_connect()) {
+                        return false;
+                    }
+                    return $this->_login_helper($username, $password);
+                }
+                user_error('Connection closed by server');
+                return false;
+            }
 
-            // from <http://tools.ietf.org/html/rfc4344#section-4>:
-            'aes128-ctr', // RECOMMENDED       AES (Rijndael) in SDCTR mode, with 128-bit key
-            'aes192-ctr', // RECOMMENDED       AES with 192-bit key
-            'aes256-ctr', // RECOMMENDED       AES with 256-bit key
-            '3des-ctr',   // RECOMMENDED       Three-key 3DES in SDCTR mode
+            if (strlen($response) < 4) {
+                return false;
+            }
+            extract(unpack('Ctype', $this->_string_shift($response, 1)));
 
-            '3des-cbc',   // REQUIRED          three-key 3DES in CBC mode
-            'none'        // OPTIONAL          no encryption; NOT RECOMMENDED
-        );
+            if ($type != NET_SSH2_MSG_SERVICE_ACCEPT) {
+                user_error('Expected SSH_MSG_SERVICE_ACCEPT');
+                return false;
+            }
+            $this->bitmap |= self::MASK_LOGIN_REQ;
+        }
 
-        static $mac_algorithms = array(
-            'hmac-sha1-96', // RECOMMENDED     first 96 bits of HMAC-SHA1 (digest length = 12, key length = 20)
-            'hmac-sha1',    // REQUIRED        HMAC-SHA1 (digest length = key length = 20)
-            'hmac-md5-96',  // OPTIONAL        first 96 bits of HMAC-MD5 (digest length = 12, key length = 16)
-            'hmac-md5',     // OPTIONAL        HMAC-MD5 (digest length = key length = 16)
-            'none'          // OPTIONAL        no MAC; NOT RECOMMENDED
-        );
+        if (strlen($this->last_interactive_response)) {
+            return !is_string($password) && !is_array($password) ? false : $this->_keyboard_interactive_process($password);
+        }
 
-        static $compression_algorithms = array(
-            'none'   // REQUIRED        no compression
-            //'zlib' // OPTIONAL        ZLIB (LZ77) compression
+        if ($password instanceof RSA) {
+            return $this->_privatekey_login($username, $password);
+        } elseif ($password instanceof Agent) {
+            return $this->_ssh_agent_login($username, $password);
+        }
+
+        if (is_array($password)) {
+            if ($this->_keyboard_interactive_login($username, $password)) {
+                $this->bitmap |= self::MASK_LOGIN;
+                return true;
+            }
+            return false;
+        }
+
+        if (!isset($password)) {
+            $packet = pack(
+                'CNa*Na*Na*',
+                NET_SSH2_MSG_USERAUTH_REQUEST,
+                strlen($username),
+                $username,
+                strlen('ssh-connection'),
+                'ssh-connection',
+                strlen('none'),
+                'none'
+            );
+
+            if (!$this->_send_binary_packet($packet)) {
+                return false;
+            }
+
+            $response = $this->_get_binary_packet();
+            if ($response === false) {
+                user_error('Connection closed by server');
+                return false;
+            }
+
+            if (!strlen($response)) {
+                return false;
+            }
+            extract(unpack('Ctype', $this->_string_shift($response, 1)));
+
+            switch ($type) {
+                case NET_SSH2_MSG_USERAUTH_SUCCESS:
+                    $this->bitmap |= self::MASK_LOGIN;
+                    return true;
+                //case NET_SSH2_MSG_USERAUTH_FAILURE:
+                default:
+                    return false;
+            }
+        }
+
+        $packet = pack(
+            'CNa*Na*Na*CNa*',
+            NET_SSH2_MSG_USERAUTH_REQUEST,
+            strlen($username),
+            $username,
+            strlen('ssh-connection'),
+            'ssh-connection',
+            strlen('password'),
+            'password',
+            0,
+            strlen($password),
+            $password
         );
 
-        static $str_kex_algorithms, $str_server_host_key_algorithms,
-               $encryption_algorithms_server_to_client, $mac_algorithms_server_to_client, $compression_algorithms_server_to_client,
-               $encryption_algorithms_client_to_server, $mac_algorithms_client_to_server, $compression_algorithms_client_to_server;
+        // remove the username and password from the logged packet
+        if (!defined('NET_SSH2_LOGGING')) {
+            $logged = null;
+        } else {
+            $logged = pack(
+                'CNa*Na*Na*CNa*',
+                NET_SSH2_MSG_USERAUTH_REQUEST,
+                strlen('username'),
+                'username',
+                strlen('ssh-connection'),
+                'ssh-connection',
+                strlen('password'),
+                'password',
+                0,
+                strlen('password'),
+                'password'
+            );
+        }
 
-        if (empty($str_kex_algorithms)) {
-            $str_kex_algorithms = implode(',', $kex_algorithms);
-            $str_server_host_key_algorithms = implode(',', $server_host_key_algorithms);
-            $encryption_algorithms_server_to_client = $encryption_algorithms_client_to_server = implode(',', $encryption_algorithms);
-            $mac_algorithms_server_to_client = $mac_algorithms_client_to_server = implode(',', $mac_algorithms);
-            $compression_algorithms_server_to_client = $compression_algorithms_client_to_server = implode(',', $compression_algorithms);
+        if (!$this->_send_binary_packet($packet, $logged)) {
+            return false;
         }
 
-        $client_cookie = '';
-        for ($i = 0; $i < 16; $i++) {
-            $client_cookie.= chr(crypt_random(0, 255));
+        $response = $this->_get_binary_packet();
+        if ($response === false) {
+            user_error('Connection closed by server');
+            return false;
         }
 
-        $response = $kexinit_payload_server;
-        $this->_string_shift($response, 1); // skip past the message number (it should be SSH_MSG_KEXINIT)
-        $server_cookie = $this->_string_shift($response, 16);
+        if (!strlen($response)) {
+            return false;
+        }
+        extract(unpack('Ctype', $this->_string_shift($response, 1)));
 
-        $temp = unpack('Nlength', $this->_string_shift($response, 4));
-        $this->kex_algorithms = explode(',', $this->_string_shift($response, $temp['length']));
+        switch ($type) {
+            case NET_SSH2_MSG_USERAUTH_PASSWD_CHANGEREQ: // in theory, the password can be changed
+                if (defined('NET_SSH2_LOGGING')) {
+                    $this->message_number_log[count($this->message_number_log) - 1] = 'NET_SSH2_MSG_USERAUTH_PASSWD_CHANGEREQ';
+                }
+                if (strlen($response) < 4) {
+                    return false;
+                }
+                extract(unpack('Nlength', $this->_string_shift($response, 4)));
+                $this->errors[] = 'SSH_MSG_USERAUTH_PASSWD_CHANGEREQ: ' . utf8_decode($this->_string_shift($response, $length));
+                return $this->_disconnect(NET_SSH2_DISCONNECT_AUTH_CANCELLED_BY_USER);
+            case NET_SSH2_MSG_USERAUTH_FAILURE:
+                // can we use keyboard-interactive authentication?  if not then either the login is bad or the server employees
+                // multi-factor authentication
+                if (strlen($response) < 4) {
+                    return false;
+                }
+                extract(unpack('Nlength', $this->_string_shift($response, 4)));
+                $auth_methods = explode(',', $this->_string_shift($response, $length));
+                if (!strlen($response)) {
+                    return false;
+                }
+                extract(unpack('Cpartial_success', $this->_string_shift($response, 1)));
+                $partial_success = $partial_success != 0;
 
-        $temp = unpack('Nlength', $this->_string_shift($response, 4));
-        $this->server_host_key_algorithms = explode(',', $this->_string_shift($response, $temp['length']));
+                if (!$partial_success && in_array('keyboard-interactive', $auth_methods)) {
+                    if ($this->_keyboard_interactive_login($username, $password)) {
+                        $this->bitmap |= self::MASK_LOGIN;
+                        return true;
+                    }
+                    return false;
+                }
+                return false;
+            case NET_SSH2_MSG_USERAUTH_SUCCESS:
+                $this->bitmap |= self::MASK_LOGIN;
+                return true;
+        }
 
-        $temp = unpack('Nlength', $this->_string_shift($response, 4));
-        $this->encryption_algorithms_client_to_server = explode(',', $this->_string_shift($response, $temp['length']));
+        return false;
+    }
 
-        $temp = unpack('Nlength', $this->_string_shift($response, 4));
-        $this->encryption_algorithms_server_to_client = explode(',', $this->_string_shift($response, $temp['length']));
+    /**
+     * Login via keyboard-interactive authentication
+     *
+     * See {@link http://tools.ietf.org/html/rfc4256 RFC4256} for details.  This is not a full-featured keyboard-interactive authenticator.
+     *
+     * @param string $username
+     * @param string $password
+     * @return bool
+     * @access private
+     */
+    function _keyboard_interactive_login($username, $password)
+    {
+        $packet = pack(
+            'CNa*Na*Na*Na*Na*',
+            NET_SSH2_MSG_USERAUTH_REQUEST,
+            strlen($username),
+            $username,
+            strlen('ssh-connection'),
+            'ssh-connection',
+            strlen('keyboard-interactive'),
+            'keyboard-interactive',
+            0,
+            '',
+            0,
+            ''
+        );
 
-        $temp = unpack('Nlength', $this->_string_shift($response, 4));
-        $this->mac_algorithms_client_to_server = explode(',', $this->_string_shift($response, $temp['length']));
+        if (!$this->_send_binary_packet($packet)) {
+            return false;
+        }
 
-        $temp = unpack('Nlength', $this->_string_shift($response, 4));
-        $this->mac_algorithms_server_to_client = explode(',', $this->_string_shift($response, $temp['length']));
+        return $this->_keyboard_interactive_process($password);
+    }
 
-        $temp = unpack('Nlength', $this->_string_shift($response, 4));
-        $this->compression_algorithms_client_to_server = explode(',', $this->_string_shift($response, $temp['length']));
+    /**
+     * Handle the keyboard-interactive requests / responses.
+     *
+     * @param string $responses...
+     * @return bool
+     * @access private
+     */
+    function _keyboard_interactive_process()
+    {
+        $responses = func_get_args();
 
-        $temp = unpack('Nlength', $this->_string_shift($response, 4));
-        $this->compression_algorithms_server_to_client = explode(',', $this->_string_shift($response, $temp['length']));
+        if (strlen($this->last_interactive_response)) {
+            $response = $this->last_interactive_response;
+        } else {
+            $orig = $response = $this->_get_binary_packet();
+            if ($response === false) {
+                user_error('Connection closed by server');
+                return false;
+            }
+        }
 
-        $temp = unpack('Nlength', $this->_string_shift($response, 4));
-        $this->languages_client_to_server = explode(',', $this->_string_shift($response, $temp['length']));
+        if (!strlen($response)) {
+            return false;
+        }
+        extract(unpack('Ctype', $this->_string_shift($response, 1)));
 
-        $temp = unpack('Nlength', $this->_string_shift($response, 4));
-        $this->languages_server_to_client = explode(',', $this->_string_shift($response, $temp['length']));
+        switch ($type) {
+            case NET_SSH2_MSG_USERAUTH_INFO_REQUEST:
+                if (strlen($response) < 4) {
+                    return false;
+                }
+                extract(unpack('Nlength', $this->_string_shift($response, 4)));
+                $this->_string_shift($response, $length); // name; may be empty
+                if (strlen($response) < 4) {
+                    return false;
+                }
+                extract(unpack('Nlength', $this->_string_shift($response, 4)));
+                $this->_string_shift($response, $length); // instruction; may be empty
+                if (strlen($response) < 4) {
+                    return false;
+                }
+                extract(unpack('Nlength', $this->_string_shift($response, 4)));
+                $this->_string_shift($response, $length); // language tag; may be empty
+                if (strlen($response) < 4) {
+                    return false;
+                }
+                extract(unpack('Nnum_prompts', $this->_string_shift($response, 4)));
+
+                for ($i = 0; $i < count($responses); $i++) {
+                    if (is_array($responses[$i])) {
+                        foreach ($responses[$i] as $key => $value) {
+                            $this->keyboard_requests_responses[$key] = $value;
+                        }
+                        unset($responses[$i]);
+                    }
+                }
+                $responses = array_values($responses);
+
+                if (isset($this->keyboard_requests_responses)) {
+                    for ($i = 0; $i < $num_prompts; $i++) {
+                        if (strlen($response) < 4) {
+                            return false;
+                        }
+                        extract(unpack('Nlength', $this->_string_shift($response, 4)));
+                        // prompt - ie. "Password: "; must not be empty
+                        $prompt = $this->_string_shift($response, $length);
+                        //$echo = $this->_string_shift($response) != chr(0);
+                        foreach ($this->keyboard_requests_responses as $key => $value) {
+                            if (substr($prompt, 0, strlen($key)) == $key) {
+                                $responses[] = $value;
+                                break;
+                            }
+                        }
+                    }
+                }
 
-        extract(unpack('Cfirst_kex_packet_follows', $this->_string_shift($response, 1)));
-        $first_kex_packet_follows = $first_kex_packet_follows != 0;
+                // see http://tools.ietf.org/html/rfc4256#section-3.2
+                if (strlen($this->last_interactive_response)) {
+                    $this->last_interactive_response = '';
+                } elseif (defined('NET_SSH2_LOGGING')) {
+                    $this->message_number_log[count($this->message_number_log) - 1] = str_replace(
+                        'UNKNOWN',
+                        'NET_SSH2_MSG_USERAUTH_INFO_REQUEST',
+                        $this->message_number_log[count($this->message_number_log) - 1]
+                    );
+                }
 
-        // the sending of SSH2_MSG_KEXINIT could go in one of two places.  this is the second place.
-        $kexinit_payload_client = pack('Ca*Na*Na*Na*Na*Na*Na*Na*Na*Na*Na*CN',
-            NET_SSH2_MSG_KEXINIT, $client_cookie, strlen($str_kex_algorithms), $str_kex_algorithms,
-            strlen($str_server_host_key_algorithms), $str_server_host_key_algorithms, strlen($encryption_algorithms_client_to_server),
-            $encryption_algorithms_client_to_server, strlen($encryption_algorithms_server_to_client), $encryption_algorithms_server_to_client,
-            strlen($mac_algorithms_client_to_server), $mac_algorithms_client_to_server, strlen($mac_algorithms_server_to_client),
-            $mac_algorithms_server_to_client, strlen($compression_algorithms_client_to_server), $compression_algorithms_client_to_server,
-            strlen($compression_algorithms_server_to_client), $compression_algorithms_server_to_client, 0, '', 0, '',
-            0, 0
-        );
+                if (!count($responses) && $num_prompts) {
+                    $this->last_interactive_response = $orig;
+                    return false;
+                }
 
-        if (!$this->_send_binary_packet($kexinit_payload_client)) {
-            return false;
+                /*
+                   After obtaining the requested information from the user, the client
+                   MUST respond with an SSH_MSG_USERAUTH_INFO_RESPONSE message.
+                */
+                // see http://tools.ietf.org/html/rfc4256#section-3.4
+                $packet = $logged = pack('CN', NET_SSH2_MSG_USERAUTH_INFO_RESPONSE, count($responses));
+                for ($i = 0; $i < count($responses); $i++) {
+                    $packet.= pack('Na*', strlen($responses[$i]), $responses[$i]);
+                    $logged.= pack('Na*', strlen('dummy-answer'), 'dummy-answer');
+                }
+
+                if (!$this->_send_binary_packet($packet, $logged)) {
+                    return false;
+                }
+
+                if (defined('NET_SSH2_LOGGING') && NET_SSH2_LOGGING == self::LOG_COMPLEX) {
+                    $this->message_number_log[count($this->message_number_log) - 1] = str_replace(
+                        'UNKNOWN',
+                        'NET_SSH2_MSG_USERAUTH_INFO_RESPONSE',
+                        $this->message_number_log[count($this->message_number_log) - 1]
+                    );
+                }
+
+                /*
+                   After receiving the response, the server MUST send either an
+                   SSH_MSG_USERAUTH_SUCCESS, SSH_MSG_USERAUTH_FAILURE, or another
+                   SSH_MSG_USERAUTH_INFO_REQUEST message.
+                */
+                // maybe phpseclib should force close the connection after x request / responses?  unless something like that is done
+                // there could be an infinite loop of request / responses.
+                return $this->_keyboard_interactive_process();
+            case NET_SSH2_MSG_USERAUTH_SUCCESS:
+                return true;
+            case NET_SSH2_MSG_USERAUTH_FAILURE:
+                return false;
         }
-        // here ends the second place.
 
-        // we need to decide upon the symmetric encryption algorithms before we do the diffie-hellman key exchange
-        for ($i = 0; $i < count($encryption_algorithms) && !in_array($encryption_algorithms[$i], $this->encryption_algorithms_server_to_client); $i++);
-        if ($i == count($encryption_algorithms)) {
-            user_error('No compatible server to client encryption algorithms found', E_USER_NOTICE);
-            return $this->_disconnect(NET_SSH2_DISCONNECT_KEY_EXCHANGE_FAILED);
+        return false;
+    }
+
+    /**
+     * Login with an ssh-agent provided key
+     *
+     * @param string $username
+     * @param \phpseclib\System\SSH\Agent $agent
+     * @return bool
+     * @access private
+     */
+    function _ssh_agent_login($username, $agent)
+    {
+        $this->agent = $agent;
+        $keys = $agent->requestIdentities();
+        foreach ($keys as $key) {
+            if ($this->_privatekey_login($username, $key)) {
+                return true;
+            }
         }
 
-        // we don't initialize any crypto-objects, yet - we do that, later. for now, we need the lengths to make the
-        // diffie-hellman key exchange as fast as possible
-        $decrypt = $encryption_algorithms[$i];
-        switch ($decrypt) {
-            case '3des-cbc':
-            case '3des-ctr':
-                $decryptKeyLength = 24; // eg. 192 / 8
-                break;
-            case 'aes256-cbc':
-            case 'aes256-ctr':
-                $decryptKeyLength = 32; // eg. 256 / 8
-                break;
-            case 'aes192-cbc':
-            case 'aes192-ctr':
-                $decryptKeyLength = 24; // eg. 192 / 8
-                break;
-            case 'aes128-cbc':
-            case 'aes128-ctr':
-                $decryptKeyLength = 16; // eg. 128 / 8
-                break;
-            case 'arcfour':
-            case 'arcfour128':
-                $decryptKeyLength = 16; // eg. 128 / 8
-                break;
-            case 'arcfour256':
-                $decryptKeyLength = 32; // eg. 128 / 8
-                break;
-            case 'none';
-                $decryptKeyLength = 0;
+        return false;
+    }
+
+    /**
+     * Login with an RSA private key
+     *
+     * @param string $username
+     * @param \phpseclib\Crypt\RSA $password
+     * @return bool
+     * @access private
+     * @internal It might be worthwhile, at some point, to protect against {@link http://tools.ietf.org/html/rfc4251#section-9.3.9 traffic analysis}
+     *           by sending dummy SSH_MSG_IGNORE messages.
+     */
+    function _privatekey_login($username, $privatekey)
+    {
+        // see http://tools.ietf.org/html/rfc4253#page-15
+        $publickey = $privatekey->getPublicKey(RSA::PUBLIC_FORMAT_RAW);
+        if ($publickey === false) {
+            return false;
         }
 
-        for ($i = 0; $i < count($encryption_algorithms) && !in_array($encryption_algorithms[$i], $this->encryption_algorithms_client_to_server); $i++);
-        if ($i == count($encryption_algorithms)) {
-            user_error('No compatible client to server encryption algorithms found', E_USER_NOTICE);
-            return $this->_disconnect(NET_SSH2_DISCONNECT_KEY_EXCHANGE_FAILED);
+        $publickey = array(
+            'e' => $publickey['e']->toBytes(true),
+            'n' => $publickey['n']->toBytes(true)
+        );
+        $publickey = pack(
+            'Na*Na*Na*',
+            strlen('ssh-rsa'),
+            'ssh-rsa',
+            strlen($publickey['e']),
+            $publickey['e'],
+            strlen($publickey['n']),
+            $publickey['n']
+        );
+
+        $part1 = pack(
+            'CNa*Na*Na*',
+            NET_SSH2_MSG_USERAUTH_REQUEST,
+            strlen($username),
+            $username,
+            strlen('ssh-connection'),
+            'ssh-connection',
+            strlen('publickey'),
+            'publickey'
+        );
+        $part2 = pack('Na*Na*', strlen('ssh-rsa'), 'ssh-rsa', strlen($publickey), $publickey);
+
+        $packet = $part1 . chr(0) . $part2;
+        if (!$this->_send_binary_packet($packet)) {
+            return false;
         }
 
-        $encrypt = $encryption_algorithms[$i];
-        switch ($encrypt) {
-            case '3des-cbc':
-            case '3des-ctr':
-                $encryptKeyLength = 24;
-                break;
-            case 'aes256-cbc':
-            case 'aes256-ctr':
-                $encryptKeyLength = 32;
-                break;
-            case 'aes192-cbc':
-            case 'aes192-ctr':
-                $encryptKeyLength = 24;
-                break;
-            case 'aes128-cbc':
-            case 'aes128-ctr':
-                $encryptKeyLength = 16;
-                break;
-            case 'arcfour':
-            case 'arcfour128':
-                $encryptKeyLength = 16;
-                break;
-            case 'arcfour256':
-                $encryptKeyLength = 32;
-                break;
-            case 'none';
-                $encryptKeyLength = 0;
+        $response = $this->_get_binary_packet();
+        if ($response === false) {
+            user_error('Connection closed by server');
+            return false;
         }
 
-        $keyLength = $decryptKeyLength > $encryptKeyLength ? $decryptKeyLength : $encryptKeyLength;
+        if (!strlen($response)) {
+            return false;
+        }
+        extract(unpack('Ctype', $this->_string_shift($response, 1)));
 
-        // through diffie-hellman key exchange a symmetric key is obtained
-        for ($i = 0; $i < count($kex_algorithms) && !in_array($kex_algorithms[$i], $this->kex_algorithms); $i++);
-        if ($i == count($kex_algorithms)) {
-            user_error('No compatible key exchange algorithms found', E_USER_NOTICE);
-            return $this->_disconnect(NET_SSH2_DISCONNECT_KEY_EXCHANGE_FAILED);
+        switch ($type) {
+            case NET_SSH2_MSG_USERAUTH_FAILURE:
+                if (strlen($response) < 4) {
+                    return false;
+                }
+                extract(unpack('Nlength', $this->_string_shift($response, 4)));
+                $this->errors[] = 'SSH_MSG_USERAUTH_FAILURE: ' . $this->_string_shift($response, $length);
+                return false;
+            case NET_SSH2_MSG_USERAUTH_PK_OK:
+                // we'll just take it on faith that the public key blob and the public key algorithm name are as
+                // they should be
+                if (defined('NET_SSH2_LOGGING') && NET_SSH2_LOGGING == self::LOG_COMPLEX) {
+                    $this->message_number_log[count($this->message_number_log) - 1] = str_replace(
+                        'UNKNOWN',
+                        'NET_SSH2_MSG_USERAUTH_PK_OK',
+                        $this->message_number_log[count($this->message_number_log) - 1]
+                    );
+                }
         }
 
-        switch ($kex_algorithms[$i]) {
-            // see http://tools.ietf.org/html/rfc2409#section-6.2 and 
-            // http://tools.ietf.org/html/rfc2412, appendex E
-            case 'diffie-hellman-group1-sha1':
-                $p = pack('H256', 'FFFFFFFFFFFFFFFFC90FDAA22168C234C4C6628B80DC1CD129024E088A67CC74' . 
-                                  '020BBEA63B139B22514A08798E3404DDEF9519B3CD3A431B302B0A6DF25F1437' . 
-                                  '4FE1356D6D51C245E485B576625E7EC6F44C42E9A637ED6B0BFF5CB6F406B7ED' . 
-                                  'EE386BFB5A899FA5AE9F24117C4B1FE649286651ECE65381FFFFFFFFFFFFFFFF');
-                $keyLength = $keyLength < 160 ? $keyLength : 160;
-                $hash = 'sha1';
-                break;
-            // see http://tools.ietf.org/html/rfc3526#section-3
-            case 'diffie-hellman-group14-sha1':
-                $p = pack('H512', 'FFFFFFFFFFFFFFFFC90FDAA22168C234C4C6628B80DC1CD129024E088A67CC74' . 
-                                  '020BBEA63B139B22514A08798E3404DDEF9519B3CD3A431B302B0A6DF25F1437' . 
-                                  '4FE1356D6D51C245E485B576625E7EC6F44C42E9A637ED6B0BFF5CB6F406B7ED' . 
-                                  'EE386BFB5A899FA5AE9F24117C4B1FE649286651ECE45B3DC2007CB8A163BF05' . 
-                                  '98DA48361C55D39A69163FA8FD24CF5F83655D23DCA3AD961C62F356208552BB' . 
-                                  '9ED529077096966D670C354E4ABC9804F1746C08CA18217C32905E462E36CE3B' . 
-                                  'E39E772C180E86039B2783A2EC07A28FB5C55DF06F4C52C9DE2BCBF695581718' . 
-                                  '3995497CEA956AE515D2261898FA051015728E5A8AACAA68FFFFFFFFFFFFFFFF');
-                $keyLength = $keyLength < 160 ? $keyLength : 160;
-                $hash = 'sha1';
-        }
-
-        $p = new Math_BigInteger($p, 256);
-        //$q = $p->bitwise_rightShift(1);
-
-        /* To increase the speed of the key exchange, both client and server may
-           reduce the size of their private exponents.  It should be at least
-           twice as long as the key material that is generated from the shared
-           secret.  For more details, see the paper by van Oorschot and Wiener
-           [VAN-OORSCHOT].
-
-           -- http://tools.ietf.org/html/rfc4419#section-6.2 */
-        $q = new Math_BigInteger(1);
-        $q = $q->bitwise_leftShift(2 * $keyLength);
-        $q = $q->subtract(new Math_BigInteger(1));
-
-        $g = new Math_BigInteger(2);
-        $x = new Math_BigInteger();
-        $x->setRandomGenerator('crypt_random');
-        $x = $x->random(new Math_BigInteger(1), $q);
-        $e = $g->modPow($x, $p);
-
-        $eBytes = $e->toBytes(true);
-        $data = pack('CNa*', NET_SSH2_MSG_KEXDH_INIT, strlen($eBytes), $eBytes);
+        $packet = $part1 . chr(1) . $part2;
+        $privatekey->setSignatureMode(RSA::SIGNATURE_PKCS1);
+        $signature = $privatekey->sign(pack('Na*a*', strlen($this->session_id), $this->session_id, $packet));
+        $signature = pack('Na*Na*', strlen('ssh-rsa'), 'ssh-rsa', strlen($signature), $signature);
+        $packet.= pack('Na*', strlen($signature), $signature);
 
-        if (!$this->_send_binary_packet($data)) {
-            user_error('Connection closed by server', E_USER_NOTICE);
+        if (!$this->_send_binary_packet($packet)) {
             return false;
         }
 
         $response = $this->_get_binary_packet();
         if ($response === false) {
-            user_error('Connection closed by server', E_USER_NOTICE);
+            user_error('Connection closed by server');
             return false;
         }
-        extract(unpack('Ctype', $this->_string_shift($response, 1)));
 
-        if ($type != NET_SSH2_MSG_KEXDH_REPLY) {
-            user_error('Expected SSH_MSG_KEXDH_REPLY', E_USER_NOTICE);
+        if (!strlen($response)) {
             return false;
         }
+        extract(unpack('Ctype', $this->_string_shift($response, 1)));
 
-        $temp = unpack('Nlength', $this->_string_shift($response, 4));
-        $this->server_public_host_key = $server_public_host_key = $this->_string_shift($response, $temp['length']);
-
-        $temp = unpack('Nlength', $this->_string_shift($server_public_host_key, 4));
-        $public_key_format = $this->_string_shift($server_public_host_key, $temp['length']);
-
-        $temp = unpack('Nlength', $this->_string_shift($response, 4));
-        $fBytes = $this->_string_shift($response, $temp['length']);
-        $f = new Math_BigInteger($fBytes, -256);
-
-        $temp = unpack('Nlength', $this->_string_shift($response, 4));
-        $this->signature = $this->_string_shift($response, $temp['length']);
+        switch ($type) {
+            case NET_SSH2_MSG_USERAUTH_FAILURE:
+                // either the login is bad or the server employs multi-factor authentication
+                return false;
+            case NET_SSH2_MSG_USERAUTH_SUCCESS:
+                $this->bitmap |= self::MASK_LOGIN;
+                return true;
+        }
 
-        $temp = unpack('Nlength', $this->_string_shift($this->signature, 4));
-        $this->signature_format = $this->_string_shift($this->signature, $temp['length']);
+        return false;
+    }
 
-        $key = $f->modPow($x, $p);
-        $keyBytes = $key->toBytes(true);
+    /**
+     * Set Timeout
+     *
+     * $ssh->exec('ping 127.0.0.1'); on a Linux host will never return and will run indefinitely.  setTimeout() makes it so it'll timeout.
+     * Setting $timeout to false or 0 will mean there is no timeout.
+     *
+     * @param mixed $timeout
+     * @access public
+     */
+    function setTimeout($timeout)
+    {
+        $this->timeout = $this->curTimeout = $timeout;
+    }
 
-        if ($this->session_id === false) {
-            $source = pack('Na*Na*Na*Na*Na*Na*Na*Na*',
-                strlen($this->identifier), $this->identifier, strlen($this->server_identifier), $this->server_identifier,
-                strlen($kexinit_payload_client), $kexinit_payload_client, strlen($kexinit_payload_server),
-                $kexinit_payload_server, strlen($this->server_public_host_key), $this->server_public_host_key, strlen($eBytes),
-                $eBytes, strlen($fBytes), $fBytes, strlen($keyBytes), $keyBytes
-            );
+    /**
+     * Get the output from stdError
+     *
+     * @access public
+     */
+    function getStdError()
+    {
+        return $this->stdErrorLog;
+    }
 
-            $source = pack('H*', $hash($source));
+    /**
+     * Execute Command
+     *
+     * If $callback is set to false then \phpseclib\Net\SSH2::_get_channel_packet(self::CHANNEL_EXEC) will need to be called manually.
+     * In all likelihood, this is not a feature you want to be taking advantage of.
+     *
+     * @param string $command
+     * @param Callback $callback
+     * @return string
+     * @access public
+     */
+    function exec($command, $callback = null)
+    {
+        $this->curTimeout = $this->timeout;
+        $this->is_timeout = false;
+        $this->stdErrorLog = '';
 
-            $this->session_id = $source;
+        if (!$this->isAuthenticated()) {
+            return false;
         }
 
-        for ($i = 0; $i < count($server_host_key_algorithms) && !in_array($server_host_key_algorithms[$i], $this->server_host_key_algorithms); $i++);
-        if ($i == count($server_host_key_algorithms)) {
-            user_error('No compatible server host key algorithms found', E_USER_NOTICE);
-            return $this->_disconnect(NET_SSH2_DISCONNECT_KEY_EXCHANGE_FAILED);
+        if ($this->in_request_pty_exec) {
+            user_error('If you want to run multiple exec()\'s you will need to disable (and re-enable if appropriate) a PTY for each one.');
+            return false;
         }
 
-        if ($public_key_format != $server_host_key_algorithms[$i] || $this->signature_format != $server_host_key_algorithms[$i]) {
-            user_error('Sever Host Key Algorithm Mismatch', E_USER_NOTICE);
-            return $this->_disconnect(NET_SSH2_DISCONNECT_KEY_EXCHANGE_FAILED);
-        }
+        // RFC4254 defines the (client) window size as "bytes the other party can send before it must wait for the window to
+        // be adjusted".  0x7FFFFFFF is, at 2GB, the max size.  technically, it should probably be decremented, but,
+        // honestly, if you're transferring more than 2GB, you probably shouldn't be using phpseclib, anyway.
+        // see http://tools.ietf.org/html/rfc4254#section-5.2 for more info
+        $this->window_size_server_to_client[self::CHANNEL_EXEC] = $this->window_size;
+        // 0x8000 is the maximum max packet size, per http://tools.ietf.org/html/rfc4253#section-6.1, although since PuTTy
+        // uses 0x4000, that's what will be used here, as well.
+        $packet_size = 0x4000;
 
-        $packet = pack('C',
-            NET_SSH2_MSG_NEWKEYS
+        $packet = pack(
+            'CNa*N3',
+            NET_SSH2_MSG_CHANNEL_OPEN,
+            strlen('session'),
+            'session',
+            self::CHANNEL_EXEC,
+            $this->window_size_server_to_client[self::CHANNEL_EXEC],
+            $packet_size
         );
 
         if (!$this->_send_binary_packet($packet)) {
             return false;
         }
 
-        $response = $this->_get_binary_packet();
+        $this->channel_status[self::CHANNEL_EXEC] = NET_SSH2_MSG_CHANNEL_OPEN;
 
+        $response = $this->_get_channel_packet(self::CHANNEL_EXEC);
         if ($response === false) {
-            user_error('Connection closed by server', E_USER_NOTICE);
-            return false;
-        }
-
-        extract(unpack('Ctype', $this->_string_shift($response, 1)));
-
-        if ($type != NET_SSH2_MSG_NEWKEYS) {
-            user_error('Expected SSH_MSG_NEWKEYS', E_USER_NOTICE);
             return false;
         }
 
-        switch ($encrypt) {
-            case '3des-cbc':
-                $this->encrypt = new Crypt_TripleDES();
-                // $this->encrypt_block_size = 64 / 8 == the default
-                break;
-            case '3des-ctr':
-                $this->encrypt = new Crypt_TripleDES(CRYPT_DES_MODE_CTR);
-                // $this->encrypt_block_size = 64 / 8 == the default
-                break;
-            case 'aes256-cbc':
-            case 'aes192-cbc':
-            case 'aes128-cbc':
-                $this->encrypt = new Crypt_AES();
-                $this->encrypt_block_size = 16; // eg. 128 / 8
-                break;
-            case 'aes256-ctr':
-            case 'aes192-ctr':
-            case 'aes128-ctr':
-                $this->encrypt = new Crypt_AES(CRYPT_AES_MODE_CTR);
-                $this->encrypt_block_size = 16; // eg. 128 / 8
-                break;
-            case 'arcfour':
-            case 'arcfour128':
-            case 'arcfour256':
-                $this->encrypt = new Crypt_RC4();
-                break;
-            case 'none';
-                //$this->encrypt = new Crypt_Null();
-        }
-
-        switch ($decrypt) {
-            case '3des-cbc':
-                $this->decrypt = new Crypt_TripleDES();
-                break;
-            case '3des-ctr':
-                $this->decrypt = new Crypt_TripleDES(CRYPT_DES_MODE_CTR);
-                break;
-            case 'aes256-cbc':
-            case 'aes192-cbc':
-            case 'aes128-cbc':
-                $this->decrypt = new Crypt_AES();
-                $this->decrypt_block_size = 16;
-                break;
-            case 'aes256-ctr':
-            case 'aes192-ctr':
-            case 'aes128-ctr':
-                $this->decrypt = new Crypt_AES(CRYPT_AES_MODE_CTR);
-                $this->decrypt_block_size = 16;
-                break;
-            case 'arcfour':
-            case 'arcfour128':
-            case 'arcfour256':
-                $this->decrypt = new Crypt_RC4();
-                break;
-            case 'none';
-                //$this->decrypt = new Crypt_Null();
-        }
-
-        $keyBytes = pack('Na*', strlen($keyBytes), $keyBytes);
-
-        if ($this->encrypt) {
-            $this->encrypt->enableContinuousBuffer();
-            $this->encrypt->disablePadding();
+        if ($this->request_pty === true) {
+            $terminal_modes = pack('C', NET_SSH2_TTY_OP_END);
+            $packet = pack(
+                'CNNa*CNa*N5a*',
+                NET_SSH2_MSG_CHANNEL_REQUEST,
+                $this->server_channels[self::CHANNEL_EXEC],
+                strlen('pty-req'),
+                'pty-req',
+                1,
+                strlen('vt100'),
+                'vt100',
+                $this->windowColumns,
+                $this->windowRows,
+                0,
+                0,
+                strlen($terminal_modes),
+                $terminal_modes
+            );
 
-            $iv = pack('H*', $hash($keyBytes . $this->session_id . 'A' . $this->session_id));
-            while ($this->encrypt_block_size > strlen($iv)) {
-                $iv.= pack('H*', $hash($keyBytes . $this->session_id . $iv));
+            if (!$this->_send_binary_packet($packet)) {
+                return false;
             }
-            $this->encrypt->setIV(substr($iv, 0, $this->encrypt_block_size));
 
-            $key = pack('H*', $hash($keyBytes . $this->session_id . 'C' . $this->session_id));
-            while ($encryptKeyLength > strlen($key)) {
-                $key.= pack('H*', $hash($keyBytes . $this->session_id . $key));
+            $response = $this->_get_binary_packet();
+            if ($response === false) {
+                user_error('Connection closed by server');
+                return false;
             }
-            $this->encrypt->setKey(substr($key, 0, $encryptKeyLength));
-        }
-
-        if ($this->decrypt) {
-            $this->decrypt->enableContinuousBuffer();
-            $this->decrypt->disablePadding();
 
-            $iv = pack('H*', $hash($keyBytes . $this->session_id . 'B' . $this->session_id));
-            while ($this->decrypt_block_size > strlen($iv)) {
-                $iv.= pack('H*', $hash($keyBytes . $this->session_id . $iv));
+            if (!strlen($response)) {
+                return false;
             }
-            $this->decrypt->setIV(substr($iv, 0, $this->decrypt_block_size));
+            list(, $type) = unpack('C', $this->_string_shift($response, 1));
 
-            $key = pack('H*', $hash($keyBytes . $this->session_id . 'D' . $this->session_id));
-            while ($decryptKeyLength > strlen($key)) {
-                $key.= pack('H*', $hash($keyBytes . $this->session_id . $key));
+            switch ($type) {
+                case NET_SSH2_MSG_CHANNEL_SUCCESS:
+                    break;
+                case NET_SSH2_MSG_CHANNEL_FAILURE:
+                default:
+                    user_error('Unable to request pseudo-terminal');
+                    return $this->_disconnect(NET_SSH2_DISCONNECT_BY_APPLICATION);
             }
-            $this->decrypt->setKey(substr($key, 0, $decryptKeyLength));
+            $this->in_request_pty_exec = true;
         }
 
-        /* The "arcfour128" algorithm is the RC4 cipher, as described in
-           [SCHNEIER], using a 128-bit key.  The first 1536 bytes of keystream
-           generated by the cipher MUST be discarded, and the first byte of the
-           first encrypted packet MUST be encrypted using the 1537th byte of
-           keystream.
+        // sending a pty-req SSH_MSG_CHANNEL_REQUEST message is unnecessary and, in fact, in most cases, slows things
+        // down.  the one place where it might be desirable is if you're doing something like \phpseclib\Net\SSH2::exec('ping localhost &').
+        // with a pty-req SSH_MSG_CHANNEL_REQUEST, exec() will return immediately and the ping process will then
+        // then immediately terminate.  without such a request exec() will loop indefinitely.  the ping process won't end but
+        // neither will your script.
 
-           -- http://tools.ietf.org/html/rfc4345#section-4 */
-        if ($encrypt == 'arcfour128' || $encrypt == 'arcfour256') {
-            $this->encrypt->encrypt(str_repeat("\0", 1536));
-        }
-        if ($decrypt == 'arcfour128' || $decrypt == 'arcfour256') {
-            $this->decrypt->decrypt(str_repeat("\0", 1536));
+        // although, in theory, the size of SSH_MSG_CHANNEL_REQUEST could exceed the maximum packet size established by
+        // SSH_MSG_CHANNEL_OPEN_CONFIRMATION, RFC4254#section-5.1 states that the "maximum packet size" refers to the
+        // "maximum size of an individual data packet". ie. SSH_MSG_CHANNEL_DATA.  RFC4254#section-5.2 corroborates.
+        $packet = pack(
+            'CNNa*CNa*',
+            NET_SSH2_MSG_CHANNEL_REQUEST,
+            $this->server_channels[self::CHANNEL_EXEC],
+            strlen('exec'),
+            'exec',
+            1,
+            strlen($command),
+            $command
+        );
+        if (!$this->_send_binary_packet($packet)) {
+            return false;
         }
 
-        for ($i = 0; $i < count($mac_algorithms) && !in_array($mac_algorithms[$i], $this->mac_algorithms_client_to_server); $i++);
-        if ($i == count($mac_algorithms)) {
-            user_error('No compatible client to server message authentication algorithms found', E_USER_NOTICE);
-            return $this->_disconnect(NET_SSH2_DISCONNECT_KEY_EXCHANGE_FAILED);
-        }
+        $this->channel_status[self::CHANNEL_EXEC] = NET_SSH2_MSG_CHANNEL_REQUEST;
 
-        $createKeyLength = 0; // ie. $mac_algorithms[$i] == 'none'
-        switch ($mac_algorithms[$i]) {
-            case 'hmac-sha1':
-                $this->hmac_create = new Crypt_Hash('sha1');
-                $createKeyLength = 20;
-                break;
-            case 'hmac-sha1-96':
-                $this->hmac_create = new Crypt_Hash('sha1-96');
-                $createKeyLength = 20;
-                break;
-            case 'hmac-md5':
-                $this->hmac_create = new Crypt_Hash('md5');
-                $createKeyLength = 16;
-                break;
-            case 'hmac-md5-96':
-                $this->hmac_create = new Crypt_Hash('md5-96');
-                $createKeyLength = 16;
+        $response = $this->_get_channel_packet(self::CHANNEL_EXEC);
+        if ($response === false) {
+            return false;
         }
 
-        for ($i = 0; $i < count($mac_algorithms) && !in_array($mac_algorithms[$i], $this->mac_algorithms_server_to_client); $i++);
-        if ($i == count($mac_algorithms)) {
-            user_error('No compatible server to client message authentication algorithms found', E_USER_NOTICE);
-            return $this->_disconnect(NET_SSH2_DISCONNECT_KEY_EXCHANGE_FAILED);
-        }
+        $this->channel_status[self::CHANNEL_EXEC] = NET_SSH2_MSG_CHANNEL_DATA;
 
-        $checkKeyLength = 0;
-        $this->hmac_size = 0;
-        switch ($mac_algorithms[$i]) {
-            case 'hmac-sha1':
-                $this->hmac_check = new Crypt_Hash('sha1');
-                $checkKeyLength = 20;
-                $this->hmac_size = 20;
-                break;
-            case 'hmac-sha1-96':
-                $this->hmac_check = new Crypt_Hash('sha1-96');
-                $checkKeyLength = 20;
-                $this->hmac_size = 12;
-                break;
-            case 'hmac-md5':
-                $this->hmac_check = new Crypt_Hash('md5');
-                $checkKeyLength = 16;
-                $this->hmac_size = 16;
-                break;
-            case 'hmac-md5-96':
-                $this->hmac_check = new Crypt_Hash('md5-96');
-                $checkKeyLength = 16;
-                $this->hmac_size = 12;
+        if ($callback === false || $this->in_request_pty_exec) {
+            return true;
         }
 
-        $key = pack('H*', $hash($keyBytes . $this->session_id . 'E' . $this->session_id));
-        while ($createKeyLength > strlen($key)) {
-            $key.= pack('H*', $hash($keyBytes . $this->session_id . $key));
+        $output = '';
+        while (true) {
+            $temp = $this->_get_channel_packet(self::CHANNEL_EXEC);
+            switch (true) {
+                case $temp === true:
+                    return is_callable($callback) ? true : $output;
+                case $temp === false:
+                    return false;
+                default:
+                    if (is_callable($callback)) {
+                        if (call_user_func($callback, $temp) === true) {
+                            $this->_close_channel(self::CHANNEL_EXEC);
+                            return true;
+                        }
+                    } else {
+                        $output.= $temp;
+                    }
+            }
         }
-        $this->hmac_create->setKey(substr($key, 0, $createKeyLength));
+    }
 
-        $key = pack('H*', $hash($keyBytes . $this->session_id . 'F' . $this->session_id));
-        while ($checkKeyLength > strlen($key)) {
-            $key.= pack('H*', $hash($keyBytes . $this->session_id . $key));
+    /**
+     * Creates an interactive shell
+     *
+     * @see self::read()
+     * @see self::write()
+     * @return bool
+     * @access private
+     */
+    function _initShell()
+    {
+        if ($this->in_request_pty_exec === true) {
+            return true;
         }
-        $this->hmac_check->setKey(substr($key, 0, $checkKeyLength));
 
-        for ($i = 0; $i < count($compression_algorithms) && !in_array($compression_algorithms[$i], $this->compression_algorithms_server_to_client); $i++);
-        if ($i == count($compression_algorithms)) {
-            user_error('No compatible server to client compression algorithms found', E_USER_NOTICE);
-            return $this->_disconnect(NET_SSH2_DISCONNECT_KEY_EXCHANGE_FAILED);
-        }
-        $this->decompress = $compression_algorithms[$i] == 'zlib';
+        $this->window_size_server_to_client[self::CHANNEL_SHELL] = $this->window_size;
+        $packet_size = 0x4000;
 
-        for ($i = 0; $i < count($compression_algorithms) && !in_array($compression_algorithms[$i], $this->compression_algorithms_client_to_server); $i++);
-        if ($i == count($compression_algorithms)) {
-            user_error('No compatible client to server compression algorithms found', E_USER_NOTICE);
-            return $this->_disconnect(NET_SSH2_DISCONNECT_KEY_EXCHANGE_FAILED);
+        $packet = pack(
+            'CNa*N3',
+            NET_SSH2_MSG_CHANNEL_OPEN,
+            strlen('session'),
+            'session',
+            self::CHANNEL_SHELL,
+            $this->window_size_server_to_client[self::CHANNEL_SHELL],
+            $packet_size
+        );
+
+        if (!$this->_send_binary_packet($packet)) {
+            return false;
         }
-        $this->compress = $compression_algorithms[$i] == 'zlib';
 
-        return true;
-    }
+        $this->channel_status[self::CHANNEL_SHELL] = NET_SSH2_MSG_CHANNEL_OPEN;
 
-    /**
-     * Login
-     *
-     * @param String $username
-     * @param optional String $password
-     * @return Boolean
-     * @access public
-     * @internal It might be worthwhile, at some point, to protect against {@link http://tools.ietf.org/html/rfc4251#section-9.3.9 traffic analysis}
-     *           by sending dummy SSH_MSG_IGNORE messages.
-     */
-    function login($username, $password = '')
-    {
-        if (!($this->bitmap & NET_SSH2_MASK_CONSTRUCTOR)) {
+        $response = $this->_get_channel_packet(self::CHANNEL_SHELL);
+        if ($response === false) {
             return false;
         }
 
-        $packet = pack('CNa*',
-            NET_SSH2_MSG_SERVICE_REQUEST, strlen('ssh-userauth'), 'ssh-userauth'
+        $terminal_modes = pack('C', NET_SSH2_TTY_OP_END);
+        $packet = pack(
+            'CNNa*CNa*N5a*',
+            NET_SSH2_MSG_CHANNEL_REQUEST,
+            $this->server_channels[self::CHANNEL_SHELL],
+            strlen('pty-req'),
+            'pty-req',
+            1,
+            strlen('vt100'),
+            'vt100',
+            $this->windowColumns,
+            $this->windowRows,
+            0,
+            0,
+            strlen($terminal_modes),
+            $terminal_modes
         );
 
         if (!$this->_send_binary_packet($packet)) {
@@ -1273,229 +2870,270 @@ class Net_SSH2 {
 
         $response = $this->_get_binary_packet();
         if ($response === false) {
-            user_error('Connection closed by server', E_USER_NOTICE);
+            user_error('Connection closed by server');
             return false;
         }
 
-        extract(unpack('Ctype', $this->_string_shift($response, 1)));
-
-        if ($type != NET_SSH2_MSG_SERVICE_ACCEPT) {
-            user_error('Expected SSH_MSG_SERVICE_ACCEPT', E_USER_NOTICE);
+        if (!strlen($response)) {
             return false;
         }
+        list(, $type) = unpack('C', $this->_string_shift($response, 1));
 
-        // although PHP5's get_class() preserves the case, PHP4's does not
-        if (is_object($password) && strtolower(get_class($password)) == 'crypt_rsa')  {
-            return $this->_privatekey_login($username, $password);
+        switch ($type) {
+            case NET_SSH2_MSG_CHANNEL_SUCCESS:
+            // if a pty can't be opened maybe commands can still be executed
+            case NET_SSH2_MSG_CHANNEL_FAILURE:
+                break;
+            default:
+                user_error('Unable to request pseudo-terminal');
+                return $this->_disconnect(NET_SSH2_DISCONNECT_BY_APPLICATION);
         }
 
-        $utf8_password = utf8_encode($password);
-        $packet = pack('CNa*Na*Na*CNa*',
-            NET_SSH2_MSG_USERAUTH_REQUEST, strlen($username), $username, strlen('ssh-connection'), 'ssh-connection',
-            strlen('password'), 'password', 0, strlen($utf8_password), $utf8_password
+        $packet = pack(
+            'CNNa*C',
+            NET_SSH2_MSG_CHANNEL_REQUEST,
+            $this->server_channels[self::CHANNEL_SHELL],
+            strlen('shell'),
+            'shell',
+            1
         );
-
         if (!$this->_send_binary_packet($packet)) {
             return false;
         }
 
-        // remove the username and password from the last logged packet
-        if (defined('NET_SSH2_LOGGING') && NET_SSH2_LOGGING == NET_SSH2_LOG_COMPLEX) {
-            $packet = pack('CNa*Na*Na*CNa*',
-                NET_SSH2_MSG_USERAUTH_REQUEST, strlen('username'), 'username', strlen('ssh-connection'), 'ssh-connection',
-                strlen('password'), 'password', 0, strlen('password'), 'password'
-            );
-            $this->message_log[count($this->message_log) - 1] = $packet;
-        }
-
-        $response = $this->_get_binary_packet();
+        $this->channel_status[self::CHANNEL_SHELL] = NET_SSH2_MSG_CHANNEL_REQUEST;
+
+        $response = $this->_get_channel_packet(self::CHANNEL_SHELL);
         if ($response === false) {
-            user_error('Connection closed by server', E_USER_NOTICE);
             return false;
         }
 
-        extract(unpack('Ctype', $this->_string_shift($response, 1)));
+        $this->channel_status[self::CHANNEL_SHELL] = NET_SSH2_MSG_CHANNEL_DATA;
 
-        switch ($type) {
-            case NET_SSH2_MSG_USERAUTH_PASSWD_CHANGEREQ: // in theory, the password can be changed
-                if (defined('NET_SSH2_LOGGING')) {
-                    $this->message_number_log[count($this->message_number_log) - 1] = 'NET_SSH2_MSG_USERAUTH_PASSWD_CHANGEREQ';
-                }
-                extract(unpack('Nlength', $this->_string_shift($response, 4)));
-                $this->errors[] = 'SSH_MSG_USERAUTH_PASSWD_CHANGEREQ: ' . utf8_decode($this->_string_shift($response, $length));
-                return $this->_disconnect(NET_SSH2_DISCONNECT_AUTH_CANCELLED_BY_USER);
-            case NET_SSH2_MSG_USERAUTH_FAILURE:
-                // either the login is bad or the server employees multi-factor authentication
-                return false;
-            case NET_SSH2_MSG_USERAUTH_SUCCESS:
-                $this->bitmap |= NET_SSH2_MASK_LOGIN;
-                return true;
-        }
+        $this->bitmap |= self::MASK_SHELL;
 
-        return false;
+        return true;
     }
 
     /**
-     * Login with an RSA private key
+     * Return the channel to be used with read() / write()
      *
-     * @param String $username
-     * @param Crypt_RSA $password
-     * @return Boolean
-     * @access private
-     * @internal It might be worthwhile, at some point, to protect against {@link http://tools.ietf.org/html/rfc4251#section-9.3.9 traffic analysis}
-     *           by sending dummy SSH_MSG_IGNORE messages.
+     * @see self::read()
+     * @see self::write()
+     * @return int
+     * @access public
      */
-    function _privatekey_login($username, $privatekey)
+    function _get_interactive_channel()
     {
-        // see http://tools.ietf.org/html/rfc4253#page-15
-        $publickey = $privatekey->getPublicKey(CRYPT_RSA_PUBLIC_FORMAT_RAW);
-        if ($publickey === false) {
-            return false;
+        switch (true) {
+            case $this->in_subsystem:
+                return self::CHANNEL_SUBSYSTEM;
+            case $this->in_request_pty_exec:
+                return self::CHANNEL_EXEC;
+            default:
+                return self::CHANNEL_SHELL;
         }
+    }
 
-        $publickey = array(
-            'e' => $publickey['e']->toBytes(true),
-            'n' => $publickey['n']->toBytes(true)
-        );
-        $publickey = pack('Na*Na*Na*',
-            strlen('ssh-rsa'), 'ssh-rsa', strlen($publickey['e']), $publickey['e'], strlen($publickey['n']), $publickey['n']
-        );
+    /**
+     * Return an available open channel
+     *
+     * @return int
+     * @access public
+     */
+    function _get_open_channel()
+    {
+        $channel = self::CHANNEL_EXEC;
+        do {
+            if (isset($this->channel_status[$channel]) && $this->channel_status[$channel] == NET_SSH2_MSG_CHANNEL_OPEN) {
+                return $channel;
+            }
+        } while ($channel++ < self::CHANNEL_SUBSYSTEM);
 
-        $part1 = pack('CNa*Na*Na*',
-            NET_SSH2_MSG_USERAUTH_REQUEST, strlen($username), $username, strlen('ssh-connection'), 'ssh-connection',
-            strlen('publickey'), 'publickey'
-        );
-        $part2 = pack('Na*Na*', strlen('ssh-rsa'), 'ssh-rsa', strlen($publickey), $publickey);
+        return false;
+    }
 
-        $packet = $part1 . chr(0) . $part2;
+    /**
+     * Returns the output of an interactive shell
+     *
+     * Returns when there's a match for $expect, which can take the form of a string literal or,
+     * if $mode == self::READ_REGEX, a regular expression.
+     *
+     * @see self::write()
+     * @param string $expect
+     * @param int $mode
+     * @return string
+     * @access public
+     */
+    function read($expect = '', $mode = self::READ_SIMPLE)
+    {
+        $this->curTimeout = $this->timeout;
+        $this->is_timeout = false;
 
-        if (!$this->_send_binary_packet($packet)) {
+        if (!$this->isAuthenticated()) {
+            user_error('Operation disallowed prior to login()');
             return false;
         }
 
-        $response = $this->_get_binary_packet();
-        if ($response === false) {
-            user_error('Connection closed by server', E_USER_NOTICE);
+        if (!($this->bitmap & self::MASK_SHELL) && !$this->_initShell()) {
+            user_error('Unable to initiate an interactive shell session');
             return false;
         }
 
-        extract(unpack('Ctype', $this->_string_shift($response, 1)));
+        $channel = $this->_get_interactive_channel();
 
-        switch ($type) {
-            case NET_SSH2_MSG_USERAUTH_FAILURE:
-                extract(unpack('Nlength', $this->_string_shift($response, 4)));
-                $this->errors[] = 'SSH_MSG_USERAUTH_FAILURE: ' . $this->_string_shift($response, $length);
-                return $this->_disconnect(NET_SSH2_DISCONNECT_AUTH_CANCELLED_BY_USER);
-            case NET_SSH2_MSG_USERAUTH_PK_OK:
-                // we'll just take it on faith that the public key blob and the public key algorithm name are as
-                // they should be
-                if (defined('NET_SSH2_LOGGING')) {
-                    $this->message_number_log[count($this->message_number_log) - 1] = 'NET_SSH2_MSG_USERAUTH_PK_OK';
-                }
+        if ($mode == self::READ_NEXT) {
+            return $this->_get_channel_packet($channel);
         }
 
-        $packet = $part1 . chr(1) . $part2;
-        $privatekey->setSignatureMode(CRYPT_RSA_SIGNATURE_PKCS1);
-        $signature = $privatekey->sign(pack('Na*a*', strlen($this->session_id), $this->session_id, $packet));
-        $signature = pack('Na*Na*', strlen('ssh-rsa'), 'ssh-rsa', strlen($signature), $signature);
-        $packet.= pack('Na*', strlen($signature), $signature);
+        $match = $expect;
+        while (true) {
+            if ($mode == self::READ_REGEX) {
+                preg_match($expect, substr($this->interactiveBuffer, -1024), $matches);
+                $match = isset($matches[0]) ? $matches[0] : '';
+            }
+            $pos = strlen($match) ? strpos($this->interactiveBuffer, $match) : false;
+            if ($pos !== false) {
+                return $this->_string_shift($this->interactiveBuffer, $pos + strlen($match));
+            }
+            $response = $this->_get_channel_packet($channel);
+            if (is_bool($response)) {
+                $this->in_request_pty_exec = false;
+                return $response ? $this->_string_shift($this->interactiveBuffer, strlen($this->interactiveBuffer)) : false;
+            }
 
-        if (!$this->_send_binary_packet($packet)) {
-            return false;
+            $this->interactiveBuffer.= $response;
         }
+    }
 
-        $response = $this->_get_binary_packet();
-        if ($response === false) {
-            user_error('Connection closed by server', E_USER_NOTICE);
+    /**
+     * Inputs a command into an interactive shell.
+     *
+     * @see self::read()
+     * @param string $cmd
+     * @return bool
+     * @access public
+     */
+    function write($cmd)
+    {
+        if (!$this->isAuthenticated()) {
+            user_error('Operation disallowed prior to login()');
             return false;
         }
 
-        extract(unpack('Ctype', $this->_string_shift($response, 1)));
-
-        switch ($type) {
-            case NET_SSH2_MSG_USERAUTH_FAILURE:
-                // either the login is bad or the server employees multi-factor authentication
-                return false;
-            case NET_SSH2_MSG_USERAUTH_SUCCESS:
-                $this->bitmap |= NET_SSH2_MASK_LOGIN;
-                return true;
+        if (!($this->bitmap & self::MASK_SHELL) && !$this->_initShell()) {
+            user_error('Unable to initiate an interactive shell session');
+            return false;
         }
 
-        return false;
+        return $this->_send_channel_packet($this->_get_interactive_channel(), $cmd);
     }
 
     /**
-     * Execute Command
+     * Start a subsystem.
+     *
+     * Right now only one subsystem at a time is supported. To support multiple subsystem's stopSubsystem() could accept
+     * a string that contained the name of the subsystem, but at that point, only one subsystem of each type could be opened.
+     * To support multiple subsystem's of the same name maybe it'd be best if startSubsystem() generated a new channel id and
+     * returns that and then that that was passed into stopSubsystem() but that'll be saved for a future date and implemented
+     * if there's sufficient demand for such a feature.
      *
-     * @param String $command
-     * @return String
+     * @see self::stopSubsystem()
+     * @param string $subsystem
+     * @return bool
      * @access public
      */
-    function exec($command)
+    function startSubsystem($subsystem)
     {
-        if (!($this->bitmap & NET_SSH2_MASK_LOGIN)) {
-            return false;
-        }
-
-        // RFC4254 defines the (client) window size as "bytes the other party can send before it must wait for the window to
-        // be adjusted".  0x7FFFFFFF is, at 4GB, the max size.  technically, it should probably be decremented, but, 
-        // honestly, if you're transfering more than 4GB, you probably shouldn't be using phpseclib, anyway.
-        // see http://tools.ietf.org/html/rfc4254#section-5.2 for more info
-        $this->window_size_client_to_server[NET_SSH2_CHANNEL_EXEC] = 0x7FFFFFFF;
-        // 0x8000 is the maximum max packet size, per http://tools.ietf.org/html/rfc4253#section-6.1, although since PuTTy
-        // uses 0x4000, that's what will be used here, as well.
-        $packet_size = 0x4000;
-
-        $packet = pack('CNa*N3',
-            NET_SSH2_MSG_CHANNEL_OPEN, strlen('session'), 'session', NET_SSH2_CHANNEL_EXEC, $this->window_size_client_to_server[NET_SSH2_CHANNEL_EXEC], $packet_size);
+        $this->window_size_server_to_client[self::CHANNEL_SUBSYSTEM] = $this->window_size;
+
+        $packet = pack(
+            'CNa*N3',
+            NET_SSH2_MSG_CHANNEL_OPEN,
+            strlen('session'),
+            'session',
+            self::CHANNEL_SUBSYSTEM,
+            $this->window_size,
+            0x4000
+        );
 
         if (!$this->_send_binary_packet($packet)) {
             return false;
         }
 
-        $this->channel_status[NET_SSH2_CHANNEL_EXEC] = NET_SSH2_MSG_CHANNEL_OPEN;
+        $this->channel_status[self::CHANNEL_SUBSYSTEM] = NET_SSH2_MSG_CHANNEL_OPEN;
 
-        $response = $this->_get_channel_packet(NET_SSH2_CHANNEL_EXEC);
+        $response = $this->_get_channel_packet(self::CHANNEL_SUBSYSTEM);
         if ($response === false) {
             return false;
         }
 
-        // sending a pty-req SSH_MSG_CHANNEL_REQUEST message is unnecessary and, in fact, in most cases, slows things
-        // down.  the one place where it might be desirable is if you're doing something like Net_SSH2::exec('ping localhost &').
-        // with a pty-req SSH_MSG_cHANNEL_REQUEST, exec() will return immediately and the ping process will then
-        // then immediately terminate.  without such a request exec() will loop indefinitely.  the ping process won't end but
-        // neither will your script.
-
-        // although, in theory, the size of SSH_MSG_CHANNEL_REQUEST could exceed the maximum packet size established by
-        // SSH_MSG_CHANNEL_OPEN_CONFIRMATION, RFC4254#section-5.1 states that the "maximum packet size" refers to the 
-        // "maximum size of an individual data packet". ie. SSH_MSG_CHANNEL_DATA.  RFC4254#section-5.2 corroborates.
-        $packet = pack('CNNa*CNa*',
-            NET_SSH2_MSG_CHANNEL_REQUEST, $this->server_channels[NET_SSH2_CHANNEL_EXEC], strlen('exec'), 'exec', 1, strlen($command), $command);
+        $packet = pack(
+            'CNNa*CNa*',
+            NET_SSH2_MSG_CHANNEL_REQUEST,
+            $this->server_channels[self::CHANNEL_SUBSYSTEM],
+            strlen('subsystem'),
+            'subsystem',
+            1,
+            strlen($subsystem),
+            $subsystem
+        );
         if (!$this->_send_binary_packet($packet)) {
             return false;
         }
 
-        $this->channel_status[NET_SSH2_CHANNEL_EXEC] = NET_SSH2_MSG_CHANNEL_REQUEST;
+        $this->channel_status[self::CHANNEL_SUBSYSTEM] = NET_SSH2_MSG_CHANNEL_REQUEST;
+
+        $response = $this->_get_channel_packet(self::CHANNEL_SUBSYSTEM);
 
-        $response = $this->_get_channel_packet(NET_SSH2_CHANNEL_EXEC);
         if ($response === false) {
             return false;
         }
 
-        $this->channel_status[NET_SSH2_CHANNEL_EXEC] = NET_SSH2_MSG_CHANNEL_DATA;
+        $this->channel_status[self::CHANNEL_SUBSYSTEM] = NET_SSH2_MSG_CHANNEL_DATA;
 
-        $output = '';
-        while (true) {
-            $temp = $this->_get_channel_packet(NET_SSH2_CHANNEL_EXEC);
-            switch (true) {
-                case $temp === true:
-                    return $output;
-                case $temp === false:
-                    return false;
-                default:
-                    $output.= $temp;
-            }
-        }
+        $this->bitmap |= self::MASK_SHELL;
+        $this->in_subsystem = true;
+
+        return true;
+    }
+
+    /**
+     * Stops a subsystem.
+     *
+     * @see self::startSubsystem()
+     * @return bool
+     * @access public
+     */
+    function stopSubsystem()
+    {
+        $this->in_subsystem = false;
+        $this->_close_channel(self::CHANNEL_SUBSYSTEM);
+        return true;
+    }
+
+    /**
+     * Closes a channel
+     *
+     * If read() timed out you might want to just close the channel and have it auto-restart on the next read() call
+     *
+     * @access public
+     */
+    function reset()
+    {
+        $this->_close_channel($this->_get_interactive_channel());
+    }
+
+    /**
+     * Is timeout?
+     *
+     * Did exec() or read() return because they timed out or because they encountered the end?
+     *
+     * @access public
+     */
+    function isTimeout()
+    {
+        return $this->is_timeout;
     }
 
     /**
@@ -1506,6 +3144,9 @@ class Net_SSH2 {
     function disconnect()
     {
         $this->_disconnect(NET_SSH2_DISCONNECT_BY_APPLICATION);
+        if (isset($this->realtime_log_file) && is_resource($this->realtime_log_file)) {
+            fclose($this->realtime_log_file);
+        }
     }
 
     /**
@@ -1522,50 +3163,125 @@ class Net_SSH2 {
     }
 
     /**
+     * Is the connection still active?
+     *
+     * @return bool
+     * @access public
+     */
+    function isConnected()
+    {
+        return (bool) ($this->bitmap & self::MASK_CONNECTED);
+    }
+
+    /**
+     * Have you successfully been logged in?
+     *
+     * @return bool
+     * @access public
+     */
+    function isAuthenticated()
+    {
+        return (bool) ($this->bitmap & self::MASK_LOGIN);
+    }
+
+    /**
+     * Resets a connection for re-use
+     *
+     * @param int $reason
+     * @access private
+     */
+    function _reset_connection($reason)
+    {
+        $this->_disconnect($reason);
+        $this->decrypt = $this->encrypt = false;
+        $this->decrypt_block_size = $this->encrypt_block_size = 8;
+        $this->hmac_check = $this->hmac_create = false;
+        $this->hmac_size = false;
+        $this->session_id = false;
+        $this->retry_connect = true;
+        $this->get_seq_no = $this->send_seq_no = 0;
+    }
+
+    /**
      * Gets Binary Packets
      *
      * See '6. Binary Packet Protocol' of rfc4253 for more info.
      *
-     * @see Net_SSH2::_send_binary_packet()
-     * @return String
+     * @see self::_send_binary_packet()
+     * @return string
      * @access private
      */
-    function _get_binary_packet()
+    function _get_binary_packet($skip_channel_filter = false)
     {
-        if (feof($this->fsock)) {
-            user_error('Connection closed prematurely', E_USER_NOTICE);
+        if (!is_resource($this->fsock) || feof($this->fsock)) {
+            user_error('Connection closed prematurely');
+            $this->bitmap = 0;
             return false;
         }
 
-        $start = strtok(microtime(), ' ') + strtok(''); // http://php.net/microtime#61838
-        $raw = fread($this->fsock, $this->decrypt_block_size);
-        $stop = strtok(microtime(), ' ') + strtok('');
+        $start = microtime(true);
+        $raw = stream_get_contents($this->fsock, $this->decrypt_block_size);
+
+        if (!strlen($raw)) {
+            return '';
+        }
 
         if ($this->decrypt !== false) {
             $raw = $this->decrypt->decrypt($raw);
         }
+        if ($raw === false) {
+            user_error('Unable to decrypt content');
+            return false;
+        }
 
+        if (strlen($raw) < 5) {
+            return false;
+        }
         extract(unpack('Npacket_length/Cpadding_length', $this->_string_shift($raw, 5)));
 
         $remaining_length = $packet_length + 4 - $this->decrypt_block_size;
+
+        // quoting <http://tools.ietf.org/html/rfc4253#section-6.1>,
+        // "implementations SHOULD check that the packet length is reasonable"
+        // PuTTY uses 0x9000 as the actual max packet size and so to shall we
+        if ($remaining_length < -$this->decrypt_block_size || $remaining_length > 0x9000 || $remaining_length % $this->decrypt_block_size != 0) {
+            if (!$this->bad_key_size_fix && $this->_bad_algorithm_candidate($this->decrypt_algorithm) && !($this->bitmap & SSH2::MASK_LOGIN)) {
+                $this->bad_key_size_fix = true;
+                $this->_reset_connection(NET_SSH2_DISCONNECT_KEY_EXCHANGE_FAILED);
+                return false;
+            }
+            user_error('Invalid size');
+            return false;
+        }
+
         $buffer = '';
         while ($remaining_length > 0) {
-            $temp = fread($this->fsock, $remaining_length);
+            $temp = stream_get_contents($this->fsock, $remaining_length);
+            if ($temp === false || feof($this->fsock)) {
+                user_error('Error reading from socket');
+                $this->bitmap = 0;
+                return false;
+            }
             $buffer.= $temp;
             $remaining_length-= strlen($temp);
         }
-        if (!empty($buffer)) {
+
+        $stop = microtime(true);
+        if (strlen($buffer)) {
             $raw.= $this->decrypt !== false ? $this->decrypt->decrypt($buffer) : $buffer;
-            $buffer = $temp = '';
         }
 
         $payload = $this->_string_shift($raw, $packet_length - $padding_length - 1);
         $padding = $this->_string_shift($raw, $padding_length); // should leave $raw empty
 
         if ($this->hmac_check !== false) {
-            $hmac = fread($this->fsock, $this->hmac_size);
-            if ($hmac != $this->hmac_check->hash(pack('NNCa*', $this->get_seq_no, $packet_length, $padding_length, $payload . $padding))) {
-                user_error('Invalid HMAC', E_USER_NOTICE);
+            $hmac = stream_get_contents($this->fsock, $this->hmac_size);
+            if ($hmac === false || strlen($hmac) != $this->hmac_size) {
+                user_error('Error reading socket');
+                $this->bitmap = 0;
+                return false;
+            } elseif ($hmac != $this->hmac_check->hash(pack('NNCa*', $this->get_seq_no, $packet_length, $padding_length, $payload . $padding))) {
+                user_error('Invalid HMAC');
                 return false;
             }
         }
@@ -1577,15 +3293,15 @@ class Net_SSH2 {
         $this->get_seq_no++;
 
         if (defined('NET_SSH2_LOGGING')) {
-            $temp = isset($this->message_numbers[ord($payload[0])]) ? $this->message_numbers[ord($payload[0])] : 'UNKNOWN';
-            $this->message_number_log[] = '<- ' . $temp .
-                                          ' (' . round($stop - $start, 4) . 's)';
-            if (NET_SSH2_LOGGING == NET_SSH2_LOG_COMPLEX) {
-                $this->message_log[] = substr($payload, 1);
-            }
+            $current = microtime(true);
+            $message_number = isset($this->message_numbers[ord($payload[0])]) ? $this->message_numbers[ord($payload[0])] : 'UNKNOWN (' . ord($payload[0]) . ')';
+            $message_number = '<- ' . $message_number .
+                              ' (since last: ' . round($current - $this->last_packet, 4) . ', network: ' . round($stop - $start, 4) . 's)';
+            $this->_append_log($message_number, $payload);
+            $this->last_packet = $current;
         }
 
-        return $this->_filter($payload);
+        return $this->_filter($payload, $skip_channel_filter);
     }
 
     /**
@@ -1593,85 +3309,236 @@ class Net_SSH2 {
      *
      * Because some binary packets need to be ignored...
      *
-     * @see Net_SSH2::_get_binary_packet()
-     * @return String
+     * @see self::_get_binary_packet()
+     * @return string
      * @access private
      */
-    function _filter($payload)
+    function _filter($payload, $skip_channel_filter)
     {
         switch (ord($payload[0])) {
             case NET_SSH2_MSG_DISCONNECT:
                 $this->_string_shift($payload, 1);
+                if (strlen($payload) < 8) {
+                    return false;
+                }
                 extract(unpack('Nreason_code/Nlength', $this->_string_shift($payload, 8)));
                 $this->errors[] = 'SSH_MSG_DISCONNECT: ' . $this->disconnect_reasons[$reason_code] . "\r\n" . utf8_decode($this->_string_shift($payload, $length));
-                $this->bitmask = 0;
+                $this->bitmap = 0;
                 return false;
             case NET_SSH2_MSG_IGNORE:
-                $payload = $this->_get_binary_packet();
+                $payload = $this->_get_binary_packet($skip_channel_filter);
                 break;
             case NET_SSH2_MSG_DEBUG:
                 $this->_string_shift($payload, 2);
+                if (strlen($payload) < 4) {
+                    return false;
+                }
                 extract(unpack('Nlength', $this->_string_shift($payload, 4)));
                 $this->errors[] = 'SSH_MSG_DEBUG: ' . utf8_decode($this->_string_shift($payload, $length));
-                $payload = $this->_get_binary_packet();
+                $payload = $this->_get_binary_packet($skip_channel_filter);
                 break;
             case NET_SSH2_MSG_UNIMPLEMENTED:
                 return false;
             case NET_SSH2_MSG_KEXINIT:
                 if ($this->session_id !== false) {
+                    $this->send_kex_first = false;
                     if (!$this->_key_exchange($payload)) {
-                        $this->bitmask = 0;
+                        $this->bitmap = 0;
                         return false;
                     }
-                    $payload = $this->_get_binary_packet();
+                    $payload = $this->_get_binary_packet($skip_channel_filter);
                 }
         }
 
         // see http://tools.ietf.org/html/rfc4252#section-5.4; only called when the encryption has been activated and when we haven't already logged in
-        if (($this->bitmap & NET_SSH2_MASK_CONSTRUCTOR) && !($this->bitmap & NET_SSH2_MASK_LOGIN) && ord($payload[0]) == NET_SSH2_MSG_USERAUTH_BANNER) {
+        if (($this->bitmap & self::MASK_CONNECTED) && !$this->isAuthenticated() && ord($payload[0]) == NET_SSH2_MSG_USERAUTH_BANNER) {
             $this->_string_shift($payload, 1);
+            if (strlen($payload) < 4) {
+                return false;
+            }
             extract(unpack('Nlength', $this->_string_shift($payload, 4)));
-            $this->errors[] = 'SSH_MSG_USERAUTH_BANNER: ' . utf8_decode($this->_string_shift($payload, $length));
+            $this->banner_message = utf8_decode($this->_string_shift($payload, $length));
             $payload = $this->_get_binary_packet();
         }
 
         // only called when we've already logged in
-        if (($this->bitmap & NET_SSH2_MASK_CONSTRUCTOR) && ($this->bitmap & NET_SSH2_MASK_LOGIN)) {
+        if (($this->bitmap & self::MASK_CONNECTED) && $this->isAuthenticated()) {
             switch (ord($payload[0])) {
+                case NET_SSH2_MSG_CHANNEL_DATA:
+                case NET_SSH2_MSG_CHANNEL_EXTENDED_DATA:
+                case NET_SSH2_MSG_CHANNEL_REQUEST:
+                case NET_SSH2_MSG_CHANNEL_CLOSE:
+                case NET_SSH2_MSG_CHANNEL_EOF:
+                    if (!$skip_channel_filter && !empty($this->server_channels)) {
+                        $this->binary_packet_buffer = $payload;
+                        $this->_get_channel_packet(true);
+                        $payload = $this->_get_binary_packet();
+                    }
+                    break;
                 case NET_SSH2_MSG_GLOBAL_REQUEST: // see http://tools.ietf.org/html/rfc4254#section-4
-                    $this->_string_shift($payload, 1);
-                    extract(unpack('Nlength', $this->_string_shift($payload)));
-                    $this->errors[] = 'SSH_MSG_GLOBAL_REQUEST: ' . utf8_decode($this->_string_shift($payload, $length));
+                    if (strlen($payload) < 4) {
+                        return false;
+                    }
+                    extract(unpack('Nlength', $this->_string_shift($payload, 4)));
+                    $this->errors[] = 'SSH_MSG_GLOBAL_REQUEST: ' . $this->_string_shift($payload, $length);
 
                     if (!$this->_send_binary_packet(pack('C', NET_SSH2_MSG_REQUEST_FAILURE))) {
                         return $this->_disconnect(NET_SSH2_DISCONNECT_BY_APPLICATION);
                     }
 
-                    $payload = $this->_get_binary_packet();
+                    $payload = $this->_get_binary_packet($skip_channel_filter);
                     break;
                 case NET_SSH2_MSG_CHANNEL_OPEN: // see http://tools.ietf.org/html/rfc4254#section-5.1
                     $this->_string_shift($payload, 1);
-                    extract(unpack('N', $this->_string_shift($payload, 4)));
-                    $this->errors[] = 'SSH_MSG_CHANNEL_OPEN: ' . utf8_decode($this->_string_shift($payload, $length));
-
-                    $this->_string_shift($payload, 4); // skip over client channel
+                    if (strlen($payload) < 4) {
+                        return false;
+                    }
+                    extract(unpack('Nlength', $this->_string_shift($payload, 4)));
+                    $data = $this->_string_shift($payload, $length);
+                    if (strlen($payload) < 4) {
+                        return false;
+                    }
                     extract(unpack('Nserver_channel', $this->_string_shift($payload, 4)));
+                    switch ($data) {
+                        case 'auth-agent':
+                        case 'auth-agent@openssh.com':
+                            if (isset($this->agent)) {
+                                $new_channel = self::CHANNEL_AGENT_FORWARD;
+
+                                if (strlen($payload) < 8) {
+                                    return false;
+                                }
+                                extract(unpack('Nremote_window_size', $this->_string_shift($payload, 4)));
+                                extract(unpack('Nremote_maximum_packet_size', $this->_string_shift($payload, 4)));
+
+                                $this->packet_size_client_to_server[$new_channel] = $remote_window_size;
+                                $this->window_size_server_to_client[$new_channel] = $remote_maximum_packet_size;
+                                $this->window_size_client_to_server[$new_channel] = $this->window_size;
+
+                                $packet_size = 0x4000;
+
+                                $packet = pack(
+                                    'CN4',
+                                    NET_SSH2_MSG_CHANNEL_OPEN_CONFIRMATION,
+                                    $server_channel,
+                                    $new_channel,
+                                    $packet_size,
+                                    $packet_size
+                                );
+
+                                $this->server_channels[$new_channel] = $server_channel;
+                                $this->channel_status[$new_channel] = NET_SSH2_MSG_CHANNEL_OPEN_CONFIRMATION;
+                                if (!$this->_send_binary_packet($packet)) {
+                                    return false;
+                                }
+                            }
+                            break;
+                        default:
+                            $packet = pack(
+                                'CN3a*Na*',
+                                NET_SSH2_MSG_REQUEST_FAILURE,
+                                $server_channel,
+                                NET_SSH2_OPEN_ADMINISTRATIVELY_PROHIBITED,
+                                0,
+                                '',
+                                0,
+                                ''
+                            );
+
+                            if (!$this->_send_binary_packet($packet)) {
+                                return $this->_disconnect(NET_SSH2_DISCONNECT_BY_APPLICATION);
+                            }
+                    }
+                    $payload = $this->_get_binary_packet($skip_channel_filter);
+                    break;
+                case NET_SSH2_MSG_CHANNEL_WINDOW_ADJUST:
+                    $this->_string_shift($payload, 1);
+                    if (strlen($payload) < 8) {
+                        return false;
+                    }
+                    extract(unpack('Nchannel', $this->_string_shift($payload, 4)));
+                    extract(unpack('Nwindow_size', $this->_string_shift($payload, 4)));
+                    $this->window_size_client_to_server[$channel]+= $window_size;
 
-                    $packet = pack('CN3a*Na*',
-                        NET_SSH2_MSG_REQUEST_FAILURE, $server_channel, NET_SSH2_OPEN_ADMINISTRATIVELY_PROHIBITED, 0, '', 0, '');
+                    $payload = ($this->bitmap & self::MASK_WINDOW_ADJUST) ? true : $this->_get_binary_packet($skip_channel_filter);
+            }
+        }
 
-                    if (!$this->_send_binary_packet($packet)) {
-                        return $this->_disconnect(NET_SSH2_DISCONNECT_BY_APPLICATION);
-                    }
+        return $payload;
+    }
+
+    /**
+     * Enable Quiet Mode
+     *
+     * Suppress stderr from output
+     *
+     * @access public
+     */
+    function enableQuietMode()
+    {
+        $this->quiet_mode = true;
+    }
+
+    /**
+     * Disable Quiet Mode
+     *
+     * Show stderr in output
+     *
+     * @access public
+     */
+    function disableQuietMode()
+    {
+        $this->quiet_mode = false;
+    }
+
+    /**
+     * Returns whether Quiet Mode is enabled or not
+     *
+     * @see self::enableQuietMode()
+     * @see self::disableQuietMode()
+     * @access public
+     * @return bool
+     */
+    function isQuietModeEnabled()
+    {
+        return $this->quiet_mode;
+    }
+
+    /**
+     * Enable request-pty when using exec()
+     *
+     * @access public
+     */
+    function enablePTY()
+    {
+        $this->request_pty = true;
+    }
 
-                    $payload = $this->_get_binary_packet();
-                    break;
-                case NET_SSH2_MSG_CHANNEL_WINDOW_ADJUST:
-                    $payload = $this->_get_binary_packet();
-            }
+    /**
+     * Disable request-pty when using exec()
+     *
+     * @access public
+     */
+    function disablePTY()
+    {
+        if ($this->in_request_pty_exec) {
+            $this->_close_channel(self::CHANNEL_EXEC);
+            $this->in_request_pty_exec = false;
         }
+        $this->request_pty = false;
+    }
 
-        return $payload;
+    /**
+     * Returns whether request-pty is enabled or not
+     *
+     * @see self::enablePTY()
+     * @see self::disablePTY()
+     * @access public
+     * @return bool
+     */
+    function isPTYEnabled()
+    {
+        return $this->request_pty;
     }
 
     /**
@@ -1680,113 +3547,258 @@ class Net_SSH2 {
      * Returns the data as a string if it's available and false if not.
      *
      * @param $client_channel
-     * @return Mixed
+     * @return mixed
      * @access private
      */
-    function _get_channel_packet($client_channel)
+    function _get_channel_packet($client_channel, $skip_extended = false)
     {
         if (!empty($this->channel_buffers[$client_channel])) {
             return array_shift($this->channel_buffers[$client_channel]);
         }
 
         while (true) {
-            $response = $this->_get_binary_packet();
-            if ($response === false) {
-                user_error('Connection closed by server', E_USER_NOTICE);
+            if ($this->binary_packet_buffer !== false) {
+                $response = $this->binary_packet_buffer;
+                $this->binary_packet_buffer = false;
+            } else {
+                if ($this->curTimeout) {
+                    if ($this->curTimeout < 0) {
+                        $this->is_timeout = true;
+                        return true;
+                    }
+
+                    $read = array($this->fsock);
+                    $write = $except = null;
+
+                    $start = microtime(true);
+                    $sec = floor($this->curTimeout);
+                    $usec = 1000000 * ($this->curTimeout - $sec);
+                    // on windows this returns a "Warning: Invalid CRT parameters detected" error
+                    if (!@stream_select($read, $write, $except, $sec, $usec) && !count($read)) {
+                        $this->is_timeout = true;
+                        return true;
+                    }
+                    $elapsed = microtime(true) - $start;
+                    $this->curTimeout-= $elapsed;
+                }
+
+                $response = $this->_get_binary_packet(true);
+                if ($response === false) {
+                    user_error('Connection closed by server');
+                    return false;
+                }
+            }
+
+            if ($client_channel == -1 && $response === true) {
+                return true;
+            }
+            if (!strlen($response)) {
+                return '';
+            }
+
+            if (!strlen($response)) {
                 return false;
             }
+            extract(unpack('Ctype', $this->_string_shift($response, 1)));
 
-            extract(unpack('Ctype/Nchannel', $this->_string_shift($response, 5)));
-
-            switch ($this->channel_status[$channel]) {
-                case NET_SSH2_MSG_CHANNEL_OPEN:
-                    switch ($type) {
-                        case NET_SSH2_MSG_CHANNEL_OPEN_CONFIRMATION:
-                            extract(unpack('Nserver_channel', $this->_string_shift($response, 4)));
-                            $this->server_channels[$client_channel] = $server_channel;
-                            $this->_string_shift($response, 4); // skip over (server) window size
-                            $temp = unpack('Npacket_size_client_to_server', $this->_string_shift($response, 4));
-                            $this->packet_size_client_to_server[$client_channel] = $temp['packet_size_client_to_server'];
-                            return true;
-                        //case NET_SSH2_MSG_CHANNEL_OPEN_FAILURE:
-                        default:
-                            user_error('Unable to open channel', E_USER_NOTICE);
-                            return $this->_disconnect(NET_SSH2_DISCONNECT_BY_APPLICATION);
-                    }
-                    break;
-                case NET_SSH2_MSG_CHANNEL_REQUEST:
-                    switch ($type) {
-                        case NET_SSH2_MSG_CHANNEL_SUCCESS:
-                            return true;
-                        //case NET_SSH2_MSG_CHANNEL_FAILURE:
-                        default:
-                            user_error('Unable to request pseudo-terminal', E_USER_NOTICE);
-                            return $this->_disconnect(NET_SSH2_DISCONNECT_BY_APPLICATION);
+            if (strlen($response) < 4) {
+                return false;
+            }
+            if ($type == NET_SSH2_MSG_CHANNEL_OPEN) {
+                extract(unpack('Nlength', $this->_string_shift($response, 4)));
+            } else {
+                extract(unpack('Nchannel', $this->_string_shift($response, 4)));
+            }
+
+            // will not be setup yet on incoming channel open request
+            if (isset($channel) && isset($this->channel_status[$channel]) && isset($this->window_size_server_to_client[$channel])) {
+                $this->window_size_server_to_client[$channel]-= strlen($response);
+
+                // resize the window, if appropriate
+                if ($this->window_size_server_to_client[$channel] < 0) {
+                    $packet = pack('CNN', NET_SSH2_MSG_CHANNEL_WINDOW_ADJUST, $this->server_channels[$channel], $this->window_size);
+                    if (!$this->_send_binary_packet($packet)) {
+                        return false;
                     }
+                    $this->window_size_server_to_client[$channel]+= $this->window_size;
+                }
+
+                switch ($type) {
+                    case NET_SSH2_MSG_CHANNEL_EXTENDED_DATA:
+                        /*
+                        if ($client_channel == NET_SSH2_CHANNEL_EXEC) {
+                            $this->_send_channel_packet($client_channel, chr(0));
+                        }
+                        */
+                        // currently, there's only one possible value for $data_type_code: NET_SSH2_EXTENDED_DATA_STDERR
+                        if (strlen($response) < 8) {
+                            return false;
+                        }
+                        extract(unpack('Ndata_type_code/Nlength', $this->_string_shift($response, 8)));
+                        $data = $this->_string_shift($response, $length);
+                        $this->stdErrorLog.= $data;
+                        if ($skip_extended || $this->quiet_mode) {
+                            continue 2;
+                        }
+                        if ($client_channel == $channel && $this->channel_status[$channel] == NET_SSH2_MSG_CHANNEL_DATA) {
+                            return $data;
+                        }
+                        if (!isset($this->channel_buffers[$channel])) {
+                            $this->channel_buffers[$channel] = array();
+                        }
+                        $this->channel_buffers[$channel][] = $data;
+
+                        continue 2;
+                    case NET_SSH2_MSG_CHANNEL_REQUEST:
+                        if ($this->channel_status[$channel] == NET_SSH2_MSG_CHANNEL_CLOSE) {
+                            continue 2;
+                        }
+                        if (strlen($response) < 4) {
+                            return false;
+                        }
+                        extract(unpack('Nlength', $this->_string_shift($response, 4)));
+                        $value = $this->_string_shift($response, $length);
+                        switch ($value) {
+                            case 'exit-signal':
+                                $this->_string_shift($response, 1);
+                                if (strlen($response) < 4) {
+                                    return false;
+                                }
+                                extract(unpack('Nlength', $this->_string_shift($response, 4)));
+                                $this->errors[] = 'SSH_MSG_CHANNEL_REQUEST (exit-signal): ' . $this->_string_shift($response, $length);
+                                $this->_string_shift($response, 1);
+                                if (strlen($response) < 4) {
+                                    return false;
+                                }
+                                extract(unpack('Nlength', $this->_string_shift($response, 4)));
+                                if ($length) {
+                                    $this->errors[count($this->errors)].= "\r\n" . $this->_string_shift($response, $length);
+                                }
+
+                                $this->_send_binary_packet(pack('CN', NET_SSH2_MSG_CHANNEL_EOF, $this->server_channels[$client_channel]));
+                                $this->_send_binary_packet(pack('CN', NET_SSH2_MSG_CHANNEL_CLOSE, $this->server_channels[$channel]));
+
+                                $this->channel_status[$channel] = NET_SSH2_MSG_CHANNEL_EOF;
+
+                                continue 3;
+                            case 'exit-status':
+                                if (strlen($response) < 5) {
+                                    return false;
+                                }
+                                extract(unpack('Cfalse/Nexit_status', $this->_string_shift($response, 5)));
+                                $this->exit_status = $exit_status;
+
+                                // "The client MAY ignore these messages."
+                                // -- http://tools.ietf.org/html/rfc4254#section-6.10
+
+                                continue 3;
+                            default:
+                                // "Some systems may not implement signals, in which case they SHOULD ignore this message."
+                                //  -- http://tools.ietf.org/html/rfc4254#section-6.9
+                                continue 3;
+                        }
+                }
 
+                switch ($this->channel_status[$channel]) {
+                    case NET_SSH2_MSG_CHANNEL_OPEN:
+                        switch ($type) {
+                            case NET_SSH2_MSG_CHANNEL_OPEN_CONFIRMATION:
+                                if (strlen($response) < 4) {
+                                    return false;
+                                }
+                                extract(unpack('Nserver_channel', $this->_string_shift($response, 4)));
+                                $this->server_channels[$channel] = $server_channel;
+                                if (strlen($response) < 4) {
+                                    return false;
+                                }
+                                extract(unpack('Nwindow_size', $this->_string_shift($response, 4)));
+                                if ($window_size < 0) {
+                                    $window_size&= 0x7FFFFFFF;
+                                    $window_size+= 0x80000000;
+                                }
+                                $this->window_size_client_to_server[$channel] = $window_size;
+                                if (strlen($response) < 4) {
+                                     return false;
+                                }
+                                $temp = unpack('Npacket_size_client_to_server', $this->_string_shift($response, 4));
+                                $this->packet_size_client_to_server[$channel] = $temp['packet_size_client_to_server'];
+                                $result = $client_channel == $channel ? true : $this->_get_channel_packet($client_channel, $skip_extended);
+                                $this->_on_channel_open();
+                                return $result;
+                            //case NET_SSH2_MSG_CHANNEL_OPEN_FAILURE:
+                            default:
+                                user_error('Unable to open channel');
+                                return $this->_disconnect(NET_SSH2_DISCONNECT_BY_APPLICATION);
+                        }
+                        break;
+                    case NET_SSH2_MSG_CHANNEL_REQUEST:
+                        switch ($type) {
+                            case NET_SSH2_MSG_CHANNEL_SUCCESS:
+                                return true;
+                            case NET_SSH2_MSG_CHANNEL_FAILURE:
+                                return false;
+                            default:
+                                user_error('Unable to fulfill channel request');
+                                return $this->_disconnect(NET_SSH2_DISCONNECT_BY_APPLICATION);
+                        }
+                    case NET_SSH2_MSG_CHANNEL_CLOSE:
+                        return $type == NET_SSH2_MSG_CHANNEL_CLOSE ? true : $this->_get_channel_packet($client_channel, $skip_extended);
+                }
             }
 
+            // ie. $this->channel_status[$channel] == NET_SSH2_MSG_CHANNEL_DATA
+
             switch ($type) {
                 case NET_SSH2_MSG_CHANNEL_DATA:
-                    if ($client_channel == NET_SSH2_CHANNEL_EXEC) {
+                    /*
+                    if ($channel == self::CHANNEL_EXEC) {
                         // SCP requires null packets, such as this, be sent.  further, in the case of the ssh.com SSH server
-                        // this actually seems to make things twice as fast.  more to the point, the message right after 
+                        // this actually seems to make things twice as fast.  more to the point, the message right after
                         // SSH_MSG_CHANNEL_DATA (usually SSH_MSG_IGNORE) won't block for as long as it would have otherwise.
                         // in OpenSSH it slows things down but only by a couple thousandths of a second.
-                        $this->_send_channel_packet($client_channel, chr(0));
+                        $this->_send_channel_packet($channel, chr(0));
+                    }
+                    */
+                    if (strlen($response) < 4) {
+                        return false;
                     }
                     extract(unpack('Nlength', $this->_string_shift($response, 4)));
                     $data = $this->_string_shift($response, $length);
+
+                    if ($channel == self::CHANNEL_AGENT_FORWARD) {
+                        $agent_response = $this->agent->_forward_data($data);
+                        if (!is_bool($agent_response)) {
+                            $this->_send_channel_packet($channel, $agent_response);
+                        }
+                        break;
+                    }
+
                     if ($client_channel == $channel) {
                         return $data;
                     }
-                    if (!isset($this->channel_buffers[$client_channel])) {
-                        $this->channel_buffers[$client_channel] = array();
+                    if (!isset($this->channel_buffers[$channel])) {
+                        $this->channel_buffers[$channel] = array();
                     }
-                    $this->channel_buffers[$client_channel][] = $data;
+                    $this->channel_buffers[$channel][] = $data;
                     break;
-                case NET_SSH2_MSG_CHANNEL_EXTENDED_DATA:
-                    if ($client_channel == NET_SSH2_CHANNEL_EXEC) {
-                        $this->_send_channel_packet($client_channel, chr(0));
-                    }
-                    // currently, there's only one possible value for $data_type_code: NET_SSH2_EXTENDED_DATA_STDERR
-                    extract(unpack('Ndata_type_code/Nlength', $this->_string_shift($response, 8)));
-                    $data = $this->_string_shift($response, $length);
-                    if ($client_channel == $channel) {
-                        return $data;
+                case NET_SSH2_MSG_CHANNEL_CLOSE:
+                    $this->curTimeout = 0;
+
+                    if ($this->bitmap & self::MASK_SHELL) {
+                        $this->bitmap&= ~self::MASK_SHELL;
                     }
-                    if (!isset($this->channel_buffers[$client_channel])) {
-                        $this->channel_buffers[$client_channel] = array();
+                    if ($this->channel_status[$channel] != NET_SSH2_MSG_CHANNEL_EOF) {
+                        $this->_send_binary_packet(pack('CN', NET_SSH2_MSG_CHANNEL_CLOSE, $this->server_channels[$channel]));
                     }
-                    $this->channel_buffers[$client_channel][] = $data;
-                    break;
-                case NET_SSH2_MSG_CHANNEL_REQUEST:
-                    extract(unpack('Nlength', $this->_string_shift($response, 4)));
-                    $value = $this->_string_shift($response, $length);
-                    switch ($value) {
-                        case 'exit-signal':
-                            $this->_string_shift($response, 1);
-                            extract(unpack('Nlength', $this->_string_shift($response, 4)));
-                            $this->errors[] = 'SSH_MSG_CHANNEL_REQUEST (exit-signal): ' . $this->_string_shift($response, $length);
-                            $this->_string_shift($response, 1);
-                            extract(unpack('Nlength', $this->_string_shift($response, 4)));
-                            if ($length) {
-                                $this->errors[count($this->errors)].= "\r\n" . $this->_string_shift($response, $length);
-                            }
-                        //case 'exit-status':
-                        default:
-                            // "Some systems may not implement signals, in which case they SHOULD ignore this message."
-                            //  -- http://tools.ietf.org/html/rfc4254#section-6.9
-                            break;
+
+                    $this->channel_status[$channel] = NET_SSH2_MSG_CHANNEL_CLOSE;
+                    if ($client_channel == $channel) {
+                        return true;
                     }
-                    break;
-                case NET_SSH2_MSG_CHANNEL_CLOSE:
-                    $this->_send_binary_packet(pack('CN', NET_SSH2_MSG_CHANNEL_CLOSE, $this->server_channels[$channel]));
-                    return true;
                 case NET_SSH2_MSG_CHANNEL_EOF:
                     break;
                 default:
-                    user_error('Error reading channel data', E_USER_NOTICE);
+                    user_error('Error reading channel data');
                     return $this->_disconnect(NET_SSH2_DISCONNECT_BY_APPLICATION);
             }
         }
@@ -1797,15 +3809,17 @@ class Net_SSH2 {
      *
      * See '6. Binary Packet Protocol' of rfc4253 for more info.
      *
-     * @param String $data
-     * @see Net_SSH2::_get_binary_packet()
-     * @return Boolean
+     * @param string $data
+     * @param string $logged
+     * @see self::_get_binary_packet()
+     * @return bool
      * @access private
      */
-    function _send_binary_packet($data)
+    function _send_binary_packet($data, $logged = null)
     {
-        if (feof($this->fsock)) {
-            user_error('Connection closed prematurely', E_USER_NOTICE);
+        if (!is_resource($this->fsock) || feof($this->fsock)) {
+            user_error('Connection closed prematurely');
+            $this->bitmap = 0;
             return false;
         }
 
@@ -1821,11 +3835,7 @@ class Net_SSH2 {
         $packet_length+= (($this->encrypt_block_size - 1) * $packet_length) % $this->encrypt_block_size;
         // subtracting strlen($data) is obvious - subtracting 5 is necessary because of packet_length and padding_length
         $padding_length = $packet_length - strlen($data) - 5;
-
-        $padding = '';
-        for ($i = 0; $i < $padding_length; $i++) {
-            $padding.= chr(crypt_random(0, 255));
-        }
+        $padding = Random::string($padding_length);
 
         // we subtract 4 from packet_length because the packet_length field isn't supposed to include itself
         $packet = pack('NCa*', $packet_length - 4, $padding_length, $data . $padding);
@@ -1839,84 +3849,192 @@ class Net_SSH2 {
 
         $packet.= $hmac;
 
-        $start = strtok(microtime(), ' ') + strtok(''); // http://php.net/microtime#61838
+        $start = microtime(true);
         $result = strlen($packet) == fputs($this->fsock, $packet);
-        $stop = strtok(microtime(), ' ') + strtok('');
+        $stop = microtime(true);
 
         if (defined('NET_SSH2_LOGGING')) {
-            $temp = isset($this->message_numbers[ord($data[0])]) ? $this->message_numbers[ord($data[0])] : 'UNKNOWN';
-            $this->message_number_log[] = '-> ' . $temp .
-                                          ' (' . round($stop - $start, 4) . 's)';
-            if (NET_SSH2_LOGGING == NET_SSH2_LOG_COMPLEX) {
-                $this->message_log[] = substr($data, 1);
-            }
+            $current = microtime(true);
+            $message_number = isset($this->message_numbers[ord($data[0])]) ? $this->message_numbers[ord($data[0])] : 'UNKNOWN (' . ord($data[0]) . ')';
+            $message_number = '-> ' . $message_number .
+                              ' (since last: ' . round($current - $this->last_packet, 4) . ', network: ' . round($stop - $start, 4) . 's)';
+            $this->_append_log($message_number, isset($logged) ? $logged : $data);
+            $this->last_packet = $current;
         }
 
         return $result;
     }
 
     /**
+     * Logs data packets
+     *
+     * Makes sure that only the last 1MB worth of packets will be logged
+     *
+     * @param string $data
+     * @access private
+     */
+    function _append_log($message_number, $message)
+    {
+        // remove the byte identifying the message type from all but the first two messages (ie. the identification strings)
+        if (strlen($message_number) > 2) {
+            $this->_string_shift($message);
+        }
+
+        switch (NET_SSH2_LOGGING) {
+            // useful for benchmarks
+            case self::LOG_SIMPLE:
+                $this->message_number_log[] = $message_number;
+                break;
+            // the most useful log for SSH2
+            case self::LOG_COMPLEX:
+                $this->message_number_log[] = $message_number;
+                $this->log_size+= strlen($message);
+                $this->message_log[] = $message;
+                while ($this->log_size > self::LOG_MAX_SIZE) {
+                    $this->log_size-= strlen(array_shift($this->message_log));
+                    array_shift($this->message_number_log);
+                }
+                break;
+            // dump the output out realtime; packets may be interspersed with non packets,
+            // passwords won't be filtered out and select other packets may not be correctly
+            // identified
+            case self::LOG_REALTIME:
+                switch (PHP_SAPI) {
+                    case 'cli':
+                        $start = $stop = "\r\n";
+                        break;
+                    default:
+                        $start = '<pre>';
+                        $stop = '</pre>';
+                }
+                echo $start . $this->_format_log(array($message), array($message_number)) . $stop;
+                @flush();
+                @ob_flush();
+                break;
+            // basically the same thing as self::LOG_REALTIME with the caveat that self::LOG_REALTIME_FILE
+            // needs to be defined and that the resultant log file will be capped out at self::LOG_MAX_SIZE.
+            // the earliest part of the log file is denoted by the first <<< START >>> and is not going to necessarily
+            // at the beginning of the file
+            case self::LOG_REALTIME_FILE:
+                if (!isset($this->realtime_log_file)) {
+                    // PHP doesn't seem to like using constants in fopen()
+                    $filename = self::LOG_REALTIME_FILENAME;
+                    $fp = fopen($filename, 'w');
+                    $this->realtime_log_file = $fp;
+                }
+                if (!is_resource($this->realtime_log_file)) {
+                    break;
+                }
+                $entry = $this->_format_log(array($message), array($message_number));
+                if ($this->realtime_log_wrap) {
+                    $temp = "<<< START >>>\r\n";
+                    $entry.= $temp;
+                    fseek($this->realtime_log_file, ftell($this->realtime_log_file) - strlen($temp));
+                }
+                $this->realtime_log_size+= strlen($entry);
+                if ($this->realtime_log_size > self::LOG_MAX_SIZE) {
+                    fseek($this->realtime_log_file, 0);
+                    $this->realtime_log_size = strlen($entry);
+                    $this->realtime_log_wrap = true;
+                }
+                fputs($this->realtime_log_file, $entry);
+        }
+    }
+
+    /**
      * Sends channel data
      *
      * Spans multiple SSH_MSG_CHANNEL_DATAs if appropriate
      *
-     * @param Integer $client_channel
-     * @param String $data
-     * @return Boolean
+     * @param int $client_channel
+     * @param string $data
+     * @return bool
      * @access private
      */
     function _send_channel_packet($client_channel, $data)
     {
-        while (strlen($data) > $this->packet_size_client_to_server[$client_channel]) {
-            // resize the window, if appropriate
-            $this->window_size_client_to_server[$client_channel]-= $this->packet_size_client_to_server[$client_channel];
-            if ($this->window_size_client_to_server[$client_channel] < 0) {
-                $packet = pack('CNN', NET_SSH2_MSG_CHANNEL_WINDOW_ADJUST, $this->server_channels[$client_channel], $this->window_size);
-                if (!$this->_send_binary_packet($packet)) {
-                    return false;
-                }
-                $this->window_size_client_to_server[$client_channel]+= $this->window_size;
+        while (strlen($data)) {
+            if (!$this->window_size_client_to_server[$client_channel]) {
+                $this->bitmap^= self::MASK_WINDOW_ADJUST;
+                // using an invalid channel will let the buffers be built up for the valid channels
+                $this->_get_channel_packet(-1);
+                $this->bitmap^= self::MASK_WINDOW_ADJUST;
             }
 
-            $packet = pack('CN2a*',
-                NET_SSH2_MSG_CHANNEL_DATA,
-                $this->server_channels[$client_channel],
+            /* The maximum amount of data allowed is determined by the maximum
+               packet size for the channel, and the current window size, whichever
+               is smaller.
+                 -- http://tools.ietf.org/html/rfc4254#section-5.2 */
+            $max_size = min(
                 $this->packet_size_client_to_server[$client_channel],
-                $this->_string_shift($data, $this->packet_size_client_to_server[$client_channel])
+                $this->window_size_client_to_server[$client_channel]
             );
 
+            $temp = $this->_string_shift($data, $max_size);
+            $packet = pack(
+                'CN2a*',
+                NET_SSH2_MSG_CHANNEL_DATA,
+                $this->server_channels[$client_channel],
+                strlen($temp),
+                $temp
+            );
+            $this->window_size_client_to_server[$client_channel]-= strlen($temp);
             if (!$this->_send_binary_packet($packet)) {
                 return false;
             }
         }
 
-        // resize the window, if appropriate
-        $this->window_size_client_to_server[$client_channel]-= strlen($data);
-        if ($this->window_size_client_to_server[$client_channel] < 0) {
-            $packet = pack('CNN', NET_SSH2_MSG_CHANNEL_WINDOW_ADJUST, $this->server_channels[$client_channel], $this->window_size);
-            if (!$this->_send_binary_packet($packet)) {
-                return false;
-            }
-            $this->window_size_client_to_server[$client_channel]+= $this->window_size;
+        return true;
+    }
+
+    /**
+     * Closes and flushes a channel
+     *
+     * \phpseclib\Net\SSH2 doesn't properly close most channels.  For exec() channels are normally closed by the server
+     * and for SFTP channels are presumably closed when the client disconnects.  This functions is intended
+     * for SCP more than anything.
+     *
+     * @param int $client_channel
+     * @param bool $want_reply
+     * @return bool
+     * @access private
+     */
+    function _close_channel($client_channel, $want_reply = false)
+    {
+        // see http://tools.ietf.org/html/rfc4254#section-5.3
+
+        $this->_send_binary_packet(pack('CN', NET_SSH2_MSG_CHANNEL_EOF, $this->server_channels[$client_channel]));
+
+        if (!$want_reply) {
+            $this->_send_binary_packet(pack('CN', NET_SSH2_MSG_CHANNEL_CLOSE, $this->server_channels[$client_channel]));
+        }
+
+        $this->channel_status[$client_channel] = NET_SSH2_MSG_CHANNEL_CLOSE;
+
+        $this->curTimeout = 0;
+
+        while (!is_bool($this->_get_channel_packet($client_channel))) {
+        }
+
+        if ($want_reply) {
+            $this->_send_binary_packet(pack('CN', NET_SSH2_MSG_CHANNEL_CLOSE, $this->server_channels[$client_channel]));
         }
 
-        return $this->_send_binary_packet(pack('CN2a*',
-            NET_SSH2_MSG_CHANNEL_DATA,
-            $this->server_channels[$client_channel],
-            strlen($data),
-            $data));
+        if ($this->bitmap & self::MASK_SHELL) {
+            $this->bitmap&= ~self::MASK_SHELL;
+        }
     }
 
     /**
      * Disconnect
      *
-     * @param Integer $reason
-     * @return Boolean
+     * @param int $reason
+     * @return bool
      * @access private
      */
     function _disconnect($reason)
     {
-        if ($this->bitmap) {
+        if ($this->bitmap & self::MASK_CONNECTED) {
             $data = pack('CNNa*Na*', NET_SSH2_MSG_DISCONNECT, $reason, 0, '', 0, '');
             $this->_send_binary_packet($data);
             $this->bitmap = 0;
@@ -1930,9 +4048,9 @@ class Net_SSH2 {
      *
      * Inspired by array_shift
      *
-     * @param String $string
-     * @param optional Integer $index
-     * @return String
+     * @param string $string
+     * @param int $index
+     * @return string
      * @access private
      */
     function _string_shift(&$string, $index = 1)
@@ -1949,14 +4067,14 @@ class Net_SSH2 {
      * named constants from it, using the value as the name of the constant and the index as the value of the constant.
      * If any of the constants that would be defined already exists, none of the constants will be defined.
      *
-     * @param Array $array
+     * @param array $array
      * @access private
      */
     function _define_array()
     {
         $args = func_get_args();
         foreach ($args as $arg) {
-            foreach ($arg as $key=>$value) {
+            foreach ($arg as $key => $value) {
                 if (!defined($value)) {
                     define($value, $key);
                 } else {
@@ -1969,10 +4087,10 @@ class Net_SSH2 {
     /**
      * Returns a log of the packets that have been sent and received.
      *
-     * Returns a string if NET_SSH2_LOGGING == NET_SSH2_LOG_COMPLEX, an array if NET_SSH2_LOGGING == NET_SSH2_LOG_SIMPLE and false if !defined('NET_SSH2_LOGGING')
+     * Returns a string if NET_SSH2_LOGGING == self::LOG_COMPLEX, an array if NET_SSH2_LOGGING == self::LOG_SIMPLE and false if !defined('NET_SSH2_LOGGING')
      *
      * @access public
-     * @return String or Array
+     * @return array|false|string
      */
     function getLog()
     {
@@ -1981,12 +4099,11 @@ class Net_SSH2 {
         }
 
         switch (NET_SSH2_LOGGING) {
-            case NET_SSH2_LOG_SIMPLE:
+            case self::LOG_SIMPLE:
                 return $this->message_number_log;
-                break;
-            case NET_SSH2_LOG_COMPLEX:
-                return $this->_format_log($this->message_log, $this->message_number_log);
-                break;
+            case self::LOG_COMPLEX:
+                $log = $this->_format_log($this->message_log, $this->message_number_log);
+                return PHP_SAPI == 'cli' ? $log : '<pre>' . $log . '</pre>';
             default:
                 return false;
         }
@@ -1995,39 +4112,31 @@ class Net_SSH2 {
     /**
      * Formats a log for printing
      *
-     * @param Array $message_log
-     * @param Array $message_number_log
+     * @param array $message_log
+     * @param array $message_number_log
      * @access private
-     * @return String
+     * @return string
      */
     function _format_log($message_log, $message_number_log)
     {
-        static $boundary = ':', $long_width = 65, $short_width = 16;
-
         $output = '';
         for ($i = 0; $i < count($message_log); $i++) {
             $output.= $message_number_log[$i] . "\r\n";
             $current_log = $message_log[$i];
             $j = 0;
             do {
-                if (!empty($current_log)) {
+                if (strlen($current_log)) {
                     $output.= str_pad(dechex($j), 7, '0', STR_PAD_LEFT) . '0  ';
                 }
-                $fragment = $this->_string_shift($current_log, $short_width);
-                $hex = substr(
-                           preg_replace(
-                               '#(.)#es',
-                               '"' . $boundary . '" . str_pad(dechex(ord(substr("\\1", -1))), 2, "0", STR_PAD_LEFT)',
-                               $fragment),
-                           strlen($boundary)
-                       );
+                $fragment = $this->_string_shift($current_log, $this->log_short_width);
+                $hex = substr(preg_replace_callback('#.#s', array($this, '_format_log_helper'), $fragment), strlen($this->log_boundary));
                 // replace non ASCII printable characters with dots
                 // http://en.wikipedia.org/wiki/ASCII#ASCII_printable_characters
                 // also replace < with a . since < messes up the output on web browsers
                 $raw = preg_replace('#[^\x20-\x7E]|<#', '.', $fragment);
-                $output.= str_pad($hex, $long_width - $short_width, ' ') . $raw . "\r\n";
+                $output.= str_pad($hex, $this->log_long_width - $this->log_short_width, ' ') . $raw . "\r\n";
                 $j++;
-            } while (!empty($current_log));
+            } while (strlen($current_log));
             $output.= "\r\n";
         }
 
@@ -2035,9 +4144,58 @@ class Net_SSH2 {
     }
 
     /**
+     * Helper function for _format_log
+     *
+     * For use with preg_replace_callback()
+     *
+     * @param array $matches
+     * @access private
+     * @return string
+     */
+    function _format_log_helper($matches)
+    {
+        return $this->log_boundary . str_pad(dechex(ord($matches[0])), 2, '0', STR_PAD_LEFT);
+    }
+
+    /**
+     * Helper function for agent->_on_channel_open()
+     *
+     * Used when channels are created to inform agent
+     * of said channel opening. Must be called after
+     * channel open confirmation received
+     *
+     * @access private
+     */
+    function _on_channel_open()
+    {
+        if (isset($this->agent)) {
+            $this->agent->_on_channel_open($this);
+        }
+    }
+
+    /**
+     * Returns the first value of the intersection of two arrays or false if
+     * the intersection is empty. The order is defined by the first parameter.
+     *
+     * @param array $array1
+     * @param array $array2
+     * @return mixed False if intersection is empty, else intersected value.
+     * @access private
+     */
+    function _array_intersect_first($array1, $array2)
+    {
+        foreach ($array1 as $value) {
+            if (in_array($value, $array2)) {
+                return $value;
+            }
+        }
+        return false;
+    }
+
+    /**
      * Returns all errors
      *
-     * @return String
+     * @return string[]
      * @access public
      */
     function getErrors()
@@ -2048,186 +4206,261 @@ class Net_SSH2 {
     /**
      * Returns the last error
      *
-     * @return String
+     * @return string
      * @access public
      */
     function getLastError()
     {
-        return $this->errors[count($this->errors) - 1];
+        $count = count($this->errors);
+
+        if ($count > 0) {
+            return $this->errors[$count - 1];
+        }
     }
 
     /**
      * Return the server identification.
      *
-     * @return String
+     * @return string
      * @access public
      */
     function getServerIdentification()
     {
+        $this->_connect();
+
         return $this->server_identifier;
     }
 
     /**
      * Return a list of the key exchange algorithms the server supports.
      *
-     * @return Array
+     * @return array
      * @access public
      */
     function getKexAlgorithms()
     {
+        $this->_connect();
+
         return $this->kex_algorithms;
     }
 
     /**
      * Return a list of the host key (public key) algorithms the server supports.
      *
-     * @return Array
+     * @return array
      * @access public
      */
     function getServerHostKeyAlgorithms()
     {
+        $this->_connect();
+
         return $this->server_host_key_algorithms;
     }
 
     /**
      * Return a list of the (symmetric key) encryption algorithms the server supports, when receiving stuff from the client.
      *
-     * @return Array
+     * @return array
      * @access public
      */
     function getEncryptionAlgorithmsClient2Server()
     {
+        $this->_connect();
+
         return $this->encryption_algorithms_client_to_server;
     }
 
     /**
      * Return a list of the (symmetric key) encryption algorithms the server supports, when sending stuff to the client.
      *
-     * @return Array
+     * @return array
      * @access public
      */
     function getEncryptionAlgorithmsServer2Client()
     {
+        $this->_connect();
+
         return $this->encryption_algorithms_server_to_client;
     }
 
     /**
      * Return a list of the MAC algorithms the server supports, when receiving stuff from the client.
      *
-     * @return Array
+     * @return array
      * @access public
      */
     function getMACAlgorithmsClient2Server()
     {
+        $this->_connect();
+
         return $this->mac_algorithms_client_to_server;
     }
 
     /**
      * Return a list of the MAC algorithms the server supports, when sending stuff to the client.
      *
-     * @return Array
+     * @return array
      * @access public
      */
     function getMACAlgorithmsServer2Client()
     {
+        $this->_connect();
+
         return $this->mac_algorithms_server_to_client;
     }
 
     /**
      * Return a list of the compression algorithms the server supports, when receiving stuff from the client.
      *
-     * @return Array
+     * @return array
      * @access public
      */
     function getCompressionAlgorithmsClient2Server()
     {
+        $this->_connect();
+
         return $this->compression_algorithms_client_to_server;
     }
 
     /**
      * Return a list of the compression algorithms the server supports, when sending stuff to the client.
      *
-     * @return Array
+     * @return array
      * @access public
      */
     function getCompressionAlgorithmsServer2Client()
     {
+        $this->_connect();
+
         return $this->compression_algorithms_server_to_client;
     }
 
     /**
      * Return a list of the languages the server supports, when sending stuff to the client.
      *
-     * @return Array
+     * @return array
      * @access public
      */
     function getLanguagesServer2Client()
     {
+        $this->_connect();
+
         return $this->languages_server_to_client;
     }
 
     /**
      * Return a list of the languages the server supports, when receiving stuff from the client.
      *
-     * @return Array
+     * @return array
      * @access public
      */
     function getLanguagesClient2Server()
     {
+        $this->_connect();
+
         return $this->languages_client_to_server;
     }
 
     /**
+     * Returns the banner message.
+     *
+     * Quoting from the RFC, "in some jurisdictions, sending a warning message before
+     * authentication may be relevant for getting legal protection."
+     *
+     * @return string
+     * @access public
+     */
+    function getBannerMessage()
+    {
+        return $this->banner_message;
+    }
+
+    /**
      * Returns the server public host key.
      *
      * Caching this the first time you connect to a server and checking the result on subsequent connections
      * is recommended.  Returns false if the server signature is not signed correctly with the public host key.
      *
-     * @return Mixed
+     * @return mixed
      * @access public
      */
     function getServerPublicHostKey()
     {
+        if (!($this->bitmap & self::MASK_CONSTRUCTOR)) {
+            if (!$this->_connect()) {
+                return false;
+            }
+        }
+
         $signature = $this->signature;
         $server_public_host_key = $this->server_public_host_key;
 
+        if (strlen($server_public_host_key) < 4) {
+            return false;
+        }
         extract(unpack('Nlength', $this->_string_shift($server_public_host_key, 4)));
         $this->_string_shift($server_public_host_key, $length);
 
+        if ($this->signature_validated) {
+            return $this->bitmap ?
+                $this->signature_format . ' ' . base64_encode($this->server_public_host_key) :
+                false;
+        }
+
+        $this->signature_validated = true;
+
         switch ($this->signature_format) {
             case 'ssh-dss':
+                $zero = new BigInteger();
+
+                if (strlen($server_public_host_key) < 4) {
+                    return false;
+                }
                 $temp = unpack('Nlength', $this->_string_shift($server_public_host_key, 4));
-                $p = new Math_BigInteger($this->_string_shift($server_public_host_key, $temp['length']), -256);
+                $p = new BigInteger($this->_string_shift($server_public_host_key, $temp['length']), -256);
 
+                if (strlen($server_public_host_key) < 4) {
+                    return false;
+                }
                 $temp = unpack('Nlength', $this->_string_shift($server_public_host_key, 4));
-                $q = new Math_BigInteger($this->_string_shift($server_public_host_key, $temp['length']), -256);
+                $q = new BigInteger($this->_string_shift($server_public_host_key, $temp['length']), -256);
 
+                if (strlen($server_public_host_key) < 4) {
+                    return false;
+                }
                 $temp = unpack('Nlength', $this->_string_shift($server_public_host_key, 4));
-                $g = new Math_BigInteger($this->_string_shift($server_public_host_key, $temp['length']), -256);
+                $g = new BigInteger($this->_string_shift($server_public_host_key, $temp['length']), -256);
 
+                if (strlen($server_public_host_key) < 4) {
+                    return false;
+                }
                 $temp = unpack('Nlength', $this->_string_shift($server_public_host_key, 4));
-                $y = new Math_BigInteger($this->_string_shift($server_public_host_key, $temp['length']), -256);
+                $y = new BigInteger($this->_string_shift($server_public_host_key, $temp['length']), -256);
 
                 /* The value for 'dss_signature_blob' is encoded as a string containing
                    r, followed by s (which are 160-bit integers, without lengths or
                    padding, unsigned, and in network byte order). */
                 $temp = unpack('Nlength', $this->_string_shift($signature, 4));
                 if ($temp['length'] != 40) {
-                    user_error('Invalid signature', E_USER_NOTICE);
+                    user_error('Invalid signature');
                     return $this->_disconnect(NET_SSH2_DISCONNECT_KEY_EXCHANGE_FAILED);
                 }
 
-                $r = new Math_BigInteger($this->_string_shift($signature, 20), 256);
-                $s = new Math_BigInteger($this->_string_shift($signature, 20), 256);
+                $r = new BigInteger($this->_string_shift($signature, 20), 256);
+                $s = new BigInteger($this->_string_shift($signature, 20), 256);
 
-                if ($r->compare($q) >= 0 || $s->compare($q) >= 0) {
-                    user_error('Invalid signature', E_USER_NOTICE);
-                    return $this->_disconnect(NET_SSH2_DISCONNECT_KEY_EXCHANGE_FAILED);
+                switch (true) {
+                    case $r->equals($zero):
+                    case $r->compare($q) >= 0:
+                    case $s->equals($zero):
+                    case $s->compare($q) >= 0:
+                        user_error('Invalid signature');
+                        return $this->_disconnect(NET_SSH2_DISCONNECT_KEY_EXCHANGE_FAILED);
                 }
 
                 $w = $s->modInverse($q);
 
-                $u1 = $w->multiply(new Math_BigInteger(sha1($this->session_id), 16));
+                $u1 = $w->multiply(new BigInteger(sha1($this->exchange_hash), 16));
                 list(, $u1) = $u1->divide($q);
 
                 $u2 = $w->multiply($r);
@@ -2241,38 +4474,47 @@ class Net_SSH2 {
                 list(, $v) = $v->divide($q);
 
                 if (!$v->equals($r)) {
-                    user_error('Bad server signature', E_USER_NOTICE);
+                    user_error('Bad server signature');
                     return $this->_disconnect(NET_SSH2_DISCONNECT_HOST_KEY_NOT_VERIFIABLE);
                 }
 
                 break;
             case 'ssh-rsa':
+                if (strlen($server_public_host_key) < 4) {
+                    return false;
+                }
                 $temp = unpack('Nlength', $this->_string_shift($server_public_host_key, 4));
-                $e = new Math_BigInteger($this->_string_shift($server_public_host_key, $temp['length']), -256);
+                $e = new BigInteger($this->_string_shift($server_public_host_key, $temp['length']), -256);
 
+                if (strlen($server_public_host_key) < 4) {
+                    return false;
+                }
                 $temp = unpack('Nlength', $this->_string_shift($server_public_host_key, 4));
-                $n = new Math_BigInteger($this->_string_shift($server_public_host_key, $temp['length']), -256);
-                $nLength = $temp['length'];
+                $rawN = $this->_string_shift($server_public_host_key, $temp['length']);
+                $n = new BigInteger($rawN, -256);
+                $nLength = strlen(ltrim($rawN, "\0"));
 
                 /*
+                if (strlen($signature) < 4) {
+                    return false;
+                }
                 $temp = unpack('Nlength', $this->_string_shift($signature, 4));
                 $signature = $this->_string_shift($signature, $temp['length']);
 
-                if (!class_exists('Crypt_RSA')) {
-                    require_once('Crypt/RSA.php');
-                }
-
-                $rsa = new Crypt_RSA();
-                $rsa->setSignatureMode(CRYPT_RSA_SIGNATURE_PKCS1);
-                $rsa->loadKey(array('e' => $e, 'n' => $n), CRYPT_RSA_PUBLIC_FORMAT_RAW);
-                if (!$rsa->verify($this->session_id, $signature)) {
-                    user_error('Bad server signature', E_USER_NOTICE);
+                $rsa = new RSA();
+                $rsa->setSignatureMode(RSA::SIGNATURE_PKCS1);
+                $rsa->loadKey(array('e' => $e, 'n' => $n), RSA::PUBLIC_FORMAT_RAW);
+                if (!$rsa->verify($this->exchange_hash, $signature)) {
+                    user_error('Bad server signature');
                     return $this->_disconnect(NET_SSH2_DISCONNECT_HOST_KEY_NOT_VERIFIABLE);
                 }
                 */
 
+                if (strlen($signature) < 4) {
+                    return false;
+                }
                 $temp = unpack('Nlength', $this->_string_shift($signature, 4));
-                $s = new Math_BigInteger($this->_string_shift($signature, $temp['length']), 256);
+                $s = new BigInteger($this->_string_shift($signature, $temp['length']), 256);
 
                 // validate an RSA signature per "8.2 RSASSA-PKCS1-v1_5", "5.2.2 RSAVP1", and "9.1 EMSA-PSS" in the
                 // following URL:
@@ -2280,23 +4522,98 @@ class Net_SSH2 {
 
                 // also, see SSHRSA.c (rsa2_verifysig) in PuTTy's source.
 
-                if ($s->compare(new Math_BigInteger()) < 0 || $s->compare($n->subtract(new Math_BigInteger(1))) > 0) {
-                    user_error('Invalid signature', E_USER_NOTICE);
+                if ($s->compare(new BigInteger()) < 0 || $s->compare($n->subtract(new BigInteger(1))) > 0) {
+                    user_error('Invalid signature');
                     return $this->_disconnect(NET_SSH2_DISCONNECT_KEY_EXCHANGE_FAILED);
                 }
 
                 $s = $s->modPow($e, $n);
                 $s = $s->toBytes();
 
-                $h = pack('N4H*', 0x00302130, 0x0906052B, 0x0E03021A, 0x05000414, sha1($this->session_id));
-                $h = chr(0x01) . str_repeat(chr(0xFF), $nLength - 3 - strlen($h)) . $h;
+                $h = pack('N4H*', 0x00302130, 0x0906052B, 0x0E03021A, 0x05000414, sha1($this->exchange_hash));
+                $h = chr(0x01) . str_repeat(chr(0xFF), $nLength - 2 - strlen($h)) . $h;
 
                 if ($s != $h) {
-                    user_error('Bad server signature', E_USER_NOTICE);
+                    user_error('Bad server signature');
                     return $this->_disconnect(NET_SSH2_DISCONNECT_HOST_KEY_NOT_VERIFIABLE);
                 }
+                break;
+            default:
+                user_error('Unsupported signature format');
+                return $this->_disconnect(NET_SSH2_DISCONNECT_HOST_KEY_NOT_VERIFIABLE);
+        }
+
+        return $this->signature_format . ' ' . base64_encode($this->server_public_host_key);
+    }
+
+    /**
+     * Returns the exit status of an SSH command or false.
+     *
+     * @return false|int
+     * @access public
+     */
+    function getExitStatus()
+    {
+        if (is_null($this->exit_status)) {
+            return false;
         }
+        return $this->exit_status;
+    }
+
+    /**
+     * Returns the number of columns for the terminal window size.
+     *
+     * @return int
+     * @access public
+     */
+    function getWindowColumns()
+    {
+        return $this->windowColumns;
+    }
+
+    /**
+     * Returns the number of rows for the terminal window size.
+     *
+     * @return int
+     * @access public
+     */
+    function getWindowRows()
+    {
+        return $this->windowRows;
+    }
+
+    /**
+     * Sets the number of columns for the terminal window size.
+     *
+     * @param int $value
+     * @access public
+     */
+    function setWindowColumns($value)
+    {
+        $this->windowColumns = $value;
+    }
+
+    /**
+     * Sets the number of rows for the terminal window size.
+     *
+     * @param int $value
+     * @access public
+     */
+    function setWindowRows($value)
+    {
+        $this->windowRows = $value;
+    }
 
-        return $this->server_public_host_key;
+    /**
+     * Sets the number of columns and rows for the terminal window size.
+     *
+     * @param int $columns
+     * @param int $rows
+     * @access public
+     */
+    function setWindowSize($columns = 80, $rows = 24)
+    {
+        $this->windowColumns = $columns;
+        $this->windowRows = $rows;
     }
 }
diff --git a/lib/phpseclib/PHP/Compat/Function/array_fill.php b/lib/phpseclib/PHP/Compat/Function/array_fill.php
deleted file mode 100644
index 79b5312..0000000
--- a/lib/phpseclib/PHP/Compat/Function/array_fill.php
+++ /dev/null
@@ -1,41 +0,0 @@
-<?php
-// $Id: array_fill.php,v 1.1 2007/07/02 04:19:55 terrafrost Exp $
-
-
-/**
- * Replace array_fill()
- *
- * @category    PHP
- * @package     PHP_Compat
- * @license     LGPL - http://www.gnu.org/licenses/lgpl.html
- * @copyright   2004-2007 Aidan Lister <aidan@php.net>, Arpad Ray <arpad@php.net>
- * @link        http://php.net/function.array_fill
- * @author      Jim Wigginton <terrafrost@php.net>
- * @version     $Revision: 1.1 $
- * @since       PHP 4.2.0
- */
-function php_compat_array_fill($start_index, $num, $value)
-{
-    if ($num <= 0) {
-        user_error('array_fill(): Number of elements must be positive', E_USER_WARNING);
-
-        return false;
-    }
-
-    $temp = array();
-
-    $end_index = $start_index + $num;
-    for ($i = (int) $start_index; $i < $end_index; $i++) {
-        $temp[$i] = $value;
-    }
-
-    return $temp;
-}
-
-// Define
-if (!function_exists('array_fill')) {
-    function array_fill($start_index, $num, $value)
-    {
-        return php_compat_array_fill($start_index, $num, $value);
-    }
-}
diff --git a/lib/phpseclib/PHP/Compat/Function/bcpowmod.php b/lib/phpseclib/PHP/Compat/Function/bcpowmod.php
deleted file mode 100644
index 4c162b8..0000000
--- a/lib/phpseclib/PHP/Compat/Function/bcpowmod.php
+++ /dev/null
@@ -1,66 +0,0 @@
-<?php
-// $Id: bcpowmod.php,v 1.1 2007/07/02 04:19:55 terrafrost Exp $
-
-
-/**
- * Replace bcpowmod()
- *
- * @category    PHP
- * @package     PHP_Compat
- * @license     LGPL - http://www.gnu.org/licenses/lgpl.html
- * @copyright   2004-2007 Aidan Lister <aidan@php.net>, Arpad Ray <arpad@php.net>
- * @link        http://php.net/function.bcpowmod
- * @author      Sara Golemon <pollita@php.net>
- * @version     $Revision: 1.1 $
- * @since       PHP 5.0.0
- * @require     PHP 4.0.0 (user_error)
- */
-function php_compat_bcpowmod($x, $y, $modulus, $scale = 0)
-{
-    // Sanity check
-    if (!is_scalar($x)) {
-        user_error('bcpowmod() expects parameter 1 to be string, ' .
-            gettype($x) . ' given', E_USER_WARNING);
-        return false;
-    }
-
-    if (!is_scalar($y)) {
-        user_error('bcpowmod() expects parameter 2 to be string, ' .
-            gettype($y) . ' given', E_USER_WARNING);
-        return false;
-    }
-
-    if (!is_scalar($modulus)) {
-        user_error('bcpowmod() expects parameter 3 to be string, ' .
-            gettype($modulus) . ' given', E_USER_WARNING);
-        return false;
-    }
-
-    if (!is_scalar($scale)) {
-        user_error('bcpowmod() expects parameter 4 to be integer, ' .
-            gettype($scale) . ' given', E_USER_WARNING);
-        return false;
-    }
-
-    $t = '1';
-    while (bccomp($y, '0')) {
-        if (bccomp(bcmod($y, '2'), '0')) {
-            $t = bcmod(bcmul($t, $x), $modulus);
-            $y = bcsub($y, '1');
-        }
-
-        $x = bcmod(bcmul($x, $x), $modulus);
-        $y = bcdiv($y, '2');
-    }
-
-    return $t;    
-}
-
-
-// Define
-if (!function_exists('bcpowmod')) {
-    function bcpowmod($x, $y, $modulus, $scale = 0)
-    {
-        return php_compat_bcpowmod($x, $y, $modulus, $scale);
-    }
-}
diff --git a/lib/phpseclib/PHP/Compat/Function/str_split.php b/lib/phpseclib/PHP/Compat/Function/str_split.php
deleted file mode 100644
index 8f5179b..0000000
--- a/lib/phpseclib/PHP/Compat/Function/str_split.php
+++ /dev/null
@@ -1,59 +0,0 @@
-<?php
-/**
- * Replace str_split()
- *
- * @category    PHP
- * @package     PHP_Compat
- * @license     LGPL - http://www.gnu.org/licenses/lgpl.html
- * @copyright   2004-2007 Aidan Lister <aidan@php.net>, Arpad Ray <arpad@php.net>
- * @link        http://php.net/function.str_split
- * @author      Aidan Lister <aidan@php.net>
- * @version     $Revision: 1.1 $
- * @since       PHP 5
- * @require     PHP 4.0.0 (user_error)
- */
-function php_compat_str_split($string, $split_length = 1)
-{
-    if (!is_scalar($split_length)) {
-        user_error('str_split() expects parameter 2 to be long, ' .
-            gettype($split_length) . ' given', E_USER_WARNING);
-        return false;
-    }
-
-    $split_length = (int) $split_length;
-    if ($split_length < 1) {
-        user_error('str_split() The length of each segment must be greater than zero', E_USER_WARNING);
-        return false;
-    }
-    
-    // Select split method
-    if ($split_length < 65536) {
-        // Faster, but only works for less than 2^16
-        preg_match_all('/.{1,' . $split_length . '}/s', $string, $matches);
-        return $matches[0];
-    } else {
-        // Required due to preg limitations
-        $arr = array();
-        $idx = 0;
-        $pos = 0;
-        $len = strlen($string);
-
-        while ($len > 0) {
-            $blk = ($len < $split_length) ? $len : $split_length;
-            $arr[$idx++] = substr($string, $pos, $blk);
-            $pos += $blk;
-            $len -= $blk;
-        }
-
-        return $arr;
-    }
-}
-
-
-// Define
-if (!function_exists('str_split')) {
-    function str_split($string, $split_length = 1)
-    {
-        return php_compat_str_split($string, $split_length);
-    }
-}
diff --git a/lib/phpseclib/System/SSH/Agent.php b/lib/phpseclib/System/SSH/Agent.php
new file mode 100644
index 0000000..a4ff054
--- /dev/null
+++ b/lib/phpseclib/System/SSH/Agent.php
@@ -0,0 +1,308 @@
+<?php
+
+/**
+ * Pure-PHP ssh-agent client.
+ *
+ * PHP version 5
+ *
+ * Here are some examples of how to use this library:
+ * <code>
+ * <?php
+ *    include 'vendor/autoload.php';
+ *
+ *    $agent = new \phpseclib\System\SSH\Agent();
+ *
+ *    $ssh = new \phpseclib\Net\SSH2('www.domain.tld');
+ *    if (!$ssh->login('username', $agent)) {
+ *        exit('Login Failed');
+ *    }
+ *
+ *    echo $ssh->exec('pwd');
+ *    echo $ssh->exec('ls -la');
+ * ?>
+ * </code>
+ *
+ * @category  System
+ * @package   SSH\Agent
+ * @author    Jim Wigginton <terrafrost@php.net>
+ * @copyright 2014 Jim Wigginton
+ * @license   http://www.opensource.org/licenses/mit-license.html  MIT License
+ * @link      http://phpseclib.sourceforge.net
+ * @internal  See http://api.libssh.org/rfc/PROTOCOL.agent
+ */
+
+namespace phpseclib\System\SSH;
+
+use phpseclib\Crypt\RSA;
+use phpseclib\System\SSH\Agent\Identity;
+
+/**
+ * Pure-PHP ssh-agent client identity factory
+ *
+ * requestIdentities() method pumps out \phpseclib\System\SSH\Agent\Identity objects
+ *
+ * @package SSH\Agent
+ * @author  Jim Wigginton <terrafrost@php.net>
+ * @access  internal
+ */
+class Agent
+{
+    /**#@+
+     * Message numbers
+     *
+     * @access private
+     */
+    // to request SSH1 keys you have to use SSH_AGENTC_REQUEST_RSA_IDENTITIES (1)
+    const SSH_AGENTC_REQUEST_IDENTITIES = 11;
+    // this is the SSH2 response; the SSH1 response is SSH_AGENT_RSA_IDENTITIES_ANSWER (2).
+    const SSH_AGENT_IDENTITIES_ANSWER = 12;
+    // the SSH1 request is SSH_AGENTC_RSA_CHALLENGE (3)
+    const SSH_AGENTC_SIGN_REQUEST = 13;
+    // the SSH1 response is SSH_AGENT_RSA_RESPONSE (4)
+    const SSH_AGENT_SIGN_RESPONSE = 14;
+    /**#@-*/
+
+    /**@+
+     * Agent forwarding status
+     *
+     * @access private
+     */
+    // no forwarding requested and not active
+    const FORWARD_NONE = 0;
+    // request agent forwarding when opportune
+    const FORWARD_REQUEST = 1;
+    // forwarding has been request and is active
+    const FORWARD_ACTIVE = 2;
+    /**#@-*/
+
+    /**
+     * Unused
+     */
+    const SSH_AGENT_FAILURE = 5;
+
+    /**
+     * Socket Resource
+     *
+     * @var resource
+     * @access private
+     */
+    var $fsock;
+
+    /**
+     * Agent forwarding status
+     *
+     * @access private
+     */
+    var $forward_status = self::FORWARD_NONE;
+
+    /**
+     * Buffer for accumulating forwarded authentication
+     * agent data arriving on SSH data channel destined
+     * for agent unix socket
+     *
+     * @access private
+     */
+    var $socket_buffer = '';
+
+    /**
+     * Tracking the number of bytes we are expecting
+     * to arrive for the agent socket on the SSH data
+     * channel
+     */
+    var $expected_bytes = 0;
+
+    /**
+     * Default Constructor
+     *
+     * @return \phpseclib\System\SSH\Agent
+     * @access public
+     */
+    function __construct()
+    {
+        switch (true) {
+            case isset($_SERVER['SSH_AUTH_SOCK']):
+                $address = $_SERVER['SSH_AUTH_SOCK'];
+                break;
+            case isset($_ENV['SSH_AUTH_SOCK']):
+                $address = $_ENV['SSH_AUTH_SOCK'];
+                break;
+            default:
+                user_error('SSH_AUTH_SOCK not found');
+                return false;
+        }
+
+        $this->fsock = fsockopen('unix://' . $address, 0, $errno, $errstr);
+        if (!$this->fsock) {
+            user_error("Unable to connect to ssh-agent (Error $errno: $errstr)");
+        }
+    }
+
+    /**
+     * Request Identities
+     *
+     * See "2.5.2 Requesting a list of protocol 2 keys"
+     * Returns an array containing zero or more \phpseclib\System\SSH\Agent\Identity objects
+     *
+     * @return array
+     * @access public
+     */
+    function requestIdentities()
+    {
+        if (!$this->fsock) {
+            return array();
+        }
+
+        $packet = pack('NC', 1, self::SSH_AGENTC_REQUEST_IDENTITIES);
+        if (strlen($packet) != fputs($this->fsock, $packet)) {
+            user_error('Connection closed while requesting identities');
+        }
+
+        $length = current(unpack('N', fread($this->fsock, 4)));
+        $type = ord(fread($this->fsock, 1));
+        if ($type != self::SSH_AGENT_IDENTITIES_ANSWER) {
+            user_error('Unable to request identities');
+        }
+
+        $identities = array();
+        $keyCount = current(unpack('N', fread($this->fsock, 4)));
+        for ($i = 0; $i < $keyCount; $i++) {
+            $length = current(unpack('N', fread($this->fsock, 4)));
+            $key_blob = fread($this->fsock, $length);
+            $key_str = 'ssh-rsa ' . base64_encode($key_blob);
+            $length = current(unpack('N', fread($this->fsock, 4)));
+            if ($length) {
+                $key_str.= ' ' . fread($this->fsock, $length);
+            }
+            $length = current(unpack('N', substr($key_blob, 0, 4)));
+            $key_type = substr($key_blob, 4, $length);
+            switch ($key_type) {
+                case 'ssh-rsa':
+                    $key = new RSA();
+                    $key->loadKey($key_str);
+                    break;
+                case 'ssh-dss':
+                    // not currently supported
+                    break;
+            }
+            // resources are passed by reference by default
+            if (isset($key)) {
+                $identity = new Identity($this->fsock);
+                $identity->setPublicKey($key);
+                $identity->setPublicKeyBlob($key_blob);
+                $identities[] = $identity;
+                unset($key);
+            }
+        }
+
+        return $identities;
+    }
+
+    /**
+     * Signal that agent forwarding should
+     * be requested when a channel is opened
+     *
+     * @param Net_SSH2 $ssh
+     * @return bool
+     * @access public
+     */
+    function startSSHForwarding($ssh)
+    {
+        if ($this->forward_status == self::FORWARD_NONE) {
+            $this->forward_status = self::FORWARD_REQUEST;
+        }
+    }
+
+    /**
+     * Request agent forwarding of remote server
+     *
+     * @param Net_SSH2 $ssh
+     * @return bool
+     * @access private
+     */
+    function _request_forwarding($ssh)
+    {
+        $request_channel = $ssh->_get_open_channel();
+        if ($request_channel === false) {
+            return false;
+        }
+
+        $packet = pack(
+            'CNNa*C',
+            NET_SSH2_MSG_CHANNEL_REQUEST,
+            $ssh->server_channels[$request_channel],
+            strlen('auth-agent-req@openssh.com'),
+            'auth-agent-req@openssh.com',
+            1
+        );
+
+        $ssh->channel_status[$request_channel] = NET_SSH2_MSG_CHANNEL_REQUEST;
+
+        if (!$ssh->_send_binary_packet($packet)) {
+            return false;
+        }
+
+        $response = $ssh->_get_channel_packet($request_channel);
+        if ($response === false) {
+            return false;
+        }
+
+        $ssh->channel_status[$request_channel] = NET_SSH2_MSG_CHANNEL_OPEN;
+        $this->forward_status = self::FORWARD_ACTIVE;
+
+        return true;
+    }
+
+    /**
+     * On successful channel open
+     *
+     * This method is called upon successful channel
+     * open to give the SSH Agent an opportunity
+     * to take further action. i.e. request agent forwarding
+     *
+     * @param Net_SSH2 $ssh
+     * @access private
+     */
+    function _on_channel_open($ssh)
+    {
+        if ($this->forward_status == self::FORWARD_REQUEST) {
+            $this->_request_forwarding($ssh);
+        }
+    }
+
+    /**
+     * Forward data to SSH Agent and return data reply
+     *
+     * @param string $data
+     * @return data from SSH Agent
+     * @access private
+     */
+    function _forward_data($data)
+    {
+        if ($this->expected_bytes > 0) {
+            $this->socket_buffer.= $data;
+            $this->expected_bytes -= strlen($data);
+        } else {
+            $agent_data_bytes = current(unpack('N', $data));
+            $current_data_bytes = strlen($data);
+            $this->socket_buffer = $data;
+            if ($current_data_bytes != $agent_data_bytes + 4) {
+                $this->expected_bytes = ($agent_data_bytes + 4) - $current_data_bytes;
+                return false;
+            }
+        }
+
+        if (strlen($this->socket_buffer) != fwrite($this->fsock, $this->socket_buffer)) {
+            user_error('Connection closed attempting to forward data to SSH agent');
+        }
+
+        $this->socket_buffer = '';
+        $this->expected_bytes = 0;
+
+        $agent_reply_bytes = current(unpack('N', fread($this->fsock, 4)));
+
+        $agent_reply_data = fread($this->fsock, $agent_reply_bytes);
+        $agent_reply_data = current(unpack('a*', $agent_reply_data));
+
+        return pack('Na*', $agent_reply_bytes, $agent_reply_data);
+    }
+}
diff --git a/lib/phpseclib/System/SSH/Agent/Identity.php b/lib/phpseclib/System/SSH/Agent/Identity.php
new file mode 100644
index 0000000..b8cc6cd
--- /dev/null
+++ b/lib/phpseclib/System/SSH/Agent/Identity.php
@@ -0,0 +1,158 @@
+<?php
+/**
+ * Pure-PHP ssh-agent client.
+ *
+ * PHP version 5
+ *
+ * @category  System
+ * @package   SSH\Agent
+ * @author    Jim Wigginton <terrafrost@php.net>
+ * @copyright 2009 Jim Wigginton
+ * @license   http://www.opensource.org/licenses/mit-license.html  MIT License
+ * @link      http://phpseclib.sourceforge.net
+ * @internal  See http://api.libssh.org/rfc/PROTOCOL.agent
+ */
+
+namespace phpseclib\System\SSH\Agent;
+
+use phpseclib\System\SSH\Agent;
+
+/**
+ * Pure-PHP ssh-agent client identity object
+ *
+ * Instantiation should only be performed by \phpseclib\System\SSH\Agent class.
+ * This could be thought of as implementing an interface that phpseclib\Crypt\RSA
+ * implements. ie. maybe a Net_SSH_Auth_PublicKey interface or something.
+ * The methods in this interface would be getPublicKey and sign since those are the
+ * methods phpseclib looks for to perform public key authentication.
+ *
+ * @package SSH\Agent
+ * @author  Jim Wigginton <terrafrost@php.net>
+ * @access  internal
+ */
+class Identity
+{
+    /**
+     * Key Object
+     *
+     * @var \phpseclib\Crypt\RSA
+     * @access private
+     * @see self::getPublicKey()
+     */
+    var $key;
+
+    /**
+     * Key Blob
+     *
+     * @var string
+     * @access private
+     * @see self::sign()
+     */
+    var $key_blob;
+
+    /**
+     * Socket Resource
+     *
+     * @var resource
+     * @access private
+     * @see self::sign()
+     */
+    var $fsock;
+
+    /**
+     * Default Constructor.
+     *
+     * @param resource $fsock
+     * @return \phpseclib\System\SSH\Agent\Identity
+     * @access private
+     */
+    function __construct($fsock)
+    {
+        $this->fsock = $fsock;
+    }
+
+    /**
+     * Set Public Key
+     *
+     * Called by \phpseclib\System\SSH\Agent::requestIdentities()
+     *
+     * @param \phpseclib\Crypt\RSA $key
+     * @access private
+     */
+    function setPublicKey($key)
+    {
+        $this->key = $key;
+        $this->key->setPublicKey();
+    }
+
+    /**
+     * Set Public Key
+     *
+     * Called by \phpseclib\System\SSH\Agent::requestIdentities(). The key blob could be extracted from $this->key
+     * but this saves a small amount of computation.
+     *
+     * @param string $key_blob
+     * @access private
+     */
+    function setPublicKeyBlob($key_blob)
+    {
+        $this->key_blob = $key_blob;
+    }
+
+    /**
+     * Get Public Key
+     *
+     * Wrapper for $this->key->getPublicKey()
+     *
+     * @param int $format optional
+     * @return mixed
+     * @access public
+     */
+    function getPublicKey($format = null)
+    {
+        return !isset($format) ? $this->key->getPublicKey() : $this->key->getPublicKey($format);
+    }
+
+    /**
+     * Set Signature Mode
+     *
+     * Doesn't do anything as ssh-agent doesn't let you pick and choose the signature mode. ie.
+     * ssh-agent's only supported mode is \phpseclib\Crypt\RSA::SIGNATURE_PKCS1
+     *
+     * @param int $mode
+     * @access public
+     */
+    function setSignatureMode($mode)
+    {
+    }
+
+    /**
+     * Create a signature
+     *
+     * See "2.6.2 Protocol 2 private key signature request"
+     *
+     * @param string $message
+     * @return string
+     * @access public
+     */
+    function sign($message)
+    {
+        // the last parameter (currently 0) is for flags and ssh-agent only defines one flag (for ssh-dss): SSH_AGENT_OLD_SIGNATURE
+        $packet = pack('CNa*Na*N', Agent::SSH_AGENTC_SIGN_REQUEST, strlen($this->key_blob), $this->key_blob, strlen($message), $message, 0);
+        $packet = pack('Na*', strlen($packet), $packet);
+        if (strlen($packet) != fputs($this->fsock, $packet)) {
+            user_error('Connection closed during signing');
+        }
+
+        $length = current(unpack('N', fread($this->fsock, 4)));
+        $type = ord(fread($this->fsock, 1));
+        if ($type != Agent::SSH_AGENT_SIGN_RESPONSE) {
+            user_error('Unable to retrieve signature');
+        }
+
+        $signature_blob = fread($this->fsock, $length - 1);
+        // the only other signature format defined - ssh-dss - is the same length as ssh-rsa
+        // the + 12 is for the other various SSH added length fields
+        return substr($signature_blob, strlen('ssh-rsa') + 12);
+    }
+}
diff --git a/lib/phpseclib/bootstrap.php b/lib/phpseclib/bootstrap.php
new file mode 100644
index 0000000..5aa2cc5
--- /dev/null
+++ b/lib/phpseclib/bootstrap.php
@@ -0,0 +1,24 @@
+<?php
+/**
+ * Bootstrapping File for phpseclib
+ *
+ * @license http://www.opensource.org/licenses/mit-license.html MIT License
+ */
+
+if (extension_loaded('mbstring')) {
+    // 2 - MB_OVERLOAD_STRING
+    if (ini_get('mbstring.func_overload') & 2) {
+        throw new \UnexpectedValueException(
+            'Overloading of string functions using mbstring.func_overload ' .
+            'is not supported by phpseclib.'
+        );
+    }
+}
+
+spl_autoload_register(function($className) {
+    $parts = explode('\\', $className);
+
+    if (array_shift($parts) == 'phpseclib') {
+        return include str_replace('\\', DIRECTORY_SEPARATOR, $className) . '.php';
+    }
+});
\ No newline at end of file
diff --git a/lib/phpseclib/openssl.cnf b/lib/phpseclib/openssl.cnf
new file mode 100644
index 0000000..2b8b52f
--- /dev/null
+++ b/lib/phpseclib/openssl.cnf
@@ -0,0 +1,6 @@
+# minimalist openssl.cnf file for use with phpseclib
+
+HOME			= .
+RANDFILE		= $ENV::HOME/.rnd
+
+[ v3_ca ]
